<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人技能]]></title>
    <url>%2F2018%2F05%2F23%2F%E4%B8%AA%E4%BA%BA%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"></content>
      <categories>
        <category>个人技能</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>js</tag>
        <tag>Ajax</tag>
        <tag>AngularJS</tag>
        <tag>BOM</tag>
        <tag>Bower</tag>
        <tag>Cookie</tag>
        <tag>DOM</tag>
        <tag>EJS</tag>
        <tag>Express</tag>
        <tag>Gulp</tag>
        <tag>HTML</tag>
        <tag>HTML5</tag>
        <tag>JSON</tag>
        <tag>MongoDB</tag>
        <tag>MySQL</tag>
        <tag>Node.js</tag>
        <tag>PHP</tag>
        <tag>React</tag>
        <tag>RequireJS</tag>
        <tag>SeaJs</tag>
        <tag>Session</tag>
        <tag>Underscore</tag>
        <tag>browser</tag>
        <tag>canvas</tag>
        <tag>cordova</tag>
        <tag>eCharts</tag>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>http</tag>
        <tag>ionic</tag>
        <tag>jQuery</tag>
        <tag>Grunt</tag>
        <tag>markdown</tag>
        <tag>mine</tag>
        <tag>net</tag>
        <tag>network</tag>
        <tag>npm</tag>
        <tag>nrm</tag>
        <tag>nvm</tag>
        <tag>tools</tag>
        <tag>webpack</tag>
        <tag>artTemplate</tag>
        <tag>ps</tag>
        <tag>sublime</tag>
        <tag>webstorm</tag>
        <tag>vs code</tag>
        <tag>svn</tag>
        <tag>eclipse</tag>
        <tag>命令行</tag>
        <tag>小项目</tag>
        <tag>库</tag>
        <tag>性能优化</tag>
        <tag>数据库</tag>
        <tag>框架</tag>
        <tag>模块化</tag>
        <tag>正则</tag>
        <tag>表单</tag>
        <tag>面向对象</tag>
        <tag>交互</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2015%2F12%2F28%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo+github可以随心所欲的部署属于自己的博客。 Hexo 博客搭建步骤搭建博客，首先需要安装 node 环境； 测试安装成功与否：打开终端，输入 node -v, 有输出版本结果则安装成功。 安装node环境的时候，已经自动安装了 npm 命令行工具，不需要单独安装。 可以通过 npm -v 测试npm是否可用 npm 是一个用来安装和管理 Node 包和前端包的一个工具。 npm 的两层含义 npm网站：https://www.npmjs.com/ 一个提供了一个用来共享或者检索的一个平台 二是托管 node 环境或者浏览器环境用到的一些第三方包 是一个命令行工具，可以用来下载 npm 网站上托管的包 CLI：Command Line Interface 命令行接口 GUI：图形化接口 npm 基本使用 本地安装1$ npm install [--save] 包名 一般是在项目中，安装项目使用的依赖包,就可以在终端中，切换到项目的根目录，然后执行 npm install 包名，npm 工具会自动将这个包下载下来然后放到 node_modules 目录中。node_modules 目录如果不存在会新建，如果已存在，则直接将下载的包放到该目录中。 包说明文件：package.json包说明文件其实就是一个产品的说明书：package.json 文件。该文件一般只存在于项目的根路径下，可以通过 npm init 命令使用向导的形式创建该文件。 该文件中描述了项目的一些元数据，例如 name、version、author等信息。 其中有一个非常重要的属性，叫做：dependencies，该属性是一个对象，里面保存了当前项目的依赖项，该字段一般不要手动修改，它需要结合 npm install --save 包名 来使用，只要在安装的时候加上--save 参数就会自动将包依赖项添加到该属性中，很方便。 甚至还可以完全把 node_modules 目录删除掉，只要 package.json文件还在，就可以执行 npm install 安装包说明文件中的所有的依赖项。执行 npm install 命令的时候，它会自动查询当前目录下的 package.json 文件，然后找到里面的 dependencies 属性，依次下载到 node_modules 目录下。 建议使用 npm 的时候，都先初始化一个 package.json 文件，然后安装包的时候最好都加上 --save 参数，将依赖项添加到包说明文件中。 全局安装全局安装：一般用于安装一些命令行工具（这些工具也是基于Node开发的。） 全局安装使用 npm install --global 包名（工具名），在任意目录执行该命令都可以。 1npm i -g hexo-cli 可以通过 npm root -g 查看全局包安装目录。 安装 git 环境；下载地址： 初始设置12$ git config --global user.name "yourname"$ git config --global user.email "your_email@example.com" 全局安装 hexo-cli在终端的任意目录输入 npm install -g hexo-cli 然后回车执行等待全局安装成功 通过输入 hexo --version 如果看到输入一大堆的版本号就说明安装成功了，Hexo 是一个命令行应用程序 初始化一个博客存储目录通过输入 hexp init 博客项目存储目录 Hexo 会在执行该命令的目录下生成一个博客项目，初始化博客项目的过程需要联网 通过终端进入刚才创建的博客项目目录，然后在该目录下输入 npm install 回车等待执行结束 启动本地服务器，查看博客内容输入 hexo server回车执行，这一执行会在本地启动一个服务器，然后通过 http://localhost:4000 / localhost:4000 就可以访问创建的博客项目 (如果此时4000端口号被占用，也可以通过 hexo server -p 5000 切换到端口号为5000，随即访问http://localhost:5000 / localhost:5000访问创建的博客项目) 创建博文进入博客项目，输入 hexo new 文章名称 创建博文 这个命令会自动在 source/_posts/ 目录下生成一个 文章名称.md 文件 生成静态文件：hexo generate该命令会自动在项目的根目录下的 public 目录下降静态文件放进去 配置主题页根据我个人所选的主题介绍。进入博客根目录，打开_config开始配置，注意：在配置主题页的时候需要图片的url，需要在七头云CDN注册； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Sitetitle: HongqinMa # 配置博客标题subtitle: "博客标签"description: "马红琴在 Github 上的个人博客"author: Hongqin Maheader-img: //ofy7k3v4s.bkt.clouddn.com/mbanner.png #email: hongqin_ma@126.com # 邮箱地址keyword: Hiraku, HongqinMa, javascript, html, css, nodejs #SEO搜索引擎查找关键词favicon: //ofy7k3v4s.bkt.clouddn.com/mylogo.png # 博客网站图标# RSS:weibo_username: Hiraku_Ma #微博账户名zhihu_username: HirakuMa #知乎账户名github_username: HongqinMa #github账户名twitter_username: HongqinMa #Twitter账户名facebook_username: Hiraku #Facebook账户名sidebar-about-description: 拼着一切代价，奔你的前程。 # 侧边栏签名sidebar-avatar: http://ofy7k3v4s.bkt.clouddn.com/photo.jpg # 侧边栏头像cdn-url: "https://ofy7k3v4s.bkt.clouddn.com/" # 我写的是七头云的域名地址theme: hexo-theme-Anisina # 主题名称friends: [ &#123; title: "掘金", href: "http://gold.xitu.io/" &#125;, &#123; title: "segmentfault", href: "https://segmentfault.com/" &#125;, &#123; title: "简书", href: "http://www.jianshu.com/users/1cbb94e5ed4d/latest_articles" &#125;, &#123; title: "七牛云", href: "https://portal.qiniu.com/" &#125;, &#123; title: "博客园", href: "https://home.cnblogs.com/" &#125;, &#123; title: "Awesomes", href: "https://www.awesomes.cn/" &#125;]duoshuo_username: Hiraku #这里需要注册多说或者主题作者：haojen Ma 文档中的另外一种，作用都一样 ，用来评论的；deploy: type: git # 快速部署 repo: https://github用户名:github密码@github.com/HongqinMa/HongqinMa.github.io.git 快速部署 修改配置文件 在项目根路径下执行 npm install hexo-deployer-git --save 该命令 接下来就可以直接输入 hexo deploy --generate/简写 hexo d -g 自动发布到 github 上 更详细介绍如下：如何配置主题（以Next主题为例进行详细说明） Hexo-Next-主题优化(一)Hexo-Next-主题优化(二)Hexo-Next-主题优化(三)Hexo-Next-主题优化(四) OK，现在可以直接通过honeyyoung.github.io访问博客了。]]></content>
      <categories>
        <category>Hexo系列</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>npm</tag>
        <tag>tools</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2015%2F12%2F16%2FAjax%2F</url>
    <content type="text"><![CDATA[服务器、网络基础、相关知识介绍服务器介绍：常见的服务器软件有： 文件服务器：Server-U、FileZilla、VsFTP等（FTP是File Transfer Protocol文件传输协议）； 数据库服务器：oracle、mysql、SQL server、DB2、ACCESS等； 邮件服务器：Postfix、Sendmail等； HTTP服务器：Apache、Nginx、IIS、Tomcat、NodeJS等； 按照不同的划分标准，服务可划分为以下类型： (1) 服务器类型 按 服务类型 可分为： 文件服务器 数据库服务器 邮件服务器 Web服务器等； 按 操作系统 可分为： Linux服务器 Windows服务器等； 按 应用软件 可分为 Apache 服务器 Nginx 服务器 IIS 服务器 Tomcat 服务器 weblogic 服务器 WebSphere 服务器 boss 服务器 Node 服务器等 (2) HTTP服务器 即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。 HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。 常见的运行在服务端的编程语言包括 php、java、.net、Python、Ruby、Perl等。 (3) 客户端介绍： 具有向服务器索取服务能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，可以获取不同的服务，比如通过QQ获得即时通讯服务、通过迅雷获得下载服务等。 常见的客户端软件：浏览器、QQ、迅雷、Foxmail等。 以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。 网络基础：IP地址 所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每部手机能正常通话需要一个号码一样) 查看本机IP地址 ping、ipconfig、ifconfig（linux） 域名 由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具” 查看域名对应的IP地址 ping DNS服务 DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简单的说就是记录IP地址和域名之间对应关系的服务。 查找优先级 本机 hosts 文件、DNS服务器 ipconfig /flushdns 刷新DNS 端口 端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。现实生活中，银行不同的窗口办理不同的业务。 查看端口占用情况 netstat -an 常见端口号 80、8080、3306、21、22 软件架构C/S结构 即Client、Server 在C/S结构的情况下，不同的服务需要安装不同的客户端软件， 比如QQ、迅雷、Foxmail 这种情况下安装的软件会越来越多，同时也有许多弊端，比如A出差，需要在B电脑上查收邮件，但是B电脑并未安装Foxmail等类似的客户端软件，这样不得不先去下载Foxmail，非常不方便。 B/S结构 即Broswer、Server 解决了C/S所带来的不便 将所有的服务都可以通过浏览器来完成（因为基本所有浏览器都安装了浏览器），但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。 网络传输协议常见协议 HTTP、HTTPS 超文本传输协议 FTP 文件传输协议 SMTP 简单邮件传输协议 http协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTML Hypertext Markup Language HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。即HTTP协议主要由请求和响应构成。 常用请求方法 POST、GET、PUT、DELETE 请求由 4 部分组成 HTTP 请求方法或 “动作” 正在请求的 URL 一个可选的请求头集合。其中可能包括身份验证信息 一个可选的请求体 请求头 由请求方式、请求URL和协议版本构成 GET /day01/code/login.php?username=123&amp;password=123 HTTP/1.1 POST /day01/code/login.php HTTP/1.1 请求行 Host：localhost 请求的主机，发出请求的页面所在的域 Cache-Control：max-age=0 控制缓存 Accept / 接受的文档MIME类型 User-Agent 很重要，浏览器的用户代理字符串 Referer 从哪个URL跳转过来的，发出请求的页面 URL Accept-Encoding 可接受的压缩格式 If-None-Match 记录服务器响应的ETag值，用于控制缓存,此值是由服务器自动生成的 If-Modified-Since 记录服务器响应的Last-Modified值,此值是由服务器自动生成的 Accept-Charset 浏览器能够显示的字符集 Accept-Language 浏览器当前设置的语言 Connection 浏览器和服务器之间连接的类型 Cookie 当前页面设置的任何 Cookie 请求主体 即传递给服务端的数据 注：当以post形式提交表单的时候，请求头里会设置 Content-Type: application/x-www-form-urlencoded，以get形式当不需要 响应和响应报文响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 服务器返回的 HTTP 响应包含 3 部分 一个数字和文字组成的状态码，用来显示请求的成功和失败 一个响应头集合 响应主体 状态行 由协议版本号、状态码和状态信息构成 HTTP/1.1 200 OK 响应头 Date ： 响应时间 Server ： 服务器信息 Last-Modified ： 资源最后修改时间 由服务器自动生成 ETag ： 资源修改后生成的唯一标识 由服务器自动生成 Content-Length ： 响应主体长度 Content-Type ： 响应资源的类型 响应主体 即服务端返回给客户端的内容； 状态码，常见的有: 200代表成功 304文档未修改 403没有权限 404未找到 500服务器错误 JavaScript 原生的 AjaxAjax 的技术核心是 XMLHttpRequest 对象。AJAX 不是一门的新的语言，而是对现有技术的综合利用。本质是在HTTP协议的基础上以异步的方式与服务器进行通信。 异步 指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。 其优势在于不阻塞程序的执行，从而提升整体执行效率。 XMLHttpRequest 对象浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。 HTTP请求3个组成部分与XMLHttpRequest方法的对应关系 请求行 xhr.open(‘post’,’01.php’); 请求头 xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’); get请求可以不设置 请求主体 xhr.send(“name=xjj&amp;age=10”); get 请求方式可以传空 1234567891011121314151617181920// 适用于 IE7 之前的版本 function createXHR() &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHtt" ], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; IE7+、FireFox、Opera、Chrome、Safari 都支持原生的 XHR 对象。 1var xhr = new XMLHttpRequest(); 封装获取 xhr 对象的函数 12345678910111213141516171819202122232425function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined") &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHtt" ], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error ("No XHR object is available"); &#125;&#125; XMLHttpRequest 对象使用 open() 方法 三个参数： 要发送的请求的类型：(“get”, “post”) 请求的 URL ，是相对于执行代码的当前页面（也可以使用绝对路径） 表示是否异步发送请求的布尔值 只能想用一个域中使用相同端口和协议的 URL 发送请求。如果 URL 与启动请求的页面有任何差别，都会发生安全错误。 12xhr.open("get", "exam.php", false);xhr.send(null); send() 方法 一个参数，请求主题发送的数据 如果不需要请求主体发送数据，必须传入 null 值，调用完之后请求就发会被分派到服务器。 由于这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行。在收到响应后 ，响应的数据会自动填充 XHR 对象的属性。属性说明如下： responseText: 作为响应主体被返回的文本。 responseXML: 如果响应的内容是 “text/xml” 或 “application/xml”，这个属性中保存着响应数据的 XML DOM 文档。 status: 响应的 HTTP 状态。 statusText: HTTP 状态说明。 在收到响应后，第一步就是检查 status 属性，以确定响应已经成功返回。一般来说，可以将 状态代码为 200 作为成功的标志。此时，responseText 属性的内容已就绪，而且在内容正确的时候，responseXML 也能够访问了。此外，状态码为 304 表示请求的资源并没有被修改，可以直接使用浏览器缓存的版本；也意味着响应是有效的。因此，检查状态码： 1234567xhr.open("get", "exam.php", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText);&#125; else &#123; console.log("请求失败: " + xhr.status);&#125; 前面这样发送同步请求没有问题，但是发送异步请求时，才能让 JavaScript 继续执行而不必等待响应。可以通过检测 XHR对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段。该属性的取值： 0 未初始化，即尚未调用 open() 方法 1 启动，已经调用 open() 方法，但尚未调用 send() 2 发送，已经调用 send() 方法，但尚未接收到响应，请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3 接收，已经接收到部分响应数据，请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4 完成，已经接收到全部响应数据，而且已经可以在客户端使用了 只要 readyState 属性的值由一个值变成另一个值，都会触发 readystatechange 事件。可以利用这个事件来检测每次状态变化后 readyState 值。通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用 open() 之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性。代码如下：onreadystatechange 是 Javascript的 事件的一种，其意义在于监听 XMLHttpRequest 的状态 获取状态行（包括状态码&amp;状态信息） xhr.status 状态码; xhr.statusText 状态码信息 获取响应头 xhr.getResponseHeader(&#39;Content-Type&#39;); xhr.getAllResponseHeaders(); 响应主体 xhr.responseText; xhr.responseXML 123456789101112var xhr = createXHR();xhr.onreadystatechange = function() &#123; if (xhr.readState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "exam.php", true);xhr.send(null); 在接收到响应之前还可以调用 abort() 方法来取消异步请求。 1xhr.abort(); setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接收两个参数： 头部名称 头部字段的值 setRequestHeader()方法必须在调用 open() 方法之后，send() 方法之前调用. GET 请求GET 请求将查询的字符串参数追加到 URL 的末尾，传入 open() 方法的 URL 末尾的查询字符串必须经过正确的编码才行。 查询字符串中的每个值都必须经过 encodeURLComponent() 进行编码，然后才能放到 URL 末尾。 所有的名-值对都必须由（&amp;）符号分隔。如： 1xhr.open("get", "exam.php?name=value&amp;name=value2", true); 封装经过编码的查询字符串。 123456// 向 URL 末尾添加查询字符串的方法function addURLParam(url, name, value) &#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURLComponent(name) + "=" + encodeURLComponent(value); return url;&#125; POST 请求通常用于向服务器发送应该保存的数据。POST 请求应该把数据作为请求的主体提交。给 open() 方法的第一个参数传入 “post” 就可以初始化一个 post 请求。 1xhr.open("post", "exam.php", true); 使用 XHR 来模仿表单提交：首先将 Content-Type 头部设置为 application/x-www-form-urlencoded ，也就是表单提交时的数据类型，其次是以适当的格式创建一个字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function submitData() &#123; var xhr = createXHR(); xhr.onreadstatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125; &#125;; xhr.open("post", "exam.php", true); xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); var form = document.getElementById("userInfo"); xhr.send(serialize(form));&#125;// 获取 XHR 对象的兼容方法function createXHR() &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHtt" ], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString);&#125;// 表单序列化函数function serialize(form) &#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i = 0, len = form.elements.length; i &lt; len; i++) &#123; field = form.elements[i]; switch(field.type) &#123; case "select-one": case "select-multipule": if (field.name.length) &#123; for (j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123; option = field.options[j]; if (option.selected) &#123; optValue = ""; if (option.hasAttribute) &#123; optValue = (option.hasAttribute("value") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes["values"].specified ? option.value : option.text); &#125; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(optValue)); &#125; &#125; &#125; break; case undefined: case "file": case "reset": case "submit": case "button": break; case "radio": case "checkbox": if (!field.name.length) &#123; break; &#125; default: if (field.name.length) &#123; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(field.value)); &#125; &#125; &#125; return parts.join("&amp;");&#125; 注：GET和POST请求方式的差异 GET没有请求主体，使用xhr.send(null) GET可以通过在请求URL上添加请求参数 POST可以通过xhr.send(‘name=itcast&amp;age=10’) POST需要设置 GET效率更好（应用多） GET大小限制约4K，POST则没有限制关于表单序列化 XMLHTTPRequest 2 级 定义了 FormData 类型。 FormData 为序列化表单以及创建与表单格式相同的数据。 12data new FormData();data.append("name", "Hiraku"); append() 方法传递两个参数。即键和值。也可以使用如下的方式： 1var data = new FormData(document.forms[0]); 创建了 FormData 的实例后，可以直接传递给 send() 方法： 1234567891011121314var xhr = createXHR();xhr.onreadstatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125;&#125;;xhr.open("post", "exam.php", true);xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");var form = document.getElementById("userInfo");xhr.send(new FormDta(form)); 超时设定123456789101112131415161718192021var xhr = createXHR();xhr.onreadstatechange = function() &#123; try &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125; &#125; catch (e) &#123; // 由 ontimeout 事件程序处理 &#125; &#125;;xhr.open("get", "exam.php", true);xht.timeout = 1000; // 仅适用于 IExhr.ontimeout = funciton() &#123; console.log("请求失败：")&#125;xhr.send(null); 进度事件 loadstart: 收到响应数据的第一个字节时触发 progress：在接收响应期间不断地触发 error: 发生错误时触发 abort: 调用 abort() 方法而终止时触发 load: 在接收到完整的响应数据时触发 loadend: 在通信完成或者触发 error、abort、或 load 事件后触发。 我们需要检测并判断响应头的 MIME 类型后确定使用 request.responseText 或者 request.responseXML API 总结 xhr.open() 发起请求，可以是get、post方式 xhr.setRequestHeader() 设置请求头 xhr.send() 发送请求主体get方式使用xhr.send(null) xhr.onreadystatechange = function () {} 监听响应状态 xhr.status 表示响应码，如200 xhr.statusText 表示响应信息，如OK xhr.getAllResponseHeaders() 获取全部响应头信息 xhr.getResponseHeader(&#39;key&#39;) 获取指定头信息 xhr.responseText、xhr.responseXML 都表示响应主体 封装ajax工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * 1. 请求的类型 type get post * 2. 请求地址 url * 3. 是异步的还是同步的 async false true * 4. 请求内容的格式 contentType * 5. 传输的数据 data json对象 * 6. 响应成功处理函数 success function * 7. 响应失败的处理函数 error function * 这些都是动态参数 参数对象 options * */window.$ = &#123;&#125;;/*封装一个函数*//*申明一个ajax的方法*/$.ajax = function(options)&#123; if(!options || typeof options != 'object')&#123; return false; &#125; /*请求的类型*/ var type = options.type || 'get';/*默认get*/ /*请求地址 */ var url = options.url || location.pathname;/*当前的地址*/ /*是异步的还是同步的 */ var async = (options.async === false)?false:true;/*默认异步*/ /*请求内容的格式 */ var contentType = options.contentType || "text/html"; /*传输的数据 */ var data = options.data || &#123;&#125;;/*｛name:'',age:''｝*/ /*在提交的时候需要转成 name=xjj 这种格式*/ var dataStr = ''; /*数据字符串*/ for(var key in data)&#123; dataStr += key+'='+data[key]+'&amp;'; &#125; dataStr = dataStr &amp;&amp; dataStr.slice(0,-1); /*ajax 编程*/ var xhr = new XMLHttpRequest(); /*请求行*/ /*(type=='get'?url+'?'+dataStr:url)判断当前的请求类型*/ xhr.open(type,(type=='get'?url+'?'+dataStr:url),async); /*请求头*/ if(type == 'post')&#123; xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); &#125; /*请求主体*/ /*需要判断请求类型*/ xhr.send(type=='get'?null:dataStr); /*监听响应状态的改变 响应状态*/ xhr.onreadystatechange = function()&#123; /*请求响应完成并且成功*/ if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; /*success*/ var data = ''; var contentType = xhr.getResponseHeader('Content-Type'); /*如果我们服务器返回的是xml*/ if(contentType.indexOf('xml') &gt; -1)&#123; data = xhr.responseXML; &#125; /*如果我们的服务器返回的是json字符串*/ else if(contentType.indexOf('json') &gt; -1)&#123; /*转化json对象*/ data = JSON.parse(xhr.responseText); &#125; /*否则的话他就是字符串*/ else&#123; data = xhr.responseText; &#125; /*回调 成功处理函数*/ options.success &amp;&amp; options.success(data); &#125; /*计时请求xhr.status不成功 他也需要的响应完成才认作是一个错误的请求*/ else if(xhr.readyState == 4)&#123; /*error*/ options.error &amp;&amp; options.error('you request fail !'); &#125; &#125;&#125;$.post = function(options)&#123; options.type = 'post'; $.ajax(options);&#125;$.get = function(options)&#123; options.type = 'get'; $.ajax(options);&#125; jQuery的ajaxjQuery为我们提供了更强大的Ajax封装 $.ajax({}) 可配置方式发起Ajax请求 $.get() 以GET方式发起Ajax请求 $.post() 以POST方式发起Ajax请求 $(&#39;form&#39;).serialize() 序列化表单（即格式化key=val&amp;key=val） url 接口地址 type 请求方式 timeout 请求超时 dataType 服务器返回格式 contentType 指定请求的 HTTP Content-Type data 发送请求数据 beforeSend: function () {} 请求发起前调用 success 成功响应后调用 error 错误响应时调用 complete 响应完成时调用（包括成功和失败） timeout 超时时间 cache 对于 GET 请求 ifModified 当为 true 时，jQuery 会为请求的每一个 URL 记录 Last-Modified 和 If-None-Match 响应头的值 global 是否触发上面描述的 Ajax 请求过程中的事件 jQuery Ajax介绍]]></content>
      <categories>
        <category>Ajax系列</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON数据]]></title>
    <url>%2F2015%2F12%2F06%2FJSON%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JSON (JavaScript Object Notion, JavaScript 对象表示法) JSON 是 JavaScript 的一个严格的子集，它是一种数据格式，而不是一种编程语言。 语法JSON 语法可以表示以下三种类型的值： 简单值：使用 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null，不支持 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对的值，每个键值对的值可以是简单类型，也可以是复杂类型。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型-简单值、对象或数组。 JSON 对象不支持变量、函数或对象实例，它就是一种表示数据结构化的数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴 简单值 5 这是 JSON 表示数值 5 的方式。 “str” 这是 JSON 表示字符串的方式。 对象1234var person = &#123; name: "Hiraku", age: 25&#125; 用 JSON 表示为： 1234&#123; "name": "Hiraku", "age": 25&#125; 又如： 1234567891011121314&#123; "name": "Hiraku", "age": 25, "school": [ &#123; "name": "Shantou University", "location": "Guangdong" &#125;, &#123; "name": "Technology of LanZhou University", "location": "Gansu" &#125; ]&#125; 数组JSON 中的复杂数据是数组。 JSON 数组采用的就是 JavaScript 中的数字字面量的形式。 如： 1[25, "Hiraku", 0]; JSON 数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。 如： 12345678910111213141516171819202122232425262728[ &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013 &#125;, &#123; "title": "HTML", "authors": [ "HuangShan", "Jack" ], "edition": 1, "year": 2012 &#125;, &#123; "title": "Java", "authors": [ "TangTang" ], "edition": 2, "year": 2015 &#125;,] JSON 解析和序列化JSON 数据可以解析为 JavaScript 对象优势及其明显。 JSON 对象eval() 函数可以解析、解释并返回 JavaScript 对象和数组。 两个重要方法： JSON.stringify() 把 JavaScript 对象序列化为 JSON 字符串 JSON.parse() 把 JSON 字符串解析为原生的 JavaScript 值 JSON.stringify() 详解出来要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数，第二个参数是一个选择，表示是否在 JSON 字符串中保留缩进。 第二个参数是数组： 1234567891011var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, ["title", "edition"]);console.log(jsonText); // &#123;"title":"JavaScript","edition":3&#125; 第二个参数是函数： 12345678910111213141516171819202122var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, function(key, value) &#123; switch(key)&#123; case "authors": return value.join(","); case "year": return "year"; case "edition": return undefined; default : return value; &#125; &#125;);console.log(jsonText); // &#123;"title":"JavaScript","authors":"Hirkau,Herscharl","year":"year"&#125; 第三个参数控制结果中的缩进和空白符：最大缩进空格为 10 。 1234567891011var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, null, 4);console.log(jsonText); 这段代码输出结果是： 123456789&#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125; 第三个参数是字符时： 1234567891011var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, null, " - -");console.log(jsonText); 输出结果： 123456789&#123; - -"title": "JavaScript", - -"authors": [ - - - -"Hirkau", - - - -"Herscharl" - -], - -"edition": 3, - -"year": 2013&#125; toJSON() 方法在 JSON.stringify() 方法不能满足某些独享进行自定义序列化的需求。可以给对象定义 toJSON() 方法，返回自身的 JSON 数据格式。 1234567891011121314var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013, toJSON: function() &#123; return this.title; &#125;&#125;var jsonText = JSON.stringify(book);console.log(jsonText); // "JavaScript" 序列化的顺序： (1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法，否则，返回对象本身； (2) 如果提供了第二个参数，应用这个函数过滤器，传入函数过滤器的值是第 (1) 步返回的值； (3) 对第 (2) 步返回的每个值进行相应的序列化； (4) 如果提供了第三个参数，执行相应的序列化。 解析选项JSON.parse() 方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。为了区别 JSON.stringify() 接收的替换(过滤)函数，这个函数被称为还原函数，实际上这两个函数的签名是相同的-接收两个参数，一个键和一个值，而且都需要返回一个值。 12345678910111213141516171819var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013, releaseDate: new Date(2011, 11, 1)&#125;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value) &#123; if (key == "releaseDate") &#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);console.log(bookCopy.releaseDate.getFullYear()); // 2011]]></content>
      <categories>
        <category>JSON系列</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2015%2F11%2F28%2FjQuery%2F</url>
    <content type="text"><![CDATA[使用 CSS 选择器来识别一组文档元素，并返回一个对象表示这些元素。返回的对象提供了大量的方法来批量操作匹配的元素。 jQuery前戏js不足 代码很麻烦，冗余 浏览器兼容性问题 入口函数只能写一个，写了多个，后面的会覆盖前面的问题 js的代码容错性比较差（比较容易出错） 实现一些简单的动画比较麻烦 什么是jquery？jquery是一个js库。jquery就是一个js文件. 什么是js库？js库其实就是把一些我们常用到的方法封装到一个单独的js文件里面，当我们想用的时候，引入它。（common.js animate.js） 特点： 丰富强大的语法 高效的查询 一套有用的方法 强大的函数式编程技巧，批量操作元素集 简洁的语言用法 引包1&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt; 全局函数jQuery() 全局函数，对应于一个快捷名：$。jQuery() 是工厂函数，不使用 new 关键字。 入口函数js入口函数1window.onload = function () &#123;...&#125;; jQuery入口函数11$(document).ready(function () &#123;...&#125;); jQuery入口函数2（简化）1$(function () &#123;...&#125;); $符实质 $实质是一个函数，jQuery 对象是类数组对象。 参数是 function 、把 dom 元素 document 转成 jQuery 对象，选择器 jQuery 的调用方式 第一种：传递 CSS 选择器（字符串）给 $() 方法。 选择器支持大部分 CSS3 选择器，也有自己扩展的。返回当前文档中匹配该选择器的元素集合。还可以将一个 jQuery 对象作为第二个参数传递给 $() 方法，返回该特定元素或元素子元素中匹配选择器的部分。第二个元素可选的。 第二种：传递一个 Element、Document 或 Window 对象给 $() 方法。将传入的内容封装成 jQuery 对象。 第三种：传递 HTML 文本字符串，会根据传入的文本创建好 HTML 元素并封装为 jQuery 对象返回。可以接收第二个参数，可以传递 Document 对象来指定与所创建元素相关联的文档。第二个参数还可以是 object 对象。 第四中：传入函数。 一些基础方法 size() 代替 length get() 代替方括号索引 toArray() 将 jQuery 对象转成真正数组 each() 遍历，代替 for 循环 参数是回调函数，回调函数中的 this 指向遍历的元素，是原生的 DOM 对象。 还可以将索引，该元素传递给回调函数的第一个和第二个参数，第二个参数也是 DOM 对象。 返回调用自身的 jQuery 对象，可以用于链式编程 map() 和 Array.prototype.map() 方法很接近。 接收回调函数作为参数； 索引是回调函数的第一个参数，元素作为 this 值和回调函数的第二个参数。 如果回调函数返回 null 或 undefined，索引忽略。 回调函数返回数组或者伪数组 map() 返回的 jQuery 对象可以不包括文档元素，但依旧可以像伪数组对象一样使用。 index() 接收一个参数，返回该元素在 jQuery 对象中的索引值。找不到返回 -1. is() 接收一个选择器，选中元素至少有一个匹配该选择器，返回 true。 jQuery 对象的三个属性 selector 选择器字符串 context 传递给 $() 的第二个参数 jquery jQuery 的版本号 选择器基本选择器 ID选择器 $(&quot;#id名&quot;); 类选择器 $(&quot;.类名&quot;); 标签选择器 $(&quot;标签名&quot;); 并集选择器 $(&quot;#curr,.cls&quot;); 交集选择器 $(&quot;li.cls&quot;); 层级选择器 子代选择器 $(&quot;#curr&gt;.cls&quot;) 后代选择器 $(&quot;li cls&quot;) 过滤选择器 :odd; :even; :eq(0); jQuery对象 方法 $(this).css(&quot;backgroundColor&quot;, &quot;pink&quot;).siblings(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;); 链式编程 $(this).find(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;); css({}); css设置样式 siblings(); 兄弟元素 find(); 后代元素 next(); 下一个兄弟元素 parent(); 父元素 show(); 显示 hide(); 隐藏 index(); 获取的是当前对象在它兄弟里面的索引/ eq(0); 取到的是jQuery对象 隐式迭代 设置属性的操作的时候设置的是所有的元素 获取性操作不去遍历，直接获取第一个 类操作 添加类 addClass(); 类名 移除类 removeClass(); 类名 判断类 hasClass(); 类名 切换 toggle(); 类名，两个类名之间切换操作 动画显示、隐藏 show(); hide(); toggle(); 参数speed,值为毫秒值 淡入、淡出 fadeIn(); fadeIn(); fadeToggle()； 不传参数的时候，有动画，normal; 滑入、滑出 slideUp(); slideUp(); slideToggle()； 不传参数的时候，有动画，normal; 自定义动画1$("#box").animate(&#123;"width":"400px","height":"400px", "left":"400px"&#125;,speed,easing); 停止动画 stop(); stop(clearQueue, jumpToEnd); 第一个参数是否清除动画队列 true, false，默认false;第二个参数是是否跳转到当前动画的最终效果 true, false jQuery和js节点操作js节点操作1234var box = document.getElementById("box");aNode.document.createElement("a");box.appendChild(aNode);aNode.innerHTML = "innerHtml"; jQuery 操作 append(); 添加节点 appendTo() 添加节点 prepend(); 添加节点 prependTo() 添加节点 after(); 添加节点 before(); 添加节点 insertAfter() 插入节点 insertBefore() 插入节点 replaceWith() 替换 add() 添加 first() 仅包含选中元素的第一个 eq() 只包含指定序号的单个元素 html(); 不传参获取，传参设置 text(); 不传参获取，传参设置 empty(); 清空节点（清理门户） remove(); 删除节点（自杀） clone(); 深度复制，不复制事件 clone(true); 深度复制，并且复制事件 val(); 获取值 val(&quot;abc&quot;); 设置值 next() 下一个节点 prev() 上一个节点 prevAll() 前面所有节点 nextAll() 后面所有节点 parent() 父节点 sibling() 兄弟节点 find() 后代节点 filer() 返回符合条件的jQuery对象 not() 排除元素 has() 是否有 gt() 参数是数字，返回大于参数的后面的元素 wrap() 包装每一个 wrapInner() 包装每一个元素的内容 wrapOuter() 将选中元素作为一组包装 jQuery属性操作 setAttribute(&quot;target&quot;, &quot;_blank&quot;); attr(&quot;title&quot;, &quot;星期四&quot;); 用法和css用法是一样 attr(name, value); 用法和css用法是一样 attr({json}); 用法和css用法是一样 css() 传入一个字符串参数，获取对应样式，注意，不能传入复合样式的属性，如 “font” 传入两个参数，设置样式 传入一个对象，设置样式 jQuery属性操作特例布尔类型的属性：true false checked selected disabled 在jquery里面，碰到布尔类型的属性的时候，不要用attr方法，应该prop方法 prop(&quot;checked&quot;); 用法和css用法是一样 jQuery获取属性值width系列（操作尺寸） width(); 能获取、设置 Innerwidth(); 获取内部宽度（包括宽度和padding） Outerwidth(); 获取内部宽度（包括宽度和padding和border） Outerwidth(true); 获取内部宽度（包括宽度和padding和border和margin） height(); 能获取、设置 Innerheight(); 获取内部高度（包括高度和 padding） Outerheight(); 获取内部高度（包括高度和 padding 和 border） Outerheight(true); 获取内部高度（包括高度和 padding 和 border 和 margin） jQuery操作坐标 position(); 只能获取不能设置，设置用 css 设置，找最近的有相对定位的的父盒子 offset(); 相对与dom最左上角（获取、设置） 带有 left 属性和 top 属性 offsetParent() 最近定位的祖先元素 scrollTop(); 设置卷去的距离（事件） scrollLeft(); 设置卷去的距离（事件） 1234$(window).scroll(function () &#123; $(this).scrollTop(); $(this).scrollLeft();&#125;); 获取和设置 CSS 类 addClass() 添加类 removeClass() 删除类 toggleClass() 没有类则添加，否则删除 hasClass() 判断是否存在 设置或获取元素内容 html() 不传参获取 传参设置值，html格式字符串 text() 不传参获取 传参设置值，纯文本jQuery事件 事件机制： 用户执行某一个操作，浏览器会相应用户的操作，执行某个函数 事件处理函数： 所谓的事件处理函数，就是响应用户的那个函数 用户事件： 就是事件名，用户可以注册的事件 注册事件： 就是赋值或调用addEventListener 响应事件： 做完操作调用某个方法 jQuery事件发展 简单事件绑定：不能同时注册两个事件 bind事件绑定 1234567$("p").bind(&#123; "click": function () &#123; alert("我执行了click"); &#125;,"mouseenter": function () &#123; alert("我执行了mouseenter"); &#125;&#125;); 不支持动态创建元素 delegate事件（委托、委派、代理） 123$("div").delegate("p", "click", function () &#123; alert("我执行了委托事件");&#125;); on事件绑定1234567/*on给div注册委托事件*/$("div").on("click", "p", function () &#123;&#125;); /*on给div注册普通的点击事件*/$("div").on("click", function () &#123; alert("我触发了div本身的事件");&#125;); 解除事件绑定123456/*off是解除所有的事件,能解除委托事件*/$("div").off();/*解除click事件*/$("div").off("click");/*解除委托的click事件*/$("div").off("click","**"); 事件触发 trigger(&quot;focus&quot;); 触发获取焦点事件，会触发浏览器默认行为 triggerHandler(&quot;focus&quot;); 触发获取焦点事件，不会触发浏览器默认行为 事件对象event click(function(event){...}); 点击 keyCode = event.keyCode; 键盘码 阻止事件冒泡方法1： event.stopPropagation(); 方法2： return false; 阻止浏览器的默认行为方法1： event.preventDefault(); 方法2： return false; 事件 click(function(){...}); 点击 scroll(function(){...}); 鼠标滚轮事件 focus(function(){...}); 获取焦点 mouseenter(function(){...}); 鼠标经过 mouseleave(function(){...}); 鼠标离开 keydown(function(event){var keyCode = event.keyCode;}); 键盘按键按下 keyup(function(event){var keyCode = event.keyCode;}); 键盘抬起 浏览器提供的事件123456789101112131415161718"onabort", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose","oncontextmenu", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover","ondragstart", "ondrop", "ondurationchange", "onemptied","onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload","onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onvolumechange", "onwaiting", "onbeforecopy", "onbeforecut", "onbeforepaste", "oncopy", "oncut", "onpaste", "onsearch", "onselectstart", "onwheel", "onwebkitfullscreenchange", "onwebkitfullscreenerror" 迭代12345678910/*显式迭代：对每一个元素做不同的处理*/for (var i = 0; i &lt; $("li").length; i++) &#123; var target = (i + 1) / 10; $("li").eq(i).css("opacity", target);&#125;/*each();*/$("li").each(function (index, element) &#123; var target = (index + 1) / 10; $(element).css("opacity", target);&#125;); 插件懒加载插件123456&lt;img class="lazy" data-original="23.jpg" alt=""&gt;&lt;script src="jquery-1.12.4.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="plugins/jquery.lazyload.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123;$("img.lazy").lazyload();&#125;);&lt;/script&gt; fullpage插件引入文件1234&lt;link rel="stylesheet" href="css/jquery.fullPage.css"&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/jquery-ui.min.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.fullPage.js"&gt;&lt;/script&gt; html1234567891011&lt;div id="fullpage"&gt; &lt;div class="section"&gt;第一屏&lt;/div&gt; &lt;div class="section"&gt;第二屏&lt;/div&gt; &lt;div class="section"&gt; &lt;div class="slide"&gt;第三屏的第一屏&lt;/div&gt; &lt;div class="slide"&gt;第三屏的第二屏&lt;/div&gt; &lt;div class="slide"&gt;第三屏的第三屏&lt;/div&gt; &lt;div class="slide"&gt;第三屏的第四屏&lt;/div&gt; &lt;/div&gt; &lt;div class="section"&gt;第四屏&lt;/div&gt;&lt;/div&gt; js1234567891011$(function()&#123; $('#fullpage').fullpage(&#123; 'verticalCentered': false, 'css3': true, 'sectionsColor': ['#254875', '#00FF00', '#254587', '#695684'], anchors: ['page1', 'page2', 'page3', 'page4'], 'navigation': true, 'navigationPosition': 'right', 'navigationTooltips': ['fullPage.js', 'Powerful', 'Amazing', 'Simple'] &#125;);&#125;); 可选配置 选项 方法 回调函数 jqueryUI插件jqueryUI插件 官网 引入文件123&lt;link rel="stylesheet" href="plugins/jquery-ui.css" /&gt;&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script src="plugins/jquery-ui.js"&gt;&lt;/script&gt; html1234567891011121314&lt;body&gt;&lt;div class="drag-wrapper"&gt; &lt;div class="drag-bar"&gt;可拖动、排序、变形的新闻模块&lt;/div&gt; &lt;div class="resize-item"&gt; &lt;div class="sort-wrapper"&gt; &lt;ul class="sort-item"&gt; &lt;li&gt;这是第1条新闻!&lt;/li&gt; &lt;li&gt;这是第2条新闻!&lt;/li&gt; &lt;li&gt;这是第3条新闻!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; js1234567&lt;script&gt; $(function () &#123; $(".drag-wrapper").draggable(&#123;"handle":".drag-bar"&#125;); $(".resize-item").resizable(&#123;"handles":"s"&#125;); $(".sort-item").sortable(&#123;"opacity":"0.5"&#125;); &#125;);&lt;/script&gt; 插件制作制作插件：就是给jquery对象添加方法。 $.fn.fnName = function(){}]]></content>
      <categories>
        <category>jQuery系列</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas]]></title>
    <url>%2F2015%2F11%2F18%2Fcanvas%2F</url>
    <content type="text"><![CDATA[什么是 Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布.在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现. canvas 的基本用法 基本语法 1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api. canvas 的使用领域 canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑 基本绘图基本绘图方法绘图步骤: 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 ‘2d’. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath(). 01-绘制基本线1234567891011121314151617var canvas = document.createElement( 'canvas' );canvas.width = 500;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( '2d' );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为: 计算机直角坐标系 分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext(&#39;2d&#39;) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo(x, y) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo(x, y) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用 CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果. getContext 方法语法: Canvas.getContext(typeStr) 描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39;作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39; 返回 CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext 类型的对象. moveTo 方法语法: CanvasRenderingContext2D.moveTo(x, y) 描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标. lineTo 方法语法: CanvasRenderingContext2D.lineTo(x, y) 描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标. stroke 方法语法: CanvasRenderingContext2D.stroke() 描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来. 总结 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式(色彩等) 绘制直线图形 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法. fill 方法语法: CanvasRenderingContext2D.fill() 描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色. 非零环绕原则非零环绕原则 说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态. 闭合路径closePath 方法 语法: CanvasRenderingContext2D.closePath() 描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来. 闭合路径的一个例子 123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为: 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法. 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin 设置相交线的拐点. CanvasRenderingContext2D.getLineDash() 获得线段样式数组. CanvasRenderingContext2D.setLineDash() 设置线段样式. CanvasRenderingContext2D.lineDashOffset 绘制线段偏移量. 设置线宽语法: CanvasRenderingContext2D.lineWidth = number 描述: 设置线宽. 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value 描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束. 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value 描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转. 虚线语法: CanvasRenderingContext2D.lineDashOffset = numberCanvasRenderingContext2D.getLineDash()CanvasRenderingContext2D.setLineDash() 描述: setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度. 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = valueCanvasRenderingContext2D.fillStyle = value 描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象. 一个例子 12345678for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + Math.floor(255-42.5*j) + ')'; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125;&#125; 绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法 绘制矩形 绘制圆弧 绘制矩形绘制矩形的方法 CanvasRenderingContext2D.strokeRect CanvasRenderingContext2D.fillRect CanvasRenderingContext2D.rect 注意: rect 方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果. 清除矩形区域: CanvasRenderingContext2D.clearRect 绘制矩形框语法: CanvasRenderingContext2D.strokeRect(x, y, width. height) 描述: 用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多. 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高. 使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法. 绘制的矩形支持 strokeStyle 设置颜色样式. 绘制填充矩形语法: CanvasRenderingContext2D.fillRect(x, y, width. height) 描述: 用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多. 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高. 使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法. 绘制的矩形支持 fillStyle 设置颜色样式. 清除矩形区域语法: CanvasRenderingContext2D.clearRect(x, y, width, height) 描述: 用于清除画布中的矩形区域的内容. 参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高. 绘制圆弧绘制圆弧的方法有 CanvasRenderingContext2D.arc() CanvasRenderingContext2D.arcTo() 绘制圆弧语法: CanvasRenderingContext2D.arc(x, y, radius. startAngle. endAngle, anticlockwise) 描述: 该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形. 方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标. 参数 radius 表示圆弧半径, 单位为弧度. 参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向. 参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选. 注意事项使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 如果设置了 moveTo, 那么会连线该点与圆弧的起点.如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 会自动闭合路径填充. 绘制扇形绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可 123456789101112... ctx.strokeStyle = 'red'; ctx.fillStyle = 'pink'; ctx.moveTo( 100, 200 ); ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 ); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo( 300, 200 ); ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 ); ctx.closePath(); ctx.fill(); 效果 绘制饼形图绘制饼形图最大的特点是角度是叠加的. 开始从 -Math.PI/2 开始绘制, 达到执行角 x 后, 下一个区域从 x 开始绘制, 然后有到一个角 y 停下来. 如此反复到 Math.PI * 3 / 2 结束. 三等分饼形图绘制一个三等分的饼形图, 颜色使用 红, 绿, 蓝. 123456789101112var x = 200, y = 200, r = 100, step = Math.PI * 2 / 3, // 120 度一个区域 start = -Math.PI / 2, // 起始角度 colors = [ 'red', 'green', 'blue' ];for ( var i = 0; i &lt; 3; i++ ) &#123; ctx.beginPath(); ctx.moveTo( x, y ); ctx.fillStyle = colors[ i ]; ctx.arc( x, y, r, start, start+=step ); ctx.fill();&#125; 绘制相切弧语法: CanvasRenderingContext2D.arcTo( x1, y1, x2, y2, radius) 描述:该方法用于绘制圆弧 绘制的规则是当前位置与第一个参考点连线, 绘制的弧与该直线相切. 同时连接两个参考点, 圆弧根据半径与该连线相切 例如有一个起始点 (100, 100), 那么绘制其点. 颜色设置为红色. 12ctx.fillStyle = 'red';ctx.fillRect(100 - 4, 100 - 4, 8, 8); 然后两个参考点分别为 (100, 300) 和 (300, 300), 绘制出该点 12ctx.fillRect(100 - 4, 300 - 4, 8, 8);ctx.fillRect(300 - 4, 300 - 4, 8, 8); 连接两个参考点 12345ctx.beginPath();ctx.strokeStyle = 'red';ctx.moveTo(100, 300);ctx.lineTo(300, 300);ctx.stroke(); 得到效果为: 调用 arcTo 方法绘制圆弧. 记得将起始点设置为 (100, 100) 12345ctx.beginPath();ctx.strokeStyle = 'blue';ctx.moveTo(100, 100);ctx.arcTo(100, 300, 300, 300, 100);ctx.stroke(); 得到效果： 注意: 使用该方法可以使用圆弧连接两条直线, 而不用计算复杂的起始角度与结束角度. 因此用于绘制圆角矩形等案例较多. 绘制圆角矩形封装一个函数, 用于绘制圆角矩形. 参考 rect 方法, 需要坐标参数 x, y. 由于设置圆角, 因此需要设置圆角半径 cornerRadius. 还需要提供宽高. 首先绘制一个矩形边框. 但是需要考虑圆角, 虽然从 x, y 开始绘制, 但是中间要空出半径的距离. 1234567891011var x = 100, y = 100, width = 300, height = 100, cornerRadius = 10;ctx.strokeStyle = 'red';ctx.moveTo(x + cornerRadius, y);ctx.lineTo(x + width - cornerRadius, y);ctx.moveTo(x + width, y + cornerRadius);ctx.lineTo(x + width, y + height - cornerRadius);ctx.moveTo(x + width - cornerRadius, y + height);ctx.lineTo(x + cornerRadius, y + height);ctx.moveTo(x, y + height - cornerRadius);ctx.lineTo(x, y + cornerRadius);ctx.stroke(); 效果为 然后再分别绘制四个角, 设置当前位置与参考点的位置. 设置当前位置为一个线端点, 然后参考点依次就是 矩形顶点 和 另一个线段的端点. 12ctx.moveTo(x + cornerRadius, y);ctx.arcTo(x, y, x, y + cornerRadius, cornerRadius); 即可得到 同理绘制另外三个圆角 123456ctx.moveTo(x + width - cornerRadius, y);ctx.arcTo(x + width, y, x + width, y + cornerRadius, cornerRadius);ctx.moveTo(x + width, y + height - cornerRadius);ctx.arcTo(x + width, y + height, x + width - cornerRadius, y + height, cornerRadius);ctx.moveTo(x + cornerRadius, y + height);ctx.arcTo(x, y + height, x, y + height - cornerRadius, cornerRadius); 即可得到 封装成方法就可以绘制更多圆角矩形了. 封装中注意 beginPath() 和 save() 和 restore() 123456789101112131415161718192021222324function cRect (x, y, width, height, cornerRadius, color) &#123; ctx.save(); ctx.beginPath(); ctx.strokeStyle = color || 'red'; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + width - cornerRadius, y); ctx.moveTo(x + width, y + cornerRadius); ctx.lineTo(x + width, y + height - cornerRadius); ctx.moveTo(x + width - cornerRadius, y + height); ctx.lineTo(x + cornerRadius, y + height); ctx.moveTo(x, y + height - cornerRadius); ctx.lineTo(x, y + cornerRadius); // 开始绘制四个圆角 ctx.moveTo(x + cornerRadius, y); ctx.arcTo(x, y, x, y + cornerRadius, cornerRadius); ctx.moveTo(x + width - cornerRadius, y); ctx.arcTo(x + width, y, x + width, y + cornerRadius, cornerRadius); ctx.moveTo(x + width, y + height - cornerRadius); ctx.arcTo(x + width, y + height, x + width - cornerRadius, y + height, cornerRadius); ctx.moveTo(x + cornerRadius, y + height); ctx.arcTo(x, y + height, x, y + height - cornerRadius, cornerRadius); ctx.stroke(); ctx.restore();&#125; 绘制文本绘制文本的方法 CanvasRenderingContext2D.fillText() CanvasRenderingContext2D.strokeText() CanvasRenderingContext2D.measureText() 文本样式 CanvasRenderingContext2D.font CanvasRenderingContext2D.textAlign CanvasRenderingContext2D.textBaseline 绘制文字语法: CanvasRenderingContext2D.strokeText(text, x, y[, maxWidth]) CanvasRenderingContext2D.fillText(text, x, y[, maxWidth]) 描述: 这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制. 计算文本尺寸语法: CanvasRenderingContext2D.measureText() 描述: 该方法返回一个文本尺寸对象, TextMetrics 对象.TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度. 设置文字属性设置文字字体语法: CanvasRenderingContext2D.font = value 描述: 该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等. 其顺序可以是: style | variant | weight | size/line-height | family. 默认值为 10px sans-serif 设置字体水平对齐方式语法: CanvasRenderingContext2D.textAlign = value 描述: 该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等. 该属性可以设置的值有: start( 默认 ), end, left, right, center. start 表示根据参考基准点的垂直直线左靠对齐 end 表示根据参考基准点的垂直直线右靠对齐 left 与 right 就是左对齐与右对齐的意思 最后 center 就是居中的含义. 设置字体垂直对齐方式语法: CanvasRenderingContext2D.textBaseline = value 描述: 该方法设置文字在垂直方向上的对齐方式. 该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic 基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐. alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母. ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下. 所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle. top, middle, bottom 使用的较多 alphabetic 表示字母参考线, ideographic 会比它低一点, hanging 表示悬挂. 实际上大多数参考方式只有在特定语言中有作用, 而且与字体也有相对复杂的关系. 例如( 下图是有部分错误的 ): 绘制图片绘制图像虽然只有一个 drawImage 函数, 但是该函数有多重参数形式. CanvasRenderingContext2D.drawImage( img, dx, dy ) CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight ) CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 绘制简单图像语法: CanvasRenderingContext2D.drawImage(img, dx, dy) 描述: 使用三个参数, 允许在画布上的 任意位置 绘制图片. 参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等. 需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载. 准备一张网络图片, 绘制, 便于查看其加载过程. 12345678// 随便从百度中搜索 '美女头像', 记录一个链接地址var url = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg';// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图ctx.drawImage( img, 100, 100 ); 此时没有任何结果, 打开调试工具查看 Net Work; 因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中. 12345678910// 随便从百度中搜索 '美女头像', 记录一个链接地址var url = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg';// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图img.onload = function () &#123; ctx.drawImage(img, 100, 100);&#125;; 注意: 这里使用 new Image()与 document.createElement(&#39;img&#39;)是一样的. 在指定区域内绘制图像当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布。因此, 需要将其控制在一个矩形区域内绘制. 语法:CanvasRenderingContext2D.drawImage(img, dx, dy, dWidth, dHeight) 描述: 参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始. 该方法绘制的图像会在指定范围内被压缩显示. 如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图. 123456...var heigth = 100, width;img.onload = function () &#123; width = img.width * height / img.height; ctx.drawImage( img, 100, 100, width, height );&#125;; 绘制任意图像类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区. 语法: CanvasRenderingContext2D.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 描述: 这里的带有 s 前缀的参数就是指图源的矩形区域. 例如将图片的 ( 100, 100, 300, 200 ) 处的内容绘制到页面的 ( 100, 100, 300, 200 ) 的位置. 1ctx.drawImage(img, 100, 100, 300, 200, 100, 100, 300, 200); 变换Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有: CanvasRenderingContext2D.transform() CanvasRenderingContext2D.scale() CanvasRenderingContext2D.translate() CanvasRenderingContext2D.rotate() CanvasRenderingContext2D.setTransForm() 还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法. 什么是变换计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果. 平移变换平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了. 语法: CanvasRenderingContext2D.translate(x, y) 描述: 该方法将坐标进行平移. x 表示水平移动, 正数向右, 负数向左. y 表示垂直移动, 正数向下, 负数向上. 变换可以重复调用, 变换是可以累加的. 使用该变换, 常常用于绘制不同位置, 但是形状重复的图形. 注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换. 旋转变换语法: CanvasRenderingContext2D.rotate(radian) 描述: 该方法将坐标轴进行旋转变换. 参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转. 该变换常常用于实现旋转动画等. 缩放变换语法: CanvasRenderingContext2D.scale(x, y) 描述: 该方法实现水平与垂直的缩放. 参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. 参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. 该变换常常用于放大与缩小, 以及反转的效果. 环境前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码. Canvas 中引入了状态的保持机制. 使用 CanvasRenderingContext2D.save() 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 CanvasRenderingContext2D.restore() 方法即可. 状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态. 一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响. 优化canvas 在绘制图片的时候, drawImage 方法还支持将一个 canvas 绘制到另一个 canvas 中. 因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 canvas 中合成需要的效果. 画布保存画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串. 语法: Canvas.ToDataURL(type, encoderOptions) 描述: 该方法可以将画布转换成 base64 格式的数据 type 表示输出类型. 例如: image/png 或 image/jpeg 等 encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用 渐变和图案绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 strokeStyle 和 fillStyle 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复. 相关方法 CanvasRenderingContext2D.createLinearGradient() CanvasRenderingContext2D.createRadialGradient() CanvasRenderingContext2D.createPattern() 线性渐变语法: CanvasRenderingContext2D.createLinearGradient(x0, y0, x1, y1) 描述: 该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式. 该方法有两个参数, 用于表示线型渐变的方向与位置. 使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间. 方法语法: CanvasGradient.addColorStop( rate, color ). 该方法用于设置在某个比例位置的颜色是什么.rate 的取值是 0 到 1 之间. 可以添加多个渐变点. 然后将该对象赋值给 *Style 属性即可. 注意: 渐变点的坐标是基于坐标轴来计算的. 放射渐变语法: CanvasRenderingContext2D.createRadialGradient(x0, y0, r0, x1, y1, r1) 描述: 该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆. 前三个参数分别表示其中一个圆的圆心的坐标, 以及半径. 后三个参数分别表示另一个圆的圆心的坐标, 以及半径. 绘制渐变效果用法与线性渐变一样. 重复填充语法: CanvasRenderingContext2D.createPattern(img, repetition) 描述: 该方法表示使用图片来填充的设置方法. 需要两个参数, 一个是图片, 一个是重复的方式. 图片允许是 img 标签, 图片, canvas 等对象 可选择的重复方式与 CSS 一致. 有: repeat, repeat-x, repeat-y, no-repeat. 如果是 空或””, 但不是 undefined, 默认就是 repeat.]]></content>
      <categories>
        <category>Canvas系列</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的表单]]></title>
    <url>%2F2015%2F11%2F08%2Fjs%E7%9A%84%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[JavaScript 最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局限。 表单基础HTML 中表单是由 &lt;form&gt; 元素来表示的。在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。有下列属性和方法。 acceptCharset: 服务器能够处理的字符串 action: 接收请求的 URL elements: 表单中所有控件的集合 enctype: 请求的编码类型 length: 表单中所有的控件的数量 method: 表单要发送的 HTTP 请求类型，通常是 “get” 或者 “post” name: 表单的名称 reset(); 将所有的表单域重置为默认值 submit(); 提交表单 target(); 用于发送请求和接收响应的窗口名称 共有表单的字段属性 disabled: 布尔值，表示当前表单是否被占用。 form: 指向当前字段所属表单的指针；只读。 name: 当前字段名称。 readOnly: 布尔值，表示当前字段是否只读。 tabIndex: 表示当前字段的切换序号。 type: 当前字段的类型。 value: 当前字段将被提交给服务器的值。 共有的表单字段方法 focus(); 用于将浏览器的焦点设置到表单字段。 blur(); 共有的表单事件 focus blur change：对于 &lt;input&gt; 和 &lt;textaera&gt; 元素，当它们失去焦点而且 value 值改变时该事件触发。 submit 阻止表单默认的同步提交的方式。 123456$("#form").on("submit", function(e)&#123; e.preventDefault(); $.ajax(&#123; // 代码段 &#125;);&#125;); 文本框脚本 type: text 可以通过设置 size 的值指定文本框中能够显示的字符数，通过 value 设置文本框中的初始值，通过 maxlength 指定文本框可以接收的最大字符数。 选择文本选择文本 select() 方法 12var textbox = document.forms[0].elements("textbox1");textbox.select(); 在文本获得焦点时选择所有文本。 取得选择的文本两个属性： selectionStart selectionEnd 12345var textbox = document.forms[0].elements("textbox1");textbox.select();function getSelectedText(textbox) &#123; return textbox.value.substring(textbox.selectionStart, selectionEnd);&#125; IE9+, FireFox, Safari, Chrome, Opera 支持 选择部分文本 setSelectionRange() 方法 两个参数：要选择的第一个字符的索引和要选择的最后一个字符的索引 IE9+, FireFox, Safari, Chrome, Opera 支持 IE8 以及之前版本：必须先使用 createTextRange(),然后调用 collapse() 将范围折叠到文本框开始位置，使用 moveStart() 和 moveEnd。 过滤输入屏蔽字符屏蔽字符需要结合键盘码，如果需要屏蔽特定的字符，需要检测 keypress 事件对应的字符编码，然后再做决定如何响应。 操作剪切板剪切板事件。 beforecopy copy beforecut cut beforepaste paste 1234567891011121314var EventUtil = &#123; // 其它代码省略... getClipboardText: function(event) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData("text"); &#125;, setClipboardText: function(event) &#123; if (event.clipboardData) &#123; return event.clipboardData.setData("text/plain", value); &#125; else if (window.clipboardData) &#123; return window.clipboardData.setData("text/plain", value); &#125; &#125;&#125; 自动切换焦点常见的一种方式是用户在填写完当前字段时，自动将焦点切换到下一个字段。 123456789101112131415function tabForword(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength) &#123; var form = target.form; for (var i = 0; i &lt; form.elements.length; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1]) &#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125;&#125; HTML5 约束验证 API支持的浏览器 FireFox 4+, Safari 5+, Chrome, Opera 10+。 必填字段 required 检查是否支持 required 字段： 1var isRequiredSupported = "required" in document.createElement("input"); 其它输入类型HTML5 为 type 又添加了几个类型： url email 数值范围 number range datetime datetime-local date month week time 输入模式HTML5 新增了 pattern 属性，值是正则表达式。 检验有效性 checkValidty() 方法 validity 对象 customError patternMismatch rangeOverflow stepMisMatch tooLong typeMismatch valid valueMissing 禁用验证 novalidate 属性，表单不验证 formnovalidate 属性，某个提交按钮不验证 选择框脚本是通过 &lt;select&gt; 和 &lt;option&gt;。 add(newOption, relOption): 向控件中插入新的 &lt;option&gt; 元素，其位置在相关项之前。 multiple: 允许多选 options: 所有 &lt;option&gt; 的集合 remove(index): 移除给定位置的选项 selectedIndex: 基于 0 的选中项的索引 size: 选择框中可见行数 选择选项 appendChild() new Option(“Option text”, “Option value”); 表单序列化浏览器给服务器发送数据： 对表单中的字段的名称和值进行 URL 编码，使用 &amp; 分隔 不发送禁用的表单字段 只发送勾线的复选框和单选按钮 单选选择框中的每个选中的值单独一个条目 在单击提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。 &lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值。如果 &lt;option&gt; 元素没有 value 属性，则是 &lt;option&gt; 元素的文本值。 表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function serialize(form) &#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i = 0, len = form.elements.length; i &lt; len; i++) &#123; field = form.elements[i]; switch(field.type) &#123; case "select-one": case "select-multipule": if (field.name.length) &#123; for (j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123; option = field.options[j]; if (option.selected) &#123; optValue = ""; if (option.hasAttribute) &#123; optValue = (option.hasAttribute("value") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes["values"].specified ? option.value : option.text); &#125; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(optValue)); &#125; &#125; &#125; break; case undefined: case "file": case "reset": case "submit": case "button": break; case "radio": case "checkbox": if (!field.name.length) &#123; break; &#125; default: if (field.name.length) &#123; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(field.value)); &#125; &#125; &#125; return parts.join("&amp;");&#125; 富文本编辑器1234567&lt;iframe src="blank.html" name="richedit" style="height: 100px; width: 100px;"&gt;&lt;/iframe&gt;&lt;script&gt; EventUtil.addHandler(window, "load", function() &#123; frames["richedit"].document.designMode = "on"; &#125;);&lt;/script&gt;` 给 &lt;iframe&gt; 指定一个简单的 HTML 页面作为其内容来源。 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blank Page for Rich Text Editing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面中就会有一个类似文本框的可编辑区字段。 使用 contenteditable 属性为页面中的某个元素设置 contenteditable 属性，这个元素中的任何文本内容就可以编辑了。 操作富文本与富文本交互的主要方式，使用document.execCommand(); 三个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值，第二个参数应始终设为 false。下面就是支持的命令。 backcolor bold createlink cut delete fontname forecolor formatblock indent inserthorizontalrule insertimage insertorderedlist insertunorderedlist insertparagraph italic justfycenter outdent paste removeformat selectall unlink 富文本选区使用框架的 getSelection() 方法，可以确定实际选择的文本，该方法返回当前选择文本的 Selection 对象。有以下属性： anchorNode: 选区起点所在起点 anchorOffset focusNode focusOffset isCollapsed rangeCount 方法： addRange(range) collapse(node, offset) collapseToEnd() collapseToStart() containsNode(node) deleteFormDocument() extend(node, offset) getRangeAt(index) removeAllRanges() selectAllChildren(node) toString() 表单和富文本富文本不会自动提交，需要手动创建表单和富文本的关系。 12345EventUtil.addHandler(form, "submit", function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements["comments"].value = frames["richedit"].document.body.innerHTML;&#125;);]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的事件]]></title>
    <url>%2F2015%2F10%2F28%2Fjs%E7%9A%84%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JavaScript 与 HTML 之间的交互是通过 事件 实现的。事件三要素: 事件源.事件 = function(){ 事件处理程序 }；等价于 &lt;标签 事件= “事件处理程序”&gt;。 事件就是文档或浏览器窗口中发生的一些特定交互瞬间。包括事件类型、事件目标、事件处理程序、事件对象。 事件类型是用过用来说明发生什么类型事件的字符串。 事件目标是发生的事件或与之相关的对象。如 window、Document、Element 对象。以及由 XMLHTTPRequest 对象。 事件处理程序或事件监听程序是处理或响应事件的函数。 事件对象是与特定事件相关且包含有关该事件的详细信息的对象。 事件传播是浏览器决定哪个对象触发其事件处理程序的过程。当文档元素上发生某个类型的事件时，它们会在文档树上向上冒泡。 事件传播的另一中形式称为事件捕获，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获。 事件流事件流描述的是页面中接收事件的顺序。 事件冒泡事件开始是由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级向上传播到较为不具体的节点。IE、FireFox、Chrome、Safari将事件一直冒泡到 window 上。 事件捕获目的是在事件到达预定目标之前捕获它。不太具体的节点最先收到事件，而最具体的节点应该最后收到事件。 DOM 事件流事件流的三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 在 DOM 事件流中，实际目标在捕获阶段不会接收到事件。下一个阶段是”处于目标阶段”，事件在目标上发生，并在事件处理中看成是冒泡阶段的一部分。然后，冒泡阶段发生。 事件处理程序HTML 事件处理程序123456789&lt;input type="button" name="butt1" value="点我" onclick="console.log('我被点击了')"&gt;&lt;input type="button" name="butt2" value="点我" onclick="showMsg()"&gt;&lt;script type="text/javascript"&gt; function showMsg() &#123; console.log('被点了'); &#125;&lt;/script&gt;&lt;input type="button" name="butt3" value="点我" onclick="console.log(event.type)"&gt;&lt;input type="button" name="butt4" value="点我" onclick="console.log(this.value)"&gt; event 变量可以直接访问事件对象。this 指的是触发事件的当前元素。 HTML 指定事件处理程序的缺点是：HTML 和 JavaScript 代码紧密耦合。 DOM0 级事件处理程序将一个函数赋值给一个事件处理程序属性。优点：简单、跨浏览器的优势。 1234var btn = document.getElementById("btn");btn.onclick = function() &#123; console.log("我被点击了");&#125; DOM2 级事件处理程序定义了两个指定和删除事件处理程序的操作： addEventListener() 和 removeEventListener()；接收 3 个参数： 要处理的事件名 作为事件处理程序的函数 一个布尔值：true 时表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序。 IE 的事件处理程序 attachEvent() detachEvent() 均接收两个参数，事件处理程序名称和事件处理程序函数。通过 attachEvent 添加的事件处理程序都会被添加到事件冒泡阶段。 跨浏览器的事件处理程序封装一个兼容的事件处理程序，参数是：要操作的元素、事件类型、事件处理程序。 1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeListener) &#123; element.removeListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;&#125; 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件相关的信息。包括： 导致事件的元素 事件类型 事件相关信息 DOM 中的事件对象兼容 DOM 浏览器会将一个 event 对象传入到事件处理程序中。可以通过事件处理程序拿到 event 对象的信息。 1234567var btn = document.getElementById("btn");btn.onclick = function(event) &#123; console.log(event.type); // "click"&#125;btn.addEventlistener("click", function(event)&#123; console.log(event.type); // "click"&#125;, false); 在通过 HTML 特性指定的事件处理程序，变量 event 保存着 event 对象。 1&lt;input type="button" name="btn" value="点我" onclick="console.log(event.type)" /&gt; event 对象包含与创建它的特定事件有关的属性和方法。触发的事件不同，可用的属性和方法也不一样。但所有事件都会有下表中列出的方法。 | 属性/方法 | 类型 | 读/写 | 说明 || bubbles | Boolean | 只读 | 表明是否冒泡 || cancelable | Boolean | 只读 | 是否可以取消事件的默认行为 || currentTarget | Element | 只读 | 事件处理程序当前正在处理事件的那个元素 || defaultPrevented | Boolean | 只读 | true 时表示调用了 perventDefault() || detail | Integer | 只读 | 事件相关的细节信息 || eventPhase | Integer | 只读 | 调用事件处理程序的阶段：1捕获 2处于目标 3冒泡 || perventDefault() | Function | 只读 | 取消事件默认行为，如果candelable是true可以使用这个方法 || stopImmediatePropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序调用 || stopPropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，如果 bubbles 为 true，则可以使用这个方法 || target | Element | 只读 | 事件目标 || trusted | Boolean | 只读 | 为 true 时表示浏览器生成的，为 false 时表示开发人员通过 javascript 创建的 || type | String | 只读 | 被触发的事件类型 || view | AbstractView | 只读 | 与事件相关联的抽象视图。等同于发生事件的 window 对象 | 在事件处理程序的内部，this 始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果时间处理程序指定给了目标元素。则这三个的值相等。 stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。 IE 中的事件对象event 对象作为 window 对象的一个属性存在。 | 属性/方法 | 类型 | 读/写 | 说明 || cancelables | Boolean | 读/写 | 默认值是 false，设置为 true 就可以取消事件冒泡 || returnValue | Boolean | 读/写 | 默认 true，设为 false 可以取消事件的默认行为 || srcElement | Element | 只读 | 事件的目标 || type | String | 只读 | 被触发的事件类型 | 跨浏览器的事件对象12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeListener) &#123; element.removeListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault; &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation; &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125; 事件类型 UI 事件：用户与页面上的元素交互时触发； 焦点事件：元素获取焦点或失去焦点时触发 鼠标事件 滚轮事件 文本事件 键盘事件 合成事件 变动事件：底层 DOM 结构发生变化时触发 UI 事件 DOMActive 已废弃 load: 页面完全加载后在 window 上触发 unload：页面卸载后在 window 上触发 abort：在用户停止下载过程时，如果嵌入的元素没有加载完，则在目标元素上面触发 select：当用户选择文本框中的一个或多个时触发 resize：当窗口或框架的大小变化时触发 scroll：当用户滚动带滚动条的元素中的内容时在该元素上触发。 焦点事件 blur：元素失去焦点时触发；这个事件不会冒泡。 DOMFocusIn：在元素获取焦点时触发。与 HTML 事件的 focus 等价。只有 Opera 支持。DOM3 级已废弃，选择了 focusin。 DOMFocusOut：在元素失去焦点时触发。DOM3 级已废弃，选择了 focusout。 focus: 获取焦点时触发。 focusin：它冒泡，和 HTML 的 focus 事件等价。 focusout：它冒泡，是 HTML 的 blur 事件的通用版本。 鼠标与滚轮事件 click：用户单击鼠标按钮（一般是左键）或者按下 Enter 键时触发。 dbclick：双击鼠标触发。不能通过键盘触发这个事件。 mousedown：按下了鼠标任意键触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseenter 和 mouseleave 是一对，IE、FireFox 9+ 和 Opera 支持这个事件。 mousemove：鼠标指针在元素内部移动时重复触发。 mouseout：在鼠标指针位于一个元素上，然后用户将其移入另一个元素时触发。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一元素边界之内时触发 mouseup：鼠标抬起时触发。 滚轮事件 mousewheel 事件 12// 检查浏览器是否支持上面所有的事件var isSupported = document.implementation.hasFeature("MouseEvent", "3.0"); 客户区坐标位置 event.clientX 事件发生时鼠标指针在视口中的位置 event.clientY 事件发生时鼠标指针在视口中的位置 屏幕坐标位置 event.screenX 相对于整个电脑屏幕的坐标位置 event.screenY 相对于整个电脑屏幕的坐标位置 键 shiftKey ctrlKey altKey metaKey 相关元素发生 mouseover 和 mouseout 时，还会涉及更多的元素。 DOM 通过 event 对象的 relatedTarget 属性提供了相关元素信息。在 mouseover 事件触发时， IE 的 fromElement 保存了相关元素，在 mouseout 事件触发时，IE 的 toElement 保存了相关元素。 12345678910111213var EventUtill = &#123; getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromEvent) &#123; return event.fromEvent; &#125; else &#123; return null; &#125; &#125;&#125; 更多事件信息DOM2 级事件规范在 event 对象提供了 detail 属性，用于给出有关事件的更多信息。包含了一个数值表示单击了多少次。 altLeft ctrlLeft shiftLeft offsetX offsetY 键盘和文件属性 keydown：按下键盘上的任意键触发 keypress：按下键盘上的字符键触发 keyup：释放键盘上的键时触发 键码 event.keyCode textInput 事件 textInput 事件 event.data 属性的值是用户输入的字符。 event.inputMethod 属性表示把文本输入到文本框的方式 复合事件 compositionstart compositionupdate compositionend 变动事件 DOMSubtreeModified DOMNodeInserted DOMNodeRemoved DOMNodeInsertedIntoDocuemnt DOMNodeRemovedFromDocuemnt DOMAttrModified DOMCharacterDataModified HTML5 事件 contexmenu 事件 beforeunload 事件 DOMContentLoaded 事件 readystatechange 事件 uninitialized 对象尚未初始化 loading 对象正在加载 loaded 对象加载数据完成 interactive 可以操作对象了，但还没有完全加载 complete 对象已经加载完毕 pageshow 和 pagehide 事件 hashchange 事件 设备事件 orientationonchange 事件 MozOrientation 事件 deviceorientation 事件 设备在空间中朝向哪里 alpha 属性 beta 属性 gamma 属性 absolute 属性 compassCalibrated 属性+devicemotion 事件 触摸与手势事件 touchstart：手势在触摸屏时触发 touchmove：手势在屏幕上滑动时触发 touchend：手势离开触摸屏时触发 touchcansel：当系统停止跟踪触摸时触发 touches：表示当前跟踪的触摸操作的 Touch 对象的数组 targetTouches：特定于事件目标的 Touch 对象的数组 changeTouches：表示自上次触摸以来发生了什么改变 Touch 对象的数组 每个 touch 对象包含以下属性 clientX clientY identitier pageX pageY screenX screenY target 内存和性能JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。 事件委托对事件处理程序过多的问题的解决方法就是 事件委托 。事件委托就是利用了事件冒泡，只指定一个事件处理程序来管理某一类型的的所有事件。 12345&lt;ul id="ulBox"&gt; &lt;li id="li1"&gt;1&lt;/li&gt; &lt;li id="li2"&gt;2&lt;/li&gt; &lt;li id="li3"&gt;3&lt;/li&gt;&lt;/ul&gt; 委托事件 12345678910111213141516var ul = document.getElementById("ulBox");EventUtil.addHandler(ul, "click", function(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch (target.id) &#123; case "li1": document.title = "I changed"; break; case "li2": location.herf = "http://www.baidu.com"; break; case "li3": console.log("Hi"); break; &#125;&#125;); 移除事件处理程序1btn.onclick = null; 禁止a标签的默认行为1onclick = "return false;" 一个判断客户端是 PC 端还是移动端的程序123456789101112131415document.getElementById("txt").onkeydown=function (e) &#123; console.log(e.keyCode); &#125;;window.onresize=function () &#123; if (document.body.clientWidth&gt;960) &#123; console.log("您用的是电脑浏览的该页面"); &#125;else if(document.body.clientWidth&gt;500)&#123; console.log("您用的是平板浏览的该页面"); &#125;else&#123; console.log("您用的是手机浏览的页面"); &#125; &#125;&#125;; // 判断浏览器窗口大小document.onclick=function (e) &#123; document.title = e.screenX+"==="+e.screenY; //screenX和screenY是相对于屏幕的左上角 console.log(e);&#125;; 图片跟着鼠标飞123456789document.onmousemove=function (e) &#123; e=e||window.event; // 兼容代码 document.title=e.clientX+"==="+e.clientY; // clientX和clientY----事件参数获取 imgObj.style.position="absolute"; imgObj.style.left=e.clientX+"px"; imgObj.style.top=e.clientY+"px"; imgObj.style.left=e.pageX+"px"; //pageX--包含可视区域的横坐标和隐藏区域 imgObj.style.top=e.pageY+"px"; //pageY---包含可视区域的纵坐标和隐藏区域&#125;； 模拟多人开发注册事件12345678910111213function addEvent(element, eventName, fn) &#123; var oldEvent=element["on"+eventName]; if(oldEvent==null)&#123;//表示该事件没有处理函数 element["on"+eventName]=fn;//注册事件了 &#125;else&#123; //有事件了---先调用原来的事件,再重新注册新的事件 element["on"+eventName]=function () &#123; //调用原来的事件-注册新的事件 oldEvent(); fn(); &#125;; &#125;&#125; 注册多个事件 三种注册事件的方式: 对象.on事件名字=事件处理函数; 对象.addEventListener(“事件的名字”,事件处理函数,false); 对象.attachEvent(“on事件的名字”,事件处理函数); 注册事件方式的区别: btnObj.onclick=fn;这种方式任何浏览器都支持 btnObj.addEventListener();谷歌和火狐浏览器支持 btnObj.attachEvent();IE8支持 同一个元素同时注册多个相同的事件，addEventListener和attachEvent区别: 前者三个参数,后者两个参数 前者第一个参数是事件的名字，没有on 后者第一个参数是事件的名字,有on addEventListener方法中第三个参数如果是false则是事件冒泡,如果是true则是事件捕获 事件冒泡阶段判断 通过事件参数–e.eventPhase 可以获取当前事件经历的是什么阶段 如果是1则是捕获阶段 如果是2则是目标阶段:第一次点谁谁就是目标 目标阶段之后就是冒泡阶段 以上是结合第三个参数是false的情况而言 另一种情况:第三个参数是true的时候,只有捕获阶段和目标阶段 先捕获,然后再目标 一般网页中都是有事件冒泡的,一般情况我们不用捕获 阻止事件冒泡两种方式: 第一种:方法 e.stopPropagation(); 第二种:属性 window.event.cancelBubble=true; 有关事件处理的函数的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeListener) &#123; element.removeListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault; &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation; &#125; else &#123; event.cancelBubble = true; &#125; &#125;, getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromEvent) &#123; return event.fromEvent; &#125; else &#123; return null; &#125; &#125;, getWheelDelta: function(event) &#123; if (event.wheelDelta) &#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; &#125; &#125;, getCharCode: function(event) &#123; if (typeof event.charCode == "number") &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, getClipboardText: function(event) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData("text"); &#125;, setClipboardText: function(event) &#123; if (event.clipboardData) &#123; return event.clipboardData.setData("text/plain", value); &#125; else if (window.clipboardData) &#123; return window.clipboardData.setData("text/plain", value); &#125; &#125;&#125; 动画函数封装（js）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//根据id获取对应的元素function my$(id) &#123; return document.getElementById(id);&#125;/** element---任意的元素* attr---属性* */function getAttrValue(element,attr) &#123; return element.currentStyle ? element.currentStyle[attr] : window.getComputedStyle(element,null)[attr]||0;&#125;/** element----要移动的元素* target----移动的目标* 初级版本* */function animate1(element,target) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; //获取当前的位置 var current=element.offsetLeft; //每次移动多少步 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style.left=current+"px"; if(current==target)&#123; clearInterval(element.timeId); &#125; console.log("target:"+target+"current:"+current+"step:"+step); &#125;,10);&#125;/** 终极版本的动画函数* */function animate(element,json,fn) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//假设都达到了目标 for(var attr in json)&#123; if(attr=="opacity")&#123;//判断属性是不是opacity var current= getAttrValue(element,attr)*100; //每次移动多少步 var target=json[attr]*100;//直接赋值给一个变量,后面的代码都不用改 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style[attr]=current/100; &#125;else if(attr=="zIndex")&#123;//判断属性是不是zIndex element.style[attr]=json[attr]; &#125;else&#123;//普通的属性 //获取当前的位置----getAttrValue(element,attr)获取的是字符串类型 var current= parseInt(getAttrValue(element,attr))||0; //每次移动多少步 var target=json[attr];//直接赋值给一个变量,后面的代码都不用改 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style[attr]=current+"px"; &#125; if(current!=target)&#123; flag=false;//如果没到目标结果就为false &#125; &#125; if(flag)&#123;//结果为true clearInterval(element.timeId); if(fn)&#123;//如果用户传入了回调的函数 fn(); //就直接的调用, &#125; &#125; console.log("target:"+target+"current:"+current+"step:"+step); &#125;,10);&#125; 总结三大系列123clientX clientY clientWidth clientHeightpageX pageY pageWidth pageHeightoffsetLeft offsetTop offsetWidth offsetHeight]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM-文档对象模型]]></title>
    <url>%2F2015%2F10%2F08%2FDOM-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DOM 是针对 HTML 和 XML 文档的一个 API。 DOM 描绘了一个层次化的节点树。 HTML 文档的树形结构包含表示 HTML 标签或元素和表示文本字符串的节点，它也可能包括表示 HTML 注释节点。 DOM基本概念DOM 描述 DOM Document Object Model 文档对象模型 就是把HTML文档模型化，当作对象来处理 DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。 内容概念 文档(Document)：就是指HTML或者XML文件 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有 元素节点 属性节点 文本节点 注释节点 元素(Element) HTML文档中的标签可以称为元素 结构概念 父节点 当前节点的父级 子节点 当前节点的子级 兄弟节点 和当前节点同属一个父级的节点 节点类型DOM1 级定义了一个 Node 接口，该接口由 DOM 中的所有节点类型实现。这个 Node 接口在 JavaScript 中是作为 Node 类型事项的。JavaScript 中的所有节点类型都继承自 Node 类型。每个节点有一个 NodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的 12 个常量来表示： Node.ELEMENT_NODE(1); 表示元素节点 Node.ATTRIBUTE_NODE(2); 表示属性节点 Node.TEXT_NODE(3); 表示文本节点 Node.CDATA_SECTION_NODE(4); Node.ENTITY_REFERENCE_NODE(5); Node.ENTITY_NODE(6); Node.PROCESSING_INSTRUCTION_NODE(7); Node.COMMENT_NODE(8); 表示文本节点 Node.DOCUMENT_NODE(9); Document 节点 Node.DOCUMENT_TYPE_NODE(10); Node.DOCUMENT_FRAGEMENT_NODE(11); DocumentFragment 是特殊的节点，作为其它节点的一个容器。 Node.NOTATION_NODE(12); someNode.nodeType 兼容所有浏览器，IE 没有公开 Node 类型的构造函数。 nodeName 和 nodeValue这两个属性了解节点的具体信息，对于节点类型为 1 的元素节点，nodeName 中保存的是元素标签名，nodeType 的值始终是 null。 节点关系作为元素树的文档节点 firstChild 指向 childNodes 列表中的第一个元素 lastChild 指向 childNodes 列表中的最后一个元素 childNodes 每个节点都有 childNodes 属性，保存了 NodeList 类数组对象。 NodeList 是有生命、有呼吸的对象，DOM 结构的变化能够自动反映在 NodeList 对象中。 下面代码将 NodeList 对象转成真正的数组。 123456789101112function convertToArray(nodes) &#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); // 针对非 IE 浏览器 &#125; catch (e) &#123; array = new Array(); for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; array.push(nodes[i]); &#125; &#125; return array;&#125; parentNode 每个节点都有 parentNode 属性，指向文档树的根节点。 previousSibling 上一个同胞节点 nextSibling 下一个同胞节点 作为元素树的文档 firstElementChild 第一个子元素 有兼容性问题 lastElementChild 最后一个子元素 有兼容性问题 children 子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持。 childElemntCount 子元素的数量。返回值和 childre.length 相等。 previousElementSibling 上一个兄弟元素 有兼容性问题 nextElementSibling 下一个兄弟元素 有兼容性问题 haschildNodes() 方法在节点包含一个或多个子节点的情况下返回 true。 操作节点 appendChild() 向 childNodes 列表的末尾添加一个节点。 添加节点后，childNodes 的新增节点、父节点以及以前的最后一个子节点的关系指针都会相应地得到更新。返回新增的节点。 如果传入的节点已经是文档的一部分了，那么就将该节点从原来的位置移动到新位置。 insertBefore() 接收两个参数：要插入的节点和作为参照的节点。 插入节点后，被插入的节点会变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是空，则该方法和 appendChild() 执行相同的操作。 replaceChild() 接收两个参数：要插入的节点，要替换的节点。 要替换的节点被该方法返回，从文档树种移除，该节点所占位置被新的节点代替 removeChild() 接收一个参数，即要被移除的节点，返回这个节点。 以上几个方法是有父节点的子节点才具有的。下面两个方法所有类型的节点都有的。 cloneNode() 用于创建调用该方法的节点完全相同的节点。 该方法接收一个布尔值，表示是否深度克隆 参数为 true 时，克隆调用该方法的节点及其整个子节点树 参数为 false 时，只复制节点本身。 复制后返回的节点副本属于文档所有，但并没有为它指定父节点。 使用上面的 appendChild()、insertBefore()、replaceChild()方法添加的文档中。 normalize() 唯一作用是处理文档树中的文本节点。 调用该方法的节点，在其后代节点中查找空文本节点并删除。如果找到相邻文本节点，则合并 Document 类型在浏览器中，document 对象是 HTMLDocument (继承自 Document) 的一个实例，表示整个 HTML 页面。 特点： nodeType 为 9 nodeName 为 “#document” nodeValue 为 “null” parentNode 为 “null” ownerDocument 为 “null” 子节点可能是 DocumentType(最多一个)、Element(最多一个)、Comment、ProcessingInstruction。 文档子节点 documentElement 属性 内置的访问子节点的方式 document.documentElement ， 返回值和 childNodes[0]、firstChlid 的值相同。 body 属性 直接指向 body 元素。 documentElement 和 body 属性所有浏览器都支持。 doctype 属性 IE8 以及之前的版本，如果存在文档声明，会错误的解释为 一个助手并当做 Comment 节点。返回 null。 IE9+ 以及 FF，如果存在文档声明，会将其作为文档的第一个子节点；document.doctype 是一个 DocmentType 节点。会出现在 document.childNodes 中。 Safari、Chrome 和 Opera，如果存在文档声明，将其解析，不作为文档的子节点。document.doctype 是一个 DocmentType 节点。不会出现在 document.childNodes 中。 浏览器对处理位于 &lt;html&gt; 外部的注释节点，也有差异 文档信息 document.title 获取 标签中的内容 网页请求相关的属性 document.URL 包含网页完整的 URL document.domain 包含页面的域名 document.referrer 保存着链接到当前页面的那个页面的 URL。 所有的这些信息保存在请求的 HTTP 头部。以上三个属性中只有 domain 属性是可以设置的。 当页面中包含来自其它子域的框架或者内嵌框架时候，能够设置 document.domain 就非常方便。由于跨域安全限制，来自不通子域的页面无法通过 JavaScript 通信。而通过将每个页面的 document.domain 设置为相同的值，这些页面就可以听歌互相访问对方包含的 JavaScript 对象了。 获取元素 getElementById(); 该方法只能被document对象调用； 该方法接收一个参数，要获取元素的 ID ； 如果找到返回该 DOM 元素，否则返回 null。 IE7 以及较低版本会将表单元素 name 值为该方法中的 id 相同的元素返回。 getElementsByTagName(); 该方法接收一个参数，标签名。还可以传入 “*”，表示获取文档中的所有元素。 通过标签名寻找一类元素（找到的是由元素对象组成的伪数组）。返回的是一个 HTMLCollection。 即可以被 document 调用，又可以被元素对象调用。 被元素对象调用时表示在该元素对象内部执行查找。 getElementByName(); 只有 HTMLDocument 才有的方法。 返回带有给定 name 特性的所有元素。最常用于取得单选按钮。 可以使用方括号或者 item() 来访问 HTMLCollection 集合中的项。该对象还有一个 nameItem() 方法，可以通过元素的 name 特性取得集合中的项。 特殊集合 document.anchors 返回包含页面中所有带 name 特性的 &lt;a&gt;元素 document.applets 包含文档中所有的 &lt;applet&gt; 元素，这个已经不用了。 document.froms 包含文档中的所有的 &lt;form&gt; 元素。 document.images 包含文档中的所有的 &lt;img&gt; 元素。 document.links 包含文档中的所有带 herf 的 &lt;a&gt; 元素。 DOM 的一致性检测 document.implementation 属性 该属性有个 hasFeature() 方法，接收两个参数： 要检测的 DOM 功能的名称 要检测的 DOM 功能的版本号 文档写入将输出流写入到网页中。可以使用这些方法动态的给网页中添加内容。 document.write() 接收要写到输出流的文本 document.writeln() 接收要写到输出流的文本 document.open() 打开输出流 document.close() 关闭输出流 write() 和 writeln() 方法动态地包含外部资源。使用时不能直接包含字符串&lt;/sript&gt;，而是使用 &lt;\/script&gt; 进行转义。 Element 类型Element 提供了对元素标签名、子节点及其特性的访问。 特点： nodeType 为 1 nodeName 为 元素的标签名 nodeValue 为 “null” parentNode 可能是 Document 或 element 子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference 要访问元素的标签名可以使用 nodeName 或 tagName 属性。DOM元素.tagName 输出的是大写。 在 HTML 中，标签名始终都是全部以大写标书；而在 XML 或 XHML 中标签名会与源码代码中保持一致。 HTML 元素由 HTMLElement 类型表示。每个 HTML 元素的特性： id 元素在文档中的唯一标识符 title 有关元素的附加说明 lang 元素内容的语言代码，很少用 dir 语言的方向，值为 “ltr” (从左至右) 或 “rtr” (从右至左)，很少用 className，与元素的 class 相对应。 获取属性 getAttribute() 传递的参数与实际的属性名相同。 可以获取自定义属性。 任何元素的所有特性，都可以通过 DOM 元素本身的属性来访问。只有非自定义的属性才会以属性的形式添加到 DOM 对象中。 有两类特殊的属性，虽然有对应的属性名，但是属性的值与通过 getAttribute() 返回的值并不相同。 style, 用于通过 CSS 为元素指定样式； 事件处理程序。通过 getAttribute() 访问会返回相对应的代码字符串。 设置属性 setAttribute() 接收两个参数：要设置的属性名，要设置的值 存在替换，不存在创建 元素对象.属性名 = &quot;属性值&quot;; &lt;标签 属性名=&quot;属性值&quot;&gt; 删除属性 removeAttribute() IE6 之前版本不支持。 attribute 属性该属性有一下几种方法： getNamedItem(name) 返回 nodeName 等于 name 的节点 removeNamedItem(name) 移除 nodeName 等于 name 的节点 setNamedItem(node) 向列表中添加节点 item(pos) 返回位于 pos 处的节点 创建元素 document.createElement() 接收的参数是要创建元素的标签名 HTML 中不区分大小写，XML 或 XHTML 中区分大小写 在 IE 中可以使用为该方法传入完整的元素标签的方式创建。 元素的子节点元素可以任意多的子节点和后代节点。 childNodes 属性包含了所有的子节点。 Text 类型不包含 HTML 结构的纯文本 特点： nodeType 为 3 nodeName 为 “#text” nodeValue 为 节点所包含的文本 parentNode 是 Element 可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本。 appendData(text): 将 text 添加到节点的末尾 deleteData(offset, count): 从 offset 指定的位置开始删除 count 个字符 insertData(offset, text): 从 offset 指定的位置开始插入 text replaceData(offset, count, text): 用 text 替换 offset 指定的位置开始到 + offset+count 为止处的文本。 splitText(offset): 从 offset 指定的位置将当前文本分成两个文本节点 substringData(offset, count): 提取从 offset 指定的位置开始到 offset + count 为止处的字符串 还有个 length 属性，保存着节点中字符的数目。 创建文本节点 document.createTextNode() 创建新文本节点 接受一个参数-要创建的文本 规范化文本节点 normalize() 在包含两个或多个文本节点的父元素上调用此方法，则会将所有文本节点合并成一个节点。 切割文本节点 splitText() 将一个文本分隔成两个文本节点。 Comment 类型特点： nodeType 为 8 nodeName 为 “#document” nodeValue 为 注释内容 parentNode 是 Document 或 Element 无子节点 CDATASection 类型特点： nodeType 为 4 nodeName 为 “#cdata-section” nodeValue 为 CDATA 区域中的内容 parentNode 是 Document 或 Element 无子节点 DocumentType 类型特点： nodeType 为 10 nodeName 为 doctype 的名称 nodeValue 为 null parentNode 是 Document 无子节点 DocumentFragment 类型特点： nodeType 为 11 nodeName 为 “#document-fragment” nodeValue 为 null parentNode 是 null 子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference 使用 document.createDocumentFragment() 方法。可以通过 appendChild() 或 insertBefore() 将文档片段中内容添加到文档中。 Attr 类型特点： nodeType 为 2 nodeName 为 属性名 nodeValue 为 特性的值 parentNode 是 null HTML 中无子节点 XML 或 HTML 中子节点可以是 Text 或 EntityReference Attr 有 3 个属性：name、value 和 specified。 操作表格 caption tBodies tFoot tHead rows createHead() createTFoot() createCaption() deleteRow(pos) insertRow(pos) cells deleteCell(pos) insertCell(pos) DOM 扩展对 DOM 的两个主要扩展是 Selectors API 和 HTML5。支持的浏览器： IE8+、FireFox 3.5+、Safari 3.1+、Chrome 和 Opera 10+。 选择符 APISelectors APILevel 1 的核心是两个方法： querySelector() 接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有匹配到，返回 null。 querySelectorAll() 接收一个 CSS 选择符，返回一个 NodeList 对象。如果没有找到，NodeList 对象是空的。 Selectors APILevel 2 新增了一个 matchesSelector() 方法，接收一个参数，CSS 选择符，如果调用元素与该选择符匹配，返回 true，否则返回 false。 元素遍历 childElementCount: 返回不包括文本节点和注释的子元素个数； firstElementChild: 指向一个子元素，firstChild 元素版 lastElementChild: 指向最后一个子元素，lastChild 元素版 previousElementChild: 指向前一个兄弟元素。 previousSibling 的元素版 nextElementChild: 指向下一个兄弟元素。 nextSibling 的元素版 HTML5与类相关的扩充 getElementsByClassName(); 通过类名获取元素。 可以通过 document以及所有 HTML 元素调用该方法。 接收一个参数，即包含一或多个类名的字符串。 返回指定类型的所有 NodeList。 getElementsByClassName() 支持的浏览器有 IE9+、FireFox 3+、Safari 3.1+、Chrome 和 Opera 9.5+。 classList 属性HTML5 新增了一种操作类名的方式，就是为所有的元素添加 classList 属性。 add(value): 给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value): 表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 remove(value): 从列表中删除给定的字符串。 toggle(value): 如果列表中已存在给定的值，删除它；如果列表值没有给定的值，添加它。 焦点管理 document.activeElement 属性 始终会引用 DOM 中当前获得了焦点的元素。 document.hasFocus() 方法 用于确定文档是否获得了焦点 支持的浏览器有 IE4+、FireFox 3+、Safari 4+、Chrome 和 Opera 8+。 HTMLDocument 的变化readyState 属性 loading， 正则加载文档 complete，已经加载完文档 支持的浏览器有 IE4+、FireFox 3.6+、Safari、Chrome 和 Opera 9+。 兼容模式在标准模式下，document.compatMode 的值等于 “CSS1Compat”; 在混杂模式下，document.compatMode 的值等于 “BackCompat”。 支持的浏览器有 FireFox、Safari 3.1+、Chrome 和 Opera。 head 属性document.head，引用文档的 &lt;head&gt; 元素。 支持的浏览器有 Safari 5、Chrome。 字符集属性 charset 属性表示文档中实际使用的字符集。默认是这个属性值是 “UTF-16”，可以通过 &lt;meta&gt; 元素、响应头部或者直接设置 charset 属性修改这个值。 defaultCharset，表示根据默认浏览器以及操作系统的设置。 document.charset 支持的浏览器有 IE、Safari、Chrome 和 Opera。document.defaultCharset 支持的浏览器有 IE、Safari 和 Chrome。 自定义数据属性自定义数据属性是以 data- 开头的。这些属性可以任意添加、随便命名。 添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。dataset 属性的值是 DOMStringMap 的一个实例，也就是键值对的映射。在这个映射中，每一个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀。 支持的浏览器有 FireFox 6+ 和 Chrome。 插入标记 innerHTML 属性 读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记； 写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素原先的所有子节点。 读模式返回的字符串内容各浏览器之间有差异 写模式 innerHTML 的值被认为是 HTML，如果是纯文本，则设置纯文本 innerHTML 中的 &lt;script&gt; 标签不会执行其中的脚本 并不是所有的元素都支持 innerHTML 属性。 &lt;col&gt;、&lt;colgrounp&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;、&lt;tr&gt; IE8 以及之前的版本 &lt;title&gt; 没有 innerHTML 属性 outerHTML 属性 读模式下，outerHTML 属性返回与调用元素的所有子节点的 HTML 标签； 写模式下，outerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素。 支持的浏览器有 IE4+、Safari 4+、Chrome 和 Opera 8+。 innerAdjacentHTML() 方法 接收两个参数：插入位置和要插入的 HTML 文本，第一个参数必须是： “beforebegin” 在当前元素之前插入一个紧邻的兄弟元素 “afterbegin” 在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素 “beforeend” 在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素 “afterend” 在当前元素之后插入一个紧邻的兄弟元素 内存与性能在使用innerHTML、outerHTML、innerAdjacentHTML() 等时最好先把被替换元素上绑定的事件处理程序删除。 使用 innerHTML 方法时，首先拼串，然后在往 DOM 树中添加，提高性能。 scrollIntoView() 方法任何 HTML 元素都可以调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在时口中。 支持的浏览器有 IE、Safari、FireFox 和 Opera。 专有扩展文档模式文档模式决定了页面可以使用什么功能。有混杂模式和标准模式。 通过 document.documentMode 属性可以指定给定页面使用的是什么样的文档模式。 children 属性返回只包含元素中同样还是元素的子节点，与 childNodes 没区别。 contains() 方法返回 true 或 false，如果传入的参数元素是调用元素的后代，则返回 true，否则返回 false。 插入文本 innerText 属性 可以操作元素中包含的所有文本内容 会按照由浅到深的顺序，将子文档树中的所有文本都拼接起来 会对文本中存在的 HTML 语法字符进行编码 支持 innerText 属性有 IE9+、Safari 3+、Chrome 和 Opera 8+。 textContext 属性 是 DOMLevel 3 规定的一个属性。 支持 textContext 属性有 IE9+、Safari 3+、Chrome、FireFox 和 Opera 10+。 outerText 它的读模式和 innerText 没区别 写模式：outerText 不只是替换调用它的子节点，而是会替换包括替换整个元素。 支持的浏览器有 IE4+、Safari3+、Chrome 和 Opera8+。 123456789101112131415//封装function getInnerText(element) &#123; if (typeof element.innerText === "string") &#123; return element.innerText; &#125; else &#123; return element.textContent; &#125;&#125;function setInnerText(element, content) &#123; if (typeof element.innerText === "string") &#123; element.innerText = content; &#125; else &#123; element.textContent = content; &#125;&#125; 滚动 scrollIntoViewIfNeeded(alignCenter): 只有当前元素在视口中不可见的情况下，才能滚动浏览器窗口或容器让其可见。 scrollByLines(lineCount): 将元素的内容滚动指定的行高； scrollByPages(pageCount): 将元素的内容滚动指定页面的高度； 支持的浏览器 Chrome 和 Safari。scrollIntoView() 是唯一个所有浏览器都支持的方法，所以比较常用。 DOM2 和 DOM3DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 则在这个基础上引进了更多的交互能力。DOM2 和 DOM3 分为很多模块。如下： DOM2 级核心(DOM Level 2 Core)：为节点添加了更多的方法和属性 DOM2 级视图(DOM Level 2 Views)：为文档定义了基于样式基本信息的不同视图。 DOM2 级事件(DOM Level 2 Events): 说明了如何使用事件与 DOM 文档操作 DOM2 级样式(DOM Level 2 Style)：定义了如何通过编程方式操作 CSS 样式 DOM2 级遍历和范围(DOM Level 2 Trversal and Range): 引入了遍历 DOM 文档和选择其他特定部分的新接口。 DOM2 级 HTML(DOM Level 2 HTML)：在 1 级 HTML 基础上添加了更多的属性、方法和新接口 DOM 变化针对 XML 命名空间的变化HTML 不支持 XML 命名空间，XHTML 支持 XML 的命名空间。 命名空间使用 xmlns 特性来定义。 Node 类型变化 Document 类型变化 Element 类型变化 NamedNodeMap 类型的变化 NamedNodeMap 类型的变化 Document 类型的变化 框架的变化 样式访问元素的样式任何支持 style 特性的 HTML 元素在 JavaScript 中都有一个对应的 style 属性。在 style 特性指定的任何 CSS 属性都将表现为 style 对象的相应属性。对于使用短线分隔的 CSS 属性，将其转换成驼峰大小写的形式。 float 是 javascript 的保留字，不能用作属性名，其相应的属性名是 cssFloat，FireFox、Safari、Opera、Chrome 都支持；但是 IE 支持的是 styleFloat. 直接可以访问的样式：widh; height; padding; margin; display; 设置和获取样式 通过对象的style属性只能设置和获取行内样式 获取样式的时候 如果行内没有该样式 输出空字符串 设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位 什么情况通过class控制样式 什么情况通过style控制样式不严格的说： 如果样式很多 通过 直接控制类名 的方式加样式 如果样式比较少 通过直接设置比较方便 严格来说： 从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名 但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候 DOM 样式属性和方法 cssText length 应用给元素的 CSS 属性 parentRule getPropertyCSSValue(propertyName) getPropertyPriority(propertyName) getPropertyValue(propertyName) item(index) 返回给定位置的 CSS 属性名称。 removeProperty(propertyName) setProperty(propertyName, value, priority) 计算的样式 getComputedStyle() 接收两个参数：要获取的计算样式的元素和一个伪元素字符串。第二个参数是可选的 在 IE 中不支持，而是有个 currentStyle 属性 使用 document.defaulView.getComputedStyle(DOM元素, 伪元素/null) 返回 CSSStyleDeclaration 对象，包含当前元素的所有计算的样式。 操作样式表 disabled href media ownerNode parentStyleSheet title type cssRules ownerRule deleteRule(index) inserRule(rule, index) 应用于文档的所有样式表时通过 document.styleSheets 集合来表示的。IE 支持的是 styleSheet 属性 而其他浏览器都支持 sheet 属性。 CSS 规则，CSSStyleRule 类型继承了 CSSRule，包含以下属性： CSSText parentRule parentStyleSheet selectorText style type 创建规则 sheet.insertRule() 接收两个参数：规则文本和在哪里插入规则的索引。 除了 IE 以外的其它四个浏览器支持 sheet.addRule() 接收两个必选参数一个可选参数：选择符文本和CSS样式信息，在哪里插入规则的索引。 IE 浏览器支持 删除规则 sheet.deleteRule() 接收一个参数：要删除规则的位置 除了 IE 以外的其它四个浏览器支持 sheet.removeRule() 接收一个参数：要删除规则的位置 IE 浏览器支持 元素的大小偏移量：包括元素在屏幕上占用的所有的可见的空间。由其高度、宽度来决定，包括内边距、滚动条和边框大小。 偏移量 offsetHeight offsetWidth offsetLeft offsetTop 客户区的大小：不包括边框，包括内边距 clientWidth clientHeight 滚动大小：包含滚动内容的大小 scrollHeight scrollWidth scrollLeft scrollTop 确定元素的大小 getBoundingClientRect() 方法返回一个矩形对象，有四个属性： left、top、right、bottom 给出了元素在叶明中相对于视口的位置。 遍历NodeIterator可以使用 document.createNodeIterator() 方法来创建 NodeIterator 的新实例，接收四个参数。 root: 想要搜索的起始树中的节点 whatToShow: 要访问哪些节点的数字代码 filter: 是一个 NodeFilter 对象，表示应该接收还是拒绝某种特定的节点的函数 entityReferenceExpansion: 布尔值，是否要扩展引用。 whatToShow 的参数在这里不再列出，需要的时候直接查找 JavaScript 高级程序设计； TreeWalker是 NodeIterator 的更高级版本。可以使用 document.createTreeWalker() 方法来创建 TreeWalker 的新实例，接收四个参数。 范围有关范围的一些方法、属性此处不再列出。详细更多参见 《JavaScript 高级程序设计》 总结动态创建结构 方式一：直接在文档中书写 document.write(“内容”) 方式二：改变元素对象内部的HTML innerHTML=”内容” 方式三：创建或克隆节点并追加 createElement(); cloneNode(); 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行! 动态创建结构（效率问题） 把字符串变为文档对象 把当前对象挂接到DOM树上 渲染引擎根据新的DOM树重新渲染]]></content>
      <categories>
        <category>DOM系列</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM-浏览器对象模型]]></title>
    <url>%2F2015%2F09%2F28%2FBOM-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DOM:中的顶级对象是document—-太监(大总管);BOM:中的顶级对象是window——皇上;整个浏览器就是window,页面中的document也属于window 变量,函数,对象都属于window 但是:写代码的时候,window可以直接省略 window 对象BOM，即浏览器对象模型，核心是：window 对象 全局变量全局变量不能通过 delete 操作符删除。 窗口关系及框架如果页面中包含框架，每个框架都有自己的 window 对象，并且保存在 frames 集合中。每一个 window 对象都有一个 name 属性，其中包含框架的名称。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt; &lt;/head&gt; &lt;frameset rows="160, *"&gt; &lt;frame src="frame0.html" name = "topFrame"&gt; &lt;frameset cols="50%, 50%"&gt; &lt;frame src="frame1.html" name = "leftFrame"&gt; &lt;frame src="frame2.html" name = "rightFrame"&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; window.frames[0] window.frames[“topFrame”] top.frames[0] top.frames[“topFrame”] frames[0] frames[“topFrame”] 窗口位置IE、Safari、Opera、Chrome 支持 screenLeft screenTop FireFox 支持 screenX screenY 窗口移动方法 moveTo() moveBy() 窗口大小IE9+、Safari、Opera、FireFox、Chrome 支持 innerWidth innerHeight outerWidth outerHeight IE9+、Safari、FireFox 中 outer… 返回浏览器本身的尺寸(window 和 框架都是)。Opera 中则是页面视图容器大小。Chrome 中 两两都返回相同的值，即视口大小而非浏览器窗口大小。 在 IE9、Safari、Opera、FireFox、Chrome 中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 保存了页面视口信息。在 IE 的标准模式下生效，而混杂模式使用的是： document.body 中的 clientHeight 和 clientWidth。而 Chrome 通过 document.body 和 document.documentElement 都可以获取到页面视图。 可以通过检查 document.compatMode 来检测浏览器是否处于标准模式。 导航和打开窗口window.open() 方法，四个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。和 a 标签的 herf 属性一个功能。不怎么用。 间歇调用和超时调用 超时调用 setTimeout() 方法 两个参数， 一是要执行的回调函数或一个包含 JavaScript 代码的字符串 而是以毫秒值表示的时间。即在执行前需要等待的时间。 传递字符串消耗性能。 返回一个 ID 在非严格模式下，this 指向 window，严格模式下是 undefined。 clearTimeout() 清除超时调用 间歇调用 setInterval() 方法 参数同 setTimeout() 方法相同 返回也是一个 ID 间歇调用一直执行到页面卸载 clearInterval() 清除间歇调用 系统对话框 alert() confirm() prompt() 12345678if(window.confirm("你确定要退出吗?")) &#123; //执行到这里,证明用户点击了确定按钮 console.log("点击了确定");&#125; else &#123; //证明了用户点击了取消的按钮 console.log("点击了取消");&#125;window.prompt("请输入用户名"); location 对象属性有： hash 返回 URL 中的哈希值 hostname 返回服务器名称和端口号 herf 返回当前页面加载的完整的 URL。 location 对象的 toString() 方法也返回这个值。 pathname 返回 URL 中的目录（或）文件名 port 返回 URL 中指定的端口号 protocol 返回页面使用的协议 search 返回 URL 的查询字符串 方法有： location.assign(“http://www.baidu.com“); 改变浏览器的位置 location.replace(“http://www.baidu.com“); 地址不会记录到历时中—-后退点不了 location.reload(); 刷新—一般情况在页面中用一个按钮点击刷新 BOM的一些方法 win = window.open(“09test.html”,”_blank”,”width=200,height=200,top=100,left=100,resizable=no”); win.close();//此时close方法 无论open中第一个参数是不是地址都可以关闭窗口 win.moveTo(300,300);//把新打开的窗口移动到距离左侧和上面300px win.moveBy(20,20);//每次移动20px win.resizeTo(400,400);//窗口的大小发生了改变 win.resizeBy(40,40); navigator对象属性或方法： appCodeName 浏览器名称 appMinorVersion 此版本信息 appName 完整浏览器名称 appVersion 浏览器版本 buildID cookieEnabled cpuClass javaEnabled() language mimeType onLine opsProfile oscpu platform plugins preference() product productSub register-ContentHandler() register-ProtocalHandler() securifyPolicy systemLanguage taintEnabled() userAgent userLanguage userProfile vendor vendorSub screen 对象用处不大，此处不再详细说明。 history对象 window.history.forward(); window.history.back();//后退 window.history.go();]]></content>
      <categories>
        <category>BOM系列</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的正则表达式]]></title>
    <url>%2F2015%2F09%2F16%2Fjs%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一个描述字符模式的对象。 JavaScript 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。 正则表达式定义正则表达式的直接量定义为包含在一对斜杠 (/) 之间的字符 如： 1var pattern = /s$/; 正则表达式中的基本元字符 . 通配符（. 除了\n以外的任意一个内容） [] 表示的是范围:表示的是范围中的任意一个 [0-9] 表示的是:0到9之间(包含)任意一个数字 [a-z] 表示所有的小写字母中的一个 [A-Z] 表示的是所有的大写字母中的任意一个 [a-zA-Z] 表示的是所有的字母中的任意一个 [9] 表示的就是9 [0-9a-zA-Z] 表示的是任意的一个数字或者任意的一个字母 ()表示的是分组(为了更明确这个正则表达式的意思),提升优先级 | 表示的是或者的意思 [0-9]|[a-z] 0-9之间的任意一个数字或者是小写字母中的任意一个字母 *表示的是该符号前面的表达式出现了0次到多次 + 表示的是该符号前面的表达式出现了1次到多次 ? 表示的是该符号前面的表达式出现了0次到一次 {} 表示的是前面的表达式出现了多少次,具体是多少次:大括号中的写法 {n,m} 匹配前一项至少 n 次，但不超过 m 次 {n,}匹配前一项 n 次或者更多次 {n} 匹配前一项 0 次或多次，等价于 {0,} 数字、字母、特殊符号 \d 表示的是任意的一个数字和 [0-9] 一样 \D 表示的是非数字，等价于 [^0-9] \s 空白符号 \S 非空白符号 \w 非特殊符号，等价于 [a-zA-Z0-9] \W 特殊符号，等价于 [^a-zA-Z0-9] 之前的元字符、都是不严格的匹配字符串 ^ (1)、以什么内容开头，必须以什么开始; (2)、取反 用法: ^[0-9] 必须以数字开头 ^[a-z0-9] 必须以数字或者以小写字母开始 ^[0-9a-zA-Z]必须以数字或者是字母开头 ^\d 必须以数字开头 [^0-9]取反 字母或者特殊符号 [^0-9a-zA-Z] 特殊符号 $ 必须以什么内容结尾 [0-9]$ “hsgd7y273d9” [a-zA-Z]$ ^[0-9a-z][a-z]$ 指定匹配位置 ^匹配字符串的开头，在多行检索中，匹配一行的开头。 $ 匹配字符串的结尾，在多行检索中，匹配一行的结尾。 \b 匹配一个单词的边界，就是位于 \w 和 \W 之间的位置，或位于字符 \w 和字符串的开头或者结尾之间的位置。 \B 匹配非单词边界的位置 修饰符 i 执行不分区大小写的匹配； g执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止； m多行匹配模式， ^ 匹配一行的开头和字符串的开头， $匹配行的结束和字符串的结束。 在js中正则表达式的写法: /正则表达式/ 创建正则表达式对象的方式: (1)、 var reg=new RegExp(/正则表达式/(2)、 var reg=/正则表达式/; reg.test(“hello998”);(3)、 /正则表达式/.方法名(参数); RegExp 属性 source global ignoreCase multiline lastIndex 选择、分组和引用正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符串。 字符| 用来分隔供选择的字符。 选择项的尝试匹配次序是从左至右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。 圆括号 () 圆括号的作用：一个作用是把单独的项组合成子表达式，以便可以处理像一个独立的单元那样用”|”、”*”、”+”、或者”?”等来对单元内的项进行处理。 另一个作用是在完整的模式中定义模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。 允许在同一正则表达式的后部引用前面的子表达式。 这是通过在字符 “\” 后加一位或多位数字来实现。这个数字指定了带圆括号的子表达式在正则表达式中的位置。 用于模式匹配的String方法的使用str=str.replace(/帅/g,&quot;呆&quot;);g表示的是全局; i 表示的是小写的str=str.replace(/^\s+|\s+$/g,&quot;&quot;);while((index=reg.exec(str))!=null){console.log(index.index); } // 如果结果为null没有匹配的var result=str.match(/帅/g); // match根据正则表达式匹配字符串中的内容,如果没有g,匹配的是第一个,如果有g匹配的是全局的 search() 参数是一个正则表达式； 返回第一个与之匹配的子串的起始位置； 找不到返回 -1。 如果参数不是正则表达式，则先通过 RegExp 构造函数将它转换成正则表达式； search() 方法不支持全局检索，会忽略正则表达式参数中的修饰符 g。 replace() 方法执行检索与替换操作： 第一个参数是一个正则表达式； 第二个参数是要进行替换的字符串； 如果正则表达式中设置了修饰符 g，那么源字符串中所有与模式匹配的第一个字符串都将替换成第二个蚕食指定的字符串； 如果不带修饰符 g, 则只替换所匹配的第一个字符串。 如果第一个参数是字符串而不是正则表达式，则 replace() 方法将直接搜索这个字符串。 正则表达式如果使用了圆括号括起来的子表达式是带有从左到右的索引编号的，而且正则表达式会记忆与每个子表达式匹配的文本。如果在替换字符串中出现了 $ 加数字，将用于指定的子表达式相匹配的文本来替换这两个字符串。 replace() 方法的第二个参数还可以是函数，该函数能够动态的计算替换字符串。 match() 是最常用的 String 正则表达式。 唯一的参数是一个正则表达式，返回的是一个有匹配结果组成的数组。 如果正则表达式设置了修饰符 g, match() 方法返回的数组包含字符串中的所有匹配结果。 如果正则表达式没有设置修饰符，match() 方法就不会进行全局检索，它只检索第一个匹配。 即使不设置全局，还是返回一个数组。 该数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果 match() 返回一个数组 a，那么 a[0] 存放的是完整的匹配，a[1] 存放的则是与第一个用圆括号起来的表达式相匹配的子串，依此类推。 split() split() 方法用以调用它的字符串拆分为一个子串组成的数组，使用的分隔符是 split() 的参数。 RegExp 的方法 exec() 方法返回一个数组 exec() 方法对一个指定的字符串执行一个正则表达式，就是在一个字符串中执行匹配检索； 给字符串的 match() 传入一个非全局的正则表达式，和给这个正则表达式的 exec() 方法传入的字符串是一模一样的，返回一个数组，数组有两个属性：index 和 input。 第一个元素包含的是与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。 属性 index 包含了发生匹配的字符位置，属性 input引用的是正在检索的字符串。 当调用 exec() 的正则表达式对象具有修饰符 g 时，它将当前正则表达式对象的 lastIndex 属性设置为紧挨着匹配子串的字符位置。当统一正则表达式第二次调用 exec() 时，它将从 lastIndex 属性所指示的字符处开始检索。如果没有匹配结果，会将 lastIndex 重置为 0； test() 方法 参数是一个字符串 用 test() 对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回 true；]]></content>
      <categories>
        <category>正则系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现继承的几种方式]]></title>
    <url>%2F2015%2F08%2F28%2F%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ECMAScript 中只支持实现继承，而且主要依靠的是原型链来实现。 扩展原型对象实现继承 描述：直接在构造函数的prototype属性上添加方法 解决的问题：解决了直接将方法设置在构造函数上时，实例化每个对象这些方法都会开辟新空间，造成内存严重浪费的问题 缺点：如果将所有的方法都直接设置到原型对象上，代码冗余 1234567891011/* 一、 扩展原型对象实现继承 */function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.personFn = function () &#123; console.log("personFn is run...");&#125;;var p1 = new Person("z3", 13);console.log("============== 一、 扩展原型对象实现继承 ==================");p1.personFn(); 替换原型对象实现继承 描述：将构造函数的原型对象用新对象替换，再往新的对象中添加新方法 解决的问题：扩展原型对象使得代码冗余 缺点：所有的方法和属性都被实例共享 注意：还原构造器 1234567891011121314/* 二、 替换原型对象实现继承 */function Animal(color, type) &#123; this.color = color; this.type = type;&#125;Animal.prototype = &#123; constructor: Animal, animalFn: function () &#123; console.log("animalFn is run..."); &#125;&#125;;var animal = new Animal("white", "cat");console.log("======================== 二、 替换原型对象实现继承 =========================");animal.animalFn(); 另一种原型继承（动态原型模式） 特点：让代码封装到一起1234567891011121314/* 二、 另一种原型继承（动态原型模式） 特点：让代码封装到一起 */function Paper(color, size)&#123; this.color = color; this.size = size; // 动态原型方法 if(typeof this.write !== "function")&#123; Paper.prototype.write = function () &#123; console.log("color: " + this.color + ", size: " + this.size); &#125; &#125;&#125;var paper = new Paper("orange", "16k");console.log("================= 二、另一种原型继承（动态原型模式）====================");paper.write(); 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in 描述： jQuery的extend()方法原理是混入继承 1234567891011121314151617181920/* 三、 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in */function mixin(target, source) &#123; for (var key in source) &#123; target[key] = source[key]; &#125; return target;&#125;var obj1 = &#123; name: "Amiy", age: 18, pray: function () &#123; console.log("name: " + this.name + ", age: " + this.age + ", sex: " + this.sex + "; obj2.pray is run..."); &#125;&#125;;var obj2 = &#123; sex: false&#125;;mixin(obj2, obj1);console.log("=================== 三、 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in ===================");obj2.pray(); 原型+混入继承：混入继承的应用 描述：在一个对象的原型对象上扩展另一个对象的属性和方法 jQuery.fn.extend() 利用的原理是原型+混入继承 1234567891011121314/* 四、 原型+混入继承：混入继承的应用 */function Cat() &#123;&#125;var cat = new Cat();var o2 = &#123; o2Attr1: "o2Attr1", o2Attr2: "o2Attr2", o2Method1: function () &#123; console.log("o2Method1 is run..."); &#125;&#125;;mixin(Cat.prototype, o2);console.log("======== 四、 原型+混入继承：混入继承的应用 =========");cat.o2Method1(); 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj 注意： ES5 Object.create()方法的实现原理就是经典继承 12345678910111213141516171819202122232425/* 五、 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj */function myCreate(knownObj) &#123; function F() &#123; &#125; F.prototype = knownObj; return new F();&#125;var knownObj = &#123; knownObjAttr1: "knownObjAttr1", knownObjMethod1: function () &#123; console.log("knownObjMethod1 is run..."); &#125;&#125;;var o = myCreate(knownObj);console.log("=============== 五、 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj ==================");o.knownObjMethod1();/* 在旧浏览器下实现继承 */if (typeof Object.create !== "function") &#123; Object.create = function (obj) &#123; function F() &#123; &#125; F.prototype = obj; return new F(); &#125;;&#125; 借用构造函数实现继承 特点： 不会继承原型对象上的方法，因为this的指向变了，原型对象上的方法只能通过构造函数的实例来访问 12345678910111213141516171819202122232425262728/* 六： 借用构造函数实现继承 */function Computer(color, type) &#123; this.color = color; this.type = type; this.run = function () &#123; console.log("run method is run... "); &#125;&#125;Computer.prototype.start = function () &#123; console.log("Computer.prototype.start is run...");&#125;;/** * 下面的借用构造函数实现继承就是对这段代码的优化 * function LenovoNoteBook(color, type, interfaceCount) &#123; * this.color = color; * this.type = type; * this.interfaceCount = interfaceCount; * &#125; */function LenovoNoteBook(color, type, interfaceCount) &#123; Computer.call(this, color, type); this.interfaceCount = interfaceCount;&#125;var lenovo = new LenovoNoteBook("write", "Y470", 8);console.log("========= 六： 借用构造函数实现继承 ========");console.log("color: " + lenovo.color + ", type: " + lenovo.type + ", interfaceCount: " + lenovo.interfaceCount);lenovo.run();// lenovo.start(); 混合继承（经典继承+借用构造函数） 特点：解决借用构造函数继承不能够继承原型对象上的方法的问题 缺点：继承了两次构造函数（模板） 12345678910111213141516171819202122232425262728293031323334353637/* 七、 混合继承（经典继承+借用构造函数）*/function BaseCar(type, modelNumber, color) &#123; this.type = type; this.modelNumber = modelNumber; this.color = color;&#125;// 原型对象上的方法BaseCar.prototype = &#123; constructor: BaseCar, canSell: function (price) &#123; var leastPrice = 2500000; if (leastPrice &lt;= price) &#123; return "恭喜恭喜，您可以卖车"; &#125; else &#123; return "您还差:" + (leastPrice - price) + "元就可以买车了"; &#125; &#125;&#125;;/** * Car 构造函数，调用call()实现继承BaseCar中的方法 * @param type * @param modelNumber * @param color * @constructor */function Car(type, modelNumber, color) &#123; BaseCar.call(this, type, modelNumber); this.color = color; this.bmwStart = function () &#123; console.log("Bmv car is starting..."); &#125;&#125;// 经典继承Car.prototype = new BaseCar();var bmwCar = new Car("Bmw", "B34212", "write");console.log("=================== 七、 混合继承（经典继承+借用构造函数） 白贺翔视频 =====================");console.log(bmwCar.canSell(2400000)); 解决混合继承的缺点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 八、 解决混合继承的缺点 */function People(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; this.sayHello = function () &#123; console.log("父的构造函数上的静态sayHello方法 运行"); &#125;;&#125;People.prototype = &#123; constructor: People, sayHello: function () &#123; console.log("父的原型对象中的sayHello方法：name: " + this.name + ", age: " + this.age + ", sex: " + this.sex + ", HelloWorld !!!"); &#125;&#125;;function Boy(name, age, sex, studyNumber) &#123; // 子类中保存了父类的原型对象 // 借用构造函数实现继承 Boy.superClass.constructor.call(this, name, age, sex); this.studyNumber = studyNumber;&#125;myExtend(Boy, People);function myExtend(subConstructor, supConstructor) &#123; // 1. 用一个空函数进行中转 var F = new Function(); // 2. 保存父的原型对象 F.prototype = supConstructor.prototype; // 3. 实现经典继承 subConstructor.prototype = new F(); // 4. 还原子构造函数原型对象的构造器 subConstructor.prototype.constructor = subConstructor; // 5. 保存父的原型对象，一方面方便解耦，另一方面可以轻松获得原型对象（添加静态方法） subConstructor.superClass = supConstructor.prototype; // 6. 判断父类型的原型对象构造器，加保险 if (supConstructor.prototype.constructor !== supConstructor) &#123; supConstructor.prototype.constructor = supConstructor; &#125;&#125;// 7. 利用保存的父类原型对象实现父类子类有重载的方法Boy.prototype = &#123; constructor: Boy, sayHello: function () &#123; console.log("子的原型对象中的sayHello方法"); &#125;&#125;;// 注意： 子类的原型对象上添加方法必须在实现继承之后var boy = new Boy("Ping", 22, true, 345234);console.log("================ 八、 解决混合继承的缺点，封装函数 ExtJs 底层 白贺翔 ===================");boy.sayHello(); // 父的构造函数上的静态sayHello方法 运行Boy.prototype.sayHello(); // 子的原型对象中的sayHello方法Boy.superClass.sayHello.call(boy); // 父的原型对象中的sayHello方法：name: Ping, age: 22, sex: true, HelloWorld !!!]]></content>
      <categories>
        <category>原型链系列</category>
      </categories>
      <tags>
        <tag>原型链，继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2015%2F08%2F08%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型对象原型对象：构造函数的prototype属性：随着实例化的次数增加，不同的对象他们拥有的say方法指向不同的内存，能相同，造成了内存的浪费,为了解决内存，将这个方法放在某个对象（原型对象）中. 结论1：给构造函数的prototype属性（对象）添加一个方法，这个方法就可以被构造函数的实例所共享推论1：构造函数的prototype属性(对象)上面的属性、方法都可以被构造函数的实例所共享推论2：Student.prototype.constructor===s1.constructor结论2：构造函数的实例有一个proto指向的是构造函数的prototype属性(原型对象) s1.proto===Student.prototype (1). 原型对象是构造函数的prototype属性(2). 构造函数的实例的proto属性指向原型对象(3). 原型对象有一个constructor属性指向构造函数本身 对象的属性的读取与设置 查找一个对象上的是否存在某个属性的过程 (1). 查找当前对象(s1)的内存中是否定义了该属性，找到就停止查找(2). 去当前对象的proto属性（原型对象）中去查找是否定义了该属性，找到就停止查找(3). 如果2中没找到，就去原型对象的原型对象中去查找是否定义了该属性(4). s1.__proto__.__proto__……(N). 找到某个对象（是没有原型对象的：没有proto属性），如果这个对象中还没有，确定了无法获取该属性 基本概念JavaScript 的对象组成，一个对象就有它的原型对象(__proto__)，原型对象也有它的原型对象，一直到原型链的顶端，这样构成了一个具有链条形状的结构，称之为原型链 __proto__该属性可以被修改，但是无法被删除 对象字面量的原型链 构造函数创建对象的原型链 数组对象的原型链 一般来说，无论是对象字面量，还是构造函数创建的对象、内置对象，基本包装了类型的对象，2次原型查找（.proto）就可以找到 函数的原型链123function f()&#123;&#125;f();//f当成了普通函数来调用new f();//f当成了构造函数来调用 一些结论： 几乎所有函数都有prototype属性（Function.prototype这个函数上没有） 所有对象中都有proto属性（Object.prototype该属性的值null） —&gt; 几乎所有函数都有prototype/__proto__属性 函数都是Function的实例（函数是通过Function创建出来的对象） ——&gt; 自定义函数、Function、Array、RegExp、String、Boolean、Number、Object 几乎所有函数都是继承自：Function.prototype（除了Function.prototype） ——&gt; 函数.__proto__ === Function.prototype ——&gt; Object.__proto__ === Function.prototype ——&gt; Function.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype String.prototype.__proto__ === Object.prototype Array.prototype.__proto__ === Object.prototype Boolean.prototype.__proto__ === Object.prototype Number.prototype.__proto__ === Object.prototype RegExp.prototype.__proto__ === Object.prototype 练习 12345678function fn()&#123;&#125;1、console.log(fn.constructor===Function);//true //查找fn的内存——&gt;查找fn.__proto__(Function.prototype)——&gt;Function2、console.log(fn.__proto__===_______);//true //Function.prototype3、console.log(Object.__proto__===______);//true //Function.prototype4、console.log(Function.prototype===______);//true //Function.__proto__——&gt;fn.__proto__——&gt;Object.__proto__5、console.log(Object.constructor); //Function6、console.log(fn.prototype.constructor); //fn7、console.log(Function.prototype.__proto__.constructor); //Object 原型链完整图]]></content>
      <categories>
        <category>原型链系列</category>
      </categories>
      <tags>
        <tag>面向对象，原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js String对象]]></title>
    <url>%2F2015%2F07%2F18%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[面向对象的语言的标志就是它们有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。JavaScript 中的类的实现是基于其原型继承机制。如果两个实例都从同一个原型对象上继承了属性，就认为是同一个类的实例。 JavaScript 的对象是属性名以及与之对应的值的基本集合。集合是一种数据结构，泳衣表示非重复值的无序集合。 理解对象JavaScript 是一门基于对象的多泛式语言。可以使用面向过程进行开发： 获取元素，绑定事件、设置样式、完成动画。。。。。。 可以使用面向对象的方式进行开发： 面向（关注于）过程：基于函数，封装函数 面向对象：关注点变成了对象 对象的概念：数据集，功能集： 无序属性的集合，包含基本值，对象或者函数。 1234567891011121314151617181920//CEO：安排一个任务给CTO(7天)，CTO又把任务给PM(5天)，PM又把任务给我了(3天)，我去开发这个页面var ceo = &#123; assignTaskToCTO: function () &#123; console.log("安排一个任务给CTO"); &#125;&#125;;var cto = &#123; assignTaskToPM: function () &#123; console.log("安排一个任务给PM");&#125;&#125;;var pm = &#123; assignTaskToMe: function () &#123; console.log("安排一个任务给我"); &#125;&#125;;var me = &#123; developWeb:function()&#123; console.log("我去开发这个页面"); &#125;&#125;;//开发一个页面function deleveWeb()&#123; ceo.assignTaskToCTO(); cto.assignTaskToPM(); pm.assignTaskToMe(); me.developWeb();&#125; 一个例子： 利用构造函数来定义 “范围类” 1234567891011121314151617181920212223 // 构造函数初始化function Range(from, to) &#123; // 存储起始位置和结束位置 this.from = from; this.to = to;&#125;Range.prototype = &#123; // constructor: Range, // 如果 x 在范围内，返回 true，否则返回 false // 这个方法可以比较数字范围，也可以比较字符串和日期范围 includes: function(x) &#123; return this.from &lt;= x &amp;&amp; x &lt;= this.to&#125;, // 对于范围内的每一个整数调用函数 f foreach: function(f) &#123; for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x); &#125;, // 返回表示这个范围的字符串 toString: function() &#123; return "(" + this.from + "..." + this.to + ")"; &#125;&#125;;// 举例var r = new Range(3, 5); console.log(r.includes(4)); // truer.foreach(console.log); // 3, 4, 5console.log(r); // Range&#123;from:3, to:5&#125; 构造函数和类的标识当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。初始化对象的状态的构造函数不能作为类的标识，两个构造函数的 prototype 属性可能指向同一个原型对象。那么这连个构造函数的实例是属于同一类型的。 可以使用r instanceof Range来判断一个实例是否继承自 Range.prototype。 constructor 属性每一个 JavaScript 函数都自动拥有一个 prototype 属性，这个属性指向一个对象即称作原型对象，这个对象包含唯一一个不可枚举的属性 constructor。 constructor 的值是一个函数对象。 构造函数的原型中存在预先定义好的 constructor 属性，这意味着通常继承的 constructor 均指代它们的构造函数。 在上面定义的 Range 构造函数的原型由于被另一个对象替换了，所以重写了预定义的 Range.prototype 对象。 Range 的实例的 constructor 没有继承自 Range.prototype 的 constructor 属性。其值变成了 Object。 创建对象的几种方式 使用 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点： 使用一个接口创建很多对象会产生大量的重复代码。 工厂模式12345678910111213141516// 创建一个包含所有必要信息的 Person 对象// 可以无数次的调用这个函数，而且每次都会返回一个包含三个属性的方法的对象function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125; return o;&#125;var p1 = createPerson("Hiraku", 23, "JavaScript Engineer");var p2 = createPerson("Wang", 22, "Java Engineer");p1.sayName();p2.sayName(); 问题： 并没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数模式123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");var p2 = new Person("Wang", 22, "Java Engineer");p1.sayName();p2.sayName(); 和工厂模式的区别： 没有显式的创建对象； 直接将属性和方法赋值给了 this 对象 没有 return 语句 使用 new 关键字创建对象的实例 将构造函数的作用域赋值给新对象（因此 this 就指向了这个对象） 返回新对象 p1 和 p2 有继承自 Person.prototype 的属性 constructor，该属性指向 Person 使用构造函数模式的缺点：每个方法都要在每个实例上创建一遍。如 p1 和 p2 都有一个名为 sayName() 方法，但是两个方法不是同一个 Function 的实例。创建两个完成相同任务的 Function 实例没有必要，这样会浪费内存。 原型模式原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 123456789function Person() &#123;&#125;Person.prototype.name = "Hiraku";Person.prototype.age = 22;Person.prototype.job = "JavaScript Engineer";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var p1 = new Person();p1.sayName(); 好处：可以让所有对象实例共享它所包含的属性和方法。 当给对象的实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性。 更简单的原型语法123456789function Person()&#123;&#125;Person.prototype = &#123; name: "Hiraku", age: 23, job: "JavaScript Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125;; 这时 constructor 属性不再指向 Person 了，constructor 变成了新对象的 constructor，是 Object 构造函数。 这时，需要还原构造器 12345678910function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name: "Hiraku", age: 23, job: "JavaScript Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125;; 注： 以上方式重置 constructor 属性会导致它的 [[enumerable]] 特性被设置为 true。 默认情况下，原生的 constructor 属性是不可枚举的，因此，可以使用 ECMAScript5 中的 Object.defineProperty() 方法来设置。 1234Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 原型的动态特性123456789function Person() &#123;&#125;var friend = new Person();Person.prototype = &#123; name: &quot;Hiraku&quot;, sayName: function() &#123; console.log(this.name); &#125;&#125;friend.sayName(); // 报错 原因是重写了原型对象，把原型对象修改为另一个对象就等于切断了构造函数与最初原型之间的联系。 实例中的指针仅仅指向原型，而不指向构造函数。 原生的对象原型原型模式不仅仅体现在创建自定义类型放没放，就连所有原生的引用类型，都采用这种模式创建的。所有原生原生引用类型都在其构造函数的原型上定义了方法。 通过原生原型对象，不仅可以取得默认方法的引用，而且还可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。 但是，不建议在编程时修改原生对象的原型。 原型模式的缺点省略了构造函数初始化，所有实例默认情况下都将取得相同的属性值。还有，原型模式的最大问题是由其共享的本性所导致。 组合使用构造函数模式和原型模式123456789101112131415161718192021function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ["Herschal", "Camile"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; console.log(this.name); &#125;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");var p2 = new Person("Wang", 22, "Java Engineer");p1.friends.push("Van");console.log(p1.friends); // "Herschal, Camile, Van"console.log(p2.friends); // "Herschal, Camile"console.log(p1.friends === p2.friends); // falseconsole.log(p1.sayName === p2.sayName); // truep1.sayName();p2.sayName(); 这种方式是使用最广泛的。 动态原型模式12345678910111213function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ["Herschal", "Camile"]; if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; console.log(this.name); &#125;; &#125;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");p1.sayName(); 这里在对原型做的修改，能立即在所有实例中得到反映。 寄生构造函数模式基本思路是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回创建的对象。 123456789101112function Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125;; return o;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");p1.sayName(); 关于寄生构造模式，首先，返回对象与构造函数或者构造函数的原型属性之间没有关系。也就是说，构造函数返回到对象与在构造函数外部创建的对象没有什么不同。不能依赖 instanceof 操作符来确定对象的类型。 稳妥构造函数模式首先介绍稳妥对象，稳妥对象是指没有公共属性，而且其它方法也不引用 this 的对象。稳妥模式适合在一些安全的环境中，或者在防止数据被其它应用程序改动时使用。稳妥模式遵循寄生模式，但有两点不同。 新创建对象的实例方法不引用 this； 不使用 new 操作符来调用构造函数。 123456789function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; console.log(name); &#125;; return o;&#125;var p1 = Person("Hiraku", 23, "JavaScript Engineer");p1.sayName();]]></content>
      <categories>
        <category>面向对象系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js String对象]]></title>
    <url>%2F2015%2F07%2F06%2Fjs%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[js 高程中这样定义函数：函数是这样一段 JavaScript 代码，只定义一次，但可以被执行任意多次。JavaScript 的函数是参数化的：函数的定义会包括一个称为形参和标识符列表，这些参数在函数体中就像局部变量一样工作。函数的调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，成为该函数调用表达式的值。出来实参之外，每次调用还会拥有另一个值-本次调用的上下文-这就是 this 关键字的值。 如果函数挂载在一个对象上，作为对象的一个方法调用，就称之为 对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文，也就是该函数的 this 的值。 用于初始化一个新建的对象的函数成为构造函数。 在 JavaScript 里，函数即对象。可以把函数赋值给变量，或者作为参数传递给其他函数。 JavaScript 的函数可以嵌套在其他函数中定义，这样就可以访问它们被定义时所处的作用域中的任何变量。这意味着 JavaScript 函数构成了一个闭包。 函数的定义函数定义方式一： 函数声明123function funcName(arg0, arg1, ...)&#123; // 函数体&#125; 函数的组成： function 关键字 函数名标识符：是函数声明语句的必要组成 一对圆括号：其中包含有 0 个或多个逗号分隔的标识符组成的列表，表示函数的参数 一对花括号 函数的定义方式二： 函数表达式123456var functionName = function(arg0, arg1, ...) &#123; //函数体&#125; var functionName = function foo(arg0, arg1, ...) &#123; //函数体&#125; 以函数表达式定义的函数，函数名称是可选的。一条语句实际上声明了一个变量，并把一个函数对象赋值给它。函数表达式定义函数通常不加函数名，图特别适合仅调用一次的函数。 函数的嵌套1234function hypotenuse(a, b) &#123; function square(x) &#123; return x * x; &#125; return Math.sqrt(square(a) + square(b));&#125; 函数调用、this指向、返回值一个函数最终产生什么样的结构，跟如何调用这个函数息息相关：函数的四种调用模式 函数的4种调用模式 第一种模式：函数调用模式，也就是写一个函数，然后调用一下 第二种模式：方法调用模式，也就是将函数成为对象的一个方法，然后通过对象来调用 第三种模式：构造函数调用模式，也就是将函数当成构造函数来调用 第四种调用模式：上下文调用模式，根据调用方式的不同可以产生不同的结果 第四种函数调用的实现方式 实现方式：call/apply (apply 和 call 的唯一区别是第二个参数是数组，将实参值一一传到数组中。fn.call (函数内部的 this 的值,实参1，实参2…)) 不同调用模式中的this的值 函数调用模式中 this 指向：window 方法调用模式中 this 指向：调用的对象 构造函数调用模式中 this 指向：构造函数的实例 上下文调用模式中 this 指向： (1) 如果 call 方法的第一个参数是一个对象，则 fn 函数内部的 this 的值指向该对象 (2) 如果 call 方法的第一个参数是一个字符串、数字、布尔值，则 fn 函数内部的 this 的值会转换为该类型所对应的基本包装类型的对象 (3) 如果 call 方法的第一个参数是 null ，则 fn 函数内部的 this 的值是 window ——&gt; 就相当于是一次函数调用模式 调用模式中的返回值 函数调用模式中返回值：由 return 语句决定 方法调用模式中返回值：由 return 语句决定 构造函数调用模式中的返回值： (1). 如果构造函数没有手动设置返回值，那么会返回构造函数的实例 (2). 如果手动给构造函数添加了返回值，有以下2种情况： (a). 返回值是值类型：最终的返回值还是构造函数的实例 (b). 返回值是引用类型(对象)：最终的返回值就是该对象 上下文调用模式中的返回值：由 return 语句决定 函数的实参和形参函数的可选形参当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。 12345678function getPropertyName(o, /*可选的*/ a) &#123; if (a === undefined) a = []; // 如果未定义，赋值一个新数组 // 上面这句代码可以替换成 a = a || []; // 这才是习惯写法 for (var property in a) a.push(property); return a;&#125;var a = getPropertyName(o);getPropertyNames(o, p); // 将 ｐ 的属性追加到数组 a 中 注意： 需要定义可选的实参来实现函数时，需要将可选的实参放在实参列表的最后。 可变长的实参列表、实参对象当调用函数时传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。函数的参数对象解决了这个问题。 在函数体内部， 标识符 arguments 指向实参对象的引用，实参对象包含一个 length 属性，是一个伪数组。、 实参的重要用途是可以操作任意数量的实参。 在非严格模式下，当一个函数包含若干个形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。 严格模式下，arguments 对象变成了一个保留字，不能给其赋值，也不能使用 arguments 作为形参名或者局部变量名，也不能给 arguments 赋值。 callee 和 caller 属性callee 指向当前正在执行的函数。 caller 是非标准的，但大多数函数实现了这个属性。指的是调用当前正在执行的函数的函数。 将对象的属性作为实参JavaScript 中，可以通过 键/值 对的形式来传入参数，这样当一个函数中的参数有很多的时候，不需要记住传入的顺序。 这种风格调用的函数，传入的实参都写进一个单独的对象中，在调用的时候传入一个对象，对象中的 键/值对是真正需要的实参数据。如： 12345678910111213141516171819// 将原始数组中的 length 元素复制到目标数组中function arraycopy(/* array */ from, /* index */ form_start, /* array */ to, /* index */ to_start, /* integer */ length)&#123; // 代码段&#125;;// 这种方式效率较低，但不必记住参数顺序function easycopy(args) &#123; arraycopy(args.from, args.from_start || 0, args.to, args.to_start || 0, args.length );&#125;// 调用 easycopy 方法var a = [1, 2, 3, 4], b = [];easycopy(&#123;from: a, to: b, length: 4&#125;); 可以使用以上这种代码来适当使用文档说明自己的函数的参数 实参类型JavaScript 方法的形参并未声明类型，在形参传入函数之前没有做任何类型检测。在定义函数的时候，需要添加类型判断。 123456789101112131415161718192021222324252627function isArrayLike(o) &#123; if (o &amp;&amp; typeof o === "object" &amp;&amp; isFinite(o.length) &amp;&amp; o.length &gt;=0 &amp;&amp; o.length === Math.floor(o.length) &amp;&amp; o.length &lt; 4294967296) return true; else return false;&#125;function sum(a) &#123; var total = 0; for(var i = 0; i &lt; argument.length; i++) &#123; var element = arguments[i], n; if (element == null) continue; // 忽略 null 和 undefined 实参 if (isArray(element)) // 如果实参是数组 n = sum.apply(this, element); // 递归地计算累加... else if (typeof element === 'function') // 是函数 n = Number(element()); // 调用并做类型转换 else n = Number(element); // 否则直接做类型转换 if (isNaN(n)) // 如果无法转换为数字，抛出异常 throw Error("sum(): can't convert " + element + " to number"); total += n; &#125; return total;&#125; 作为值的函数JavaScript 中的函数不仅仅是一种语法，也是值，可以将函数赋值给变量，也可以存储在对象的属性或数组的元素中，还可以作为参数传入另外一个函数等。 比如： 12var a = [function(x) &#123; return x*x;&#125;, 20];console.log(a[0](a[2])); // =&gt; 400 自定义函数的属性JavaScript 中的函数并不是原始值，而是一个种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个”静态” 变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量。 1234uniquInteger.counter = 0;function uniquInteger() &#123; return uniquInteger.counter++; &#125; 计算阶乘的函数： 123456789function factorial(n) &#123; if (isFinite(n) &amp;&amp; n &gt; 0 &amp;&amp; n == Math.round(n)) &#123; // 有限的正整数 if (!(n in factorial)) factorial[n] = n * factorial(n-1); return factorial[n]; &#125; else return NaN;&#125;console.log(factorial[1]); // 初始化 作为命名空间的函数命名空间内定义的变量不会污染全局变量，这就解决环境中变量冲突问题。 123(function() &#123; // 模块代码段&#125;)(); 一个例子： 123456789101112131415161718192021222324252627282930313233// 定义一个用来将第二个以及后续参数复制至第一个参数// 如果 o 的属性拥有了一个不可枚举的同名属性，则 for/in 循环// 不会枚举对象 o 的可枚举属性var extend = (function()&#123; // 在修复之前，先检测 bug 是否存在 for (var p in &#123;toString: null&#125;) &#123; return function extend(o) &#123; // 代码执行到这里，for/in 循环会正确工作并返回 for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var prop in source) o[prop] = source[prop]; &#125; return o; &#125;; &#125; // 代码执行到这里，说明 for/in 不会枚举测试对象的 toString 属性 // 如果返回的另一个版本的 extend() 函数，这个函数是显式测试 Object.prototype中的不可枚举属性 return function patched_extend(o) &#123; for (var i =1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var prop in source) o[prop] = source[prop]; for (var j = 0; j &lt; protoprops.length; i++) &#123; prop = protoprops[j]; if (source.hasOwnProperty(prop)) o[prop] = source[prop]; &#125; &#125; return o; &#125;; // 列出了需要检测的特殊属性 var protoprops = ["toString", "valueOf", "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString" ];&#125;()); js 词法分析程序执行过程 读取代码，主关注声明的部分：var 判断var后面的名字是否已经被标记，如果没有被标记过，就标记 读取完毕后，代码从上往下，从左往右依次执行 词法作用域（作用域：变量可以使用到不能使用的范围） 词法作用域就是描述变量的访问范围： 在代码中只有函数可以限定作用范围，允许函数访问外部的变量 在函数内优先访问内部声明的变量，如果没有才会访问外部的 所有变量的访问规则，按照预解析规则来访问 作用域链： 每一个函数具有独立作用域，由于函数内可以套函数，所以在函数内部访问变量的时候，需要一级一级的往上查找该变量，这样就好像构成了一个链式结构，把它称之为作用域链。 严格模式开启严格模式：”use strict”; 严格模式中禁止给一个未声明的变量赋值： 严格模式中eval具有了独立作用域——&gt;在eval中声明的变量和函数都是局部变量 严格模式中禁止使用arguments.callee进行递归调用 闭包JavaScript 函数的执行依赖于变量作用域，这个作用域在函数定义时决定的，而不是函数调用的时候决定的。为了实现这种词法作用域, JavaScript 函数对象的内部状态不仅仅包含函数的代码逻辑，还必须引用当前的作用域， JavaScript 函数对象的内部状态不仅包含函数代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称闭包。 函数定义时的定义作用域链到函数执行时依然有效。 12345678910111213141516// 利用闭包实现的私有属性存取器方法function addPrivateProperty (o, name, predicate) &#123; var value; o["get" + name] = function() &#123; return value; &#125;; o["set" + name] = function(v) &#123; if (predicate &amp;&amp; !predicate(v)) throw Error("set" + name + ": invalid value " + v); else value = v; &#125;;&#125;var o = &#123;&#125;;addPrivateProperty(o, "Name", function(x) &#123; return typeof x == "string"&#125;);o.setName("Hiraku"); // 设置属性值console.log(o.getName); // 获取属性值o.setName(0); // 试图设置一个错误的值 闭包的一个应用: 模块化 1234567891011121314151617181920//面向对象——&gt;模块化var SongManager2=(function()&#123; function f1()&#123;&#125; function f2()&#123;&#125; function f3()&#123;&#125; //构造函数 function SongManager()&#123;&#125; SongManager.prototype=&#123; //原型对象 init:function()&#123; f1(); f2(); f3();//这3个功能：如果业务逻辑非常复杂，需要把这些方法拆分掉， // 并且这些方法不能让用户随便调用，用一些函数封装一下 &#125;, //原型对象中的方法对于子对象是完全公开的，对象可以随意调用 init1:function()&#123;&#125;, init2:function()&#123;&#125; &#125;; return SongManager;&#125;()); 闭包实现思路：外层函数，内层函数 通常设置外层函数的返回值就是内层函数 也可以让外层函数的返回值是一个对象（方法) 如果需要保存一个数据(外层函数的同一个变量)，让内层函数调用多次，该变量的值都是共享的 如果需要保存多个数据(外层函数的同一个变量)，让外层函数调用多次 函数的属性、方法和构造函数JavaScript 中的函数是值， 使用 typeof 方法得到的结果是 “function”，但是函数是 JavaScript 中的特殊的对象，也可以拥有属性和方法。甚至可以用 Function()构造函数来创建新的函数对象。 length 属性在函数体里， arguments.length 表示传入函数的实参的个数。而函数本事的 length 属性是只读的，它代表函数形参数量，即函数定义时时给出的实参个数，通常也是函数在调用时期望传入的个数。 123456789101112// 判断所传入的实参个数是否正确// 该函数使用 arguments.callee 不能在严格模式下调用function check(args) &#123; var actual = args.length; var expected = args.callee.length; if (actural !== expected) throw Error("Expected " + expected + "args; got " + actual);&#125;function f(x, y, z) &#123; check(arguments); return x + y + z;&#125; prototype 属性每一个函数都包含一个 prototype 属性，该属性指向一个对象的引用，这个对象称为原型对象。下一篇文章将深入分析。 call() 方法和 apply() 方法call() 和 apply() 的第一个实参是要调用函数的母体对象，它是调用上下文，在函数体内通过 this 来获得对它的引用。 在严格模式中，call() 和 apply() 的第一个实参都会变成 this 的值，哪怕传入的是 null 或 undefined。在严格模式下，传入 null 或 undefined 的时候都会被全局对象代替。 call/apply区别 相同点： (1) 都是Function.prototype对象中定义的方法 (2) 第一个参数都是表示函数内部的this的值 不同点： 如果需要给函数传递参数的时候: 利用call方法，将函数的参数从第二个参数开始依次排开 apply方法的第二个参数是一个数组对象，数组的第一个参数表示函数的第一个实参，依次以此类推 apply的一个漂亮的应用1234 var points = [ &#123; x: 110, y: 50&#125;, &#123; x: 130, y: 60 &#125;, &#123; x: 20, y: 70 &#125;, &#123; x: 60, y: 50 &#125; ];var maxX = Math.max.apply( null, points.map(function (v) &#123; return v.x; &#125;)); 以上代码中借用Math对的max方法，利用arr.map()方法中返回的是数组这一特性得到了数组中对象的某个属性的最大值。 将当前函数的 arguments 数组直接传入 apply() 来调用另一个函数1234567891011// 将对象 o 中的方法替换为另一个方法// 可以在调用原始方法之前和之后记录日志消息function trace(o, m) &#123; var original = o[m]; // 在闭包中保存原有方法 o[m] = function () &#123; // 定义新方法 console.log(new Date(), "Entering:", m); // 输出日志消息 var result = original.apply(this, arguments); // 调用原始函数 console.log(new Date(), "Exiting:", m); // 输出日志消息 return result; // 返回结果 &#125;;&#125; trace 方法接收两个参数，一个对象和一个方法名，它将制定的方法替换为一个新的方法。 bind() 方法bind() 方法在 Function 的原型对象上 bind 方法是 ECMAScript 5 的新方法，用途是将函数绑定到某个对象。当函数 f() 上调用 bind 方法并传入一个对象 o 作为参数，这个方法返回一个新的对象。 1234function f(y) &#123; return this.x + y; &#125;; var o = &#123;x: 1&#125;;var g = f.bind(o);console.log(g(2)); // 3 bind() 简单绑定 1234567// 返回一个函数，通过调用它来调用 o 中的方法 f(), 传递它所有的实参function bind(f, o) &#123; if (f.bind) return f.bind(o); else return function() &#123; return f.apply(o, arguments); &#125;&#125; ECMAScript 5 的 bind() 方法不仅仅是将函数绑定到一个对象，它还可以附带一些其它应用：除了第一个参数外，传入 bind() 的实参也会绑定到 this。 12345678var sum = function(x, y) &#123; return x + y; &#125;;// 创建一个类似 sum 的函数，但 this 的值绑定到 null// 并且第一个参数绑定到 1，这个新的函数期望只传入一个实参var succ = sum.bind(null, 1);console.log(succ(2)); // 3: x 绑定到 1， 并传入 2 作为实参 yfunction f(y,z) &#123; return this.x + y + z &#125;;var g = f.bind(&#123;x:1&#125;, 2);console.log(g(3)); // 6: this.x 绑定到 1，y 绑定到 2， z 绑定到 3 bind() 的兼容方法123456789101112if (!Function.prototype.bind) &#123; Function.prototype.bind = function (o /*, args*/) &#123; // 将 this 和 arguments 的值保存到变量中 var self = this, boundArgs = arguments; return function() &#123; var args = [], i; for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]); for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]); return self.apply(o, args); &#125;; &#125;;&#125; ECMAScript 5 的 bind() 方法返回的函数不包含 prototype 属性，并且将这些绑定的函数用作构造函数时所创建的对象从原始的未绑定的构造函数中继承 prototype 。 toString() 方法函数也有 toString() 方法，大多数函数的 toString() 方法返回包含函数体本身的字符串。 静态属性和实例属性 给函数添加一个属性（静态属性——&gt;函数对象自身的属性） 给某个构造函数的实例添加的属性：实例属性 所有的函数对象都共有的一些静态属性 name：获取函数的名称 length：表示函数形参的个数 caller：表示当前函数调用是在哪个函数内 Function() 构造函数Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体，它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其它所有字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只需要给构造函数简单的传入一个字符串，即函数体。 注： Function() 构造函数并不需要通过传入实参以指定函数名。就像函数的直接量一样，Function() 构造函数创建一个匿名函数。 Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数 每次调用 Function() 构造函数都会解析函数体，并创建函数对象 Function() 构造函数创建的函数并不使用词法作用域，函数体代码的编译总是会在顶层函数执行。 1234567var scope = "global";function constructFunction() &#123; var scope = "local"; return new Function("return scope"); // 这里无法使用局部作用域的变量&#125;// 通过 Function() 构造函数定义的函数使用的不是局部作用域console.log(constructFunction()()); // "golobal" 可以认为 Function() 构造函数是在全局作用域中执行的 eval(); eval() 可以在自己的私有作用域内定义新变量和函数。 Function() 很少用到。 可调用的对象类似于 所有的”伪数组”，对于函数也存在类似的情况。”可调用对象” 是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。 可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器实现了客户端方法，比如 Window.alert(), Document.getElementById(), 使用了可调用的宿主对象，而不是内置函数对象。 另一个可调用对象是 RegExp 对象，可以直接调用 RegExp 对象，这比调用它的 exec() 方法更快一些。这是 JavaScript 中的一个非标准特性，使用typeof 运算的结果并不统一。 函数式编程使用函数处理数组ECMAScript 3 中没有数组的 map() 和 reduce() 函数，封装兼容的 map() 和 reduce()。 123456789101112131415161718192021222324252627282930313233343536373839// 对于数组的每个元素调用函数，返回一个数组var map = Array.prototype.map ? function(a, callback) &#123; return a.map(callback); &#125; : function(a, callback) &#123; var results = []; for (var i = 0, len = a.length; i &lt; len; i++) &#123; if (i in a) results[i] = callback.call(null, a[i], i, a); &#125; return results; &#125;;// 如果函数 callback 和可选的初始值将数组 a 减至一个值var reduce = Array.prototype.reduce ? function(a, callback, initial) &#123; if (arguments.length &gt; 2) return a.reduce(callback, initial); // 如果传入了一个初始值 else return a.reduce(callback); // 否则没有初始值 &#125; : funciton(a, callback, initial) &#123; var i = 0, len = a.length, accumulator; if (arguments.length &gt; 2) accumulator = initial; else &#123; // 找到数组中已定义的索引 if (len == 0) throw TypeError(); while(i &lt; len) &#123; if (i in a) &#123; accumulator = a[i++]; break; &#125; else i++; &#125; if (i == len) throw TypeError(); &#125; // 对数组剩余的元素依次调用 callback while (i &lt; len) &#123; if (i in a) accumulator = callback.call(undefined, accumulator, a[i], i, a); i++; &#125; return accumulator; &#125;; 递归：函数自己调用自己计算斐波那契数列第n项的值：1,1,2,3,5,8,13…12345function fibonacci(n)&#123; if(n==1 || n==2) return 1; return fibonacci(n-1)+fibonacci(n-2);&#125;for (var i = 0; i &lt; 10; i++) &#123; console.log(fibonacci(i+1)); &#125; 递归计算阶乘123456function factorial(n)&#123; if(n&lt;0) return 0; //为了防止报错 if(n==0) return 1; //递归的结束条件：0的阶乘为1 return factorial(n-1)*n;&#125;for (var i = 0; i &lt; 10; i++) &#123; console.log("数字："+i); console.log(factorial(i));&#125; m的n次方123456function pow(n, m) &#123; if (m === 0) return 1; if (m &lt; 0) return 1 / (pow(n, -(m + 1)) * n); else if (m &gt; 0) return pow(n, m - 1) * n; &#125; for (var i = -2; i &lt;= 0; i++) &#123; console.log(pow(2, i)); &#125; 递归查找父元素需求：要判断一个div是否在另一个div的下面 123456789101112function find(child,parent)&#123; //实现思路：由子元素一级一级的查找父元素 //递归的结束条件：查到了文档的根节点、找到了父元素 if(child.parentNode===parent) return true; //说明已经找到了符合条件的父元素 if(child.parentNode===null) return false; //说明已经查找到了文档的根节点 return find(child.parentNode,parent); //第1次执行find——&gt;child.parentNode===parent //第2次执行find——&gt;child.parentNode.parentNode===parent //第3次执行find——&gt;child.parentNode.parentNode.parentNode===parent&#125;console.log(find(d3,d10));//falseconsole.log(find(d3,d1));//true]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js String对象]]></title>
    <url>%2F2015%2F06%2F28%2Fjs%20String%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[String类型String 类型是字符串的对象包装类型。创建方式有两种： var strObject = new String(“abc”); var strValue = “abc”;其中，继承的 valueOf()，toLocaleString()，toString() 方法，都返回对象所表示的基本字符串值。 String 类型的实例都有一个 length 属性，表示包含多少个字符，可以用来获取字符串的长度。 字符方法:charAt() 和 charCodeAt() charAt(下标);获取该下标位置的字符串 charCodeAt(下标);获取对应下标字符串的ASCII的码值 charAt() 和 charCodeAt() 方法接收一个参数，即基于 0 的字符位置 12var str = "abc";console.log(str.charAt(1)); // "a" concat(字符串); 拼接字符串，用于将一个或多个字符串拼接起来，得到新串 concat 可以接收任意多个参数 12var str = "abc";console.log(str.concat("de", "fgh")); // "abcdefgh" slice()、substring() 和 substr() slice(开始下标,结束下标);截取一段字符串的 substring(开始的下标,结束的下标);截取指定部分的字符串 substr(开始的下标，截取的个数);截取指定长度的字符串 slice(), substring(), substr() 这三个方法都会返回被操作字符串的一个子串 都接受一个或两个参数 第二个参数表示子字符串到哪里结束 slice() 和 substring() 第二个参数是子字符串最后一个字符后面的位置 substr() 的第二个参数是指返回的字符个数 如果没有给这三个方法指定第二个参数，则将字符串的长度作为结束位置。 这几个方法都返回新字符串，不影响原字符串. 1234567var str = &quot;Hello World&quot;;console.log(str.slice(3)); // &quot;Hello World&quot;console.log(str.substring(3)); // &quot;Hello World&quot;console.log(str.substr(3)); // &quot;Hello World&quot;console.log(str.slice(3, 7)); // &quot;lo W&quot;console.log(str.subtring(3, 7)); // &quot;lo W&quot;console.log(str.subtr(3, 7)); // &quot;lo Worl&quot; 传入负值时，slice() 方法会将传入的负值与字符串的长度相加 substr() 方法将负的第一个参数加载字符串的长度，而将负的第二个参数转为 0 substring() 方法会把所有负值参数都转换为 0 。 1234567var str = "Hello World";console.log(str.slice(-3)); // "rld"console.log(str.substring(-3)); // "Hello World"console.log(str.substr(-3)); // "rld"console.log(str.slice(3, -4)); // "lo W" 会将传入的负值与字符串的长度相加，第二个值转成了7console.log(str.subtring(3, -4)); // "Hel", 会将较小的数作为起始位置，将较大的说作为结束位置console.log(str.subtr(3, -4)); // "" toLocaleUpperCase()、toUpperCase()、toLocaleLowerCase()、toLowerCase() toLocaleUpperCase 字符串转大写, 针对特定地区 toUpperCase 字符串转大写 toLocaleLowerCase 字符串转小写, 针对特定地区 toLowerCase 字符串转小写 12345var str = "Hello World";console.log(str.toLocaleUpperCase()); // "HELLO WORLD"console.log(str.toUpperCase()); // "HELLO WORLD"console.log(str.toLocaleLowerCase()); // "hello world"console.log(str.toLowerCase()); // "hello world" indexOf() 和 lastIndexOf() indexOf 查找指定的字符串，找到则返回下标，找不到返回-1 lastIndexOf 从后面向前面找指定的字符串，找不到也是返回的是-1 indexOf() 和 lastIndexOf() 方法都是从一个字符串中搜索给定的子字符串， 返回子字符串的位置 找不到则返回 -1 123var str = "Hello World";console.log(str.indexOf("o")); // 4console.log(str.lastIndexOf("o")); // 7 indexOf() 和 lastIndexOf() 方法都可以接收第二个参数，表示从字符串中的哪个位置开始搜索 indexOf() 会从指定位置向后搜索，忽略指定位置之前的 lastIndexOf() 会从指定位置向前搜索，忽略指定位置之后的 123var str = "Hello World";console.log(str.indexOf("o", 6)); // 7console.log(str.lastIndexOf("o", 6)); // 4 查找某个元素在字符串中出现的位置 12345678var str = "Spell at all costs， to rush you in the future。", position = [], pos = str.indexOf("t");while( pos &gt; -1 )&#123; position.push(pos); pos = str.indexOf("t", pos + 1); &#125;console.log(position); // [7, 16, 20, 35, 41] trim 切掉字符串前面和后面的空格 创建一个字符串的副本，删除前置以及后缀空格，然后返回结果 1234var str = " Hello World ";var strTrim = str.trim();console.log(str); // " Hello World "console.log(strTrim); // "Hello World" 字符串匹配模式方法match() 直接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象 12345678var str = "cat, bat, sat, fat";var pattern = /.at/;// 与 pattern.exec() 方法相同var matches = str.match(pattern);console.log(matches.index); // 0console.log(matches[0]); // "cat"console.log(matches); // ["cat", index: 0, input: "cat, bat, sat, fat"]console.log(pattern.lastIndex); // 0 以上的实例中 match 方法返回了一个数组； 如果是调用 RegExp 对象的 exec() 方法并,传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串； search() 方法 唯一参数与 match() 方法的相同： 由字符串或 RegExp 对象指定的一个正则表达式。 该方法返回字符串中第一个匹配项的索引； 如果没有找到返回 -1 123var str = "cat, bat, sat, fat";var pos = str.search(/at/);console.log(pos); // 1 replace() 方法 两个参数： 第一个可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转成正则表示） 第二个参数可以是一个字符串或者一个函数 如果第一个参数是字符串，只会替换第一个字符串 要替换所有，指定正则表达式，指定 g 标志 12345var str = "cat, bat, sat, fat";var res1 = str.replace("at", "ond");var res2 = str.replace(/at/g, "ond");console.log(res1); // "cond, bat, sat, fat"console.log(res2); // "cond, bond, sond, fond" replace() 方法的第二个参数可以是函数。 在只有一个匹配项（即与模式匹配的字符串）的情况下，会向函数传递三个参数 模式匹配项、模式匹配项在字符串中的位置和原始字符串。 在正则表达式定义了多个捕获组的情况下， 传递给函数的参数一次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项…… 最后两个参数依然分别是模式匹配项在字符串中的位置和原始字符串。 函数返回一个字符串，表示应该被替换的匹配项。 12345678910111213141516function htmlEscape(text)&#123; return text.replace(/[&lt;&gt;"&amp;]/g, function(match, pos, orginText)&#123; switch(match)&#123; case "&lt;": return "&amp;lt;"; case "&gt;": return "&amp;gt;"; case "&amp;": return "&amp;amp;"; case "\"": return "&amp;quot;"; &#125; &#125;);&#125;console.log(htmlEscape("&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;"));// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello World!&amp;lt;/p&amp;gt; split 切割指定的字符串的，返回的是一个数组 基于指定的分隔符将一个字符串分隔成多个子字符串，并将结果放在数组中 分隔符可以是一个 RegExp 对象。 可接受第二个可选的参数，指定数组中大小。 1234567var color = "red,green,yellow,blue";var colors1 = color.split(",");console.log(colors1); // ["red", "green", "yellow", "blue"]var colors2 = color.split(",", 2);console.log(colors2); // ["red", "green"]var colors3 = color.split(/[^\,]+/);console.log(colors3); //["", ",", ",", ",", ""] localCompare()此方法比较两个字符串，并返回： 若字符串再字母表中排在字符串参数之前，返回一个负数，大多数情况下为 -1 若字符串邓毅字符串参数，返回 0 若字符串再字母表中排在字符串参数之后，返回一个正数，大多数情况下为 1 1234var str = "yellow";console.log(str.localCompare("brick")); // 1console.log(str.localCompare("yellow")); // 0console.log(str.localCompare("zoo")); // -1 fromCharCode()这个方法是 String 构造函数的静态方法，接收一个多字符编码，转化为一个字符串 1console.log(String.fromCharCode(104, 101, 108, 108, 111)); // "hello" HTML 方法 anchor() &lt;a name=&quot;name&quot;&gt;string&lt;/a&gt; big() &lt;big&gt;string&lt;/big&gt; bold() &lt;b&gt;string&lt;/b&gt; fixd() &lt;tt&gt;string&lt;/tt&gt; fontcolor(color) &lt;font color=&quot;color&quot;&gt;string&lt;/font&gt; fontsize(size) &lt;font size=&quot;size&quot;&gt;string&lt;/font&gt; italics() &lt;i&gt;string&lt;/i&gt; link(url) &lt;a href=&quot;url&quot;&gt;string&lt;/a&gt; small() &lt;small&gt;string&lt;/small&gt; strike() &lt;strike&gt;string&lt;/strike&gt; sub() &lt;sub&gt;string&lt;/sub&gt; sup() &lt;sup&gt;string&lt;/sup&gt;]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的数组]]></title>
    <url>%2F2015%2F06%2F22%2Fjs%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是表示集合的值，每一个值是一个元素，每一个元素在数组中有一个位置，以数字表示，叫索引。数组继承自 Array.prototype. js的内置对象：数组Array数组声明 直接量方式创建数组 1234var empty = []; // 没有元素的空数组var num = [1,3,2,4,5]; // 有5个元素的数组var misc = [1, true, "a", ]; // 有不同数据类型元素的数组var misc2 = [[1], &#123;x: 1, y: 2&#125;,[2, &#123;x:2, y: 1&#125;]]; 数组直接量中可以是任意的表达式。 使用构造函数 123var arr = new Array();// 数组的构造函数 创建的是一个空数组var arr = new Array("4");// 只有传入一个数值的时候 才表示数组元素的个数var arr = new Array(5, 4, "abc"); // 显示的指定两个或多个数组元素或者数组的一个非数值元素 数组元素的读和写数组的合法表达式1234567891011var a = ["world"]; var value = a[0]; // 读取第 0 个元素a[1] = 10; // 设置值var b = [];for (var i = 0; i &lt; 5; i++)&#123; a[length++] = i; // 将 0 - 4 的数值装到数组中&#125;var j = 2;a[j] = 3; // 写第二个元素a[j+1] = "abc"; // 写第三个元素a[a[j]] = a[0]; // 读第 0 个元素和第 2 个元素，写第 3 个元素 数组索引和对象属性数组是对象的特殊形式。 常规的对象如：o = {}; o[1] = &quot;one&quot;; // 可以用一个整数来访问。数组的索引只能是 0 ~ 2的32次幂 - 2 之间的整数，所有的索引是属性名。负数和浮点数也可以来索引数组。这种情况下转成字符串当成常规对象的属性，而非负整数字符串被使用了： arr[&quot;99&quot;], 当做数组的索引，而非对象的属性。数组的索引是属性的特殊类型，因此数组的索引找不到值时不会报错，而是 undefined。 数组的长度每一个数组都有一个 length 属性。 123var arr = new Array();console.log(arr.lengh); //获取数组元素的个数// length属性是动态改变的 通过arr.length可以动态追加 可以将数组的长度设置。 1234var arr = [1,2,3];arr.length = [1]; // arr 现在为 [1];arr.length = []; // 删除 arr 中的元素arr.length = 5; // 长度为 4，但没有元素，相当于 new Array(5); ECMAScript 5，可以使用 Object.defineProperty() 来设置数组的 length 为只读的。 稀疏数组稀疏数组是包含从 0 开始的不连续索引的数组。可以使用 Array() 构造函数或简单指定数组索引大于当前数组的长度来定义稀疏数组。还可以使用 delete 操作符来创建稀疏数组。 1234var a = new Array(5);var arr[99] = 1; // 赋值添加一个元素1，length 变为 100var a2 = [];var a3 = [,]; // 此时数组没有元素，长度是 1；也是稀疏数组 注：当给直接量中省略值时不会创建稀疏数组。因为省略的值是 undefined 类型。 12var a5 = [,,,]; // 不是稀疏数组var a4 = [undefined]; // 此时数组包含一个数值 undefined 类型。 数组冒泡排序12345678910111213141516171819var arr17 = [56,45,23,78,67,34,96,39,44,23,45,37,85];var outer = 0;var inner = 0;for(var i = 0; i &lt; arr17.length - 1; i++)&#123; var flag = true; for(var j = 0 ; j &lt; arr17.length - 1 - i; j++)&#123; if(arr17[j] &gt; arr17[j+1])&#123; var tempValue = arr17[j+1]; arr17[j+1] = arr17[j]; arr17[j] = tempValue; flag = false; &#125; inner++; &#125; outer++; if(flag)&#123; break; &#125;&#125; 数组的方法 push(); 尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样； 返回新数组长度 操作原数组，末尾追加 1234var a = [];a.push("ab");a.push("bc","cd"); // a = ["ab","bc","cd"];a.push("123",["e","f"]); // a = ["ab","bc","cd","123",["e","f"]]; pop(); 删除数组中最后一个元素， 返回值是被删除的这个元素 操作原数组 shift(); 删除数组中的第一个元素， 返回值是被删除的元素 unshift(); 向数组中第一个元素之前插入一个或多个新的元素 返回值是新数组的长度 concat(); Array.concat() 方法创建并返回新数组 新的数组和旧的数组拼接，产生一个新的数组 不修改原数组 123var arr = [1,2];arr.concat([3,4]); // 返回 [1,2,3,4]arr.concat(3,[4,[5,6]]); // 返回 [1,2,3,4,[5,6]] slice(); Array.slice()方法返回指定数组的一个片段或子数组 两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素； 指定一个参数，返回包含开始位置到数组结尾的所有元素 参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个 从原来的数组中截取出来指定的一部分元素，产生新的数组 不操作原数组 12345var a = [0,1,2,3,4,5];a.slice (0,3); // [0,1,2];a.slice(3); // [3,4,5]a.slice(1,-1); // [1,2,3,4];a.slice(-3,-2); // [3] splice(); Array.splice()是数组中插入或删除元素的方法。 会修改调用数组， 第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数； 如果省略了第二个参数，从开始索引位置后的元素都被删除； 可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入； 该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。 join(); 将数组中的所有元素都转化成字符串并连接到一起 返回最终生成的字符串 是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组； reverse(); 反转数组 操作原数组 返回操作后的逆向数组 sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组 操作原数组； 返回排序后的数组 1234567891011121314151617function sort(arr, fn) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; var flag = true; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (fn(arr[j], arr[j + 1]) &gt; 0) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125; toString() 和不使用任何参数调用 join() 方法返回的字符串是一样的。 12[1,2].toString(); // "1,2"[1,2,[3,"c",5]].toString(); // "1,2,3,c,5" toLocalString() 方法是 toString() 方法的本地化版本，使用本地化分隔符将这些字符串连接起来生成最终字符串。 ECMAScript 5 中的数组方法ECMAScript 5 定义了 9 个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组；大多数 ECMAScript 5 数组方法的第一个参数是一个函数，第二个参数是可选的，如果有第二个参数，则调用的函数被看做是第二个参数的方法。即在调用函数时传递的第二个参数作为它的 this 关键字的值来使用。ECMAScript 5 中的数组方法都不会修改原始数组。 indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素 查找某个元素， 第一个参数是要查找的元素, 第二个参数是开始查找的下标, 找到则返回找到的第一个元素的索引，找不到则返回-1 lastIndexOf(); 这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1； 第二个元素可以是负数，代表相对数组末尾的偏移量； 123456789101112function findall(a, x)&#123; var results = [], len = a.length, index = 0; while(index &lt; len)&#123; index = a.indexOf(x, index); if (pos === -1) break; // 未找到，完成搜索 results.push(index); // 否则在数组中存储索引 index = index + 1; &#125; returen results; // 返回包含索引的数组&#125; every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件； every() 方法针对所有的元素判断调用函数返回全为 true，则返回true； every() 方法有一个不满足条件的则返回 false some() 方法所有的元素判断调用函数有一个满足条件的则返回 true some() 方法全为 false, 则返回 false map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个包含该函数的数组。 返回新数组 不修改原数组 稀疏数组调用返回的还是稀疏数组 一个例子：arr.map(Math.sqrt); map这个方法可以传入一个回调函数, 直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的 调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数 map方法内部帮我们遍历并且传入数组的每个元素 filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值； 压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter(); 123a = a.filter(function(x)&#123; return x !== undefined &amp;&amp; x !== null;&#125;); 检测数组 instanceof 12[] instanceof Array; // true&#123;&#125; instanceof Array; // false 但是在web浏览器多窗口或窗体存在时，每个全局对象有自己的一组构造函数。一个窗体中的对象不可能是另外一个窗体中构造函数和实例。因此，instanceof 操作符不能视为一个可靠的数组检测方法。 isArray(); ECMAScript 5 中给出的检测数组类型的方法； 这个方法是判断变量是不是数组 因此，封装检测数组的方法 123var isArray = Function.isArray || function(o) &#123; return typeof o === "object" &amp;&amp; Object.prototype.toString.call(o) === "[object Array]";&#125; forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数； 三个参数，数值元素、数组索引、数组本身 无法再所有元素传递完调用函数之前终止遍历 1234567891011var data = [1,2,3,4,5];// 计算数组元素和值var sum = 0;data.forEach(function(v)&#123; sum += v;&#125;);console.log(sum); // sum =&gt; 15data.forEach(funciton (v,i,a) &#123; a[i] = v + 1;&#125;);console.log(data); // [2,3,4,5,6]; 123456789// 终止 forEach 循环function foreach (a, f, t)&#123; try &#123; a.forEach (f, t)&#125; catch (e) &#123; if (e === foreach.break) return; else throw e; &#125;&#125;foreach.break = new Error("StopIteration"); reduce()和 reduceRight() reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。 1234567var a = [1,2,3,4,5];var sum = a.reduce(function(x, y)&#123; return x + y;&#125;); // 求和var max = a.reduce(function(x, y)&#123; return (x&gt;y)?x:y;&#125;); // 求最大值 reduce() 两个参数： 第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。 第二个参数是可选参数 reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组； reduce() 和 reduceRight() 都能接收一个可选的参数，它指定了化简函数调用时的 this 关键值。 计算两个对象的并集，返回一个新对象： 1234567891011/** * [union description] 如果有重名属性，使用 p 中的属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] 返回一个新对象这个对象同时拥有 o 的属性 */function union (o, p) &#123; return extend (extend(&#123;&#125;, o), p);&#125;var objs = [&#123;x:1&#125;, &#123;y:2&#125;, &#123;z:3&#125;];var merged = objs.reduce(union); // &#123;x:1, y:2, z:3&#125; 拥有同名属性时，reduce() 和 reduceRight() 方法返回值不同； 123var objs = [&#123;x:1, a:1&#125;, &#123;y:2, a:2&#125;, &#123;z:3, a:3&#125;];var lUnion = objs.reduce(union); // &#123;x:1, y:2, z:3, a:1&#125;var lUnion = objs.reduceRight(union); // &#123;x:1, y:2, z:3, a:3&#125; ECMAScript 6 中数组新方法 Array.prototype.find 方法用于找出第一个符合条件的数组成员。 参数是一个回调函数，找到第一个返回 true 的数组项，然后返回该数组项； 找不到返回undefined； 1234var arr = [123,23];arr.find(functiton(num)&#123; return num === 123;&#125;); 两个静态方法 Array.from 将一个伪数组转成正真的数组 Array.of 将方法中参数都添加到一个数组中 操作、填充和过滤数组的方法 Array.prototype.copyWidthin Array.prototype.fill Array.prototype.find 接收一个回调函数，每一项执行调用它 123456789var users = [ &#123;name: 'bb', age:24&#125;, &#123;name: 'cc', age:32&#125;, &#123;name: 'dd', age:12&#125;, &#123;name: 'aa', age:16&#125;, &#123;name: 'ed', age:18&#125;, &#123;name: 'aa', age:29&#125;];console.log(users.find(u =&gt; u.name === 'aa')); // &#123;name: 'aa', age:16&#125; Array.prototype.findIndex 有关数组迭代的方法 Array.prototype.keys Array.prototype.values Array.prototype.entries Array.prototype[Symbol.iterator] 类数组对象(伪数组)JavaScript 的类数组对象：把拥有数组 length 属性和对应非负整数属性的对象看着一种类型的数组。 123456789101112var a = &#123;&#125;;var i = 0;while (i &lt; 10) &#123; a[i] = i * i; i++;&#125;a.length = i;// 那么可以当成真正的数组遍历var total = 0;for (var j = 0; j &lt; a.length; j++)&#123; total += a[j];&#125; 判断是否是伪数组 12345678910function isArrayLike(o) &#123; if (o &amp;&amp; typeof o === "object" &amp;&amp; isFinite(o.length) &amp;&amp; o.length &gt;=0 &amp;&amp; o.length === Math.floor(o.length) &amp;&amp; o.length &lt; 4294967296) return true; else return false;&#125; 作为数组的字符串ECMAScript 5 中的字符串除了用 charAt() 访问单个元素之外，还可以使用方括号： 123var str = "string";console.log(str.charAt(1)); // =&gt; "t";console.log(s[1]); // =&gt; "t"; 数组方法总结： push(); 尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样； 返回新数组长度 操作原数组，末尾追加 pop(); 删除数组中最后一个元素， 返回值是被删除的这个元素 操作原数组 shift(); 删除数组中的第一个元素， 返回值是被删除的元素 unshift(); 向数组中第一个元素之前插入一个或多个新的元素 返回值是新数组的长度 concat(); Array.concat() 方法创建并返回新数组 新的数组和旧的数组拼接，产生一个新的数组 不修改原数组 slice(); Array.slice()方法返回指定数组的一个片段或子数组 两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素； 指定一个参数，返回包含开始位置到数组结尾的所有元素 参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个 从原来的数组中截取出来指定的一部分元素，产生新的数组 不操作原数组 splice(); Array.splice()是数组中插入或删除元素的方法。 会修改调用数组， 第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数； 如果省略了第二个参数，从开始索引位置后的元素都被删除； 可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入； 该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。 join(); 将数组中的所有元素都转化成字符串并连接到一起 返回最终生成的字符串 是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组； reverse(); 反转数组 操作原数组 返回操作后的逆向数组 sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组 操作原数组； 返回排序后的数组 toString() 和不使用任何参数调用 join() 方法返回的字符串是一样的。 toLocalString() 方法是 toString() 方法的本地化版本，使用本地化分隔符将这些字符串连接起来生成最终字符串。 indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素 查找某个元素， 第一个参数是要查找的元素, 第二个参数是开始查找的下标, 找到则返回找到的第一个元素的索引，找不到则返回-1 lastIndexOf(); 这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1； 第二个元素可以是负数，代表相对数组末尾的偏移量； every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件； every() 方法针对所有的元素判断调用函数返回全为 true，则返回true； every() 方法有一个不满足条件的则返回 false some() 方法所有的元素判断调用函数有一个满足条件的则返回 true some() 方法全为 false, 则返回 false map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个包含该函数的数组。 返回新数组 不修改原数组 稀疏数组调用返回的还是稀疏数组 一个例子：arr.map(Math.sqrt); map这个方法可以传入一个回调函数, 直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的 调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数 map方法内部帮我们遍历并且传入数组的每个元素 filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值； 压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter(); instanceof isArray(); ECMAScript 5 中给出的检测数组类型的方法； 这个方法是判断变量是不是数组 forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数； 三个参数，数值元素、数组索引、数组本身 无法再所有元素传递完调用函数之前终止遍历 reduce()和 reduceRight() reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。 reduce() 两个参数： 第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。 第二个参数是可选参数 reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组； 本文参考自：《JavaScript 权威指南》]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的对象]]></title>
    <url>%2F2015%2F06%2F18%2Fjs%E7%9A%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[除了字符串、数字、true、false、null 和 undefined 之外，JavaScript 中的值都是对象。引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。 从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示； 从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理。 对象的创建JavaScript 对象的创建有三种方式：直接量，new 关键字 和 Object.creat() 方来创建。 对象直接量对象的直接量就是由若干兼职对组成的映射表，键和值之间用 “:” 分隔，键值对之间用 “,” 分隔，整个映射表用一对花括号包裹，比如通过字面量声明（更加简便）var obj= {}; 键值对键值对就是一种对应关系，通过键能够方便地找到值 键:值 key:value k:v 例子：123456789101112var emptyObj = &#123;&#125;;var pointObj = &#123;x:0, y:0&#125;;var pointObj2 = &#123;x: pointObj.x, y: pointObj.y&#125;;var books = &#123; "main title": "JavaScript", // 属性名中有空格时，必须用字符串 'sub-title': "The Definitive Guide", // 属性名中有连字符，必须用字符串 "for": "all audiences", // "for" 是保留字，必须用引号 author: &#123; // 这里的属性名没有引号 firstname: "Hiraku", surname: "Hongqin" &#125;&#125;; 对象的字面量是一个表达式，这个表达式的每次运算都创建并初始化一个新对象。每次计算对象直接量的时候，也会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用对象直接量，它将创建很多新对象，并且每次创建的对象的属性值可有可能不同。 通过 new 关键字创建对象new 运算符创建并初始化一个新对象。n关键字 new 后面跟随一个函数调用。 通过构造函数声明（更加通用）var obj= new Object(); // 创建一个空对象，和 {} 一样 对象具有属性和方法 属性 用来描述对象的特征 一般是名词 对应变量 方法 用来描述对象的行为 一般是动词 对应函数 原型初识除了 null 以外的每一个 JavaScript 对象都和 原型 相关联。所有通过对象直接量创建的对象对具有同一个原型对象，可通过 Object.prototype 获得对原型对象的引用。通过 new 关键字和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，和使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。 没有原型的对象有 Object.prototype，它不继承任何属性。其他对象都是普通对象，都有原型。所有的内置构造函数比如：Array(), Date() 都具有一个继承自 Object.prototype 的原型。 Object.create()ECMAScript 5 定义了一个名为 Object.create() 方法，是一个静态函数，可以用来创建对象。有两个参数：第一个参数是对象，第二个参数可选，用于对属性进行详细描述。 123456// o1 继承了属性 x 和 yvar o1 = Object.create(&#123;x:1, y:1&#125;); // o2 不继承任何属性和方法，没有原型，不能和 + 运算符一起工作var o2 = Object.create(null);// o3 创建一个普通的空对象var o3 = Object.create(Object.prototype); 可以通过任意原型对象创建新对象，即可以使任意对象继承。 例子： 返回一个继承自原型对象 p 的属性的新对象 123456789function inherit(p)&#123; if (p == null) throw TypeError(); // p 是一个对象 if (Object.create) return Object.create(p); // 如果存在 Object.create，直接使用它来创建 var t = typeof p; // 否则进一步检测 if (t !== "object" &amp;&amp; t !== "function") throw TypeError(); function f() &#123;&#125;; // 创建一个空构造函数 f.prototype = p; // 将其原型属性设置为 p return new f(); // 使用 f() 创建 p 的继承对象&#125; 属性和方法的查询和设置属性 属性的定义 对象.属性名 = 值； 对象[“属性名”] = 值; 属性的调用 对象.属性名; 对象[“属性名”]; 方法 方法的定义 对象.方法名 = function() { //函数体 }; 对象[“方法名”] = function() { //函数体 }; 方法的调用 对象.方法名(); 对象[“方法名”]; 作为关联数组的对象对象属性和方法的第二种设置和访问用了 “[]”，只是利用的不是索引访问，而是字符串。这种数据就是关联数组，也叫散列、映射或者字典。 当我们通过 [] 来访问对象的属性时，在程序运行是可以设置和修改或者创建它们。 继承对象具有自有属性（own property），也有一些属性是从原型对象上继承来的。 还是这个例子： 123456789101112131415161718function inherit(p)&#123; if (p == null) throw TypeError(); // p 是一个对象 if (Object.create) return Object.create(p); // 如果存在 Object.create，直接使用它来创建 var t = typeof p; // 否则进一步检测 if (t !== "object" &amp;&amp; t !== "function") throw TypeError(); function f() &#123;&#125;; // 创建一个空构造函数 f.prototype = p; // 将其原型属性设置为 p return new f(); // 使用 f() 创建 p 的继承对象&#125;var o = &#123;&#125;;o.x = 1;var p = inherit(o); // p 继承自对象 o 和 Object.prototypep.y = 2;var q = inherit(p); // q 继承自对象 p、 o 和 Object.prototypeq.z = 3;var s = q.toString();console.log(s); // "[object object]"console.log(q.x + q.y + q.z); // 6 属性 x 和 y 分别继承自 o 和 p 属性访问错误 JavaScript 中，属性访问时，并不总是会话或者设置。 在查询不存在的属性时不会报错，而返回 undefined。 内置构造函数的原型是只读的。 删除属性delete 运算符可以删除对象的属性。delete 只是断开属性和宿主对象的联系，而不会操作属性中的属性。 delete 只能删除自有属性，不能删除继承属性。 delete 不能删除可配置属性。 在非严格模式下，删除全局独享的可配置属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟要删除的属性名即可。 在严格模式下，delete x; 报错， delete this.x; 正常运行 属性检测通过 in 运算符、hasOwnProperty()、propertyIsEnumerable() 方法； in 运算符 12var o = &#123;x: 1&#125;;"x" in o; // true "x" 是 o 的属性 hasOwnProperty() 方法 123var o = &#123;x: 1&#125;;o.hasOwnProperty(x); // true "x" 是 o 的自有属性o.hasOwnProperty(constructor); // false constructor 是原型中的属性 propertyIsEnumerable() 方法 12345678910111213function inherit(p)&#123; if (p == null) throw TypeError(); // p 是一个对象 if (Object.create) return Object.create(p); // 如果存在 Object.create，直接使用它来创建 var t = typeof p; // 否则进一步检测 if (t !== "object" &amp;&amp; t !== "function") throw TypeError(); function f() &#123;&#125;; // 创建一个空构造函数 f.prototype = p; // 将其原型属性设置为 p return new f(); // 使用 f() 创建 p 的继承对象&#125;var o = interit(&#123;x: 1&#125;);o.y = 1; o.propertyIsEnumerable("x"); // false "x" 属性是继承的，不能被枚举o.propertyIsEnumerable("y"); // true 除了 in 以外， 另一种简单的判断一个属性是否是 “undefined” 使用 “!==” 1234var o = &#123;x: 1&#125;;o.x !== undefined; // trueo.y !== undefined; // false;o.toString !== undefined; // true 但 in 可以区分不存在的属性和存在但值为 undefined 类型的属性 1234567var o = &#123;x: undefined&#125;;o.x !== undefined; // false 属性存在，但是值为 undefinedo.y !== undefined; // false 属性不存在"x" in o; // true 属性存在"y" in o; // false 属性不存在delete o.x; // 删除了属性 x"x" in o; // false 属性不再存在 对象的枚举属性除了检测对象的属性，我们经常需要遍历对象的属性，通常使用 for-in 遍历; ECMAScript 5 提供了 Object.keys() 方法，返回值是一个数组，这个数组由对象中可枚举的自有属性的名称组成。 ECMASciript 5 提供的另一种枚举属性的方法是 Object.getOwnPropertyNames(), 和 Object.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可以枚举的属性。 用来枚举对象属性的工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * [extend description] 把 P 中的可枚举属性复制到 o 中， * 如果有同名属性，则覆盖 o 中的属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function extend(o, p) &#123; for (var prop in p) &#123; o[prop] = p [prop]; &#125; return o;&#125;/** * [merge description] 把 P 中的可枚举属性复制到 o 中， * 如果有同名属性, o 中的属性不受影响 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function merge (o, p) &#123; for (var prop in p) &#123; if (o.hasOwnProperty[prop]) continue; o[prop] = p [prop]; &#125; return o;&#125;/** * [restrict description] 如果 o 中的属性没有同名属性，则从 o 中删除这个属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] 返回 o */function restrict (o, p) &#123; for (var prop in p) &#123; if (!(prop in p)) delete o[prop]; &#125; return o;&#125;/** * [substract description] 如果 o 中存在同名属性，则删除这个属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function substract(o, p) &#123; for (var prop in p) &#123; delete o[prop]; &#125; return o;&#125;/** * [union description] 如果有重名属性，使用 p 中的属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] 返回一个新对象这个对象同时拥有 o 的属性 */function union (o, p) &#123; return extend (extend(&#123;&#125;, o), p);&#125;/** * [keys description] 返回的数组中包含的是 o 中可枚举的自有属性的名字 * @param &#123;[type]&#125; o [description] * @return &#123;[type]&#125; [description] 返回一个数组 */function keys(o) &#123; if (typeof o !== "object") throw TypeError(); var result = []; for (var prop in o)&#123; if (o.hasOwnProperty(prop)) result.push(prop); &#125; return result;&#125; 属性 getter 和 setter当程序执行查询存储属性的值的时候，JavaScript 调用 getter 方法(无参数)，当设置属性值的时候，调用的是 setter 方法。 属性的特性属性包含一个属性名和4个特性： value 属性值 writable 可写性 enumerable 可枚举性 configurable 可配置性存取器属性不具有值 value 和 可写性 ECMAScript 5 中定义了属性描述符 Object.getOwnPropertyDesctiptor() 获取某个对象特定的属性，这个方法只能得到自有属性的特性。 让新建的属性具有某种特性，需要调用 Object.definePeoperty() 方法；传入要修改的对象，要创建或修改的属性的名称以及属性描述符对象； 12345678910111213141516171819202122232425var o = &#123;&#125;; // 创建一个空对象// 插入一个不可枚举的数据属性 x, 并赋值为 1；Object.defineProperty(o, "x", &#123; value: 1, writable: true, enumerable: false, configurable: true&#125;);o.x; // --&gt; 1Object.keys(o); // --&gt; []// 对属性 x 做修改变为只读Object.defineProperty(o, "x", &#123;writable: false&#125;);// 试图更改这个属性值o.x = 2; // 更改操作失败，在严格模式中抛出异常o.x; // =&gt; 1;// 属性依然是可配置的，因此可以通过这种方式对它进行修改Object.defineProperty(o, "x", &#123;value: 2&#125;);o.x; // =&gt; 2// 现在讲 x 从数据属性修改为存储器属性Object.defineProperty(o, "x", &#123; get: function()&#123; return 0; &#125;&#125;);o.x; // =&gt; 0 需要同时修改多个属性，使用 Object.defineProperties(),它返回修改后的对象。 12345678910111213141516171819202122232425/** * 复制属性的特性 * 给 Object.prototype 上添加一个不可枚举的extend() 方法 * 这个方法继承自它的调用对象，将作为参数传入的对象的属性以一幅字 * 除了值之外也赋值属性所有的特性，除非在目标对象中存在同名的属性。 * 参数对象的所有自有属性（包括不可枚举的属性）也会一一复制 */Object.defineProperty(object.prototype, "extend", &#123; // 定义 Object.prototype.extend writable: true, enumerable: false, // 将其定义为不可枚举的 configurable: true, value: function(o)&#123; // 得到所有的自有属性，包括不可枚举属性 var names = Object.getOwnPropertyNames(o); // 遍历它们 for (var i = 0; i &lt; names.length; i++)&#123; // 如果属性已经存在，则跳过 if (names[i] in this) continue; // 获取 o 中的属性描述符 var desc = Object.getOwnPropertyDescriptor(o, names[i]) // 用它给 this 创建一个属性 Object.defineProperty(this, names[i], desc) &#125; &#125;&#125;); 对象的三个属性每一个对象都有与之相关联的原型 (prototype)、类 (class) 和可扩展性 (extensible attribute)。 原型属性通过直接量创建的对象使用 Object.prototype 作为它们的原型，而使用 new 创建的对象使用 构造函数的 prototype 属性作为它们的原型。而通过 Object.create() 创建的对象使用第一个参数作为它们的原型，也可以是 null . ECMAScript 5 中将对象作为参数传入 Object.getPrototypeOf() 方法中可以查询它的原型。 要检测一个对象是否是另一个对象的原型（或处于原型链中），用 isPrototypeOf() 方法。 类属性对象的类属性是一个字符串，用以表示对象的类型信息。只有一种间接的方法可以访问，即toString() 方法。默认的 toString() 方法继承自 Object.prototype，返回 [object class] 格式的字符串。 如何获得对象的类？ 12345678/** * classof() 函数 */function classof(o)&#123; if (o === null ) return "null"; if (o === undefined) return "undefined"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 这个函数可以传入任意的参数。 对象的可扩展性ECMAScript 5 的 Object.preventExtensions() 方法将对象转为不可扩展的，Object.seal() 还可以设置对象的属性不可配置。 序列化对象（JSON 对象表示法）是指将对象的状态转为字符串，也可以将字符串还原为对象。 ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原JavaScript对象。这两个方法使用 JSON 数据格式。 JSON, 即 JavaScript Object Notation（ JavaScript 对象表示法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。 即 JSON 注意：函数、RegExp、Error 对象和 undefined 值不能序列化和还原 JSON 转字符串 序列化 JSON.stringfy(); 字符串转 JSON 反序列化 JSON.parse(); 遍历的 JSON 两种方式通过for可以对集合进行有序的遍历for(var k in json) { 语句 }; k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思,名字不同而已 对象的方法 toString() 方法 toLocalString() 方法 toJSON() 方法 valueOf() 方法]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js语句]]></title>
    <url>%2F2015%2F06%2F15%2Fjs%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[ECMAScript 语法定义的语句通常使用一个或多个关键字来完成给定的任务。 条件判断结构 if/ if…else/ if…else 嵌套12345if(条件表达式)&#123; // 如果条件表达式为true，执行该处代码&#125;else&#123; // 如果条件表达式为false,执行该处代码&#125; 条件判断的嵌套 123456789if(条件表达式）&#123; //如果条件表达式结果为true,执行该语句，下边语句不执行。&#125;else if(条件表达式)&#123; // 如果条件表达式结果为true,执行该语句，下边语句不执行。&#125;else if(条件表达式)&#123; // 如果条件表达式结果为true,执行该语句，下边语句不执行。&#125;else &#123; // 如果以上语句都为false,执行该语句。&#125; Switch语句写法 123456789101112131415161718var mon=prompt("请输入月份");switch(mon)&#123; case "3": case "4": case "5": alert("春季"); break; case "6": case "7": case "8": alert("夏季"); break; case "9": case "10": case "11": alert("秋季"); break; case "12": case "1": case "2": alert("冬季"); break; default: alert("请输入正确月份"); break;&#125; 注意:switch后边的变量和case后边值的数据类型必须保持一致。 While循环语句语法: 1234var n1;While(条件表达式)&#123; // 循环语句&#125; 如果while后边的条件表达式为true,循环语句一直执行，直到while后边的条件表达式为false, 循环终止（跳出循环）,使用while语句的时候，需在外边定义一个变量。 Do while 语句语法 123do&#123; // 循环语句&#125;while(条件表达式) 先执行do里循环代码，再和while后边的条件表达式进行判断，如果结果为true,继续执行do里的循环，结果为false，循环终止。比while多执行一次循环。 while语句 先判断后执行do while 语句 先执行后判断 for循环语法 123for(var i=1; i&lt;=100; i++)&#123; //循环代码&#125; break语句单独使用 break 语句的作用是立即退出最内层的循环或 switch 语句。 语法： 1234while()&#123; // 循环语句 break;&#125; Break是跳出当前循环体； continue语句跳出循环一次。后边的代码不继续执行。 break 和 continue 的区别 break跳出当前循环，执行循环后的语句 continue跳出当前循环，继续执行循环 for-in 属性枚举语句for-in 语句用来枚举对象的属性。 123for(variable in object)&#123; // 代码段&#125; variable 是一个变量名，也可以是一个可以产生左值表达式或者一个通过 var 语句声明的变量，每次循环都会计算 variable 这个表达式，也就是说每次循环它的值可能不同。for/in 循环并不会遍历对象的所有属性，只有”可枚举”的属性才会遍历到。内置对象的方法就是不可枚举的 label （标签）语句label 语句可以在代码中添加标签，以便将来使用。通过给语句定义标签，就可以在程序的任何地方通过标签名引用这条语句。 123start: for(var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; with 语句with 语句的作用是将作用域设置到一个特定的对象中。如： 123456789var qs = location.search.substring();var hostName = location.hostname();var utl = location.href();// 以上代码可以写成下面的方式, 严格模式下不允许使用 withwith(location)&#123; var qs = search.substring(); var hostName = hostname(); var utl = href();&#125; return 语句函数是一种表达式，所有的表达式都有值。函数中国的 return 语句既是指定函数调用后的返回值。因此，return 语句只能在函数体内部出现，而且 return 语句经常作为函数的最后一条语句出现，但并不是说一定要放在函数体的最后，即使在执行 return 语句的时候还有很多后续代码没有执行，这是函数也还会返回调用程序。 throw 语句异常是指程序在程序在运行时发生的异常情况或错误时产生的一个信号。在 JavaScript 中，当产生运行时错误或者程序使用 throw 语句时就会显式的抛出异常。 try/catch/finally 语句try/catch/finally 是 JavaScript 的异常处理机制。其中 try 从句中定义了需要处理的异常所在代码块，catch 从句跟在 try 后，当 try 块内发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中国放置清理代码，不管是 try 块中是否产生异常，finally 块内的逻辑总是会执行。 12345678try &#123; // 需要捕获异常的代码块&#125; catch(e) &#123; // try 代码块抛出异常才会执行此代码块中的逻辑 // 还可以通过 throw 语句来再次抛出异常&#125; finally &#123; // 不管异常有没有发生，这个代码块中的逻辑都会执行&#125; 其它语句debugger 语句“use strict”开启 ECMAScript 5 引入的一条命令，开启严格模式。说明后续的所有 JavaScript 代码都在严格模式下执行。 严格模式下禁止使用 with 语句 在严格模式下，所有的变量都要先声明； 严格模式中，调用的函数中的一个 this 值是 undefined ； 可以利用这种方式判断 JavaScript 实现是否支持严格模式 1234var hasStrictMode = (function()&#123; "use strict"; return this === undefined;&#125;()); 在严格模式中，当通过 call() 或 apply() 来调用函数时，其中 this 值就是通过 call() 或 apply() 传入的第一个参数；+（在非严格模式中，null 和 undefined 值被全局对象和转换为对象的费对象值所替代） 在严格模式，给只读属性和给不可扩展的对象创建新成员都抛出一个类型错误异常。+（在非严格模式中，这些操作只是简单地操作失败，不会报错） 在严格模式下，传入 eval() 的代码不能在调用程序锁在的上下文中声明变量或定义函数 在非严格模式中是可以这样做的。 严格模式下，函数里的 arguments 对象拥有传入函数值的静态副本。 严格模式下，delete 运算符后跟随非法的标识符会抛出异常 严格模式下，试图删除一个不可配置的属性将抛出一个类型错误异常 严格模式下，在一个对象直接量中定义两个或多个同名属性将会产生一个语法错误 严格模式下是不允许使用八进制整数直接量 严格模式下标识符 eval() 和 arguments 当做关键字，它们的值是不能更改的。不能给这些标识符赋值。 严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常。 严格模式的函数同样具有 caller 和 arguments 属性，当访问这两个属性时将会抛出类型错误异常。]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js Date、Math、包装对象、RegExp]]></title>
    <url>%2F2015%2F06%2F08%2Fjs%20Date%E3%80%81Math%E3%80%81%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E3%80%81RegExp%2F</url>
    <content type="text"><![CDATA[javaScript的几个内置对象Date对象ECMAScript 5 提供了两个方法：Date.parase() 和 Date.UTC() 返回日期的毫秒数 12345678var now = new Date(); //创建对象alert(Date()); //返回一个完整的日期时间alert(now.getDate()); //返回从1开始计数的天数alert(now.getDay()); //返回当前周几alert(now.getFullYear()); //返回当前年份alert(now.getMonth()+1); //返回当前月份alert(now.getHours()); //当地时间的小时var then = new Date(2011, 10, 10); // 2011年10月10日 日期格式化方法 toDateString(); toTimeString(); toLocaleDateString(); toLocalTimeString(); toUTCString() Math对象123456789101112131415161718// 控制台输出Math.max(1,2,3,4,5);//这些数字中的最大值Math.min(1,2,3,4,5);//返回多个数中的最小值Math.floor(45.84334);//向下取整Math.ceil(5.4443);//向上取整Math.round(67.55);//四舍五入Math.random();//随机数 0-1 parseInt(Math.random()*10+1); //随机数 1-10parseInt(Math.random()*100+1); //随机数 1-100Math.abs(-100);//返回绝对值 Math.pow(4,3); //4 的 3 次幂 Math.sqrt(16); //开平方Math.sin(4);//返回正弦值Math.PI; // π 圆周率Math.sqrt(3); // 3 的平方根Math.exp(3); // e 的 3 次幂Math.log(10); // 10 的自然对数Math.E; // 自然对数的底数 全局对象当 JavaScript 解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性。 全局属性，如 undefined、Infinity 和 NaN; 全局函数，如：isNaN()、parseInt() 和 eval(); 构造函数，如：Date()、RegExp()、String()、Object() 和 Array() 全局对象，如：Math 和 JSON; 包装对象 String() Number() Boolean()字符串字面量、数字字面量、布尔字面量均可以使用”.”符号引用属性值，当属性值是一个函数时，称其为方法。只有对象有属性，JavaScript 在创建字符串、数字、布尔值时会自动的通过调用 new String(); new Number(); new Boolean() 的方式调用。 RegExp 对象var expression = /pattern/flags; pattern 是正则表达式，可以包含字符类，限定符，分组，向前查找以及反向查找。flag是标志，有 3 种： g: 全局(global)模式 i: 表示不区分大小写 m: 表示多行(multiline)模式 RegExp 构造函数的模式参数是字符串，在某些情况下需要双重转义； RegExp 实例属性 global 布尔值，是否设置了 g 标志 ignoreCase 布尔值，是否设置了 i 标志 lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从 0 算起 multiline 布尔值，是否设置了 m 标志 source 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回； RegExp 实例方法 exec() ； 接收一个参数，要引用匹配模式的字符串，返回包含第一个匹配项信息的数组； 没有匹配项的情况下返回 null 返回的数组虽然是 Array 的实例，但包含两个属性：index 和 input index 表示匹配项子在字符串中的位置 input 表示应用正则表达式的字符串 exec() 方法在设置了全局标志的情况下，每次调用该方法都会在字符串中继续查找新匹配项。 12345678var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var mataches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // "mom and dad and baby"console.log(matches[0]); // "mom and dad and baby"console.log(matches[1]); // " and dad and baby"console.log(matches[2]); // " and baby" 总之：正则分组之后匹配到的结果如果匹配成功则会得到数组，数组中第 0 项是与整个模式匹配的字符串，从第一项开始就是数正则表达式中的左括号就可以了，左括号是第几个，则解析出来的数据就是数组中下标为该数字的元素`]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js表达式和运算符]]></title>
    <url>%2F2015%2F06%2F06%2Fjs%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 解释器会将表达式计算出一个结果，程序中最常见的变量就是一种表达式。变量名也是一种表达式。复杂表达式是由简单表达式组成的，最常用的方法是使用运算符。 表达式原始表达式原始表达式是表达式的最小单位，通常包含： 常量 直接量 关键字 变量 对象和数组的初始化表达式 数组表达式 [] [1+2,3+1] var matrix = [[1,2,3],[1,2,2],[2,3,1]]; [0,,,1] 对象表达式 var p = {name: &quot;Hiraku&quot;, age: 17}; var q = {}; q.x = 2.3 var data = {casData:{cas: canvas, ctx: context}, lineData{lineStyle:&quot;red&quot;,lineWidth:2}} 函数定义表达式 var square = function(x){ return x * x}; 访问对象属性的方式 obj.key; obj[key]; 调用表达式: 函数表达式开始，这个函数表达式指代了要调用的函数，函数表达式后是一对圆括号，括号内是以逗号隔开的参数； f(0); Math.max(1,2,3); 对象创建表达式 new Object() new Point(1,3) 无参数时()可以省略： new Object 运算符ECMAScript 描述了一组用于操作数组的操作符，分为算术操作符、位操作符、关系操作符合相等操作符。对于对象，相应的操作符通常都会调用对象的 valueOf() 方法或者 toString() 方法。 比较、typeof、+、-、*、/、%、=、==、===、三元、逻辑运算符 比较运算符 &lt; = &lt;= != 判断数据类型 typeof(变量名); 算术运算符 加运算： 两个数据类型都为数字类型变量相加，得到的是数字类型。 一个为数字类型的变量和一个为字符串类型的变量相加，得到的是一个字符串类型，加号起一个连接的作用。 减运算 如果两个变量都为数字类型相减，得到的是数字类型。 如果一个为数字类型的变量，一个为数字字符串，相减得到的是数字类型。 如果一个为数字类型的变量，一个为非数字字符串，相减得到的NaN,数字类型。 * 乘运算 Inifinity 与 0 相乘， undefined。 / 除运算 两个都为数字类型的变量，相除得到的是数字类型。 如果一个为数字类型的变量，一个为数字字符串变量，相除得到的是数字类型。 如果一个为数字类型的变量，一个为非数字字符串，相除得到的NaN,数字类型。 如果0作为除数，得到的是infinity(无限大)，是一个数字类型。 0 / 0 是 undefined。 Infinity / Infinity 结果是 NaN。 % 取余数 ()优先级 先计算()括号里边的值。 等号运算符 “=” 赋值预算符 “==” 比较运算符: 只判断内容是否相同，不判断数据类型。 “===” 比较运算符: 不仅判断内容是否相同，还判断数据类型是否相同。 “!=” 不等于: 只判断内容是否不相同，不判断数据类型。 “!==” 不等于: 不仅判断内容是否不相同，还判断数据类型是否相同。 三元运算符 语法： 表达式？如果表达式的值为true,执行表达式后边的代码，如果值为false,执行冒号后边的值。 三元运算符可以理解为if..else的另外一种写法。 逻辑运算符：逻辑运算的前提是参与运算的变量结果为Boolean类型。 或（||） 参与运算，只要满足一个为true,或运算最后的值为true. 参与运算的值都为false,或运算最后的值为false. 且（&amp;&amp;） 参与运算，只要满足一个为false,或运算最后的值为false. 参与运算，都为true的时候，且运算最后的值为true. 非（!） 如果运算结果为true,非运算结果为false 如果运算结果为false,非运算结果为true. 非 如果操作数是一个对象，返回 false 如果操作数是一个空字符串，返回 true 如果操作数是一个非空字符串，返回 false 如果操作数是数值 0 ，返回 true 如果操作数是任意非 0 数值，包括 Infinity ，返回 true 如果操作数是 null ，返回 true 如果操作数是 NaN ，返回 true 如果操作数是 undefined ，返回 true与 如果第一个操作数是对象，返回第二个操作数； 如果第二个操作数是对象，只有第二个数求值结果为 true 是，返回该对象 如果两个都是对象，返回第二个； 如果有一个操作数是 null ，返回 null 如果有一个操作数是 NaN ，返回 NaN 如果有一个操作数是 undefined ，返回 undefined或 如果第一个操作数是对象，返回第一个； 如果第一个操作数求值结果 false ，返回第二个 如果两个都是对象，返回第一个； 如果两个操作数是 null ，返回 null 如果两个操作数是 NaN ，返回 NaN 如果两个操作数是 undefined ，返回 undefined 总结逻辑运算符： &amp;&amp;和||都采取短路运算，即第一个能够决定结果就不再看第二个了 &amp;&amp; 的要求比较宽松 要两个都是true才是true 所以看到第一个是false就没有必要继续完后看了 || 的要求比较严格，要两个都是false才是false，所以看到第一个是true就没有必要继续完后看了 &amp;&amp;和||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 自增自减 ++i，i++ 在没有参加运算的情况下，++i i++都是在变量的基础上加1。 在参加运算的情况下： 123var n1=123;var n2=n1++; // 先把n1的值赋给n2,然后n1执行加1的操作。Var n2=++n1; // 先执行n1加1的操作，再赋值给n2. 总的来说： 递增++ 递减– a++ 先参与运算 后自加 ++a 先自加 后参与运算 注意： 在应用于一个包含有效数字字符串是，先将其转换为数字值再执行加减1的操作。 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。 在应用于对象时，先抵用对象的 valueOf 方法以取得一个可供操作的值，然后对该值应用前面的规则。如果结果是NaN，则调用 toString() 方法后再应用前述的规则。 带操作的赋值运算符 位操作符0 正 1 负，最高位表示符号位。正数和负数都是以二进制码来存储，但负数使用的格式是二进制补码。计算过程如下： 求这个数绝对值的二进制码； 求二进制反码； 得到的反码加 1。ECMAScript 中，对 NaN, Infinity 值应用位操作时，这两个值都当做 0 来处理。 按位非(~) 按位与(&amp;) 按位或(|) 按位异或(^) 左移(&lt;&lt;) 有符号右移(&gt;&gt;) 无符号右移(&gt;&gt;&gt;) instanceof 操作符测试对象类，左操作数是一个对象，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true，否则返回false。 操作符优先级 eval()eval() 是一个函数，但它已经被当做运算符来对待了。 eval()eval() 只有一个参数。如果传入的不是字符串，直接返回这个参数，如果是字符串，会把字符串当成 JavaScript 代码进行编译，如果便以失败抛出异常，编译成功则执行这段代码。返回字符串中最后一个表达式或语句的值，如果最后一个表达式中没有返回值，则返回 undefined。 eval() 它使用了调用它的变量作用域环境。它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。 全局的eval()eval() 具有改变局部变量的能力。当直接使用 “eval” 名称来调用 eval() 函数时，通常称为”直接 eval”.直接调用 eval() 时，它总是调用它的上下文作用域内执行。其它间接调用使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。 1234567891011121314var geval = eval;var x = "global", y = "global";function f()&#123; var x = "local"; eval ("x += 'changed'"); return x;&#125;function g()&#123; var y = "local"; geval ("y += 'changed'"); return y;&#125;console.log(f(),x);console.log(g(),y); 严格的eval()ECMAScript 5 严格模式中，eval() 是私有上下文环境中的局部 eval()，eval() 执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新变量。 eval总结 函数是封装了一段可以重复执行的代码 eval方法的功能：执行一段JS代码(封装了代码) 在eval方法中没有作用域的概念（ES5严格模式有了独立的作用域）——&gt;声明的变量都是全局变量，函数都是全局函数 eval和函数的比较 eval封装了一段代码（只能执行一次）；函数封装了一段代码（可以重复执行） eval中没有独立作用域的——&gt;声明的变量和函数都是全局的； 函数中是有独立作用域 ——&gt;函数内声明的变量和函数只能在当前函数内部所访问 delete运算符delete 运算符时一元运算符，用来删除对象属性或者数组元素。删除属性或者删除数组元素不仅仅是设置了一个 undefined 的值。当删除一个属性时，这个属性将不再存在。读取一个不存在的属性将返回 undefined，但是可以通过 in 运算符来检测这个属性是否在对象中存在。 void运算符void 运算符是一元运算符，在操作数之前，操作数可以使任意类型。通常用在客户端的URL–javascript: URL 中，在 URL 中可以写带有副作用的表达式，而 void 则让浏览器不比显示这个表达式的计算结果。 例如： 1&lt;a href="javascript:void window.open();"&gt;打开一个新窗口&lt;/a&gt; 通过给 &lt;a&gt; 标签的onclick 绑定一个事件处理程序要比在 href 中写 “javascript:URL” 要更加清晰，这种情况下 void 可有可无。 逗号运算符逗号运算符是二元操作符，操作数可以是任意类型，先计算左边操作数后计算右边操作数，最后返回右操作数的值。]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js变量和数据类型]]></title>
    <url>%2F2015%2F06%2F03%2Fjs%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量JavaScript是弱类型的语言，变量是松散的。所谓松散是可以保存任何类型的变量。即声明不同数据类型的变量使用同一个关键字 var，变量就是变化的量，变量的作用就是用来装数据的容器。声明变量的时候不用考虑类型，但是处理和计算的时候要考虑类型. 定义变量定义变量使用关键字 var来定义变量名。 1234// 在全局作用域下声明了变量 avar a; // 使用赋值运算符来给变量赋值a = "a此时是字符串"; 赋值： 赋值运算符为“=”，这个等号不用判断两者是否相同。 如果判断是否相同，可使用==（===）。 以上两步可简写为： 1var a = "a此时是字符串"; 注意： 123function foo()&#123; msg = "我是函数内部定义的全局变量";&#125; 上面例子省略了var操作符， msg 就变成了全局变量，函数外部也能访问到，但不要这样做！。 变量命名规范 由字母、数字、下划线、$ 组成且开头不能是数字定义变量名。 不能使用特殊符号或者特殊符号开头来定义变量名（_除外）。 不能以关键字来定义变量名 变量的名称要有实际意义 规则中所说的字母包括ASCII和Unicode字母字符，如汉字，但不推荐使用 变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName 关键字 1234567break do instanceof typeofcase else new varcatch finally return voidcontinue for switch whiledebugger* function this withdefault if throwdelete in try 不能使用保留字来定义变量名 (保留字) 12345678abstract enum int shortboolean export interface staticbyte extends long superchar final native synchronizedclass float package throwsconst goto private transientdebugger implements protected volatiledouble import public 注意：在JS中，是严格区分大小写的。 执行环境和作用域执行环境是 JavaScript 中最为重要的一个概念。定义了变量或函数有权访问其它数据。每个环境中都有一个与之关联的变量对象，我们编写的代码无法访问，但是环境中定义的变量存放在这个对象中。 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境的不同，表示执行环境的对象也不一样。在 web 浏览器中，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都是作为 window 对象的属性和方法创建的。某个环境中的代码全部执行完，该环境中的变量被销毁，保存在其中的所有的变量和函数定义也随之销毁。全局执行环境直到应用程序退出才销毁。 每个函数都有自己的执行环境。当代码在一个环境中执行时，会创建作用域链。作用域链式保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始的时候只包含一个变量，即 arguments 对象。作用域中的下一个变量对象来说包含（外部的环境），而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。 一个变量的作用域是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在 JavaScript 代码中任何地方都是有定义的。而在函数内部声明的变量只有在函数体内有定义，它们是局部变量，作用域是局部的。 在函数体内部，局部变量的优先级高于同名的全局变量。 函数作用域和声明提前块级作用域是指在一对花括号内的代码都具有各自的作用域，而且变量在声明它们的代码之外是不可见的。但是 JavaScript 没有块级作用域的概念。而是使用了函数作用域。JavaScript 的函数作用域是指函数内声明的所有变量在函数体内始终是可见的。 1234567891011function test(o)&#123; var i = 0; // i 在整个函数体内部有定义 if (typeof o == 'object')&#123; var j = 0; // j 在函数体内有定义 for(var k = 0; k &lt; 10; k++)&#123; // k 在函数体内是有定义的，不仅仅是在循环内 console.log(k); // 输出 0~9 &#125; console.log(k); // 输出 10 &#125; console.log(j); // j 已经定义了，但是可能没有初始化&#125; 作为属性的变量当声明一个变量时，实际上是定义了一个全局对象的一个属性，当使用 var 声明变量时，创建的这个对象是不可配置的，也就是说这个变量不能通过 delete 操作符来删除。如果在非严格模式下，给一个未声明的全局变量赋值的话， JavaScript 会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配置属性，并且可以删除它们。 作用域链嵌套的函数体内部，可以访问它上一级作用域中的变量。 延长作用域链： try-catch 语句 with 语句 垃圾收集 标记清除 引用计数 性能问题 管理内存 数据类型javaScript 数据类型有两类： 基本数据类型 和 复杂数据类型，其中基本数据类型（简单类型）有： Number/String/Boolean/Uundefined/Null一种复杂数据类型：object：Array/Date/Math/RegExp/ typeof 操作符 “undefined” –&gt; 这个值未定义 “boolean” –&gt; 这个值是布尔值 “string” –&gt; 这个只是字符串 “number” –&gt; 这个值是数值 “object” –&gt; 这个值是对象或null “function” –&gt; 这个值是函数 typeof 操作符号后面的操作数可以是变量，也可以是字面量； typeof 误区： null 值返回 “object”; Safari5 以及之前的版本、Chrome7 以及之前的版本对正则表达式调用返回”object”， 其他浏览器在这种情况下返回”object” 未初始化的变量和没有定义的变量操作符 typeof 都返回 “undefined”， 但它们有本质区别 Number 数据类型字面量： var num = 数字; 包括正数，负数，小数 取值范围： 能表示的最大值是±1.7976931348623157乘以10的308次方 能表示的最小值是±5 乘以10的-324次方 表示方式 十进制 十六进制 以 0x 开头，从 0-9，a(A) 到 f（F）的范围。 八进制 以 0 开头，0-7 组成。 NaN (not a number) 也是 number 类型，NaN 不等于自身 两个都为字符串的变量相减，得到的是NaN. 浮点数： 计算浮点数时会丢失精度 通常用整数的计算来表示浮点数的计算 不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的） String,字符串类型字面量： var str = “字符串”; 字符串的长度： str.length; 凡是用””或者’’引起来的全是字符串类型。 转义字符 \” 转双引号 \’ 转单引 \r 回车 \n 换行 \t 制表符 \f 进纸 \xnn 以十六进制表示一个字符(n 是 0~F) \unnnn 以十六进制代码nnnn表示一个 Unicode 字符 (n 是 0~F) 字符串的特点ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的直就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含心智的字符串填充该变量。如： 12var str = "Java";str = str + "Script"; 转换为字符串数值、布尔值、对象和字符串值都有 toString()方法, 但是 null 和 undefined 没用这个方法。 调用toString() 方法时，大多数情况下不传参数，但是如果传递了一个参数，输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值字符串表示。而通过传递基数，可以输出对应的二进制、八进制、十六进制。 123456var n = 10;console.log(n.toString()); // "10"console.log(n.toString(2)); // "1010"console.log(n.toString(8)); // "12"console.log(n.toString(10)); // "10"console.log(n.toString(16)); // "a" 在不知道要转换的值是什么类型的时候，可以用 String() 函数，它可以将任意类型转成字符串。 Boolean 布尔类型 布尔数据类型两个数据值: true/false 实际运算中，true 代表1, false代表0; Undefined 表示声明但未赋值的变量在 js 中，一下四种情况的返回值是 undefined 变量声明了但没有赋值 函数没有返回值默认返回undefined 函数传递的实参个数少于形参个数时，未传递的参数值为undefined 对象没有定义的属性默认为undefined Null用 typeof判断时值为 object(值为空)/引用为空，内存里找不到这个变量。 再如： 1console.log(undefined == null); // true 两等号判断，两边都转成false 总的来说，只要意在保存对象的变量还没有真正保存对象，就应该让该变量保存 null 值，这样做体现了 null 作为空对象指针的惯例，也区分了 undefined 和 null。 复杂类型（来自JavaScript高级程序设计） object 对象 ECMAScript 中的对象就是一组数据和功能的集合。可以通过 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性或方法，就可以创建自定义对象，如： 1var o = new Object(); Object的每个实例具有的属性和方法 constructor： 保存着用于创建当前对象的函数，即构造函数。 hasOwnProperty(propertyName): 用于检查给定的属性在当前对象的实例中(而不是在原型中)存在；参数是字符串。 isPrototypeOf(object): 检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName): 检查给定的属性是否能够使用 for-in 语言来枚举。参数是字符串。 toLocalString(): 返回对象的字符串表示，该字符串与执行环境的地区对应。 toString(): 返回对象的字符串表示。 valueOf(): 返回对象的字符串、数值、或布尔值表示。通常与 toString() 方法的返回值相同。 数据类型转换隐式数据类型转换 变量参与到运算中，程序对变量进行的数据类型转换（不是程序员进行的数据类型） 强制数据类型转换 将数字转换为字符串 String 变量.toString ，注意：null 和 undefined 没有 toString() 方法 将字符串转换为数字 Number 转换后保留原数据，不会对数据进行四舍五入。 非数字类型字符串转换后，比如 undefined，得到 NaN 。 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值。 parseInt 对小数转换后保留的是整数部分，不会对数据进行四舍五入。 如果是数字后边有非数字字符串，转换后得到的是前边数字的整数部分。 parseFloat 转换为数字类型之后保留原数据，不进行四舍五入。 非数字类型字符串转换后，得到 NaN 。 如果是数字后边有非数字字符串，转换后得到的是前边数字的部分。 将其他类型转换为布尔类型：所有类型的值都可以转化成布尔值 Boolean 会转化成false的值有： 空字符串 数值零 NaN undefined null 假值：空字符串””/数字0/null/undefined/false/NaN 基本数据类型和复杂数据类型总结 基本类型—值类型— String Undefined Number Boolean Null 复杂类型—引用类型– Object 数组–Array,Date…. 基本类型的值存储在—- 栈中 复杂类型的地址(引用)存储在栈中,—地址指向的空间中的对象(对象)—对象存储在堆中 创建对象并返回对象—返回的是对象的地址(对象在堆空间中的地址) 基本类型传值的时候，传递的是值 复杂类型(引用类型)传递的时候,传递的是:地址(引用)]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js词法结构]]></title>
    <url>%2F2015%2F06%2F01%2Fjs%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[js 的词法结构是一套基本规则，用来描述如何使用 js 编程。它规定了如何变量名长什么样，如何写注释以及程序语句之间如何分隔。 字符集（JavaScript权威指南）区分大小写标识符关键字、变量名、函数名、函数参数和所有标识符都是采用一致的大小写。 第一个字符必须是一个字母、下划线(_)或一个美元符($)； 其它字符可以是字母、下划线、美元符号或者数字 驼峰命名法 关键字js 没有使用但保留的关键字 class const enum export extends import super 保留字 js已经使用的关键字 123456break delete function return typeofcase do if switch var catch else in this void continue false instanceof throw whiledebugger finally new true withdefault for null try 严格模式下的保留字 123implements let private public yieldinterface package protected staticarguments eval js 尽量避免使用的标识符 123456abstract double goto native ataticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatiole js 预定义的全局变量和函数名 123456arguments encodeURI Infinity Number RegExpencodeURICompnent Array isFinite Object StringBoolean Error isNaN parseFloat SyntaxError Date eval JSON parseInt TypeErrordecodeURI EvalError Math RangeError undefineddecodeURIComponent Function NaN ReferenceError URIError 空格、换行符、格式控制 \u0020 空格符 \u0009 水平制表符 \u000B 垂直制表符 \u000C 换页符 \u00A0 不中断空白符 \uFEFF 字节标记 \u000A 换行符 \u000D 回车符 \u2028 行分隔符 \u2029 段分隔符 \u200F 格式控制符 \u200E 格式控制符 \u200D 零宽连接符 \uFEFF 零宽非连接符注释 单行注释 1//单行注释 单行段落注释 1/*这是一个段落注释*/ 多行注释 1234/** 多行注释* 这里的注释可以连续写几行*/ 直接量直接量就是程序中直接使用的数据值，如： 1.2 // 数字 “123” // 字符串 “string” // 字符串 true // 布尔值 /^/w+/g // 正则表达式直接量 null // 空 {name:&quot;Hiraku&quot;,age:12} // 对象 [1,2,4] // 数组 分号的问题JavaScritp 使用分号(;)将语句和语句分开。JavaScript 并不是所有换行处都加分号，而是只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号。 如果当前语句和下一行语句无法合并解析，JavaScript 则在第一行后面填补分号，这是通用规则，但是有两个例外，一个是在涉及语句时，如果这三个关键字后紧跟着换行，JavaScript 则会在换行处填补分号。也就是说， return、break 和 continue 语句之后不能直接换行.]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js初识]]></title>
    <url>%2F2015%2F05%2F30%2Fjs%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ECMAScript 是一种由 Ecma 国际前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association，制定的标准。 JavaScript 是由公司开发而成的，公司开发而成的一定是有一些问题，不便于其他的公司拓展和使用。所以欧洲的这个ECMA的组织，牵头制定 JavaScript 的标准，取名为 ECMAScript。简单来说 ECMAScript 不是一门语言，而是一个标准。符合这个标准的比较常见的有：JavaScript、Action Script（Flash中用的语言）。就是说，你JavaScript学完了，Flash中的程序也会写了。 ECMAScript 在 2015 年 6 月，发布了 ECMAScript 6 版本，语言的能力更强。 javaScript概念、组成概念：js是一门在客户端进行交互的网页编程语言. 一个完整的 JavaScript实现应该由下列三个部分组成： 组成： ECMAScript js标准 Dom 可以利用JS操作网页元素 Bom 通过api来操作浏览器 ECMAScriptweb 浏览器是 ECMAScript 实现可能的宿主环境之一，ECMAScript 规定了语言的的下列组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript 就是对实现这个标准规定的各方面内容的语言描述。 DOM 文档对象模型 简介文档对象模型是针对 XML 但经过扩展用于 HTML 的应用程序编程接口。DOM 把整个页面映射为一个多层节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含不同的数据类型的数据。 BOM 浏览器对象模型 简介BOM 只处理浏览器窗口和框架，习惯上把所有针对浏览器的 JavaScrip 扩展算作 BOM 的一部分。如： 弹出新浏览器窗口 移动、缩放和关闭浏览器窗口的功能 提供浏览器信息信息的 navigator 对象 提供浏览器所加载页面详细信息的 location 对象 提供用户显示器分辨率详细信息的 screen 对象 对 cookie 的支持 像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象 由于没 BOM 统一标准，所以各个浏览器都有自己的实现功能，尽管各规定浏览器都实现 window 对象和 navigator 对象； JavaScript 的特点 简单易用 基于对象 基于过程 解释执行：js引擎来执行源代码 ， node 平台 编译执行类语言有：Java c# 源代码 ==&gt; 可执行文件.dll ==&gt; 电脑执行.dll课执行文件 使用范围： 表单验证 轮播图特效 游戏开发 &lt;script&gt;&lt;/script&gt;元素&lt;script&gt;&lt;/script&gt; 定义了6个属性 async: 可选。立即下载脚标，对页面中其他元素没有影响。只对外部脚标文件有效 charset: 可选。 表示通过 src 属性指定的代码的字符集。大多数浏览器会忽略其值，很少用 defer：可选。 表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本有效 language: 已废弃。 src：可选。要执行的外部文件 type：可选。考虑到最大程度的兼容，使用 &quot;text/javascript&quot; js书写位置 内嵌式 1234567&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;js 书写位置&lt;/title&gt;&lt;script&gt; // js 代码段&lt;/script&gt;&lt;/head&gt; 外链式写法 新建一个js文件 通过script标签里的src=”1.js”属性将JS文件调入到当前页面。 补充内嵌式写法：推荐Js代码最好放在body结束标签的后边。 在XHTML中的用法XHTML 即可扩展的超文本标记语言，是将 HTML 作为 XML 的应用重新定义的一个标准。 1234567&lt;script type="text/javascript"&gt;// &lt;![CDATA[ funciton foo()&#123; // 代码段 &#125;//]]&gt;&lt;/script&gt; 文档模式doctype: 标准模式、混杂模式 严格模式开启：use strict; 页面中输出消息的几种方式12345alert("信息") 在页面出现一个弹出框，将信息弹出。confirm("信息") 在页面出现一个弹出框，将信息显示，常与if判断语句结合使用。prompt("信息") 弹出一个文本框，可以在文本框接收内容。常用于接收信息。console.log("信息")将信息输出到控制台，常用于代码调试。document.write("信息") 直接在页面输出消息。 注：document.write(“信息”)，不仅可以输出内容，还可以输出html标签。]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML元素分类、伪类、背景图片]]></title>
    <url>%2F2015%2F05%2F28%2FHTML%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB%E3%80%81%E4%BC%AA%E7%B1%BB%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[CSS Cascading style sheets写法 内嵌式 外链式 1&lt;link rel="stylesheet" href="1.css"&gt; 行内样式 三种样式写法的区别 内嵌样式表： 影响范围限于当前页面，其他页面无效，不能真正实现结构和表现解耦 外链样式表 影响范围大，是整个站点，实现真正的结构表现分离 行内样式表： 仅限于当前标签，作用范围小。结构和表现完全耦合 link和@import区别 link属于HTML标签，而@import是CSS提供的 页面加载时，link会同时加载，而@import引入的CSS要等到页面中的所有元素加载完再加载 @import有兼容性，而link是HTML标签，无兼容性问题 link方式的样式的权重高于@import的权重 link引入的CSS支持js修改样式，而@import导入的CSS不能被js代码修改样式； html分类（显示方式）块元素最常用的有： div,p, li, h1-h6 特点： 独占一行 可以定义宽度和高度 包含关系的时候，父元素和子元素都为块元素的时候，子元素的宽度等于父元素的宽度 行内元素（内联元素）典型代表：strong span a em b del s ins i u 特点： 不能设置宽高， 宽高度由内容撑开 在一行上显示 行内块元素典型代表img input 特点： 在一行显示 可以定义宽高 元素之间的转换 行内元素转成块级元素 1display:block; 块级元素转成行内元素 1display:inline-block; 块元素转成行内元素 块、行内元素转成行内块元素 css特性层叠性当样式属性冲突时，执行时是最后面样式。和标签调用顺序无关。 继承性 条件：包含关系 普遍性：文本大小、字体、粗细、颜色、行高、风格样式被继承 特殊性： 标题标签不会继承，但受父级元素的影响，文字大小。 a标签不会继承父元素的文字颜色。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 文字的所有属性可以继承，行高也可以继承, 但a标签不继承文字颜色 优先级 !important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 默认 1000以上 1000 100 10 1 0 继承的权重为0, 权重会叠加 连接伪类a:link{属性:值;}, 没有点击时默认状态 a{属性:值;} 一般写这个 1234567891011121314151617181920a:link&#123; /*连接默认状态*/ 属性:值;&#125;a:visited&#123; /*连接访问之后的状态*/ 属性:值;&#125;a:hover&#123; /*鼠标放上去显示的状态*/ 属性:值;&#125;a:active&#123; /*连接激活的状态*/ 属性:值;&#125;a:focus&#123; /*获取较大*/ 属性:值;&#125; 注意：连接伪类的顺序不能错； text-decoration 文本修饰 text-decoration: none; 去掉a标签的默认样式的下划线 text-decoration: underline; 加上下划线 text-decoration: line-through; 删除线 背景 background-color background-image background-repeat 背景图片沿着x轴平铺 background-position left|right|top|bottom|center 背景定位写具体方位的时候，书写顺序没有限制 background-attchment scroll|fixed scroll 背景滚动 默认 fixed 背景固定 背景属性连写1background: color imge repeat position attachment 特点：没有顺序要求]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式表、CSS选择器]]></title>
    <url>%2F2015%2F05%2F26%2FCSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E3%80%81CSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[样式表的书写位置写在 &lt;head&gt;&lt;/head&gt; 中, 样式：选择器{属性:值;属性:值; }1234567&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;样式表写法&lt;/title&gt; &lt;style type="texr/css"&gt; 样式表内容 &lt;/style&gt;&lt;/head&gt; 样式表的常见属性 width 宽度 width:200px; height 高度 height:200px; background-color 背景色 background-color:red; font-size 文字大小 font-size:20px; color 文本颜色(前景色) color:yellow; text-align 内容的水平对齐方式 text-align:left|center|right text-indent 首行缩进 text-indent:2em;（2个汉字的大小） 常见属性表格 属性 值 说明 width 20px 宽 height 300px 高 background-color red 背景色 text-align left/center/right 内容水平对齐方式 text-indent 2em/px/% 首行缩进 font-size normal/bold 文本大小 font-weight 100-900/bold 文本粗细 font-style normal/italic 文本风格 font-family 宋体 字体 line-height 1.5/2em/px/% 行高 行高行高 浏览器默认文字大小 div 1350px*18px 行高=文本+上边距+下边距 默认文字大小是16px 默认行高大小是18px一行文字，行高与父元素高度一致时，文本垂直居中对齐。 行高的单位12345行高值 文字大小 行高大小40px 20px 40px2em 20px 40px150% 20px 30px3 20px 60px 总结： 当给父元素设置行高的时候，除了以px为单位以外，其他的值都与文字大小有关，是与文字大小的乘积, 行高是可以继承。 12345父元素行高 父元素文字大小 子元素文字大小 子元素行高40px 20px 30px 40px2em 20px 30px 40px150% 20px 30px 30px3 20px 30px 90px 文本基线 基础选择器标签选择器 写法：标签{属性值;} 特点：标签选择器定义之后，会将页面所有的元素都执行这个样式颜色的显示方式： 直接写颜色名称： 如： “red”； 16进制显示 由0-9和a-ff一共16个值组成；#ff0000; #ff0000,前边2个数值对应的是红色, #00ff00,中间2个对应的是绿色, #0000ff,后边2个对应的是蓝色。 RGB表示颜色 如：span{color: rgb(23,23,23); } r代表红色，g绿色 b蓝色 rgba 表示不透明度 如：h1{width: 500px; height: 400px; color: rgba(121,232,108,0.5); } a代标alpha 0-1; 类选择器 写法：自定义类名{属性:值;} 特点：类选择器需要调用才能生效，谁调用谁生效1.box&#123;width: 200px; height: 40px; color: yellow; background-color: rgb(24,124,101); text-align: center; font-size: 24px; &#125; 多标签可以调用同一个类选择器1&lt;div class="box baby"&gt;加油努力奋斗&lt;/div&gt; 类选择器的命名规则 不能使用纯数字和纯数字开头来定义类名 不建议使用中文 不能使用特殊符号来定义类名（“_”除外） 不建议使用标签名和属性名来定义类名 id选择器 写法： #名称{属性:值} 1#box&#123;width: 300px; height: 200px; background-color: pink; font-size: 20px; &#125; 特点: id选择器需要调用才能生效，谁调用谁生效 一个标签不能调用多个ID选择器 一个id选择器在一个页面内只能调用一次，多次调用不符合w3c规范，配合js使用，若出现多次js调用则会出错 通配符选择器 写法：*{属性:值;} 特点： 浏览器累死了，消耗服务器资源，不推荐使用； 会将所有的标签都执行这个通配符选择器 文本介绍文本属性 文本属性 font-size 文字大小 font-weight 文字的粗细 值从100-900; 700的值和bold大约一样(用700,不用bold) font-style 文本风格： nomarl |italic font-family 字体：宋体，微软雅黑，楷体 line-height 行高 文本属性连写顺序：font: font-style font-weight font-size/line-height font-family 注：按照顺序写，文字大小和字体在文字连写的时候为必须写的属性 字体的表达方式 直接写中文字体（宋体|微软雅黑） 直接写字体的英文名字（simsun|microsoft yahei|） Unicode编码方式 在浏览器中查找Unicode编码 chrome–&gt;f12–&gt;console–&gt;escape(“宋体”)–&gt;enter 复合选择器两个或两个以上的选择器通过不同的方式连接到一起 交集选择器 写法 标签+类(id){属性:值} 特点：既…又的关系 后代选择器 写法： 选择器+空格+选择器+空格+选择器{属性:值;} 注意：后代选择器首先要满足包含（嵌套关系）。 特点： 可以无限制隔代。 只要能代表父子关系，标签选择器、类选择器、id选择器可以任意组合 父级元素在前面，子级元素在后面 子代选择器 写法：选择器&gt;选择器{属性:值;} 特点：选中的是直接下一级 12345678910111213&lt;style type="text/css"&gt; div&gt;span&#123; color: red; font-size: 36px;&#125;&lt;/style&gt;&lt;div&gt; &lt;p&gt; &lt;span&gt; 愿使岁月静好，现世安稳。 &lt;/span&gt; &lt;/p&gt; &lt;span&gt;天才在左疯子在右&lt;/span&gt;&lt;/div&gt; 并集选择器将不同选择器之间相同的样式写在一起，选择器之间通过逗号链接在一起。 可能是包含关系，也可能是并列关系。 如果标签样式相同或者部分相同，可以用并集选择器，通过逗号连接在一起 选择器+,+选择器{属性:值;} 特点：并集选择器不一定是并列关系 标签选择器、类选择器、id选择器、复合选择器，可以通过逗号任意组合连接在一起 123456.one,.one .two, .three, p&#123;font-size: 50px; font-weight: normal; &#125;&lt;div class="one"&gt;&lt;h1 class="two"&gt;明媚的心&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;天才，和蠢材的差别是勤奋&lt;/p&gt;&lt;div class="three"&gt;美丽的人生要靠努力&lt;/div&gt;]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表格、表单、标签语义化]]></title>
    <url>%2F2015%2F05%2F22%2FHTML%E8%A1%A8%E6%A0%BC%E3%80%81%E8%A1%A8%E5%8D%95%E3%80%81%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTML5标签结构sublime 快捷键 !+Tab 可以写成HTML5结构 字符编码 ASCLL ansi unicode GBK GB2312(中文简体) BIG5(只支持繁体字) UTF-8(国际通用编码) meta标签12345678910标签说明 &lt;!--编码--&gt; &lt;meta charset="utf-8"&gt; &lt;!--关键字--&gt; &lt;meta name="keywords" content="java培训, ios"&gt; &lt;!--name 页面里面的关键词 content 里面是给SEO用的--&gt; &lt;!--网页描述--&gt; &lt;meta name="description" content="给搜索引擎看的，可以看得到的内容"&gt; &lt;!--网页重定向--&gt; &lt;meta http-equiv="refresh" content="5;http:www.itcast.com"&gt; link标签调用外部样式表：11 &lt;link rel="stylesheet" href="1.css"&gt; ico小图标，在网页显示时的标题的前面：(必用)11 &lt;link rel="icon" href="../favicom.ico"&gt; 简单表格用来存放数据的，表格是对网页重构（css+div）一个有有益补充 行 tr 列 td 简单结构（1行2列）123456&lt;table border="1" width="300" height="100" cellspacing="0" cellpadding="10"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格属性介绍 边框 border=”1” 宽度 width=”300” 高度 height=”100” 单元格与单元格的距离 cellspacing=”2”，默认值2 内容到边框的距离cellpadding=”2” 默认值0 背景色 bgcolor=”yellow” 对齐方式 align left|center|right 如果align放到tr或者td里面是内容的对齐方式 如果align放到table里面，是表格的对齐方式 表格标题 用法和td一样 1234567891011&lt;table border="1" width="300" height="100" cellspacing="0" cellpadding="10"&gt; &lt;caption&gt;表头&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; 表格的标题 &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格的标准结构1234567891011121314151617&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;/tfoot&gt;&lt;/table&gt; 表格单元格的合并 在同一行上合并 colspan=”2” 在同一列上合并 表单用来收集信息 提示信息 表单控件 action：用来处理信息（信息提交给谁，把文件提交给那个文件处理） method：get|post 传递信息的方法 get 安全性很低，通过浏览器的地址栏传递信息，post 安全性高，通过action文件处理，它们的区别如下 1.GET没有请求主体，使用xhr.send(null)2.GET可以通过在请求URL上添加请求参数3.POST可以通过xhr.send(‘name=itcast&amp;age=10’)4.POST需要设置5.GET效率更好（应用多）6.GET大小限制约4K，POST则没有限制 表单控件1 &lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 单行文本输入框1 &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;Hiraku&quot; maxlength=&quot;16&quot; readonly=&quot;readonly&quot; &gt; name 文本输入框的名字 value 接收的默认值 文本框的值 maxlength 输入的最大字符长度 readonly 输入框为只读状态 disabled 输入框为未激活状态 密码输入框1 &lt;input type=&quot;password&quot; name=&quot;密码输入框&quot;&gt; 单行文本输入框的属性对密码输入框都适用 单选框1 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked=&quot;checked&quot;&gt;男 2 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 当将单选框name值设置相同的时候才能实现单选效果, checked 设置默认选中项。 下拉列表下拉列表12345678910111213&lt;select&gt; &lt;option selected=”selected”&gt;下拉列表选项&lt;/option&gt; &lt;!--设置默认选项--&gt;&lt;/select&gt;&lt;!-- multiple="mutiple" 下拉列表多选 设置下拉列表为多选项 --&gt;&lt;optgroup label="甘肃省"&gt; 对下拉列表进行分组 &lt;option value=""&gt;定西市&lt;/option&gt; &lt;option value=""&gt;兰州市&lt;/option&gt; &lt;option value=""&gt;庆阳市&lt;/option&gt; &lt;option value=""&gt;天水市&lt;/option&gt; &lt;option value=""&gt;嘉峪关&lt;/option&gt; &lt;option value=""&gt;酒泉市&lt;/option&gt;&lt;/optgroup&gt; 多选框1234&lt;input type="checkbox" checked="checked"&gt;动漫&lt;input type="checkbox"&gt;电影&lt;input type="checkbox"&gt;电子竞技&lt;input type="checkbox"&gt;音乐 checked 默认选项 多文本输入框1 &lt;textarea name=&quot;输入框&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; cols 输入字符的长度 rows 输入字符的行数 上传文件控件1 &lt;input type=&quot;file&quot;&gt; 提交按钮1 &lt;input type=&quot;submit&quot;&gt; 普通按钮1 &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; 普通按钮不能实现表单信息提交，常配合js使用 图片按钮1 &lt;input type=&quot;image&quot; src=&quot;&quot;&gt; 表单信息分组1 &lt;form&gt; 2 &lt;fieldset&gt; 3 &lt;legend&gt;注册信息&lt;/legend&gt; 4 &lt;input&gt; 5 &lt;/fieldset&gt; 6 &lt;/form&gt; 重置按钮1 &lt;input type=”reset” value=”重置信息”&gt; HTML5表单控件1 &lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt; 2 &lt;!-- 判断网址 --&gt; 3 &lt;input type=&quot;url&quot;&gt;&lt;br/&gt;&lt;br/&gt; 4 &lt;!-- 判断邮箱 --&gt; 5 &lt;input type=&quot;email&quot;&gt;&lt;br/&gt;&lt;br/&gt; 6 &lt;!-- 日期控件 --&gt; 7 &lt;input type=&quot;date&quot;&gt;&lt;br/&gt;&lt;br/&gt; 8 &lt;!-- 时间控件 --&gt; 9 &lt;input type=&quot;time&quot;&gt;&lt;br/&gt;&lt;br/&gt; 10 &lt;!-- 数字控件 --&gt; 11 &lt;input type=&quot;number&quot;&gt;&lt;br/&gt;&lt;br/&gt; 12 &lt;!-- 滑块控件 --&gt; 13 &lt;input type=&quot;range&quot; max=&quot;150&quot; min=&quot;2&quot; step=&quot;5&quot;&gt;&lt;br/&gt;&lt;br/&gt; 14 &lt;input type=&quot;submit&quot;&gt; 15 &lt;/form&gt; 标签语义化标签语义化即：根据内容的结构化（内容语义化），选择合适的标签 注意事项： 尽可能少的使用无语义的标签div和span 在语义不明显是尽量用p,即可使用div也可使用p 不要使用纯样式标签: 需要强调的文本尽量用和 好的标签语义化网站：去掉CSS，结构依然很清晰]]></content>
      <categories>
        <category>HTML系列</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识HTML]]></title>
    <url>%2F2015%2F05%2F20%2F%E5%88%9D%E8%AF%86HTML%2F</url>
    <content type="text"><![CDATA[HTML基础 Hyper text markup language 超文本标记语言 超文本：网页中可以包含图片、文字、视频、音频、文本框等元素; 标记（标签）：在网页中给网页元素做标记（右键，查看网页源代码） 超链接：实现页面之间的跳转 Sublime常用快捷键 windows+D 返回桌面 windows+R 运行dos windows+E 打开我的电脑 Alt+Tab 切换软件 Ctrl+Tab 软件内部文档间切换 F2 重命名 Web标准 结构标准：HTML HyperText Mark Language 超文本标记语言 表现标准：CSS Casading Style Sheets 层次样式表 行为标准：javaScript ECMAScript javaScript标准 DOM Document Object Model 文档对象模型 BOM Browser Object Model 浏览器对象模型 浏览器简介浏览器涉及技术：浏览器内核，渲染引擎 SEO,Search Engine Optimization(搜索引擎优化)。 浏览器内核：分为两部分：渲染引擎和JS引擎，决定了浏览器如何显示网页的内容、页面格式等 ie trident firefox gecko chrome/safari webkit chrome blink opera persto 浏览器和服务器的那点事 http协议：超文本传输协议、浏览器和服务器之间的对话（通信的协议）。 https：加密的过程 url协议：规定url地址的格式 协议规定格式：scheme:定义因特网服务类型 host：定义域主机 端口：网页默认80端口 path：路径 filename： 文件名 HTML结构1234567891011121314151617&lt;! Doctype html&gt; &lt;!--声明文档类型--&gt;&lt;html&gt; &lt;!--根标签--&gt;&lt;head&gt; &lt;!--头部标签--&gt;&lt;title&gt;标题&lt;/title&gt; &lt;!--网页标题标签--&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;网页主体&lt;/div&gt; &lt;!--网页主体标签--&gt;&lt;/body&gt;&lt;/html&gt;解析： &lt;! Doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 注：文档的后缀名只能决定打开方式，不能修改文档类型 HTML标签的分类 单标签 &lt;! Doctype html&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; 双标签 &lt;html&gt;&lt;/html&gt; &lt;head&gt;&lt;/head&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt;&lt;/body&gt; … HTML关系 并列关系（同级） &lt;head&gt;&lt;/head&gt; 和 &lt;body&gt;&lt;/body&gt; 包含关系（嵌套） &lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt; 开发工具 DreamWeaver：很老的一个软件 偏设计师使用 Sublime:轻量级的软件，有很多好用的插件 WebStorm:重量级软件，功能强大 Sublime 常用的快捷键 html:xt + tab html结构 html:5 + tab html结构 Ctrl+shift+D 快速复制 Ctrl+shift+K 快速删除一行 Ctrl+shift+↑/↓ 快速上下移动一行 Tab 补全标签 Ctrl+鼠标左键 选中多行 Ctrl+L 选中一行 Ctrl+H 替换别的标签 Alt+shift+2 查看布局 Alt+V 显示/隐藏菜单栏 ctrl+shift+p + move指令 移动文件 HTML标签单标签1231 &lt;!--注释: 快捷键Ctrl+/--&gt; 2 &lt;br/&gt; 换行3 &lt;hr/&gt; 水平线 双标签 段落标签：&lt;p&gt;&lt;/p&gt; 文本标签：&lt;font&gt;&lt;/font&gt; 标题标签：12341 &lt;h1&gt;&lt;/h1&gt;2 &lt;!--h1只能出现一次，出现多了不利于搜索引擎--&gt;3 &lt;h2&gt;&lt;/h2&gt;4 &lt;h6&gt;&lt;/h6&gt; 标题系列取值只能取到h6 文本格式化标签 加粗 , 常用strong 倾斜 , 常用em 删除线标签 , 常用del 插入文本： , 常用ins 上下标标签：, 注意：使用strong em del ins 更有意义 图片标签&lt;img src=&quot;Legolas.jpg&quot; alt=&quot;我的男神&quot; title=&quot;legolas&quot; width=&quot;500&quot; /&gt; 仅指定宽或高时，等比例缩放。 src 图片来源（路径）, alt 替换文本. title 提示文本（鼠标放到图片上显示的文字; width 图片显示的宽度 height 图片显示的高度 相对路径和绝对路径（相对路径的可移植性好） 相对路径： 文档（html/图片）在同一个文件夹，直接写图片（文档）名字 &lt;img src=&quot;Legolas.jpg&quot; alt=&quot;legolas&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在上级文件中 &lt;img src=&quot;../1.jpg&quot; alt=&quot;legolas&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在上两级文件中 &lt;img src=&quot;../../Hydrangeas.jpg&quot; alt=&quot;菊花&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在下级文件中 &lt;img src=&quot;pic/Koala.jpg&quot; alt=&quot;考拉&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在下两级文件中 &lt;img src=&quot;pic/photo/Penguins.jpg&quot; alt=&quot;企鹅&quot; height=&quot;300&quot; /&gt; 绝对路径： 本地电脑绝对路径 &lt;img src=&quot;F:\pic\photo&quot; alt=&quot;企鹅&quot; /&gt; 互联网上的绝对路径： 网页中的图片来自服务器端传输过来的。 超链接标签超链接：&lt;a href=&quot;06_test&quot; target=&quot;_blank&quot; title=&quot;气温高&quot;&gt;气温案例&lt;/a&gt; href 去往的路径（连接的文档），必写属性。 target=” _self” 关闭自身串口，打开新窗口 target=”_blank” 自身窗口不关闭，打开新窗口 title 提示文本，是非必须的 ctrl+shift+s: 另存为 把文件复制并另存为 超链接优化： &lt;base target=”_blank”&gt; 锚点： 第一步：给标签加id 第二部：herf写上#+id名 &lt;a href=&quot;#xd&quot;&gt;回到顶部&lt;/a&gt; 压缩包：&lt;a href=&quot;压缩包.rar&quot;&gt;压缩文件下载&lt;/a&gt; 空连接：&lt;a href=&quot;#&quot;&gt;此处有连接&lt;/a&gt; 特殊字符：段落标签的写法列表标签 无序列表 square 实心方块 dick 默认实心小圆圈 circle 空心小圆圈 注意：ul标签里面只能放li标签，li里面可以放任何标签 有序列表 12345671 &lt;ol&gt;2 &lt;li&gt;打开冰箱门&lt;/li&gt;3 &lt;li&gt;把大象装在冰箱里&lt;/li&gt;4 &lt;li&gt;关上冰箱门&lt;/li&gt;5 &lt;/ol&gt;6 &lt;ol type="A"&gt;&lt;/ol&gt;7 &lt;ol type="1" start="4"&gt;&lt;/ol&gt; type 的取值可以是1，a，A，i，I start 是开始的序号 自定义列表 12341 &lt;dl&gt;2 &lt;dt&gt;北京&lt;/dt&gt; &lt;!--小标题--&gt;3 &lt;dd&gt;昌平区&lt;/dd&gt; &lt;!—标题的解释--&gt;4 &lt;/dl&gt; 其他标签 音乐标签 embed 背景音乐 &lt;embed src=&quot;BIGBANG - BAD BOY (Live).mp3&quot; hidden=&quot;false&quot; /&gt; hidden = “ture” 影藏，默认是false，播放器 滚动标签 &lt;marquee behavior=&quot;scroll&quot; direction=&quot;right&quot; width=&quot;500px&quot; height=&quot;100px&quot; bgcolor=&quot;blue&quot;&gt;我来也&lt;/marquee&gt;]]></content>
      <categories>
        <category>HTML系列</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
