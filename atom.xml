<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Honey Young</title>
  
  <subtitle>小杨鹤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-01T07:20:46.208Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>honey young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人技能</title>
    <link href="http://yoursite.com/2018/05/23/%E4%B8%AA%E4%BA%BA%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/05/23/个人标签/</id>
    <published>2018-05-23T07:23:29.000Z</published>
    <updated>2018-06-01T07:20:46.208Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="个人技能" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
      <category term="AngularJS" scheme="http://yoursite.com/tags/AngularJS/"/>
    
      <category term="BOM" scheme="http://yoursite.com/tags/BOM/"/>
    
      <category term="Bower" scheme="http://yoursite.com/tags/Bower/"/>
    
      <category term="Cookie" scheme="http://yoursite.com/tags/Cookie/"/>
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
      <category term="EJS" scheme="http://yoursite.com/tags/EJS/"/>
    
      <category term="Express" scheme="http://yoursite.com/tags/Express/"/>
    
      <category term="Gulp" scheme="http://yoursite.com/tags/Gulp/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="RequireJS" scheme="http://yoursite.com/tags/RequireJS/"/>
    
      <category term="SeaJs" scheme="http://yoursite.com/tags/SeaJs/"/>
    
      <category term="Session" scheme="http://yoursite.com/tags/Session/"/>
    
      <category term="Underscore" scheme="http://yoursite.com/tags/Underscore/"/>
    
      <category term="browser" scheme="http://yoursite.com/tags/browser/"/>
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
      <category term="cordova" scheme="http://yoursite.com/tags/cordova/"/>
    
      <category term="eCharts" scheme="http://yoursite.com/tags/eCharts/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="ionic" scheme="http://yoursite.com/tags/ionic/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="Grunt" scheme="http://yoursite.com/tags/Grunt/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="mine" scheme="http://yoursite.com/tags/mine/"/>
    
      <category term="net" scheme="http://yoursite.com/tags/net/"/>
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="nrm" scheme="http://yoursite.com/tags/nrm/"/>
    
      <category term="nvm" scheme="http://yoursite.com/tags/nvm/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="artTemplate" scheme="http://yoursite.com/tags/artTemplate/"/>
    
      <category term="ps" scheme="http://yoursite.com/tags/ps/"/>
    
      <category term="sublime" scheme="http://yoursite.com/tags/sublime/"/>
    
      <category term="webstorm" scheme="http://yoursite.com/tags/webstorm/"/>
    
      <category term="vs code" scheme="http://yoursite.com/tags/vs-code/"/>
    
      <category term="svn" scheme="http://yoursite.com/tags/svn/"/>
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
      <category term="命令行" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="小项目" scheme="http://yoursite.com/tags/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="库" scheme="http://yoursite.com/tags/%E5%BA%93/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
      <category term="表单" scheme="http://yoursite.com/tags/%E8%A1%A8%E5%8D%95/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="交互" scheme="http://yoursite.com/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="http://yoursite.com/2015/12/28/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2015/12/28/Hexo博客搭建/</id>
    <published>2015-12-27T16:00:00.000Z</published>
    <updated>2018-06-01T08:05:11.809Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo+github可以随心所欲的部署属于自己的博客。</p><h2 id="Hexo-博客搭建步骤"><a href="#Hexo-博客搭建步骤" class="headerlink" title="Hexo 博客搭建步骤"></a>Hexo 博客搭建步骤</h2><h2 id="搭建博客，首先需要安装-node-环境；"><a href="#搭建博客，首先需要安装-node-环境；" class="headerlink" title="搭建博客，首先需要安装 node 环境；"></a>搭建博客，首先需要安装 node 环境；</h2><ul><li>测试安装成功与否：打开终端，输入 node -v, 有输出版本结果则安装成功。</li><li>安装node环境的时候，已经自动安装了 npm 命令行工具，不需要单独安装。</li><li>可以通过 npm -v 测试npm是否可用</li></ul><p>npm 是一个用来安装和管理 Node 包和前端包的一个工具。</p><h3 id="npm-的两层含义"><a href="#npm-的两层含义" class="headerlink" title="npm 的两层含义"></a>npm 的两层含义</h3><ul><li>npm网站：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a><ul><li>一个提供了一个用来共享或者检索的一个平台</li><li>二是托管 node 环境或者浏览器环境用到的一些第三方包</li></ul></li><li>是一个命令行工具，可以用来下载 npm 网站上托管的包<ul><li>CLI：Command Line Interface 命令行接口</li><li>GUI：图形化接口</li></ul></li></ul><h3 id="npm-基本使用"><a href="#npm-基本使用" class="headerlink" title="npm 基本使用"></a>npm 基本使用</h3><a id="more"></a><h4 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install [--save] 包名</span><br></pre></td></tr></table></figure><p>一般是在项目中，安装项目使用的依赖包,就可以在终端中，切换到项目的根目录，然后执行 <code>npm install 包名</code>，npm 工具会自动将这个包下载下来然后放到 node_modules 目录中。<code>node_modules</code> 目录如果不存在会新建，如果已存在，则直接将下载的包放到该目录中。</p><h4 id="包说明文件：package-json"><a href="#包说明文件：package-json" class="headerlink" title="包说明文件：package.json"></a>包说明文件：package.json</h4><p>包说明文件其实就是一个产品的说明书：<code>package.json</code> 文件。该文件一般只存在于项目的根路径下，可以通过 <code>npm init</code> 命令使用向导的形式创建该文件。</p><p>该文件中描述了项目的一些元数据，例如 <code>name、version、author</code>等信息。</p><p>其中有一个非常重要的属性，叫做：<code>dependencies</code>，该属性是一个对象，里面保存了当前项目的依赖项，该字段一般不要手动修改，它需要结合 <code>npm install --save 包名</code> 来使用，只要在安装的时候加上<code>--save</code> 参数就会自动将包依赖项添加到该属性中，很方便。</p><p>甚至还可以完全把 <code>node_modules</code> 目录删除掉，只要 <code>package.json</code>文件还在，就可以执行 <code>npm install</code> 安装包说明文件中的所有的依赖项。执行 <code>npm install</code> 命令的时候，它会自动查询当前目录下的 <code>package.json</code> 文件，然后找到里面的 <code>dependencies</code> 属性，依次下载到 <code>node_modules</code> 目录下。</p><p>建议使用 npm 的时候，都先初始化一个 <code>package.json</code> 文件，然后安装包的时候最好都加上 <code>--save</code> 参数，将依赖项添加到包说明文件中。</p><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><p>全局安装：一般用于安装一些命令行工具（这些工具也是基于Node开发的。）</p><p>全局安装使用 <code>npm install --global 包名（工具名）</code>，在任意目录执行该命令都可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo-cli</span><br></pre></td></tr></table></figure><p>可以通过 <code>npm root -g</code> 查看全局包安装目录。</p><h2 id="安装-git-环境；"><a href="#安装-git-环境；" class="headerlink" title="安装 git 环境；"></a>安装 <code>git</code> 环境；</h2><p><a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载地址：</a></p><h3 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><h2 id="全局安装-hexo-cli"><a href="#全局安装-hexo-cli" class="headerlink" title="全局安装 hexo-cli"></a>全局安装 <code>hexo-cli</code></h2><p>在终端的任意目录输入 <code>npm install -g hexo-cli</code> 然后回车执行等待全局安装成功</p><p>通过输入 <code>hexo --version</code> 如果看到输入一大堆的版本号就说明安装成功了，Hexo 是一个命令行应用程序</p><h2 id="初始化一个博客存储目录"><a href="#初始化一个博客存储目录" class="headerlink" title="初始化一个博客存储目录"></a>初始化一个博客存储目录</h2><p>通过输入 <code>hexp init 博客项目存储目录</code></p><p>Hexo 会在执行该命令的目录下生成一个博客项目，初始化博客项目的过程需要联网</p><p>通过终端进入刚才创建的博客项目目录，然后在该目录下输入 <code>npm install</code> 回车等待执行结束</p><h2 id="启动本地服务器，查看博客内容"><a href="#启动本地服务器，查看博客内容" class="headerlink" title="启动本地服务器，查看博客内容"></a>启动本地服务器，查看博客内容</h2><p>输入 <code>hexo server</code>回车执行，这一执行会在本地启动一个服务器，然后通过 <code>http://localhost:4000</code> / <code>localhost:4000</code> 就可以访问创建的博客项目 (如果此时4000端口号被占用，也可以通过 hexo server -p 5000 切换到端口号为5000，随即访问<code>http://localhost:5000</code> / <code>localhost:5000</code>访问创建的博客项目)</p><h2 id="创建博文"><a href="#创建博文" class="headerlink" title="创建博文"></a>创建博文</h2><p>进入博客项目，输入 <code>hexo new 文章名称</code> 创建博文</p><p>这个命令会自动在 source/_posts/ 目录下生成一个 文章名称.md 文件</p><h2 id="生成静态文件：hexo-generate"><a href="#生成静态文件：hexo-generate" class="headerlink" title="生成静态文件：hexo generate"></a>生成静态文件：<code>hexo generate</code></h2><p>该命令会自动在项目的根目录下的 public 目录下降静态文件放进去</p><h2 id="配置主题页"><a href="#配置主题页" class="headerlink" title="配置主题页"></a>配置主题页</h2><p>根据我个人所选的主题介绍。进入博客根目录，打开_config开始配置，注意：在配置主题页的时候需要图片的url，需要在<a href="https://portal.qiniu.com/" target="_blank" rel="noopener">七头云CDN</a>注册；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: HongqinMa  # 配置博客标题</span><br><span class="line">subtitle: <span class="string">"博客标签"</span></span><br><span class="line">description: <span class="string">"马红琴在 Github 上的个人博客"</span></span><br><span class="line">author: Hongqin Ma</span><br><span class="line">header-img: <span class="comment">//ofy7k3v4s.bkt.clouddn.com/mbanner.png  #</span></span><br><span class="line">email: hongqin_ma@126.com  # 邮箱地址</span><br><span class="line">keyword: Hiraku, HongqinMa, javascript, html, css, nodejs  #SEO搜索引擎查找关键词</span><br><span class="line">favicon: <span class="comment">//ofy7k3v4s.bkt.clouddn.com/mylogo.png  # 博客网站图标</span></span><br><span class="line"># RSS:</span><br><span class="line">weibo_username: Hiraku_Ma #微博账户名</span><br><span class="line">zhihu_username: HirakuMa #知乎账户名</span><br><span class="line">github_username: HongqinMa #github账户名</span><br><span class="line">twitter_username: HongqinMa #Twitter账户名</span><br><span class="line">facebook_username: Hiraku #Facebook账户名</span><br><span class="line">sidebar-about-description: 拼着一切代价，奔你的前程。 # 侧边栏签名</span><br><span class="line">sidebar-avatar: http:<span class="comment">//ofy7k3v4s.bkt.clouddn.com/photo.jpg # 侧边栏头像</span></span><br><span class="line">cdn-url: "https://ofy7k3v4s.bkt.clouddn.com/" # 我写的是七头云的域名地址</span><br><span class="line">theme: hexo-theme-Anisina  # 主题名称</span><br><span class="line">friends: [</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">"掘金"</span>,</span><br><span class="line">    href: <span class="string">"http://gold.xitu.io/"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">"segmentfault"</span>,</span><br><span class="line">    href: <span class="string">"https://segmentfault.com/"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">"简书"</span>,</span><br><span class="line">    href: <span class="string">"http://www.jianshu.com/users/1cbb94e5ed4d/latest_articles"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">"七牛云"</span>,</span><br><span class="line">    href: <span class="string">"https://portal.qiniu.com/"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">"博客园"</span>,</span><br><span class="line">    href: <span class="string">"https://home.cnblogs.com/"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">"Awesomes"</span>,</span><br><span class="line">    href: <span class="string">"https://www.awesomes.cn/"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">duoshuo_username: Hiraku #这里需要注册多说或者主题作者：haojen Ma 文档中的另外一种，作用都一样 ，用来评论的；</span><br><span class="line">deploy: </span><br><span class="line">  type: git # 快速部署</span><br><span class="line">  repo: https:<span class="comment">//github用户名:github密码@github.com/HongqinMa/HongqinMa.github.io.git</span></span><br></pre></td></tr></table></figure><h3 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h3><ol><li>修改配置文件</li><li>在项目根路径下执行 <code>npm install hexo-deployer-git --save</code> 该命令</li><li>接下来就可以直接输入 <code>hexo deploy --generate</code>/简写 <code>hexo d -g</code> 自动发布到 github 上</li></ol><h2 id="更详细介绍如下："><a href="#更详细介绍如下：" class="headerlink" title="更详细介绍如下："></a>更详细介绍如下：</h2><p>如何配置主题（以Next主题为例进行详细说明）</p><p><a href="https://www.jianshu.com/p/3ff20be8574c" target="_blank" rel="noopener">Hexo-Next-主题优化(一)</a><br><a href="https://www.jianshu.com/p/428244cd2caa" target="_blank" rel="noopener">Hexo-Next-主题优化(二)</a><br><a href="https://www.jianshu.com/p/d23d67d318c7" target="_blank" rel="noopener">Hexo-Next-主题优化(三)</a><br><a href="https://www.jianshu.com/p/4ef35521fee9" target="_blank" rel="noopener">Hexo-Next-主题优化(四)</a></p><p>OK，现在可以直接通过<a href="https://honeyyoung.github.io/" target="_blank" rel="noopener">honeyyoung.github.io</a>访问博客了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo+github可以随心所欲的部署属于自己的博客。&lt;/p&gt;
&lt;h2 id=&quot;Hexo-博客搭建步骤&quot;&gt;&lt;a href=&quot;#Hexo-博客搭建步骤&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客搭建步骤&quot;&gt;&lt;/a&gt;Hexo 博客搭建步骤&lt;/h2&gt;&lt;h2 id=&quot;搭建博客，首先需要安装-node-环境；&quot;&gt;&lt;a href=&quot;#搭建博客，首先需要安装-node-环境；&quot; class=&quot;headerlink&quot; title=&quot;搭建博客，首先需要安装 node 环境；&quot;&gt;&lt;/a&gt;搭建博客，首先需要安装 node 环境；&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;测试安装成功与否：打开终端，输入 node -v, 有输出版本结果则安装成功。&lt;/li&gt;
&lt;li&gt;安装node环境的时候，已经自动安装了 npm 命令行工具，不需要单独安装。&lt;/li&gt;
&lt;li&gt;可以通过 npm -v 测试npm是否可用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;npm 是一个用来安装和管理 Node 包和前端包的一个工具。&lt;/p&gt;
&lt;h3 id=&quot;npm-的两层含义&quot;&gt;&lt;a href=&quot;#npm-的两层含义&quot; class=&quot;headerlink&quot; title=&quot;npm 的两层含义&quot;&gt;&lt;/a&gt;npm 的两层含义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;npm网站：&lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.npmjs.com/&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;一个提供了一个用来共享或者检索的一个平台&lt;/li&gt;
&lt;li&gt;二是托管 node 环境或者浏览器环境用到的一些第三方包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是一个命令行工具，可以用来下载 npm 网站上托管的包&lt;ul&gt;
&lt;li&gt;CLI：Command Line Interface 命令行接口&lt;/li&gt;
&lt;li&gt;GUI：图形化接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;npm-基本使用&quot;&gt;&lt;a href=&quot;#npm-基本使用&quot; class=&quot;headerlink&quot; title=&quot;npm 基本使用&quot;&gt;&lt;/a&gt;npm 基本使用&lt;/h3&gt;
    
    </summary>
    
      <category term="Hexo系列" scheme="http://yoursite.com/categories/Hexo%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="http://yoursite.com/2015/12/16/Ajax/"/>
    <id>http://yoursite.com/2015/12/16/Ajax/</id>
    <published>2015-12-15T16:00:00.000Z</published>
    <updated>2018-06-01T07:13:48.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器、网络基础、相关知识介绍"><a href="#服务器、网络基础、相关知识介绍" class="headerlink" title="服务器、网络基础、相关知识介绍"></a>服务器、网络基础、相关知识介绍</h2><h3 id="服务器介绍："><a href="#服务器介绍：" class="headerlink" title="服务器介绍："></a>服务器介绍：</h3><h4 id="常见的服务器软件有："><a href="#常见的服务器软件有：" class="headerlink" title="常见的服务器软件有："></a>常见的服务器软件有：</h4><ul><li>文件服务器：Server-U、FileZilla、VsFTP等（FTP是File Transfer Protocol文件传输协议）；</li><li>数据库服务器：oracle、mysql、SQL server、DB2、ACCESS等；</li><li>邮件服务器：Postfix、Sendmail等；</li><li><strong>HTTP服务器</strong>：Apache、Nginx、IIS、Tomcat、NodeJS等；</li></ul><blockquote><p>按照不同的划分标准，服务可划分为以下类型：</p></blockquote><a id="more"></a><p>(1) 服务器类型</p><ul><li>按 服务类型 可分为：<ul><li>文件服务器</li><li>数据库服务器</li><li>邮件服务器</li><li>Web服务器等；</li></ul></li><li>按 操作系统 可分为：<ul><li>Linux服务器</li><li>Windows服务器等；</li></ul></li><li>按 应用软件 可分为<ul><li>Apache 服务器</li><li>Nginx 服务器</li><li>IIS 服务器</li><li>Tomcat 服务器</li><li>weblogic 服务器</li><li>WebSphere 服务器</li><li>boss 服务器</li><li>Node 服务器等</li></ul></li></ul><p>(2) HTTP服务器</p><ul><li>即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。</li><li>HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为<strong>服务端开发</strong>。</li><li>常见的运行在服务端的编程语言包括 php、java、.net、Python、Ruby、Perl等。</li></ul><p>(3) 客户端介绍：</p><ul><li>具有向服务器<strong>索取服务</strong>能力的终端，如比如 手机、电脑等，通过安装不同的客户端软件，可以获取不同的服务，比如通过QQ获得即时通讯服务、通过迅雷获得下载服务等。</li><li>常见的客户端软件：浏览器、QQ、迅雷、Foxmail等。</li><li>以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为<strong>前端开发</strong>。</li></ul><h2 id="网络基础："><a href="#网络基础：" class="headerlink" title="网络基础："></a>网络基础：</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每部手机能正常通话需要一个号码一样)</li><li>查看本机IP地址 ping、ipconfig、ifconfig（linux）</li></ul><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ul><li>由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具”</li><li>查看域名对应的IP地址 ping</li></ul><h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><ul><li>DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</li><li>简单的说就是记录IP地址和域名之间对应关系的服务。</li><li>查找优先级 本机 hosts 文件、DNS服务器</li><li>ipconfig /flushdns 刷新DNS</li></ul><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><ul><li>端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。现实生活中，银行不同的窗口办理不同的业务。</li><li>查看端口占用情况 <code>netstat -an</code></li><li>常见端口号 80、8080、3306、21、22</li></ul><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><h3 id="C-S结构"><a href="#C-S结构" class="headerlink" title="C/S结构"></a>C/S结构</h3><blockquote><p>即Client、Server</p></blockquote><ul><li>在C/S结构的情况下，不同的服务需要安装不同的客户端软件，</li><li>比如QQ、迅雷、Foxmail 这种情况下安装的软件会越来越多，同时也有许多弊端，比如A出差，需要在B电脑上查收邮件，但是B电脑并未安装Foxmail等类似的客户端软件，这样不得不先去下载Foxmail，非常不方便。</li></ul><h3 id="B-S结构"><a href="#B-S结构" class="headerlink" title="B/S结构"></a>B/S结构</h3><blockquote><p>即Broswer、Server</p></blockquote><ul><li>解决了C/S所带来的不便</li><li>将所有的服务都可以通过浏览器来完成（因为基本所有浏览器都安装了浏览器），但B/S也有一些不利，比如操作稳定性、流畅度等方面相对较弱。</li></ul><h2 id="网络传输协议"><a href="#网络传输协议" class="headerlink" title="网络传输协议"></a>网络传输协议</h2><h3 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h3><ul><li>HTTP、HTTPS 超文本传输协议</li><li>FTP 文件传输协议</li><li>SMTP 简单邮件传输协议</li></ul><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><ul><li>超文本传输协议（HTTP，HyperText Transfer Protocol) 网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。</li><li>HTML Hypertext Markup Language</li><li>HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。即HTTP协议主要由请求和响应构成。</li></ul><blockquote><p>常用请求方法 <strong>POST</strong>、<strong>GET</strong>、PUT、DELETE</p></blockquote><h4 id="请求由-4-部分组成"><a href="#请求由-4-部分组成" class="headerlink" title="请求由 4 部分组成"></a>请求由 4 部分组成</h4><ul><li>HTTP 请求方法或 “动作”</li><li>正在请求的 URL</li><li>一个可选的请求头集合。其中可能包括身份验证信息</li><li>一个可选的请求体</li></ul><p><strong>请求头</strong></p><p>由请求方式、请求URL和协议版本构成</p><ul><li><code>GET /day01/code/login.php?username=123&amp;password=123 HTTP/1.1</code></li><li><code>POST /day01/code/login.php HTTP/1.1</code></li></ul><p><strong>请求行</strong></p><ul><li><code>Host：localhost</code><ul><li>请求的主机，发出请求的页面所在的域</li></ul></li><li><code>Cache-Control：max-age=0</code><ul><li>控制缓存</li></ul></li><li><code>Accept</code><ul><li>/ 接受的文档MIME类型</li></ul></li><li><code>User-Agent</code><ul><li>很重要，浏览器的用户代理字符串</li></ul></li><li><code>Referer</code><ul><li>从哪个URL跳转过来的，发出请求的页面 URL</li></ul></li><li><code>Accept-Encoding</code><ul><li>可接受的压缩格式</li></ul></li><li><code>If-None-Match</code><ul><li>记录服务器响应的ETag值，用于控制缓存,此值是由服务器自动生成的</li></ul></li><li><code>If-Modified-Since</code><ul><li>记录服务器响应的Last-Modified值,此值是由服务器自动生成的</li></ul></li><li><code>Accept-Charset</code><ul><li>浏览器能够显示的字符集</li></ul></li><li><code>Accept-Language</code><ul><li>浏览器当前设置的语言</li></ul></li><li><code>Connection</code><ul><li>浏览器和服务器之间连接的类型</li></ul></li><li><code>Cookie</code><ul><li>当前页面设置的任何 Cookie</li></ul></li></ul><p><strong>请求主体</strong></p><ul><li>即传递给服务端的数据</li><li>注：当以post形式提交表单的时候，请求头里会设置</li><li><code>Content-Type: application/x-www-form-urlencoded</code>，以get形式当不需要</li></ul><h3 id="响应和响应报文"><a href="#响应和响应报文" class="headerlink" title="响应和响应报文"></a>响应和响应报文</h3><p>响应由服务器发出，其规范格式为：状态行、响应头、响应主体。</p><blockquote><p>服务器返回的 HTTP 响应包含 3 部分</p></blockquote><ul><li>一个数字和文字组成的状态码，用来显示请求的成功和失败</li><li>一个响应头集合</li><li>响应主体</li></ul><p><strong>状态行</strong></p><p>由协议版本号、状态码和状态信息构成 <code>HTTP/1.1 200 OK</code></p><p><strong>响应头</strong></p><ul><li><code>Date ：</code><ul><li>响应时间</li></ul></li><li><code>Server ：</code><ul><li>服务器信息</li></ul></li><li><code>Last-Modified ：</code><ul><li>资源最后修改时间 由服务器自动生成</li></ul></li><li><code>ETag ：</code><ul><li>资源修改后生成的唯一标识 由服务器自动生成</li></ul></li><li><code>Content-Length ：</code><ul><li>响应主体长度</li></ul></li><li><code>Content-Type ：</code><ul><li>响应资源的类型</li></ul></li></ul><p><strong>响应主体</strong></p><p>即服务端返回给客户端的内容；</p><p>状态码，常见的有:</p><ul><li>200代表成功</li><li>304文档未修改</li><li>403没有权限</li><li>404未找到</li><li>500服务器错误</li></ul><h2 id="JavaScript-原生的-Ajax"><a href="#JavaScript-原生的-Ajax" class="headerlink" title="JavaScript 原生的 Ajax"></a>JavaScript 原生的 Ajax</h2><p>Ajax 的技术核心是 <code>XMLHttpRequest</code> 对象。AJAX 不是一门的新的语言，而是对现有技术的综合利用。本质是在HTTP协议的基础上以异步的方式与服务器进行通信。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><blockquote><p>指某段程序执行时不会阻塞其它程序执行，其表现形式为程序的执行顺序不依赖程序本身的书写顺序，相反则为同步。</p></blockquote><p><strong>其优势在于不阻塞程序的执行，从而提升整体执行效率。</strong></p><h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>浏览器内建对象，用于在后台与服务器通信(交换数据) ，由此我们便可实现对网页的部分更新，而不是刷新整个页面。</p><blockquote><p>HTTP请求3个组成部分与XMLHttpRequest方法的对应关系</p></blockquote><ul><li>请求行 xhr.open(‘post’,’01.php’);</li><li>请求头 xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’); get请求可以不设置</li><li>请求主体 xhr.send(“name=xjj&amp;age=10”); get 请求方式可以传空</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于 IE7 之前的版本</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> versions = [</span><br><span class="line">        <span class="string">"MSXML2.XMLHttp.6.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XMLHtt"</span></span><br><span class="line">      ], i, len;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, len = versions.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">          <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">          <span class="comment">// 跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>IE7+、FireFox、Opera、Chrome、Safari 都支持原生的 XHR 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>封装获取 xhr 对象的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> versions = [</span><br><span class="line">        <span class="string">"MSXML2.XMLHttp.6.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">        <span class="string">"MSXML2.XMLHtt"</span></span><br><span class="line">      ], i, len;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>, len = versions.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">          <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">          <span class="comment">// 跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">"No XHR object is available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest-对象使用"><a href="#XMLHttpRequest-对象使用" class="headerlink" title="XMLHttpRequest 对象使用"></a>XMLHttpRequest 对象使用</h3><ul><li>open() 方法<ul><li>三个参数：<ul><li>要发送的请求的类型：(“get”, “post”)</li><li>请求的 URL ，是相对于执行代码的当前页面（也可以使用绝对路径）</li><li>表示是否异步发送请求的布尔值</li></ul></li><li>只能想用一个域中使用相同端口和协议的 URL 发送请求。如果 URL 与启动请求的页面有任何差别，都会发生安全错误。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"exam.php"</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li>send() 方法<ul><li>一个参数，请求主题发送的数据</li><li>如果不需要请求主体发送数据，必须传入 null 值，调用完之后请求就发会被分派到服务器。</li></ul></li></ul><p>由于这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行。在收到响应后 ，响应的数据会自动填充 XHR 对象的属性。属性说明如下：</p><ul><li>responseText: 作为响应主体被返回的文本。</li><li>responseXML: 如果响应的内容是 “text/xml” 或 “application/xml”，这个属性中保存着响应数据的 XML DOM 文档。</li><li>status: 响应的 HTTP 状态。</li><li>statusText: HTTP 状态说明。</li></ul><p>在收到响应后，第一步就是检查 <code>status</code> 属性，以确定响应已经成功返回。一般来说，可以将 状态代码为 200 作为成功的标志。此时，responseText 属性的内容已就绪，而且在内容正确的时候，responseXML 也能够访问了。此外，状态码为 304 表示请求的资源并没有被修改，可以直接使用浏览器缓存的版本；也意味着响应是有效的。因此，检查状态码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"exam.php"</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"请求失败: "</span> + xhr.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面这样发送同步请求没有问题，但是发送异步请求时，才能让 JavaScript 继续执行而不必等待响应。可以通过检测 <code>XHR</code>对象的 <code>readyState</code> 属性，该属性表示请求/响应过程的当前活动阶段。该属性的取值：</p><ul><li>0 未初始化，即尚未调用 open() 方法</li><li>1 启动，已经调用 open() 方法，但尚未调用 send()</li><li>2 发送，已经调用 send() 方法，但尚未接收到响应，请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</li><li>3 接收，已经接收到部分响应数据，请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</li><li>4 完成，已经接收到全部响应数据，而且已经可以在客户端使用了</li></ul><p>只要 <code>readyState</code> 属性的值由一个值变成另一个值，都会触发 <code>readystatechange</code> 事件。可以利用这个事件来检测每次状态变化后 <code>readyState</code> 值。通常，我们只对 <code>readyState</code> 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。不过，必须在调用 <code>open()</code> 之前指定 <code>onreadystatechange</code> 事件处理程序才能确保跨浏览器兼容性。代码如下：<code>onreadystatechange</code> 是 <code>Javascript的</code> 事件的一种，其意义在于监听 <code>XMLHttpRequest</code> 的状态</p><ul><li>获取状态行（包括状态码&amp;状态信息）<ul><li><code>xhr.status</code> 状态码;</li><li><code>xhr.statusText</code> 状态码信息</li></ul></li><li><p>获取响应头</p><ul><li><code>xhr.getResponseHeader(&#39;Content-Type&#39;);</code></li><li><code>xhr.getAllResponseHeaders();</code></li></ul></li><li><p>响应主体</p><ul><li><code>xhr.responseText;</code></li><li><code>xhr.responseXML</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"请求失败: "</span> + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"exam.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>在接收到响应之前还可以调用 <code>abort()</code> 方法来取消异步请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure><p><code>setRequestHeader()</code>方法可以设置自定义的请求头部信息。这个方法接收两个参数：</p><ul><li>头部名称</li><li>头部字段的值</li></ul><p><code>setRequestHeader()</code>方法必须在调用 open() 方法之后，send() 方法之前调用.</p><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>GET 请求将查询的字符串参数追加到 URL 的末尾，传入 open() 方法的 URL 末尾的查询字符串必须经过正确的编码才行。</p><p>查询字符串中的每个值都必须经过 encodeURLComponent() 进行编码，然后才能放到 URL 末尾。</p><p>所有的名-值对都必须由（&amp;）符号分隔。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"exam.php?name=value&amp;name=value2"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>封装经过编码的查询字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 URL 末尾添加查询字符串的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>) </span>&#123;</span><br><span class="line">  url += (url.indexOf(<span class="string">"?"</span>) == <span class="number">-1</span> ? <span class="string">"?"</span> : <span class="string">"&amp;"</span>);</span><br><span class="line">  url += encodeURLComponent(name) + <span class="string">"="</span> + encodeURLComponent(value);</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>通常用于向服务器发送应该保存的数据。POST 请求应该把数据作为请求的主体提交。给 open() 方法的第一个参数传入 “post” 就可以初始化一个 post 请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"exam.php"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>使用 XHR 来模仿表单提交：首先将 <code>Content-Type</code> 头部设置为 <code>application/x-www-form-urlencoded</code> ，也就是表单提交时的数据类型，其次是以适当的格式创建一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">  xhr.onreadstatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求失败: "</span> + xhr.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(<span class="string">"post"</span>, <span class="string">"exam.php"</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">  <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"userInfo"</span>);</span><br><span class="line">  xhr.send(serialize(form));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 XHR 对象的兼容方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> versions = [</span><br><span class="line">      <span class="string">"MSXML2.XMLHttp.6.0"</span>,</span><br><span class="line">      <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">      <span class="string">"MSXML2.XMLHtt"</span></span><br><span class="line">    ], i, len;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = versions.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">        <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="comment">// 跳过</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表单序列化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span>(<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parts = [],</span><br><span class="line">    field = <span class="literal">null</span>,</span><br><span class="line">    i,</span><br><span class="line">    len,</span><br><span class="line">    j,</span><br><span class="line">    optLen,</span><br><span class="line">    option,</span><br><span class="line">    optValue;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = form.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">    field = form.elements[i];</span><br><span class="line">    <span class="keyword">switch</span>(field.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"select-one"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"select-multipule"</span>:</span><br><span class="line">        <span class="keyword">if</span> (field.name.length) &#123;</span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>, optLen = field.options.length; j &lt; optLen; j++) &#123;</span><br><span class="line">            option = field.options[j];</span><br><span class="line">            <span class="keyword">if</span> (option.selected) &#123;</span><br><span class="line">              optValue = <span class="string">""</span>;</span><br><span class="line">              <span class="keyword">if</span> (option.hasAttribute) &#123;</span><br><span class="line">                optValue = (option.hasAttribute(<span class="string">"value"</span>) ? option.value : option.text);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                optValue = (option.attributes[<span class="string">"values"</span>].specified ? option.value : option.text);</span><br><span class="line">              &#125;</span><br><span class="line">              parts.push(encodeURLComponent(field.name) + <span class="string">"="</span> + encodeURLComponent(optValue));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">undefined</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"file"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"reset"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"submit"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"button"</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"radio"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"checkbox"</span>:</span><br><span class="line">        <span class="keyword">if</span> (!field.name.length) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (field.name.length) &#123;</span><br><span class="line">          parts.push(encodeURLComponent(field.name) + <span class="string">"="</span> + encodeURLComponent(field.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parts.join(<span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：GET和POST请求方式的差异</strong></p><ul><li>GET没有请求主体，使用xhr.send(null)</li><li>GET可以通过在请求URL上添加请求参数</li><li>POST可以通过xhr.send(‘name=itcast&amp;age=10’)</li><li>POST需要设置</li><li>GET效率更好（应用多）</li><li>GET大小限制约4K，POST则没有限制<h3 id="关于表单序列化"><a href="#关于表单序列化" class="headerlink" title="关于表单序列化"></a>关于表单序列化</h3></li></ul><p>XMLHTTPRequest 2 级 定义了 FormData 类型。 FormData 为序列化表单以及创建与表单格式相同的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"Hiraku"</span>);</span><br></pre></td></tr></table></figure><p>append() 方法传递两个参数。即键和值。也可以使用如下的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>创建了 FormData 的实例后，可以直接传递给 send() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadstatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"请求失败: "</span> + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"exam.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">"userInfo"</span>);</span><br><span class="line">xhr.send(<span class="keyword">new</span> FormDta(form));</span><br></pre></td></tr></table></figure><h3 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR();</span><br><span class="line">xhr.onreadstatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求失败: "</span> + xhr.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 由 ontimeout 事件程序处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"exam.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xht.timeout = <span class="number">1000</span>; <span class="comment">// 仅适用于 IE</span></span><br><span class="line">xhr.ontimeout = funciton() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"请求失败："</span>)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><ul><li>loadstart: 收到响应数据的第一个字节时触发</li><li>progress：在接收响应期间不断地触发</li><li>error: 发生错误时触发</li><li>abort: 调用 abort() 方法而终止时触发</li><li>load: 在接收到完整的响应数据时触发</li><li>loadend: 在通信完成或者触发 error、abort、或 load 事件后触发。</li></ul><p>我们需要检测并判断响应头的 MIME 类型后确定使用 <code>request.responseText</code> 或者 <code>request.responseXML</code></p><h3 id="API-总结"><a href="#API-总结" class="headerlink" title="API 总结"></a>API 总结</h3><ul><li><code>xhr.open()</code><ul><li>发起请求，可以是get、post方式</li></ul></li><li><code>xhr.setRequestHeader()</code><ul><li>设置请求头</li></ul></li><li><code>xhr.send()</code><ul><li>发送请求主体get方式使用xhr.send(null)</li></ul></li><li><code>xhr.onreadystatechange = function () {}</code><ul><li>监听响应状态</li></ul></li><li><code>xhr.status</code><ul><li>表示响应码，如200</li></ul></li><li><code>xhr.statusText</code><ul><li>表示响应信息，如OK</li></ul></li><li><code>xhr.getAllResponseHeaders()</code><ul><li>获取全部响应头信息</li></ul></li><li><code>xhr.getResponseHeader(&#39;key&#39;)</code><ul><li>获取指定头信息</li></ul></li><li><code>xhr.responseText、xhr.responseXML</code><ul><li>都表示响应主体</li></ul></li></ul><h3 id="封装ajax工具函数"><a href="#封装ajax工具函数" class="headerlink" title="封装ajax工具函数"></a>封装ajax工具函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 请求的类型                type    get post</span></span><br><span class="line"><span class="comment"> * 2. 请求地址                  url</span></span><br><span class="line"><span class="comment"> * 3. 是异步的还是同步的         async   false true</span></span><br><span class="line"><span class="comment"> * 4. 请求内容的格式            contentType</span></span><br><span class="line"><span class="comment"> * 5. 传输的数据                data    json对象</span></span><br><span class="line"><span class="comment"> * 6. 响应成功处理函数           success   function</span></span><br><span class="line"><span class="comment"> * 7. 响应失败的处理函数         error     function</span></span><br><span class="line"><span class="comment"> * 这些都是动态参数  参数对象  options</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">window</span>.$ = &#123;&#125;;<span class="comment">/*封装一个函数*/</span></span><br><span class="line"><span class="comment">/*申明一个ajax的方法*/</span></span><br><span class="line">$.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!options || <span class="keyword">typeof</span> options != <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*请求的类型*/</span></span><br><span class="line">    <span class="keyword">var</span> type = options.type || <span class="string">'get'</span>;<span class="comment">/*默认get*/</span></span><br><span class="line">    <span class="comment">/*请求地址 */</span></span><br><span class="line">    <span class="keyword">var</span> url = options.url || location.pathname;<span class="comment">/*当前的地址*/</span></span><br><span class="line">    <span class="comment">/*是异步的还是同步的 */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">async</span> = (options.async === <span class="literal">false</span>)?<span class="literal">false</span>:<span class="literal">true</span>;<span class="comment">/*默认异步*/</span></span><br><span class="line">    <span class="comment">/*请求内容的格式 */</span></span><br><span class="line">    <span class="keyword">var</span> contentType = options.contentType || <span class="string">"text/html"</span>;</span><br><span class="line">    <span class="comment">/*传输的数据 */</span></span><br><span class="line">    <span class="keyword">var</span> data = options.data || &#123;&#125;;<span class="comment">/*｛name:'',age:''｝*/</span></span><br><span class="line">    <span class="comment">/*在提交的时候需要转成 name=xjj 这种格式*/</span></span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">''</span>; <span class="comment">/*数据字符串*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">        dataStr += key+<span class="string">'='</span>+data[key]+<span class="string">'&amp;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataStr = dataStr &amp;&amp; dataStr.slice(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">/*ajax 编程*/</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">/*请求行*/</span></span><br><span class="line">    <span class="comment">/*(type=='get'?url+'?'+dataStr:url)判断当前的请求类型*/</span></span><br><span class="line">    xhr.open(type,(type==<span class="string">'get'</span>?url+<span class="string">'?'</span>+dataStr:url),<span class="keyword">async</span>);</span><br><span class="line">    <span class="comment">/*请求头*/</span></span><br><span class="line">    <span class="keyword">if</span>(type == <span class="string">'post'</span>)&#123;</span><br><span class="line">        xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*请求主体*/</span></span><br><span class="line">    <span class="comment">/*需要判断请求类型*/</span></span><br><span class="line">    xhr.send(type==<span class="string">'get'</span>?<span class="literal">null</span>:dataStr);</span><br><span class="line">    <span class="comment">/*监听响应状态的改变  响应状态*/</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/*请求响应完成并且成功*/</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">/*success*/</span></span><br><span class="line">            <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">var</span> contentType = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line">            <span class="comment">/*如果我们服务器返回的是xml*/</span></span><br><span class="line">            <span class="keyword">if</span>(contentType.indexOf(<span class="string">'xml'</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                data = xhr.responseXML;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*如果我们的服务器返回的是json字符串*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(contentType.indexOf(<span class="string">'json'</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">/*转化json对象*/</span></span><br><span class="line">                data = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*否则的话他就是字符串*/</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                data = xhr.responseText;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*回调 成功处理函数*/</span></span><br><span class="line">            options.success &amp;&amp; options.success(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*计时请求xhr.status不成功  他也需要的响应完成才认作是一个错误的请求*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">/*error*/</span></span><br><span class="line">            options.error &amp;&amp; options.error(<span class="string">'you request fail !'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$.post = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    options.type = <span class="string">'post'</span>;</span><br><span class="line">    $.ajax(options);</span><br><span class="line">&#125;</span><br><span class="line">$.get = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    options.type = <span class="string">'get'</span>;</span><br><span class="line">    $.ajax(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jQuery的ajax"><a href="#jQuery的ajax" class="headerlink" title="jQuery的ajax"></a>jQuery的ajax</h2><p>jQuery为我们提供了更强大的Ajax封装</p><ul><li><code>$.ajax({})</code><ul><li>可配置方式发起Ajax请求</li></ul></li><li><code>$.get()</code><ul><li>以GET方式发起Ajax请求</li></ul></li><li><code>$.post()</code><ul><li>以POST方式发起Ajax请求</li></ul></li><li><code>$(&#39;form&#39;).serialize()</code><ul><li>序列化表单（即格式化key=val&amp;key=val）</li></ul></li><li><code>url</code><ul><li>接口地址</li></ul></li><li><code>type</code><ul><li>请求方式</li></ul></li><li><code>timeout</code><ul><li>请求超时</li></ul></li><li><code>dataType</code><ul><li>服务器返回格式</li></ul></li><li><code>contentType</code><ul><li>指定请求的 HTTP Content-Type</li></ul></li><li><code>data</code><ul><li>发送请求数据</li></ul></li><li><code>beforeSend: function () {}</code><ul><li>请求发起前调用</li></ul></li><li><code>success</code><ul><li>成功响应后调用</li></ul></li><li><code>error</code><ul><li>错误响应时调用</li></ul></li><li><code>complete</code><ul><li>响应完成时调用（包括成功和失败）</li></ul></li><li>timeout<ul><li>超时时间</li></ul></li><li><code>cache</code><ul><li>对于 GET 请求</li></ul></li><li><code>ifModified</code><ul><li>当为 true 时，jQuery 会为请求的每一个 URL 记录 Last-Modified 和 If-None-Match 响应头的值</li></ul></li><li><code>global</code><ul><li>是否触发上面描述的 Ajax 请求过程中的事件</li></ul></li></ul><p><a href="http://www.w3school.com.cn/jquery/jquery_ref_ajax.asp" target="_blank" rel="noopener">jQuery Ajax介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务器、网络基础、相关知识介绍&quot;&gt;&lt;a href=&quot;#服务器、网络基础、相关知识介绍&quot; class=&quot;headerlink&quot; title=&quot;服务器、网络基础、相关知识介绍&quot;&gt;&lt;/a&gt;服务器、网络基础、相关知识介绍&lt;/h2&gt;&lt;h3 id=&quot;服务器介绍：&quot;&gt;&lt;a href=&quot;#服务器介绍：&quot; class=&quot;headerlink&quot; title=&quot;服务器介绍：&quot;&gt;&lt;/a&gt;服务器介绍：&lt;/h3&gt;&lt;h4 id=&quot;常见的服务器软件有：&quot;&gt;&lt;a href=&quot;#常见的服务器软件有：&quot; class=&quot;headerlink&quot; title=&quot;常见的服务器软件有：&quot;&gt;&lt;/a&gt;常见的服务器软件有：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;文件服务器：Server-U、FileZilla、VsFTP等（FTP是File Transfer Protocol文件传输协议）；&lt;/li&gt;
&lt;li&gt;数据库服务器：oracle、mysql、SQL server、DB2、ACCESS等；&lt;/li&gt;
&lt;li&gt;邮件服务器：Postfix、Sendmail等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP服务器&lt;/strong&gt;：Apache、Nginx、IIS、Tomcat、NodeJS等；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;按照不同的划分标准，服务可划分为以下类型：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Ajax系列" scheme="http://yoursite.com/categories/Ajax%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JSON数据</title>
    <link href="http://yoursite.com/2015/12/06/JSON%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2015/12/06/JSON数据/</id>
    <published>2015-12-05T16:00:00.000Z</published>
    <updated>2018-06-01T06:23:23.440Z</updated>
    
    <content type="html"><![CDATA[<p>JSON (JavaScript Object Notion, JavaScript 对象表示法)</p><p>JSON 是 JavaScript 的一个严格的子集，它是一种数据格式，而不是一种编程语言。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON 语法可以表示以下三种类型的值：</p><p><strong>简单值</strong>：使用 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null，不支持 undefined。</p><p><strong>对象</strong>：对象作为一种复杂数据类型，表示的是一组无序的键值对的值，每个键值对的值可以是简单类型，也可以是复杂类型。</p><p><strong>数组</strong>：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型-简单值、对象或数组。</p><p>JSON 对象不支持变量、函数或对象实例，它就是一种表示数据结构化的数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴</p><a id="more"></a><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><ul><li>5 这是 JSON 表示数值 5 的方式。</li><li>“str” 这是 JSON 表示字符串的方式。</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Hiraku"</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 JSON 表示为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Hiraku"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Hiraku"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="string">"school"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"Shantou University"</span>,</span><br><span class="line">      <span class="string">"location"</span>: <span class="string">"Guangdong"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"Technology of LanZhou University"</span>,</span><br><span class="line">      <span class="string">"location"</span>: <span class="string">"Gansu"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSON 中的复杂数据是数组。 JSON 数组采用的就是 JavaScript 中的数字字面量的形式。</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">25</span>, <span class="string">"Hiraku"</span>, <span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>JSON 数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">      <span class="string">"Hirkau"</span>, </span><br><span class="line">      <span class="string">"Herscharl"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"HTML"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">      <span class="string">"HuangShan"</span>, </span><br><span class="line">      <span class="string">"Jack"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"edition"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"year"</span>: <span class="number">2012</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"Java"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">      <span class="string">"TangTang"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"edition"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"year"</span>: <span class="number">2015</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="JSON-解析和序列化"><a href="#JSON-解析和序列化" class="headerlink" title="JSON 解析和序列化"></a>JSON 解析和序列化</h2><p>JSON 数据可以解析为 JavaScript 对象优势及其明显。</p><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>eval() 函数可以解析、解释并返回 JavaScript 对象和数组。</p><p>两个重要方法：</p><ul><li><code>JSON.stringify()</code><ul><li>把 JavaScript 对象序列化为 JSON 字符串</li></ul></li><li><code>JSON.parse()</code><ul><li>把 JSON 字符串解析为原生的 JavaScript 值</li></ul></li></ul><h3 id="JSON-stringify-详解"><a href="#JSON-stringify-详解" class="headerlink" title="JSON.stringify() 详解"></a>JSON.stringify() 详解</h3><p>出来要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同方式序列化 JavaScript 对象。第一个参数是个过滤器，可以是一个数组，也可以是一个函数，第二个参数是一个选择，表示是否在 JSON 字符串中保留缩进。</p><p>第二个参数是数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Hirkau"</span>, </span><br><span class="line">    <span class="string">"Herscharl"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">"title"</span>, <span class="string">"edition"</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(jsonText); <span class="comment">// &#123;"title":"JavaScript","edition":3&#125;</span></span><br></pre></td></tr></table></figure><p>第二个参数是函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Hirkau"</span>, </span><br><span class="line">    <span class="string">"Herscharl"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line">      <span class="keyword">return</span> value.join(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"year"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"year"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"edition"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(jsonText); <span class="comment">// &#123;"title":"JavaScript","authors":"Hirkau,Herscharl","year":"year"&#125;</span></span><br></pre></td></tr></table></figure><p>第三个参数控制结果中的缩进和空白符：最大缩进空格为 10 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Hirkau"</span>, </span><br><span class="line">    <span class="string">"Herscharl"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jsonText);</span><br></pre></td></tr></table></figure><p>这段代码输出结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">        <span class="string">"Hirkau"</span>,</span><br><span class="line">        <span class="string">"Herscharl"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个参数是字符时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Hirkau"</span>, </span><br><span class="line">    <span class="string">"Herscharl"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="string">" - -"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jsonText);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> - -<span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line"> - -<span class="string">"authors"</span>: [</span><br><span class="line"> - - - -<span class="string">"Hirkau"</span>,</span><br><span class="line"> - - - -<span class="string">"Herscharl"</span></span><br><span class="line"> - -],</span><br><span class="line"> - -<span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line"> - -<span class="string">"year"</span>: <span class="number">2013</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toJSON-方法"><a href="#toJSON-方法" class="headerlink" title="toJSON() 方法"></a>toJSON() 方法</h3><p>在 JSON.stringify() 方法不能满足某些独享进行自定义序列化的需求。可以给对象定义 toJSON() 方法，返回自身的 JSON 数据格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Hirkau"</span>, </span><br><span class="line">    <span class="string">"Herscharl"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"year"</span>: <span class="number">2013</span>,</span><br><span class="line">    toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"><span class="built_in">console</span>.log(jsonText); <span class="comment">// "JavaScript"</span></span><br></pre></td></tr></table></figure><p><strong>序列化的顺序：</strong></p><p>(1) 如果存在 toJSON() 方法而且能通过它取得有效的值，则调用该方法，否则，返回对象本身；</p><p>(2) 如果提供了第二个参数，应用这个函数过滤器，传入函数过滤器的值是第 (1) 步返回的值；</p><p>(3) 对第 (2) 步返回的每个值进行相应的序列化；</p><p>(4) 如果提供了第三个参数，执行相应的序列化。</p><h2 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h2><p>JSON.parse() 方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。为了区别 JSON.stringify() 接收的替换(过滤)函数，这个函数被称为还原函数，实际上这两个函数的签名是相同的-接收两个参数，一个键和一个值，而且都需要返回一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"JavaScript"</span>,</span><br><span class="line">  <span class="string">"authors"</span>: [</span><br><span class="line">    <span class="string">"Hirkau"</span>, </span><br><span class="line">    <span class="string">"Herscharl"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"edition"</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">"year"</span>: <span class="number">2013</span>,</span><br><span class="line">  releaseDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="string">"releaseDate"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(bookCopy.releaseDate.getFullYear()); <span class="comment">// 2011</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON (JavaScript Object Notion, JavaScript 对象表示法)&lt;/p&gt;
&lt;p&gt;JSON 是 JavaScript 的一个严格的子集，它是一种数据格式，而不是一种编程语言。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;JSON 语法可以表示以下三种类型的值：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单值&lt;/strong&gt;：使用 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null，不支持 undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;：对象作为一种复杂数据类型，表示的是一组无序的键值对的值，每个键值对的值可以是简单类型，也可以是复杂类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组&lt;/strong&gt;：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型-简单值、对象或数组。&lt;/p&gt;
&lt;p&gt;JSON 对象不支持变量、函数或对象实例，它就是一种表示数据结构化的数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴&lt;/p&gt;
    
    </summary>
    
      <category term="JSON系列" scheme="http://yoursite.com/categories/JSON%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="http://yoursite.com/2015/11/28/jQuery/"/>
    <id>http://yoursite.com/2015/11/28/jQuery/</id>
    <published>2015-11-27T16:00:00.000Z</published>
    <updated>2018-06-01T06:08:44.837Z</updated>
    
    <content type="html"><![CDATA[<p>使用 CSS 选择器来识别一组文档元素，并返回一个对象表示这些元素。返回的对象提供了大量的方法来批量操作匹配的元素。</p><h2 id="jQuery前戏"><a href="#jQuery前戏" class="headerlink" title="jQuery前戏"></a>jQuery前戏</h2><h3 id="js不足"><a href="#js不足" class="headerlink" title="js不足"></a>js不足</h3><ul><li>代码很麻烦，冗余</li><li>浏览器兼容性问题</li><li>入口函数只能写一个，写了多个，后面的会覆盖前面的问题</li><li>js的代码容错性比较差（比较容易出错）</li><li>实现一些简单的动画比较麻烦</li></ul><h3 id="什么是jquery？"><a href="#什么是jquery？" class="headerlink" title="什么是jquery？"></a>什么是jquery？</h3><p>jquery是一个js库。jquery就是一个js文件.</p><p>什么是js库？js库其实就是把一些我们常用到的方法封装到一个单独的js文件里面，当我们想用的时候，引入它。（common.js animate.js）</p><p>特点：</p><ul><li>丰富强大的语法</li><li>高效的查询</li><li>一套有用的方法</li><li>强大的函数式编程技巧，批量操作元素集</li><li>简洁的语言用法</li></ul><a id="more"></a><h3 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jquery-1.12.4.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><p><code>jQuery()</code> 全局函数，对应于一个快捷名：<code>$</code>。<code>jQuery()</code> 是工厂函数，不使用 <code>new</code> 关键字。</p><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><h4 id="js入口函数"><a href="#js入口函数" class="headerlink" title="js入口函数"></a>js入口函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;;</span><br></pre></td></tr></table></figure><h4 id="jQuery入口函数1"><a href="#jQuery入口函数1" class="headerlink" title="jQuery入口函数1"></a>jQuery入口函数1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure><h4 id="jQuery入口函数2（简化）"><a href="#jQuery入口函数2（简化）" class="headerlink" title="jQuery入口函数2（简化）"></a>jQuery入口函数2（简化）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;);</span><br></pre></td></tr></table></figure><h3 id="符实质"><a href="#符实质" class="headerlink" title="$符实质"></a>$符实质</h3><ul><li>$实质是一个函数，jQuery 对象是类数组对象。</li><li>参数是 function 、把 dom 元素 document 转成 jQuery 对象，选择器</li></ul><blockquote><p>jQuery 的调用方式</p></blockquote><p>第一种：传递 CSS 选择器（字符串）给 <code>$()</code> 方法。 选择器支持大部分 CSS3 选择器，也有自己扩展的。返回当前文档中匹配该选择器的元素集合。还可以将一个 jQuery 对象作为第二个参数传递给 <code>$()</code> 方法，返回该特定元素或元素子元素中匹配选择器的部分。第二个元素可选的。</p><p>第二种：传递一个 Element、Document 或 Window 对象给 <code>$()</code> 方法。将传入的内容封装成 jQuery 对象。</p><p>第三种：传递 HTML 文本字符串，会根据传入的文本创建好 HTML 元素并封装为 jQuery 对象返回。可以接收第二个参数，可以传递 Document 对象来指定与所创建元素相关联的文档。第二个参数还可以是 object 对象。</p><p>第四中：传入函数。</p><h2 id="一些基础方法"><a href="#一些基础方法" class="headerlink" title="一些基础方法"></a>一些基础方法</h2><ul><li><code>size()</code> 代替 <code>length</code></li><li><code>get()</code> 代替方括号索引</li><li><code>toArray()</code> 将 <code>jQuery</code> 对象转成真正数组</li><li><code>each()</code> 遍历，代替 for 循环<ul><li>参数是回调函数，回调函数中的 this 指向遍历的元素，是原生的 DOM 对象。</li><li>还可以将索引，该元素传递给回调函数的第一个和第二个参数，第二个参数也是 DOM 对象。</li><li>返回调用自身的 jQuery 对象，可以用于链式编程</li></ul></li><li><code>map()</code> 和 <code>Array.prototype.map()</code> 方法很接近。<ul><li>接收回调函数作为参数；</li><li>索引是回调函数的第一个参数，元素作为 this 值和回调函数的第二个参数。</li><li>如果回调函数返回 null 或 undefined，索引忽略。</li><li>回调函数返回数组或者伪数组</li><li>map() 返回的 jQuery 对象可以不包括文档元素，但依旧可以像伪数组对象一样使用。</li></ul></li><li><code>index()</code> 接收一个参数，返回该元素在 jQuery 对象中的索引值。找不到返回 -1.</li><li><code>is()</code> 接收一个选择器，选中元素至少有一个匹配该选择器，返回 true。</li></ul><p>jQuery 对象的三个属性</p><ul><li><code>selector</code> 选择器字符串</li><li><code>context</code> 传递给 <code>$()</code> 的第二个参数</li><li><code>jquery</code> jQuery 的版本号</li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ul><li>ID选择器 <code>$(&quot;#id名&quot;);</code></li><li>类选择器 <code>$(&quot;.类名&quot;);</code></li><li>标签选择器 <code>$(&quot;标签名&quot;);</code></li><li>并集选择器 <code>$(&quot;#curr,.cls&quot;);</code></li><li>交集选择器 <code>$(&quot;li.cls&quot;);</code></li></ul><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><ul><li>子代选择器 <code>$(&quot;#curr&gt;.cls&quot;)</code></li><li>后代选择器 <code>$(&quot;li cls&quot;)</code></li></ul><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><ul><li><code>:odd;</code></li><li><code>:even;</code></li><li><code>:eq(0);</code><ul><li>jQuery对象</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>$(this).css(&quot;backgroundColor&quot;, &quot;pink&quot;).siblings(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;);</code><ul><li>链式编程</li></ul></li><li><code>$(this).find(&quot;li&quot;).css(&quot;backgroundColor&quot;, &quot;&quot;);</code></li><li><code>css({});</code><ul><li>css设置样式</li></ul></li><li><code>siblings();</code><ul><li>兄弟元素</li></ul></li><li><code>find();</code><ul><li>后代元素</li></ul></li><li><code>next();</code><ul><li>下一个兄弟元素</li></ul></li><li><code>parent();</code><ul><li>父元素</li></ul></li><li><code>show();</code><ul><li>显示</li></ul></li><li><code>hide();</code><ul><li>隐藏</li></ul></li><li><code>index();</code><ul><li>获取的是当前对象在它兄弟里面的索引/</li></ul></li><li><code>eq(0);</code><ul><li>取到的是jQuery对象</li></ul></li></ul><h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><ul><li>设置属性的操作的时候设置的是所有的元素</li><li>获取性操作不去遍历，直接获取第一个</li></ul><h2 id="类操作"><a href="#类操作" class="headerlink" title="类操作"></a>类操作</h2><ul><li>添加类 <code>addClass();</code><ul><li>类名</li></ul></li><li>移除类 <code>removeClass();</code><ul><li>类名</li></ul></li><li>判断类 <code>hasClass();</code><ul><li>类名</li></ul></li><li>切换 <code>toggle();</code><ul><li>类名，两个类名之间切换操作</li></ul></li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="显示、隐藏"><a href="#显示、隐藏" class="headerlink" title="显示、隐藏"></a>显示、隐藏</h3><ul><li>show(); hide(); toggle();<ul><li>参数speed,值为毫秒值</li></ul></li></ul><h3 id="淡入、淡出"><a href="#淡入、淡出" class="headerlink" title="淡入、淡出"></a>淡入、淡出</h3><ul><li>fadeIn(); fadeIn(); fadeToggle()；<ul><li>不传参数的时候，有动画，normal;</li></ul></li></ul><h3 id="滑入、滑出"><a href="#滑入、滑出" class="headerlink" title="滑入、滑出"></a>滑入、滑出</h3><ul><li>slideUp(); slideUp(); slideToggle()；<ul><li>不传参数的时候，有动画，normal;</li></ul></li></ul><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#box"</span>).animate(&#123;<span class="string">"width"</span>:<span class="string">"400px"</span>,<span class="string">"height"</span>:<span class="string">"400px"</span>, <span class="string">"left"</span>:<span class="string">"400px"</span>&#125;,speed,easing);</span><br></pre></td></tr></table></figure><h3 id="停止动画-stop"><a href="#停止动画-stop" class="headerlink" title="停止动画 stop();"></a>停止动画 <code>stop();</code></h3><ul><li>stop(clearQueue, jumpToEnd);<ul><li>第一个参数是否清除动画队列 true, false，默认false;第二个参数是是否跳转到当前动画的最终效果 true, false</li></ul></li></ul><h2 id="jQuery和js节点操作"><a href="#jQuery和js节点操作" class="headerlink" title="jQuery和js节点操作"></a>jQuery和js节点操作</h2><h3 id="js节点操作"><a href="#js节点操作" class="headerlink" title="js节点操作"></a>js节点操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">aNode.document.createElement(<span class="string">"a"</span>);</span><br><span class="line">box.appendChild(aNode);</span><br><span class="line">aNode.innerHTML = <span class="string">"innerHtml"</span>;</span><br></pre></td></tr></table></figure><h3 id="jQuery-操作"><a href="#jQuery-操作" class="headerlink" title="jQuery 操作"></a>jQuery 操作</h3><ul><li><code>append();</code><ul><li>添加节点</li></ul></li><li><code>appendTo()</code><ul><li>添加节点</li></ul></li><li><code>prepend();</code><ul><li>添加节点</li></ul></li><li><code>prependTo()</code><ul><li>添加节点</li></ul></li><li><code>after();</code><ul><li>添加节点</li></ul></li><li><code>before();</code><ul><li>添加节点</li></ul></li><li><code>insertAfter()</code><ul><li>插入节点</li></ul></li><li><code>insertBefore()</code><ul><li>插入节点</li></ul></li><li><code>replaceWith()</code><ul><li>替换</li></ul></li><li><code>add()</code><ul><li>添加</li></ul></li><li><code>first()</code><ul><li>仅包含选中元素的第一个</li></ul></li><li><code>eq()</code><ul><li>只包含指定序号的单个元素</li></ul></li><li><code>html();</code><ul><li>不传参获取，传参设置</li></ul></li><li><code>text();</code><ul><li>不传参获取，传参设置</li></ul></li><li><code>empty();</code><ul><li>清空节点（清理门户）</li></ul></li><li><code>remove();</code><ul><li>删除节点（自杀）</li></ul></li><li><code>clone();</code><ul><li>深度复制，不复制事件</li></ul></li><li><code>clone(true);</code><ul><li>深度复制，并且复制事件</li></ul></li><li><code>val();</code><ul><li>获取值</li></ul></li><li><code>val(&quot;abc&quot;);</code><ul><li>设置值</li></ul></li><li><code>next()</code><ul><li>下一个节点</li></ul></li><li><code>prev()</code><ul><li>上一个节点</li></ul></li><li><code>prevAll()</code><ul><li>前面所有节点</li></ul></li><li><code>nextAll()</code><ul><li>后面所有节点</li></ul></li><li><code>parent()</code><ul><li>父节点</li></ul></li><li><code>sibling()</code><ul><li>兄弟节点</li></ul></li><li><code>find()</code><ul><li>后代节点</li></ul></li><li><code>filer()</code><ul><li>返回符合条件的jQuery对象</li></ul></li><li><code>not()</code><ul><li>排除元素</li></ul></li><li><code>has()</code><ul><li>是否有</li></ul></li><li><code>gt()</code><ul><li>参数是数字，返回大于参数的后面的元素</li></ul></li><li><code>wrap()</code><ul><li>包装每一个</li></ul></li><li><code>wrapInner()</code><ul><li>包装每一个元素的内容</li></ul></li><li><code>wrapOuter()</code><ul><li>将选中元素作为一组包装</li></ul></li></ul><h3 id="jQuery属性操作"><a href="#jQuery属性操作" class="headerlink" title="jQuery属性操作"></a>jQuery属性操作</h3><ul><li><code>setAttribute(&quot;target&quot;, &quot;_blank&quot;);</code></li><li><code>attr(&quot;title&quot;, &quot;星期四&quot;);</code><ul><li>用法和css用法是一样</li></ul></li><li><code>attr(name, value);</code><ul><li>用法和css用法是一样</li></ul></li><li><code>attr({json});</code><ul><li>用法和css用法是一样</li></ul></li><li><code>css()</code><ul><li>传入一个字符串参数，获取对应样式，注意，不能传入复合样式的属性，如 “font”</li><li>传入两个参数，设置样式</li><li>传入一个对象，设置样式</li></ul></li></ul><h3 id="jQuery属性操作特例"><a href="#jQuery属性操作特例" class="headerlink" title="jQuery属性操作特例"></a>jQuery属性操作特例</h3><p>布尔类型的属性：<code>true</code> <code>false</code></p><ul><li><code>checked</code></li><li><code>selected</code></li><li><code>disabled</code></li></ul><p>在jquery里面，碰到布尔类型的属性的时候，不要用attr方法，应该prop方法</p><ul><li><code>prop(&quot;checked&quot;);</code><ul><li>用法和css用法是一样</li></ul></li></ul><h3 id="jQuery获取属性值width系列（操作尺寸）"><a href="#jQuery获取属性值width系列（操作尺寸）" class="headerlink" title="jQuery获取属性值width系列（操作尺寸）"></a>jQuery获取属性值width系列（操作尺寸）</h3><ul><li><code>width();</code><ul><li>能获取、设置</li></ul></li><li><code>Innerwidth();</code><ul><li>获取内部宽度（包括宽度和padding）</li></ul></li><li><code>Outerwidth();</code><ul><li>获取内部宽度（包括宽度和padding和border）</li></ul></li><li><code>Outerwidth(true);</code><ul><li>获取内部宽度（包括宽度和padding和border和margin）</li></ul></li><li><code>height();</code><ul><li>能获取、设置</li></ul></li><li><code>Innerheight();</code><ul><li>获取内部高度（包括高度和 padding）</li></ul></li><li><code>Outerheight();</code><ul><li>获取内部高度（包括高度和 padding 和 border）</li></ul></li><li><code>Outerheight(true);</code><ul><li>获取内部高度（包括高度和 padding 和 border 和 margin）</li></ul></li></ul><h3 id="jQuery操作坐标"><a href="#jQuery操作坐标" class="headerlink" title="jQuery操作坐标"></a>jQuery操作坐标</h3><ul><li><code>position();</code><ul><li>只能获取不能设置，设置用 css 设置，找最近的有相对定位的的父盒子</li></ul></li><li><code>offset();</code><ul><li>相对与dom最左上角（获取、设置）</li><li>带有 left 属性和 top 属性</li></ul></li><li><code>offsetParent()</code><ul><li>最近定位的祖先元素</li></ul></li><li><code>scrollTop();</code> <ul><li>设置卷去的距离（事件）</li></ul></li><li><code>scrollLeft();</code><ul><li>设置卷去的距离（事件）</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).scrollTop();</span><br><span class="line">  $(<span class="keyword">this</span>).scrollLeft();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="获取和设置-CSS-类"><a href="#获取和设置-CSS-类" class="headerlink" title="获取和设置 CSS 类"></a>获取和设置 CSS 类</h3><ul><li><code>addClass()</code><ul><li>添加类</li></ul></li><li><code>removeClass()</code><ul><li>删除类</li></ul></li><li><code>toggleClass()</code><ul><li>没有类则添加，否则删除</li></ul></li><li><code>hasClass()</code><ul><li>判断是否存在</li></ul></li></ul><h3 id="设置或获取元素内容"><a href="#设置或获取元素内容" class="headerlink" title="设置或获取元素内容"></a>设置或获取元素内容</h3><ul><li><code>html()</code><ul><li>不传参获取</li><li>传参设置值，html格式字符串</li></ul></li><li><p><code>text()</code></p><ul><li>不传参获取</li><li>传参设置值，纯文本<h2 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h2></li></ul></li><li><p>事件机制：</p><ul><li>用户执行某一个操作，浏览器会相应用户的操作，执行某个函数</li></ul></li><li>事件处理函数：<ul><li>所谓的事件处理函数，就是响应用户的那个函数</li></ul></li><li>用户事件：<ul><li>就是事件名，用户可以注册的事件</li></ul></li><li>注册事件：<ul><li>就是赋值或调用addEventListener</li></ul></li><li>响应事件：<ul><li>做完操作调用某个方法</li></ul></li></ul><h3 id="jQuery事件发展"><a href="#jQuery事件发展" class="headerlink" title="jQuery事件发展"></a>jQuery事件发展</h3><blockquote><p>简单事件绑定：不能同时注册两个事件</p></blockquote><p>bind事件绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).bind(&#123;</span><br><span class="line">   <span class="string">"click"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"我执行了click"</span>);</span><br><span class="line">   &#125;,<span class="string">"mouseenter"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">"我执行了mouseenter"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不支持动态创建元素</p><blockquote><p>delegate事件（委托、委派、代理）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).delegate(<span class="string">"p"</span>, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"我执行了委托事件"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="on事件绑定"><a href="#on事件绑定" class="headerlink" title="on事件绑定"></a>on事件绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*on给div注册委托事件*/</span></span><br><span class="line">$(<span class="string">"div"</span>).on(<span class="string">"click"</span>, <span class="string">"p"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">/*on给div注册普通的点击事件*/</span></span><br><span class="line">$(<span class="string">"div"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"我触发了div本身的事件"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="解除事件绑定"><a href="#解除事件绑定" class="headerlink" title="解除事件绑定"></a>解除事件绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*off是解除所有的事件,能解除委托事件*/</span></span><br><span class="line">$(<span class="string">"div"</span>).off();</span><br><span class="line"><span class="comment">/*解除click事件*/</span></span><br><span class="line">$(<span class="string">"div"</span>).off(<span class="string">"click"</span>);</span><br><span class="line"><span class="comment">/*解除委托的click事件*/</span></span><br><span class="line">$(<span class="string">"div"</span>).off(<span class="string">"click"</span>,<span class="string">"**"</span>);</span><br></pre></td></tr></table></figure><h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><ul><li><code>trigger(&quot;focus&quot;);</code><ul><li>触发获取焦点事件，会触发浏览器默认行为</li></ul></li><li><code>triggerHandler(&quot;focus&quot;);</code><ul><li>触发获取焦点事件，不会触发浏览器默认行为</li></ul></li></ul><h3 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h3><ul><li><code>click(function(event){...});</code><ul><li>点击</li></ul></li><li><code>keyCode = event.keyCode;</code><ul><li>键盘码</li></ul></li></ul><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>方法1：</p><ul><li><code>event.stopPropagation();</code></li></ul><p>方法2：</p><ul><li><code>return false;</code></li></ul><h3 id="阻止浏览器的默认行为"><a href="#阻止浏览器的默认行为" class="headerlink" title="阻止浏览器的默认行为"></a>阻止浏览器的默认行为</h3><p>方法1：</p><ul><li><code>event.preventDefault();</code></li></ul><p>方法2：</p><ul><li><code>return false;</code></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><code>click(function(){...});</code><ul><li>点击</li></ul></li><li><code>scroll(function(){...});</code><ul><li>鼠标滚轮事件</li></ul></li><li><code>focus(function(){...});</code><ul><li>获取焦点</li></ul></li><li><code>mouseenter(function(){...});</code><ul><li>鼠标经过</li></ul></li><li><code>mouseleave(function(){...});</code><ul><li>鼠标离开</li></ul></li><li><code>keydown(function(event){var keyCode = event.keyCode;});</code><ul><li>键盘按键按下</li></ul></li><li><code>keyup(function(event){var keyCode = event.keyCode;});</code><ul><li>键盘抬起</li></ul></li></ul><h3 id="浏览器提供的事件"><a href="#浏览器提供的事件" class="headerlink" title="浏览器提供的事件"></a>浏览器提供的事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"onabort"</span>, <span class="string">"onblur"</span>, <span class="string">"oncancel"</span>, <span class="string">"oncanplay"</span>, </span><br><span class="line"><span class="string">"oncanplaythrough"</span>, <span class="string">"onchange"</span>, <span class="string">"onclick"</span>, <span class="string">"onclose"</span>,</span><br><span class="line"><span class="string">"oncontextmenu"</span>, <span class="string">"oncuechange"</span>, <span class="string">"ondblclick"</span>, <span class="string">"ondrag"</span>, </span><br><span class="line"><span class="string">"ondragend"</span>, <span class="string">"ondragenter"</span>, <span class="string">"ondragleave"</span>, <span class="string">"ondragover"</span>,</span><br><span class="line"><span class="string">"ondragstart"</span>, <span class="string">"ondrop"</span>, <span class="string">"ondurationchange"</span>, <span class="string">"onemptied"</span>,</span><br><span class="line"><span class="string">"onended"</span>, <span class="string">"onerror"</span>, <span class="string">"onfocus"</span>, <span class="string">"oninput"</span>, <span class="string">"oninvalid"</span>, </span><br><span class="line"><span class="string">"onkeydown"</span>, <span class="string">"onkeypress"</span>, <span class="string">"onkeyup"</span>, <span class="string">"onload"</span>,</span><br><span class="line"><span class="string">"onloadeddata"</span>, <span class="string">"onloadedmetadata"</span>, <span class="string">"onloadstart"</span>, <span class="string">"onmousedown"</span>, </span><br><span class="line"><span class="string">"onmouseenter"</span>, <span class="string">"onmouseleave"</span>, <span class="string">"onmousemove"</span>, <span class="string">"onmouseout"</span>, </span><br><span class="line"><span class="string">"onmouseover"</span>, <span class="string">"onmouseup"</span>, <span class="string">"onmousewheel"</span>, <span class="string">"onpause"</span>, </span><br><span class="line"><span class="string">"onplay"</span>, <span class="string">"onplaying"</span>, <span class="string">"onprogress"</span>, <span class="string">"onratechange"</span>, </span><br><span class="line"><span class="string">"onreset"</span>, <span class="string">"onresize"</span>, <span class="string">"onscroll"</span>, <span class="string">"onseeked"</span>, </span><br><span class="line"><span class="string">"onseeking"</span>, <span class="string">"onselect"</span>, <span class="string">"onshow"</span>, <span class="string">"onstalled"</span>, </span><br><span class="line"><span class="string">"onsubmit"</span>, <span class="string">"onsuspend"</span>, <span class="string">"ontimeupdate"</span>, <span class="string">"ontoggle"</span>, </span><br><span class="line"><span class="string">"onvolumechange"</span>, <span class="string">"onwaiting"</span>, <span class="string">"onbeforecopy"</span>, <span class="string">"onbeforecut"</span>, </span><br><span class="line"><span class="string">"onbeforepaste"</span>, <span class="string">"oncopy"</span>, <span class="string">"oncut"</span>, <span class="string">"onpaste"</span>, </span><br><span class="line"><span class="string">"onsearch"</span>, <span class="string">"onselectstart"</span>, <span class="string">"onwheel"</span>, <span class="string">"onwebkitfullscreenchange"</span>, </span><br><span class="line"><span class="string">"onwebkitfullscreenerror"</span></span><br></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*显式迭代：对每一个元素做不同的处理*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; $(<span class="string">"li"</span>).length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> target = (i + <span class="number">1</span>) / <span class="number">10</span>;</span><br><span class="line">  $(<span class="string">"li"</span>).eq(i).css(<span class="string">"opacity"</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*each();*/</span></span><br><span class="line">$(<span class="string">"li"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = (index + <span class="number">1</span>) / <span class="number">10</span>;</span><br><span class="line">  $(element).css(<span class="string">"opacity"</span>, target);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="懒加载插件"><a href="#懒加载插件" class="headerlink" title="懒加载插件"></a>懒加载插件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="class"><span class="keyword">class</span></span>=<span class="string">"lazy"</span> data-original=<span class="string">"23.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"jquery-1.12.4.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"plugins/jquery.lazyload.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;$(<span class="string">"img.lazy"</span>).lazyload();&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fullpage插件"><a href="#fullpage插件" class="headerlink" title="fullpage插件"></a>fullpage插件</h3><h4 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/jquery.fullPage.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-ui.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.fullPage.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"fullpage"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>第一屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>第二屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span>第三屏的第一屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span>第三屏的第二屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span>第三屏的第三屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slide"</span>&gt;</span>第三屏的第四屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>第四屏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#fullpage'</span>).fullpage(&#123;</span><br><span class="line">    <span class="string">'verticalCentered'</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">'css3'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'sectionsColor'</span>: [<span class="string">'#254875'</span>, <span class="string">'#00FF00'</span>, <span class="string">'#254587'</span>, <span class="string">'#695684'</span>],</span><br><span class="line">    anchors: [<span class="string">'page1'</span>, <span class="string">'page2'</span>, <span class="string">'page3'</span>, <span class="string">'page4'</span>],</span><br><span class="line">    <span class="string">'navigation'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'navigationPosition'</span>: <span class="string">'right'</span>,</span><br><span class="line">    <span class="string">'navigationTooltips'</span>: [<span class="string">'fullPage.js'</span>, <span class="string">'Powerful'</span>, <span class="string">'Amazing'</span>, <span class="string">'Simple'</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="可选配置"><a href="#可选配置" class="headerlink" title="可选配置"></a>可选配置</h4><ul><li>选项</li><li>方法</li><li>回调函数</li></ul><h3 id="jqueryUI插件"><a href="#jqueryUI插件" class="headerlink" title="jqueryUI插件"></a>jqueryUI插件</h3><p><a href="http://jqueryui.com/" target="_blank" rel="noopener">jqueryUI插件 官网</a></p><h4 id="引入文件-1"><a href="#引入文件-1" class="headerlink" title="引入文件"></a>引入文件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"plugins/jquery-ui.css"</span> /&gt;</span><br><span class="line">&lt;script src=<span class="string">"jquery-1.12.4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"plugins/jquery-ui.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"drag-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"drag-bar"</span>&gt;</span>可拖动、排序、变形的新闻模块<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"resize-item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sort-wrapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"sort-item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第1条新闻!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第2条新闻!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是第3条新闻!<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">".drag-wrapper"</span>).draggable(&#123;<span class="string">"handle"</span>:<span class="string">".drag-bar"</span>&#125;);</span><br><span class="line">        $(<span class="string">".resize-item"</span>).resizable(&#123;<span class="string">"handles"</span>:<span class="string">"s"</span>&#125;);</span><br><span class="line">        $(<span class="string">".sort-item"</span>).sortable(&#123;<span class="string">"opacity"</span>:<span class="string">"0.5"</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件制作"><a href="#插件制作" class="headerlink" title="插件制作"></a>插件制作</h3><p>制作插件：就是给jquery对象添加方法。</p><ul><li><code>$.fn.fnName = function(){}</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 CSS 选择器来识别一组文档元素，并返回一个对象表示这些元素。返回的对象提供了大量的方法来批量操作匹配的元素。&lt;/p&gt;
&lt;h2 id=&quot;jQuery前戏&quot;&gt;&lt;a href=&quot;#jQuery前戏&quot; class=&quot;headerlink&quot; title=&quot;jQuery前戏&quot;&gt;&lt;/a&gt;jQuery前戏&lt;/h2&gt;&lt;h3 id=&quot;js不足&quot;&gt;&lt;a href=&quot;#js不足&quot; class=&quot;headerlink&quot; title=&quot;js不足&quot;&gt;&lt;/a&gt;js不足&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代码很麻烦，冗余&lt;/li&gt;
&lt;li&gt;浏览器兼容性问题&lt;/li&gt;
&lt;li&gt;入口函数只能写一个，写了多个，后面的会覆盖前面的问题&lt;/li&gt;
&lt;li&gt;js的代码容错性比较差（比较容易出错）&lt;/li&gt;
&lt;li&gt;实现一些简单的动画比较麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是jquery？&quot;&gt;&lt;a href=&quot;#什么是jquery？&quot; class=&quot;headerlink&quot; title=&quot;什么是jquery？&quot;&gt;&lt;/a&gt;什么是jquery？&lt;/h3&gt;&lt;p&gt;jquery是一个js库。jquery就是一个js文件.&lt;/p&gt;
&lt;p&gt;什么是js库？js库其实就是把一些我们常用到的方法封装到一个单独的js文件里面，当我们想用的时候，引入它。（common.js animate.js）&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;丰富强大的语法&lt;/li&gt;
&lt;li&gt;高效的查询&lt;/li&gt;
&lt;li&gt;一套有用的方法&lt;/li&gt;
&lt;li&gt;强大的函数式编程技巧，批量操作元素集&lt;/li&gt;
&lt;li&gt;简洁的语言用法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="jQuery系列" scheme="http://yoursite.com/categories/jQuery%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Canvas</title>
    <link href="http://yoursite.com/2015/11/18/canvas/"/>
    <id>http://yoursite.com/2015/11/18/canvas/</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2018-05-31T08:50:28.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Canvas"><a href="#什么是-Canvas" class="headerlink" title="什么是 Canvas"></a>什么是 Canvas</h2><p>canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布.在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.</p><a id="more"></a><h4 id="canvas-的基本用法"><a href="#canvas-的基本用法" class="headerlink" title="canvas 的基本用法"></a>canvas 的基本用法</h4><blockquote><p>基本语法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><ul><li>使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸.</li><li>默认 canvas 的宽高为 300 和 150.</li><li>不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性.</li><li>如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力.</li><li>canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题.</li><li>canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.</li></ul><blockquote><p>canvas 的使用领域</p></blockquote><p>canvas 的使用领域很多:</p><ul><li>游戏</li><li>可视化数据(重点)</li><li>banner 广告</li><li>多媒体</li><li>未来</li><li>模拟仿真</li><li>远程操作</li><li>图形编辑</li></ul><h2 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h2><h3 id="基本绘图方法"><a href="#基本绘图方法" class="headerlink" title="基本绘图方法"></a>基本绘图方法</h3><p><strong>绘图步骤:</strong></p><ul><li>获得 <code>canvas</code> 对象.</li><li>调用 <code>getContext</code> 方法, 提供字符串参数 ‘2d’.<ul><li>该方法返回 <code>CanvasRenderingContext2D</code> 类型的对象. 该对象提供基本的绘图命令.</li><li>使用 <code>CanvasRenderingContext2D</code> 对象提供的方法进行绘图.</li></ul></li><li>基本绘图命令<ul><li>设置开始绘图的位置: <code>context.moveTo( x, y )</code>.</li><li>设置直线到的位置: <code>context.lineTo( x, y )</code>.</li><li>描边绘制: <code>context.stroke()</code>.</li><li>填充绘制: <code>context.fill()</code>.</li><li>闭合路径: <code>context.closePath()</code>.</li></ul></li></ul><h3 id="01-绘制基本线"><a href="#01-绘制基本线" class="headerlink" title="01-绘制基本线"></a>01-绘制基本线</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement( <span class="string">'canvas'</span> );</span><br><span class="line">canvas.width = <span class="number">500</span>;</span><br><span class="line">canvas.height = <span class="number">400</span>;</span><br><span class="line">canvas.style.border = <span class="string">'1px dashed red'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild( canvas );</span><br><span class="line"><span class="comment">// 获得 CanvasRenderingContext2D 对象</span></span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext( <span class="string">'2d'</span> );</span><br><span class="line"><span class="comment">// 设置 起点</span></span><br><span class="line">context.moveTo( <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"><span class="comment">// 绘制直线</span></span><br><span class="line">context.lineTo( <span class="number">500</span>, <span class="number">400</span> );</span><br><span class="line"><span class="comment">// 设置 起点</span></span><br><span class="line">context.moveTo( <span class="number">0</span>, <span class="number">400</span> );</span><br><span class="line"><span class="comment">// 绘制直线</span></span><br><span class="line">context.lineTo( <span class="number">500</span>, <span class="number">0</span> );</span><br><span class="line"><span class="comment">// 描边显示效果</span></span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure><p>运行结果为:</p><p><img src="/images/canvas01.png" alt="canvas01"></p><h3 id="计算机直角坐标系"><a href="#计算机直角坐标系" class="headerlink" title="计算机直角坐标系"></a>计算机直角坐标系</h3><p><img src="/images/canvas02.png" alt="canvas02"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>需要绘图就需要有 <code>canvas</code> 标签, 该标签用于展示图像.</li><li><code>canvas</code> 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置.</li><li>但是 <code>canvas</code> 只是展示图像的标签, 它没有绘图的能力. 需要使用 <code>canvas</code> 的上下文工具来实现绘图.</li><li>使用 <code>canvas.getContext(&#39;2d&#39;)</code> 可以获得绘图工具, 该工具是 <code>CanvasRenderingContext2D</code> 类型的对象.</li><li>需要绘图, 首选设置绘图的起点.<ul><li>使用 <code>canvas</code> 绘图, 需要主要的是他主张先描点, 再连线绘制效果.</li><li>因此需要首先设置起点, 然后在起点的基础上描述其他需要的点.</li><li>使用 <code>CanvasRenderingContext2D.moveTo(x, y)</code> 方法设置起点.<ul><li>其中 x, y 表示的是在坐标系中的位置.</li></ul></li></ul></li><li>使用 <code>CanvasRenderingContext2D.lineTo(x, y)</code> 来描述绘制直线的下一个点. 依次类推可以描述多个点.</li><li>描点结束后, 需要使用 <code>CanvasRenderingContext2D.stroke()</code> 方法来连线. 开可以显示出效果.</li></ul><h4 id="getContext-方法"><a href="#getContext-方法" class="headerlink" title="getContext 方法"></a>getContext 方法</h4><p>语法: <code>Canvas.getContext(typeStr)</code></p><p>描述:</p><ul><li>该方法用于绘制上下文工具.</li><li>如果是绘制平面图形使用 <code>&#39;2d&#39;</code>作为参数, 如果绘制立体图形使用 <code>&#39;webgl&#39;</code>.</li><li>使用 <code>&#39;2d&#39;</code> 返回 <code>CanvasRenderingContext2D</code> 类型的对象.</li><li>使用 <code>&#39;webgl&#39;</code> 返回 <code>WebGLRenderingContext</code> 类型的对象.</li></ul><h4 id="moveTo-方法"><a href="#moveTo-方法" class="headerlink" title="moveTo 方法"></a>moveTo 方法</h4><p>语法: <code>CanvasRenderingContext2D.moveTo(x, y)</code></p><p>描述:</p><ul><li>该方法用于设置绘制起点.</li><li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li></ul><h4 id="lineTo-方法"><a href="#lineTo-方法" class="headerlink" title="lineTo 方法"></a>lineTo 方法</h4><p>语法: <code>CanvasRenderingContext2D.lineTo(x, y)</code></p><p>描述:</p><ul><li>该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点.</li><li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li></ul><h4 id="stroke-方法"><a href="#stroke-方法" class="headerlink" title="stroke 方法"></a>stroke 方法</h4><p>语法: <code>CanvasRenderingContext2D.stroke()</code></p><p>描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来.</p><p><strong>总结</strong></p><ul><li>绘图先要获得上下文, 即绘图工具</li><li>绘图需要设置开始的坐标</li><li>绘图是先描点, 然后一个一个依次连线</li><li>依次绘图只能绘制单一样式(色彩等)</li></ul><p>绘制直线图形</p><ul><li>绘制直线计算坐标.</li><li>描边调用 <code>CanvasRenderingContext2D.stroke()</code> 方法.</li><li>填充使用 <code>CanvasRenderingContext2D.fill()</code> 方法.</li></ul><h4 id="fill-方法"><a href="#fill-方法" class="headerlink" title="fill 方法"></a>fill 方法</h4><p>语法: <code>CanvasRenderingContext2D.fill()</code></p><p>描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.</p><h3 id="非零环绕原则"><a href="#非零环绕原则" class="headerlink" title="非零环绕原则"></a>非零环绕原则</h3><p>非零环绕原则</p><p><img src="/images/canvas03.jpg" alt="canvas03"></p><p>说明:</p><ul><li>在 canvas 中使用各种方法描点实际上描述的是一个称为路径( path )的东西.</li><li>在 canvas 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果.</li><li>每一个路径都是一个状态.</li></ul><h3 id="闭合路径"><a href="#闭合路径" class="headerlink" title="闭合路径"></a>闭合路径</h3><p><strong>closePath 方法</strong></p><p>语法: <code>CanvasRenderingContext2D.closePath()</code></p><p>描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.</p><p><strong>闭合路径的一个例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ctx.moveTo( <span class="number">100</span>, <span class="number">100</span> );</span><br><span class="line">ctx.lineTo( <span class="number">300</span>, <span class="number">100</span> );</span><br><span class="line">ctx.lineTo( <span class="number">300</span>, <span class="number">200</span> );</span><br><span class="line">ctx.closePath();</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>结果为:</p><p><img src="/images/闭合路径.png" alt="闭合路径"></p><h3 id="路径的概念"><a href="#路径的概念" class="headerlink" title="路径的概念"></a>路径的概念</h3><ul><li>路径就是一次绘图<ul><li>类比使用油漆刷墙面</li><li>首先打底色, 绝对不会一次性使用多个色彩</li><li>一定是先画完某一个色彩再考虑另一个色彩</li><li>除非需要自己创作才会考虑墙面绘画</li></ul></li><li>路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域.</li><li>如果需要开启新的绘制, 那么使用 <code>CanvasRenderingContext2D.beginPath()</code> 方法.</li></ul><h3 id="线型相关属性"><a href="#线型相关属性" class="headerlink" title="线型相关属性"></a>线型相关属性</h3><p>设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果</p><ul><li><code>CanvasRenderingContext2D.lineWidth</code> 设置线宽.</li><li><code>CanvasRenderingContext2D.lineCap</code> 设置线末端类型.</li><li><code>CanvasRenderingContext2D.lineJoin</code> 设置相交线的拐点.</li><li><code>CanvasRenderingContext2D.getLineDash()</code> 获得线段样式数组.</li><li><code>CanvasRenderingContext2D.setLineDash()</code> 设置线段样式.</li><li><code>CanvasRenderingContext2D.lineDashOffset</code> 绘制线段偏移量.</li></ul><h3 id="设置线宽"><a href="#设置线宽" class="headerlink" title="设置线宽"></a>设置线宽</h3><p>语法: <code>CanvasRenderingContext2D.lineWidth = number</code></p><p>描述: 设置线宽.</p><h3 id="设置线末端类型"><a href="#设置线末端类型" class="headerlink" title="设置线末端类型"></a>设置线末端类型</h3><p>语法: <code>CanvasRenderingContext2D.lineCap = value</code></p><p>描述:</p><p>设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’.</p><ul><li>‘butt’ 表示两端使用方形结束.</li><li>‘round’ 表示两端使用圆角结束.</li><li>‘square’ 表示突出的圆角结束.</li></ul><h3 id="设置相交线的拐点"><a href="#设置相交线的拐点" class="headerlink" title="设置相交线的拐点"></a>设置相交线的拐点</h3><p>语法: <code>CanvasRenderingContext2D.lineJoin = value</code></p><p>描述:</p><p>设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认)</p><ul><li>‘round’ 使用圆角连接.</li><li>‘bevel’ 使用平切连接.</li><li>‘miter’ 使用直角转.</li></ul><h3 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h3><p>语法:</p><p><code>CanvasRenderingContext2D.lineDashOffset = number</code><br><code>CanvasRenderingContext2D.getLineDash()</code><br><code>CanvasRenderingContext2D.setLineDash()</code></p><p>描述:</p><ul><li>setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移.</li><li>getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.</li></ul><h3 id="填充与描边样式"><a href="#填充与描边样式" class="headerlink" title="填充与描边样式"></a>填充与描边样式</h3><p>语法:</p><p><code>CanvasRenderingContext2D.strokeStyle = value</code><br><code>CanvasRenderingContext2D.fillStyle = value</code></p><p>描述:</p><ul><li><code>strokeStyle</code> 可以设置描边颜色, 与 CSS 的语法一样</li><li><code>fillStyle</code> 设置填充颜色, 与 CSS 语法一样</li></ul><p>这两个属性还可以设置渐变对象.</p><p>一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">        ctx.strokeStyle = <span class="string">'rgb(0,'</span> + <span class="built_in">Math</span>.floor(<span class="number">255</span><span class="number">-42.5</span>*i) + <span class="string">','</span> + <span class="built_in">Math</span>.floor(<span class="number">255</span><span class="number">-42.5</span>*j) + <span class="string">')'</span>;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(<span class="number">12.5</span>+j*<span class="number">25</span>,<span class="number">12.5</span>+i*<span class="number">25</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h2><p>绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法</p><ul><li>绘制矩形</li><li>绘制圆弧</li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>绘制矩形的方法</p><ul><li><code>CanvasRenderingContext2D.strokeRect</code></li><li><code>CanvasRenderingContext2D.fillRect</code></li><li><code>CanvasRenderingContext2D.rect</code></li></ul><p>注意: rect 方法就是矩形路径, 还需要使用 fill 或 stroke 才可以看到效果. 因此一般使用 strokeRect 或 fillRect 直接可以看到结果.</p><p>清除矩形区域: <code>CanvasRenderingContext2D.clearRect</code></p><h4 id="绘制矩形框"><a href="#绘制矩形框" class="headerlink" title="绘制矩形框"></a>绘制矩形框</h4><p>语法: <code>CanvasRenderingContext2D.strokeRect(x, y, width. height)</code></p><p>描述:</p><ul><li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li><li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li><li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 <code>stroke</code> 等绘画方法.</li><li>绘制的矩形支持 <code>strokeStyle</code> 设置颜色样式.</li></ul><h4 id="绘制填充矩形"><a href="#绘制填充矩形" class="headerlink" title="绘制填充矩形"></a>绘制填充矩形</h4><p>语法: <code>CanvasRenderingContext2D.fillRect(x, y, width. height)</code></p><p>描述:</p><ul><li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li><li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li><li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 stroke 等绘画方法.</li><li>绘制的矩形支持 <code>fillStyle</code> 设置颜色样式.</li></ul><h4 id="清除矩形区域"><a href="#清除矩形区域" class="headerlink" title="清除矩形区域"></a>清除矩形区域</h4><p>语法: <code>CanvasRenderingContext2D.clearRect(x, y, width, height)</code></p><p>描述:</p><ul><li>用于清除画布中的矩形区域的内容.</li><li>参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高.</li></ul><h3 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h3><p>绘制圆弧的方法有</p><ul><li>CanvasRenderingContext2D.arc()</li><li>CanvasRenderingContext2D.arcTo()</li></ul><h4 id="绘制圆弧-1"><a href="#绘制圆弧-1" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h4><p>语法: <code>CanvasRenderingContext2D.arc(x, y, radius. startAngle. endAngle, anticlockwise)</code></p><p>描述:</p><ul><li>该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形.</li><li>方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标.</li><li>参数 radius 表示圆弧半径, 单位为弧度.</li><li>参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向.</li><li>参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选.</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 如果设置了 moveTo, 那么会连线该点与圆弧的起点.<br>如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 会自动闭合路径填充.</p><h4 id="绘制扇形"><a href="#绘制扇形" class="headerlink" title="绘制扇形"></a>绘制扇形</h4><p>绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">  ctx.fillStyle = <span class="string">'pink'</span>;</span><br><span class="line">  ctx.moveTo( <span class="number">100</span>, <span class="number">200</span> );</span><br><span class="line">  ctx.arc( <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, -<span class="built_in">Math</span>.PI/<span class="number">3</span>, <span class="built_in">Math</span>.PI/<span class="number">3</span> );</span><br><span class="line">  ctx.closePath();</span><br><span class="line">  ctx.stroke();</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo( <span class="number">300</span>, <span class="number">200</span> );</span><br><span class="line">  ctx.arc( <span class="number">300</span>, <span class="number">200</span>, <span class="number">100</span>, -<span class="built_in">Math</span>.PI/<span class="number">3</span>, <span class="built_in">Math</span>.PI/<span class="number">3</span> );</span><br><span class="line">  ctx.closePath();</span><br><span class="line">  ctx.fill();</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="/images/扇形.png" alt="扇形"></p><h4 id="绘制饼形图"><a href="#绘制饼形图" class="headerlink" title="绘制饼形图"></a>绘制饼形图</h4><p>绘制饼形图最大的特点是角度是叠加的. 开始从 <code>-Math.PI/2</code> 开始绘制, 达到执行角 x 后, 下一个区域从 x 开始绘制, 然后有到一个角 y 停下来. 如此反复到 <code>Math.PI * 3 / 2</code> 结束.</p><h5 id="三等分饼形图"><a href="#三等分饼形图" class="headerlink" title="三等分饼形图"></a>三等分饼形图</h5><p>绘制一个三等分的饼形图, 颜色使用 红, 绿, 蓝.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">200</span>, y = <span class="number">200</span>,</span><br><span class="line">    r = <span class="number">100</span>,</span><br><span class="line">    step = <span class="built_in">Math</span>.PI * <span class="number">2</span> / <span class="number">3</span>,     <span class="comment">// 120 度一个区域</span></span><br><span class="line">    start = -<span class="built_in">Math</span>.PI / <span class="number">2</span>,       <span class="comment">// 起始角度</span></span><br><span class="line">    colors = [ <span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span> ];</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo( x, y );</span><br><span class="line">    ctx.fillStyle = colors[ i ];</span><br><span class="line">    ctx.arc( x, y, r, start, start+=step );</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制相切弧"><a href="#绘制相切弧" class="headerlink" title="绘制相切弧"></a>绘制相切弧</h4><p>语法: <code>CanvasRenderingContext2D.arcTo( x1, y1, x2, y2, radius)</code></p><p>描述:该方法用于绘制圆弧</p><ul><li>绘制的规则是当前位置与第一个参考点连线, 绘制的弧与该直线相切.</li><li>同时连接两个参考点, 圆弧根据半径与该连线相切</li></ul><p>例如有一个起始点 (100, 100), 那么绘制其点. 颜色设置为红色.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">100</span> - <span class="number">4</span>, <span class="number">100</span> - <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>然后两个参考点分别为 (100, 300) 和 (300, 300), 绘制出该点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillRect(<span class="number">100</span> - <span class="number">4</span>, <span class="number">300</span> - <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">ctx.fillRect(<span class="number">300</span> - <span class="number">4</span>, <span class="number">300</span> - <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>连接两个参考点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">300</span>);</span><br><span class="line">ctx.lineTo(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>得到效果为:</p><p><img src="/images/相切.png" alt="相切"></p><p>调用 arcTo 方法绘制圆弧. 记得将起始点设置为 (100, 100)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">ctx.moveTo(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.arcTo(<span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">100</span>);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>得到效果：</p><p><img src="/images/相切2.png" alt="相切2"></p><p>注意: 使用该方法可以使用圆弧连接两条直线, 而不用计算复杂的起始角度与结束角度. 因此用于绘制圆角矩形等案例较多.</p><h4 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h4><p>封装一个函数, 用于绘制圆角矩形.</p><ul><li>参考 rect 方法, 需要坐标参数 x, y.</li><li>由于设置圆角, 因此需要设置圆角半径 cornerRadius.</li><li>还需要提供宽高.</li><li>首先绘制一个矩形边框. 但是需要考虑圆角, 虽然从 x, y 开始绘制, 但是中间要空出半径的距离.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span>, y = <span class="number">100</span>, width = <span class="number">300</span>, height = <span class="number">100</span>, cornerRadius = <span class="number">10</span>;</span><br><span class="line">ctx.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">ctx.moveTo(x + cornerRadius, y);</span><br><span class="line">ctx.lineTo(x + width - cornerRadius, y);</span><br><span class="line">ctx.moveTo(x + width, y + cornerRadius);</span><br><span class="line">ctx.lineTo(x + width, y + height - cornerRadius);</span><br><span class="line">ctx.moveTo(x + width - cornerRadius, y + height);</span><br><span class="line">ctx.lineTo(x + cornerRadius, y + height);</span><br><span class="line">ctx.moveTo(x, y + height - cornerRadius);</span><br><span class="line">ctx.lineTo(x, y + cornerRadius);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>效果为 </p><p><img src="/images/缺圆角的矩形.png" alt="缺圆角的矩形"></p><p>然后再分别绘制四个角, 设置当前位置与参考点的位置. 设置当前位置为一个线端点, 然后参考点依次就是 矩形顶点 和 另一个线段的端点.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(x + cornerRadius, y);</span><br><span class="line">ctx.arcTo(x, y, x, y + cornerRadius, cornerRadius);</span><br></pre></td></tr></table></figure><p>即可得到</p><p><img src="/images/得到一个圆角的矩形.png" alt="得到一个圆角的矩形"></p><p>同理绘制另外三个圆角</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(x + width - cornerRadius, y);</span><br><span class="line">ctx.arcTo(x + width, y, x + width, y + cornerRadius, cornerRadius);</span><br><span class="line">ctx.moveTo(x + width, y + height - cornerRadius);</span><br><span class="line">ctx.arcTo(x + width, y + height, x + width - cornerRadius, y + height, cornerRadius);</span><br><span class="line">ctx.moveTo(x + cornerRadius, y + height);</span><br><span class="line">ctx.arcTo(x, y + height, x, y + height - cornerRadius, cornerRadius);</span><br></pre></td></tr></table></figure><p>即可得到</p><p><img src="/images/得到四个圆角的矩形.png" alt="得到四个圆角的矩形"></p><p>封装成方法就可以绘制更多圆角矩形了. 封装中注意 <code>beginPath()</code> 和 <code>save()</code> 和 <code>restore()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cRect</span> (<span class="params">x, y, width, height, cornerRadius, color</span>) </span>&#123;</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.strokeStyle = color || <span class="string">'red'</span>;</span><br><span class="line">    ctx.moveTo(x + cornerRadius, y);</span><br><span class="line">    ctx.lineTo(x + width - cornerRadius, y);</span><br><span class="line">    ctx.moveTo(x + width, y + cornerRadius);</span><br><span class="line">    ctx.lineTo(x + width, y + height - cornerRadius);</span><br><span class="line">    ctx.moveTo(x + width - cornerRadius, y + height);</span><br><span class="line">    ctx.lineTo(x + cornerRadius, y + height);</span><br><span class="line">    ctx.moveTo(x, y + height - cornerRadius);</span><br><span class="line">    ctx.lineTo(x, y + cornerRadius);</span><br><span class="line">    <span class="comment">// 开始绘制四个圆角</span></span><br><span class="line">    ctx.moveTo(x + cornerRadius, y);</span><br><span class="line">    ctx.arcTo(x, y, x, y + cornerRadius, cornerRadius);</span><br><span class="line">    ctx.moveTo(x + width - cornerRadius, y);</span><br><span class="line">    ctx.arcTo(x + width, y, x + width, y + cornerRadius, cornerRadius);</span><br><span class="line">    ctx.moveTo(x + width, y + height - cornerRadius);</span><br><span class="line">    ctx.arcTo(x + width, y + height, x + width - cornerRadius, y + height, cornerRadius);</span><br><span class="line">    ctx.moveTo(x + cornerRadius, y + height);</span><br><span class="line">    ctx.arcTo(x, y + height, x, y + height - cornerRadius, cornerRadius);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    ctx.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><p>绘制文本的方法</p><ul><li><code>CanvasRenderingContext2D.fillText()</code></li><li><code>CanvasRenderingContext2D.strokeText()</code></li><li><code>CanvasRenderingContext2D.measureText()</code></li></ul><p>文本样式</p><ul><li><code>CanvasRenderingContext2D.font</code></li><li><code>CanvasRenderingContext2D.textAlign</code></li><li><code>CanvasRenderingContext2D.textBaseline</code></li></ul><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>语法:</p><ul><li><code>CanvasRenderingContext2D.strokeText(text, x, y[, maxWidth])</code></li><li><code>CanvasRenderingContext2D.fillText(text, x, y[, maxWidth])</code></li></ul><p>描述:</p><p>这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制.</p><h3 id="计算文本尺寸"><a href="#计算文本尺寸" class="headerlink" title="计算文本尺寸"></a>计算文本尺寸</h3><p>语法: <code>CanvasRenderingContext2D.measureText()</code></p><p>描述:</p><p>该方法返回一个文本尺寸对象, TextMetrics 对象.TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度.</p><h3 id="设置文字属性"><a href="#设置文字属性" class="headerlink" title="设置文字属性"></a>设置文字属性</h3><h4 id="设置文字字体"><a href="#设置文字字体" class="headerlink" title="设置文字字体"></a>设置文字字体</h4><p>语法: <code>CanvasRenderingContext2D.font = value</code></p><p>描述:</p><ul><li>该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等.</li><li>其顺序可以是: style | variant | weight | size/line-height | family.</li><li>默认值为 10px sans-serif</li></ul><h4 id="设置字体水平对齐方式"><a href="#设置字体水平对齐方式" class="headerlink" title="设置字体水平对齐方式"></a>设置字体水平对齐方式</h4><p>语法: <code>CanvasRenderingContext2D.textAlign = value</code></p><p>描述:</p><ul><li>该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等.</li><li>该属性可以设置的值有: start( 默认 ), end, left, right, center.</li><li>start 表示根据参考基准点的垂直直线左靠对齐</li><li>end 表示根据参考基准点的垂直直线右靠对齐</li><li>left 与 right 就是左对齐与右对齐的意思</li><li>最后 center 就是居中的含义.</li></ul><h4 id="设置字体垂直对齐方式"><a href="#设置字体垂直对齐方式" class="headerlink" title="设置字体垂直对齐方式"></a>设置字体垂直对齐方式</h4><p>语法: <code>CanvasRenderingContext2D.textBaseline = value</code></p><p>描述:</p><ul><li>该方法设置文字在垂直方向上的对齐方式.</li><li>该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic</li><li>基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐.</li><li>alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母.</li><li>ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下.</li><li>所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle.</li><li>top, middle, bottom 使用的较多</li></ul><p><code>alphabetic</code> 表示字母参考线, <code>ideographic</code> 会比它低一点, <code>hanging</code> 表示悬挂.</p><p>实际上大多数参考方式只有在特定语言中有作用, 而且与字体也有相对复杂的关系. 例如( 下图是有部分错误的 ):</p><h2 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h2><p>绘制图像虽然只有一个 <code>drawImage</code> 函数, 但是该函数有多重参数形式.</p><ul><li><code>CanvasRenderingContext2D.drawImage( img, dx, dy )</code></li><li><code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )</code></li><li><code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )</code></li></ul><h3 id="绘制简单图像"><a href="#绘制简单图像" class="headerlink" title="绘制简单图像"></a>绘制简单图像</h3><p>语法: <code>CanvasRenderingContext2D.drawImage(img, dx, dy)</code></p><p>描述:</p><ul><li>使用三个参数, 允许在画布上的 任意位置 绘制图片.</li><li>参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等.</li><li>需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载.</li></ul><p>准备一张网络图片, 绘制, 便于查看其加载过程.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随便从百度中搜索 '美女头像', 记录一个链接地址</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg'</span>;</span><br><span class="line"><span class="comment">// 创建 img 对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image(); <span class="comment">// 就是 img 标签</span></span><br><span class="line"><span class="comment">// 设置 src 属性为 图片</span></span><br><span class="line">img.src = url;</span><br><span class="line"><span class="comment">// 绘图</span></span><br><span class="line">ctx.drawImage( img, <span class="number">100</span>, <span class="number">100</span> );</span><br></pre></td></tr></table></figure><p>此时没有任何结果, 打开调试工具查看 Net Work;</p><p>因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随便从百度中搜索 '美女头像', 记录一个链接地址</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg'</span>;</span><br><span class="line"><span class="comment">// 创建 img 对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image(); <span class="comment">// 就是 img 标签</span></span><br><span class="line"><span class="comment">// 设置 src 属性为 图片</span></span><br><span class="line">img.src = url;</span><br><span class="line"><span class="comment">// 绘图</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.drawImage(img, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意: 这里使用 <code>new Image()</code>与 <code>document.createElement(&#39;img&#39;)</code>是一样的.</p><h3 id="在指定区域内绘制图像"><a href="#在指定区域内绘制图像" class="headerlink" title="在指定区域内绘制图像"></a>在指定区域内绘制图像</h3><p>当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布。因此, 需要将其控制在一个矩形区域内绘制.</p><p>语法:<code>CanvasRenderingContext2D.drawImage(img, dx, dy, dWidth, dHeight)</code></p><p>描述:</p><ul><li>参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始.</li><li>该方法绘制的图像会在指定范围内被压缩显示.</li></ul><p>如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> heigth = <span class="number">100</span>, width;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    width = img.width * height / img.height;</span><br><span class="line">    ctx.drawImage( img, <span class="number">100</span>, <span class="number">100</span>, width, height );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="绘制任意图像"><a href="#绘制任意图像" class="headerlink" title="绘制任意图像"></a>绘制任意图像</h3><p>类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区.</p><p>语法: <code>CanvasRenderingContext2D.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></p><p>描述: 这里的带有 s 前缀的参数就是指图源的矩形区域.</p><p>例如将图片的 ( 100, 100, 300, 200 ) 处的内容绘制到页面的 ( 100, 100, 300, 200 ) 的位置.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.drawImage(img, <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>,  <span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有:</p><ul><li><code>CanvasRenderingContext2D.transform()</code></li><li><code>CanvasRenderingContext2D.scale()</code></li><li><code>CanvasRenderingContext2D.translate()</code></li><li><code>CanvasRenderingContext2D.rotate()</code></li><li><code>CanvasRenderingContext2D.setTransForm()</code></li></ul><p>还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法.</p><h3 id="什么是变换"><a href="#什么是变换" class="headerlink" title="什么是变换"></a>什么是变换</h3><p>计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果.</p><h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><p>平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了.</p><p>语法: <code>CanvasRenderingContext2D.translate(x, y)</code></p><p>描述:</p><ul><li>该方法将坐标进行平移.</li><li>x 表示水平移动, 正数向右, 负数向左.</li><li>y 表示垂直移动, 正数向下, 负数向上.</li><li>变换可以重复调用, 变换是可以累加的.</li><li>使用该变换, 常常用于绘制不同位置, 但是形状重复的图形.</li></ul><p>注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换.</p><h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>语法: <code>CanvasRenderingContext2D.rotate(radian)</code></p><p>描述:</p><ul><li>该方法将坐标轴进行旋转变换.</li><li>参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转.</li><li>该变换常常用于实现旋转动画等.</li></ul><h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p>语法: <code>CanvasRenderingContext2D.scale(x, y)</code></p><p>描述:</p><ul><li>该方法实现水平与垂直的缩放.</li><li>参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li><li>参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li><li>该变换常常用于放大与缩小, 以及反转的效果.</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码.</p><p>Canvas 中引入了状态的保持机制. 使用 <code>CanvasRenderingContext2D.save()</code> 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 <code>CanvasRenderingContext2D.restore()</code> 方法即可.</p><p>状态保持的机制是基于状态栈实现的. 也就是说 <code>save</code> 一次就存储一个状态. <code>restore</code> 一次就将刚刚存入的恢复. 如果 <code>save</code> 两次, 就需要 <code>restore</code> 两次, 才可以恢复到最先的状态.</p><p>一般在封装绘图的时候都会采用开始绘制之前, <code>save</code> 一次, 然后 开启一个新路径, 然后绘制结束后 <code>restore</code>, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响.</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>canvas 在绘制图片的时候, <code>drawImage</code> 方法还支持将一个 <code>canvas</code> 绘制到另一个 <code>canvas</code> 中. 因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 <code>canvas</code> 中合成需要的效果.</p><h2 id="画布保存"><a href="#画布保存" class="headerlink" title="画布保存"></a>画布保存</h2><p>画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 <code>base64</code> 编码的字符串.</p><p>语法: <code>Canvas.ToDataURL(type, encoderOptions)</code></p><p>描述:</p><ul><li>该方法可以将画布转换成 base64 格式的数据</li><li>type 表示输出类型. 例如: image/png 或 image/jpeg 等</li><li>encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用</li></ul><h2 id="渐变和图案"><a href="#渐变和图案" class="headerlink" title="渐变和图案"></a>渐变和图案</h2><p>绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 <code>strokeStyle</code> 和 <code>fillStyle</code> 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复.</p><p>相关方法</p><ul><li><code>CanvasRenderingContext2D.createLinearGradient()</code></li><li><code>CanvasRenderingContext2D.createRadialGradient()</code></li><li><code>CanvasRenderingContext2D.createPattern()</code></li></ul><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>语法: <code>CanvasRenderingContext2D.createLinearGradient(x0, y0, x1, y1)</code></p><p>描述:</p><ul><li>该方法返回一个 <code>CanvasGradient</code> 对象. 用于描述渐变的方式.</li><li>该方法有两个参数, 用于表示线型渐变的方向与位置.</li><li>使用的时候, 首先创建一个 <code>CanvasGradient</code> 对象, 然后利用 <code>addColorStop</code> 方法添加颜色区间.</li><li>方法语法: <code>CanvasGradient.addColorStop( rate, color )</code>.</li><li>该方法用于设置在某个比例位置的颜色是什么.<code>rate</code> 的取值是 0 到 1 之间.</li><li>可以添加多个渐变点.</li><li>然后将该对象赋值给 <code>*Style</code> 属性即可.</li></ul><p>注意: 渐变点的坐标是基于坐标轴来计算的.</p><h3 id="放射渐变"><a href="#放射渐变" class="headerlink" title="放射渐变"></a>放射渐变</h3><p>语法: <code>CanvasRenderingContext2D.createRadialGradient(x0, y0, r0, x1, y1, r1)</code></p><p>描述:</p><ul><li>该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆.</li><li>前三个参数分别表示其中一个圆的圆心的坐标, 以及半径.</li><li>后三个参数分别表示另一个圆的圆心的坐标, 以及半径.</li><li>绘制渐变效果用法与线性渐变一样.</li></ul><h3 id="重复填充"><a href="#重复填充" class="headerlink" title="重复填充"></a>重复填充</h3><p>语法: <code>CanvasRenderingContext2D.createPattern(img, repetition)</code></p><p>描述:</p><ul><li>该方法表示使用图片来填充的设置方法. 需要两个参数, 一个是图片, 一个是重复的方式.</li><li>图片允许是 img 标签, 图片, canvas 等对象</li><li>可选择的重复方式与 CSS 一致. 有: repeat, repeat-x, repeat-y, no-repeat.</li><li>如果是 空或””, 但不是 undefined, 默认就是 repeat.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Canvas&quot;&gt;&lt;a href=&quot;#什么是-Canvas&quot; class=&quot;headerlink&quot; title=&quot;什么是 Canvas&quot;&gt;&lt;/a&gt;什么是 Canvas&lt;/h2&gt;&lt;p&gt;canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布.在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.&lt;/p&gt;
    
    </summary>
    
      <category term="Canvas系列" scheme="http://yoursite.com/categories/Canvas%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>js的表单</title>
    <link href="http://yoursite.com/2015/11/08/js%E7%9A%84%E8%A1%A8%E5%8D%95/"/>
    <id>http://yoursite.com/2015/11/08/js的表单/</id>
    <published>2015-11-07T16:00:00.000Z</published>
    <updated>2018-06-01T06:17:22.464Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局限。</p><h2 id="表单基础"><a href="#表单基础" class="headerlink" title="表单基础"></a>表单基础</h2><p>HTML 中表单是由 <code>&lt;form&gt;</code> 元素来表示的。在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。有下列属性和方法。</p><ul><li>acceptCharset: 服务器能够处理的字符串</li><li>action: 接收请求的 URL</li><li>elements: 表单中所有控件的集合</li><li>enctype: 请求的编码类型</li><li>length: 表单中所有的控件的数量</li><li>method: 表单要发送的 HTTP 请求类型，通常是 “get” 或者 “post”</li><li>name: 表单的名称</li><li>reset(); 将所有的表单域重置为默认值</li><li>submit(); 提交表单</li><li>target(); 用于发送请求和接收响应的窗口名称</li></ul><a id="more"></a><h3 id="共有表单的字段属性"><a href="#共有表单的字段属性" class="headerlink" title="共有表单的字段属性"></a>共有表单的字段属性</h3><ul><li>disabled: 布尔值，表示当前表单是否被占用。</li><li>form: 指向当前字段所属表单的指针；只读。</li><li>name: 当前字段名称。</li><li>readOnly: 布尔值，表示当前字段是否只读。</li><li>tabIndex: 表示当前字段的切换序号。</li><li>type: 当前字段的类型。</li><li>value: 当前字段将被提交给服务器的值。</li></ul><h3 id="共有的表单字段方法"><a href="#共有的表单字段方法" class="headerlink" title="共有的表单字段方法"></a>共有的表单字段方法</h3><ul><li>focus(); 用于将浏览器的焦点设置到表单字段。</li><li>blur();</li></ul><h3 id="共有的表单事件"><a href="#共有的表单事件" class="headerlink" title="共有的表单事件"></a>共有的表单事件</h3><ul><li>focus</li><li>blur</li><li>change：对于 <code>&lt;input&gt;</code> 和 <code>&lt;textaera&gt;</code> 元素，当它们失去焦点而且 value 值改变时该事件触发。</li><li>submit</li></ul><p>阻止表单默认的同步提交的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#form"</span>).on(<span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    <span class="comment">// 代码段</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><ul><li>type: text</li></ul><p>可以通过设置 size 的值指定文本框中能够显示的字符数，通过 value 设置文本框中的初始值，通过 maxlength 指定文本框可以接收的最大字符数。</p><h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><h4 id="选择文本-1"><a href="#选择文本-1" class="headerlink" title="选择文本"></a>选择文本</h4><ul><li>select() 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements(<span class="string">"textbox1"</span>);</span><br><span class="line">textbox.select();</span><br></pre></td></tr></table></figure><p>在文本获得焦点时选择所有文本。</p><h4 id="取得选择的文本"><a href="#取得选择的文本" class="headerlink" title="取得选择的文本"></a>取得选择的文本</h4><p>两个属性：</p><ul><li>selectionStart</li><li>selectionEnd</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textbox = <span class="built_in">document</span>.forms[<span class="number">0</span>].elements(<span class="string">"textbox1"</span>);</span><br><span class="line">textbox.select();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSelectedText</span>(<span class="params">textbox</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> textbox.value.substring(textbox.selectionStart, selectionEnd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IE9+, FireFox, Safari, Chrome, Opera 支持</p><h4 id="选择部分文本"><a href="#选择部分文本" class="headerlink" title="选择部分文本"></a>选择部分文本</h4><ul><li>setSelectionRange() 方法<ul><li>两个参数：要选择的第一个字符的索引和要选择的最后一个字符的索引</li></ul></li></ul><p>IE9+, FireFox, Safari, Chrome, Opera 支持</p><p>IE8 以及之前版本：必须先使用 <code>createTextRange()</code>,然后调用 <code>collapse()</code> 将范围折叠到文本框开始位置，使用 <code>moveStart()</code> 和 <code>moveEnd</code>。</p><h3 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h3><h4 id="屏蔽字符"><a href="#屏蔽字符" class="headerlink" title="屏蔽字符"></a>屏蔽字符</h4><p>屏蔽字符需要结合键盘码，如果需要屏蔽特定的字符，需要检测 keypress 事件对应的字符编码，然后再做决定如何响应。</p><h4 id="操作剪切板"><a href="#操作剪切板" class="headerlink" title="操作剪切板"></a>操作剪切板</h4><p>剪切板事件。</p><ul><li>beforecopy</li><li>copy</li><li>beforecut</li><li>cut</li><li>beforepaste</li><li>paste</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  <span class="comment">// 其它代码省略...</span></span><br><span class="line">  getClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">    <span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.clipboardData) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><p>常见的一种方式是用户在填写完当前字段时，自动将焦点切换到下一个字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tabForword</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">  <span class="keyword">if</span> (target.value.length == target.maxLength) &#123;</span><br><span class="line">    <span class="keyword">var</span> form = target.form;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; form.elements.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (form.elements[i] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (form.elements[i+<span class="number">1</span>]) &#123;</span><br><span class="line">          form.elements[i+<span class="number">1</span>].focus();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTML5-约束验证-API"><a href="#HTML5-约束验证-API" class="headerlink" title="HTML5 约束验证 API"></a>HTML5 约束验证 API</h3><p>支持的浏览器 FireFox 4+, Safari 5+, Chrome, Opera 10+。</p><h4 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h4><ul><li>required</li></ul><p>检查是否支持 required 字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isRequiredSupported = <span class="string">"required"</span> <span class="keyword">in</span> <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br></pre></td></tr></table></figure><h4 id="其它输入类型"><a href="#其它输入类型" class="headerlink" title="其它输入类型"></a>其它输入类型</h4><p>HTML5 为 type 又添加了几个类型：</p><ul><li>url</li><li>email</li></ul><h4 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h4><ul><li>number</li><li>range</li><li>datetime</li><li>datetime-local</li><li>date</li><li>month</li><li>week</li><li>time</li></ul><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>HTML5 新增了 pattern 属性，值是正则表达式。</p><h4 id="检验有效性"><a href="#检验有效性" class="headerlink" title="检验有效性"></a>检验有效性</h4><ul><li>checkValidty() 方法</li><li>validity 对象</li><li>customError</li><li>patternMismatch</li><li>rangeOverflow</li><li>stepMisMatch</li><li>tooLong</li><li>typeMismatch</li><li>valid</li><li>valueMissing</li></ul><h4 id="禁用验证"><a href="#禁用验证" class="headerlink" title="禁用验证"></a>禁用验证</h4><ul><li>novalidate 属性，表单不验证</li><li>formnovalidate 属性，某个提交按钮不验证</li></ul><h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><p>是通过 <code>&lt;select&gt;</code> 和 <code>&lt;option&gt;</code>。</p><ul><li>add(newOption, relOption): 向控件中插入新的 <code>&lt;option&gt;</code> 元素，其位置在相关项之前。</li><li>multiple: 允许多选</li><li>options: 所有 <code>&lt;option&gt;</code> 的集合</li><li>remove(index): 移除给定位置的选项</li><li>selectedIndex: 基于 0 的选中项的索引</li><li>size: 选择框中可见行数</li></ul><h3 id="选择选项"><a href="#选择选项" class="headerlink" title="选择选项"></a>选择选项</h3><ul><li>appendChild()</li><li>new Option(“Option text”, “Option value”);</li></ul><h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><p>浏览器给服务器发送数据：</p><ul><li>对表单中的字段的名称和值进行 URL 编码，使用 &amp; 分隔</li><li>不发送禁用的表单字段</li><li>只发送勾线的复选框和单选按钮</li><li>单选选择框中的每个选中的值单独一个条目</li><li>在单击提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。</li><li><code>&lt;select&gt;</code> 元素的值，就是选中的 <code>&lt;option&gt;</code> 元素的 value 特性的值。如果 <code>&lt;option&gt;</code> 元素没有 value 属性，则是 <code>&lt;option&gt;</code> 元素的文本值。</li></ul><p>表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serialize</span>(<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> parts = [],</span><br><span class="line">    field = <span class="literal">null</span>,</span><br><span class="line">    i,</span><br><span class="line">    len,</span><br><span class="line">    j,</span><br><span class="line">    optLen,</span><br><span class="line">    option,</span><br><span class="line">    optValue;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, len = form.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">    field = form.elements[i];</span><br><span class="line">    <span class="keyword">switch</span>(field.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"select-one"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"select-multipule"</span>:</span><br><span class="line">        <span class="keyword">if</span> (field.name.length) &#123;</span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>, optLen = field.options.length; j &lt; optLen; j++) &#123;</span><br><span class="line">            option = field.options[j];</span><br><span class="line">            <span class="keyword">if</span> (option.selected) &#123;</span><br><span class="line">              optValue = <span class="string">""</span>;</span><br><span class="line">              <span class="keyword">if</span> (option.hasAttribute) &#123;</span><br><span class="line">                optValue = (option.hasAttribute(<span class="string">"value"</span>) ? option.value : option.text);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                optValue = (option.attributes[<span class="string">"values"</span>].specified ? option.value : option.text);</span><br><span class="line">              &#125;</span><br><span class="line">              parts.push(encodeURLComponent(field.name) + <span class="string">"="</span> + encodeURLComponent(optValue));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">undefined</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"file"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"reset"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"submit"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"button"</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"radio"</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"checkbox"</span>:</span><br><span class="line">        <span class="keyword">if</span> (!field.name.length) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (field.name.length) &#123;</span><br><span class="line">          parts.push(encodeURLComponent(field.name) + <span class="string">"="</span> + encodeURLComponent(field.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parts.join(<span class="string">"&amp;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"blank.html"</span> name=<span class="string">"richedit"</span> style=<span class="string">"height: 100px; width: 100px;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  EventUtil.addHandler(<span class="built_in">window</span>, <span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    frames[<span class="string">"richedit"</span>].document.designMode = <span class="string">"on"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">`</span></span><br></pre></td></tr></table></figure><p>给 <code>&lt;iframe&gt;</code> 指定一个简单的 HTML 页面作为其内容来源。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Blank Page <span class="keyword">for</span> Rich Text Editing&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p>页面中就会有一个类似文本框的可编辑区字段。</p><h3 id="使用-contenteditable-属性"><a href="#使用-contenteditable-属性" class="headerlink" title="使用 contenteditable 属性"></a>使用 contenteditable 属性</h3><p>为页面中的某个元素设置 contenteditable 属性，这个元素中的任何文本内容就可以编辑了。</p><h3 id="操作富文本"><a href="#操作富文本" class="headerlink" title="操作富文本"></a>操作富文本</h3><p>与富文本交互的主要方式，使用document.execCommand(); 三个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值，第二个参数应始终设为 false。下面就是支持的命令。</p><ul><li>backcolor</li><li>bold</li><li>createlink</li><li>cut</li><li>delete</li><li>fontname</li><li>forecolor</li><li>formatblock</li><li>indent</li><li>inserthorizontalrule</li><li>insertimage</li><li>insertorderedlist</li><li>insertunorderedlist</li><li>insertparagraph</li><li>italic</li><li>justfycenter</li><li>outdent</li><li>paste</li><li>removeformat</li><li>selectall</li><li>unlink</li></ul><h3 id="富文本选区"><a href="#富文本选区" class="headerlink" title="富文本选区"></a>富文本选区</h3><p>使用框架的 getSelection() 方法，可以确定实际选择的文本，该方法返回当前选择文本的 Selection 对象。有以下属性：</p><ul><li>anchorNode: 选区起点所在起点</li><li>anchorOffset</li><li>focusNode</li><li>focusOffset</li><li>isCollapsed</li><li>rangeCount</li></ul><p>方法：</p><ul><li>addRange(range)</li><li>collapse(node, offset)</li><li>collapseToEnd()</li><li>collapseToStart()</li><li>containsNode(node)</li><li>deleteFormDocument()</li><li>extend(node, offset)</li><li>getRangeAt(index)</li><li>removeAllRanges()</li><li>selectAllChildren(node)</li><li>toString()</li></ul><h3 id="表单和富文本"><a href="#表单和富文本" class="headerlink" title="表单和富文本"></a>表单和富文本</h3><p>富文本不会自动提交，需要手动创建表单和富文本的关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(form, <span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">  target.elements[<span class="string">"comments"</span>].value = frames[<span class="string">"richedit"</span>].document.body.innerHTML;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 最初的一个应用就是分担服务器处理表单的责任，打破处处依赖服务器的局限。&lt;/p&gt;
&lt;h2 id=&quot;表单基础&quot;&gt;&lt;a href=&quot;#表单基础&quot; class=&quot;headerlink&quot; title=&quot;表单基础&quot;&gt;&lt;/a&gt;表单基础&lt;/h2&gt;&lt;p&gt;HTML 中表单是由 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 元素来表示的。在 JavaScript 中，表单对应的则是 HTMLFormElement 类型。有下列属性和方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;acceptCharset: 服务器能够处理的字符串&lt;/li&gt;
&lt;li&gt;action: 接收请求的 URL&lt;/li&gt;
&lt;li&gt;elements: 表单中所有控件的集合&lt;/li&gt;
&lt;li&gt;enctype: 请求的编码类型&lt;/li&gt;
&lt;li&gt;length: 表单中所有的控件的数量&lt;/li&gt;
&lt;li&gt;method: 表单要发送的 HTTP 请求类型，通常是 “get” 或者 “post”&lt;/li&gt;
&lt;li&gt;name: 表单的名称&lt;/li&gt;
&lt;li&gt;reset(); 将所有的表单域重置为默认值&lt;/li&gt;
&lt;li&gt;submit(); 提交表单&lt;/li&gt;
&lt;li&gt;target(); 用于发送请求和接收响应的窗口名称&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="表单" scheme="http://yoursite.com/tags/%E8%A1%A8%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>js的事件</title>
    <link href="http://yoursite.com/2015/10/28/js%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2015/10/28/js的事件/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2018-06-01T06:17:17.146Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 与 HTML 之间的交互是通过 <strong>事件</strong> 实现的。事件三要素: 事件源.事件 = function(){ 事件处理程序 }；等价于 &lt;标签 事件= “事件处理程序”&gt;。</p><p>事件就是文档或浏览器窗口中发生的一些特定交互瞬间。包括事件类型、事件目标、事件处理程序、事件对象。</p><p>事件类型是用过用来说明发生什么类型事件的字符串。</p><p>事件目标是发生的事件或与之相关的对象。如 window、Document、Element 对象。以及由 XMLHTTPRequest 对象。</p><p>事件处理程序或事件监听程序是处理或响应事件的函数。</p><p>事件对象是与特定事件相关且包含有关该事件的详细信息的对象。</p><p>事件传播是浏览器决定哪个对象触发其事件处理程序的过程。当文档元素上发生某个类型的事件时，它们会在文档树上向上冒泡。</p><p>事件传播的另一中形式称为事件捕获，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获。</p><a id="more"></a><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是页面中接收事件的顺序。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件开始是由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级向上传播到较为不具体的节点。IE、FireFox、Chrome、Safari将事件一直冒泡到 window 上。</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>目的是在事件到达预定目标之前捕获它。不太具体的节点最先收到事件，而最具体的节点应该最后收到事件。</p><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件流的三个阶段：</p><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><p>在 DOM 事件流中，实际目标在捕获阶段不会接收到事件。下一个阶段是”处于目标阶段”，事件在目标上发生，并在事件处理中看成是冒泡阶段的一部分。然后，冒泡阶段发生。</p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><h3 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> name=<span class="string">"butt1"</span> value=<span class="string">"点我"</span> onclick=<span class="string">"console.log('我被点击了')"</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> name=<span class="string">"butt2"</span> value=<span class="string">"点我"</span> onclick=<span class="string">"showMsg()"</span>&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'被点了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="button" name="butt3" value="点我" onclick="console.log(event.type)"&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="button" name="butt4" value="点我" onclick="console.log(this.value)"&gt;</span></span><br></pre></td></tr></table></figure><p>event 变量可以直接访问事件对象。this 指的是触发事件的当前元素。</p><p>HTML 指定事件处理程序的缺点是：HTML 和 JavaScript 代码紧密耦合。</p><h3 id="DOM0-级事件处理程序"><a href="#DOM0-级事件处理程序" class="headerlink" title="DOM0 级事件处理程序"></a>DOM0 级事件处理程序</h3><p>将一个函数赋值给一个事件处理程序属性。优点：简单、跨浏览器的优势。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我被点击了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h3><p>定义了两个指定和删除事件处理程序的操作： addEventListener() 和 removeEventListener()；接收 3 个参数：</p><ul><li>要处理的事件名</li><li>作为事件处理程序的函数</li><li>一个布尔值：true 时表示在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序。</li></ul><h3 id="IE-的事件处理程序"><a href="#IE-的事件处理程序" class="headerlink" title="IE 的事件处理程序"></a>IE 的事件处理程序</h3><ul><li>attachEvent()</li><li>detachEvent()</li></ul><p>均接收两个参数，事件处理程序名称和事件处理程序函数。通过 attachEvent 添加的事件处理程序都会被添加到事件冒泡阶段。</p><h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>封装一个兼容的事件处理程序，参数是：要操作的元素、事件类型、事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeListener) &#123;</span><br><span class="line">      element.removeListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件相关的信息。包括：</p><ul><li>导致事件的元素</li><li>事件类型</li><li>事件相关信息</li></ul><h3 id="DOM-中的事件对象"><a href="#DOM-中的事件对象" class="headerlink" title="DOM 中的事件对象"></a>DOM 中的事件对象</h3><p>兼容 DOM 浏览器会将一个 event 对象传入到事件处理程序中。可以通过事件处理程序拿到 event 对象的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);   <span class="comment">// "click"</span></span><br><span class="line">&#125;</span><br><span class="line">btn.addEventlistener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);   <span class="comment">// "click"</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在通过 HTML 特性指定的事件处理程序，变量 event 保存着 event 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> name=<span class="string">"btn"</span> value=<span class="string">"点我"</span> onclick=<span class="string">"console.log(event.type)"</span> /&gt;</span><br></pre></td></tr></table></figure><p>event 对象包含与创建它的特定事件有关的属性和方法。触发的事件不同，可用的属性和方法也不一样。但所有事件都会有下表中列出的方法。</p><p>| 属性/方法 | 类型 | 读/写 | 说明 |<br>| bubbles | Boolean | 只读 | 表明是否冒泡 |<br>| cancelable | Boolean | 只读 | 是否可以取消事件的默认行为 |<br>| currentTarget | Element | 只读 | 事件处理程序当前正在处理事件的那个元素 |<br>| defaultPrevented | Boolean | 只读 | true 时表示调用了 perventDefault() |<br>| detail | Integer | 只读 | 事件相关的细节信息 |<br>| eventPhase | Integer | 只读 | 调用事件处理程序的阶段：1捕获 2处于目标 3冒泡 |<br>| perventDefault() | Function | 只读 | 取消事件默认行为，如果candelable是true可以使用这个方法 |<br>| stopImmediatePropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序调用 |<br>| stopPropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，如果 bubbles 为 true，则可以使用这个方法 |<br>| target | Element | 只读 | 事件目标 |<br>| trusted | Boolean | 只读 | 为 true 时表示浏览器生成的，为 false 时表示开发人员通过 javascript 创建的 |<br>| type | String | 只读 | 被触发的事件类型 |<br>| view | AbstractView | 只读 | 与事件相关联的抽象视图。等同于发生事件的 window 对象 |</p><p>在事件处理程序的内部，this 始终等于 currentTarget 的值，而 target 只包含事件的实际目标。如果时间处理程序指定给了目标元素。则这三个的值相等。</p><p>stopPropagation() 方法用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。</p><h3 id="IE-中的事件对象"><a href="#IE-中的事件对象" class="headerlink" title="IE 中的事件对象"></a>IE 中的事件对象</h3><p>event 对象作为 window 对象的一个属性存在。</p><p>| 属性/方法 | 类型 | 读/写 | 说明 |<br>| cancelables | Boolean | 读/写 | 默认值是 false，设置为 true 就可以取消事件冒泡 |<br>| returnValue | Boolean | 读/写 | 默认 true，设为 false 可以取消事件的默认行为 |<br>| srcElement | Element | 只读 | 事件的目标 |<br>| type | String | 只读 | 被触发的事件类型 |</p><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeListener) &#123;</span><br><span class="line">      element.removeListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><ul><li>UI 事件：用户与页面上的元素交互时触发；</li><li>焦点事件：元素获取焦点或失去焦点时触发</li><li>鼠标事件</li><li>滚轮事件</li><li>文本事件</li><li>键盘事件</li><li>合成事件</li><li>变动事件：底层 DOM 结构发生变化时触发</li></ul><h3 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h3><ul><li>DOMActive 已废弃</li><li>load: 页面完全加载后在 window 上触发</li><li>unload：页面卸载后在 window 上触发</li><li>abort：在用户停止下载过程时，如果嵌入的元素没有加载完，则在目标元素上面触发</li><li>select：当用户选择文本框中的一个或多个时触发</li><li>resize：当窗口或框架的大小变化时触发</li><li>scroll：当用户滚动带滚动条的元素中的内容时在该元素上触发。</li></ul><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><ul><li>blur：元素失去焦点时触发；这个事件不会冒泡。</li><li>DOMFocusIn：在元素获取焦点时触发。与 HTML 事件的 focus 等价。只有 Opera 支持。DOM3 级已废弃，选择了 focusin。</li><li>DOMFocusOut：在元素失去焦点时触发。DOM3 级已废弃，选择了 focusout。</li><li>focus: 获取焦点时触发。</li><li>focusin：它冒泡，和 HTML 的 focus 事件等价。</li><li>focusout：它冒泡，是 HTML 的 blur 事件的通用版本。</li></ul><h3 id="鼠标与滚轮事件"><a href="#鼠标与滚轮事件" class="headerlink" title="鼠标与滚轮事件"></a>鼠标与滚轮事件</h3><ul><li>click：用户单击鼠标按钮（一般是左键）或者按下 Enter 键时触发。</li><li>dbclick：双击鼠标触发。不能通过键盘触发这个事件。</li><li>mousedown：按下了鼠标任意键触发。不能通过键盘触发这个事件。</li><li>mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。</li><li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。<ul><li>mouseenter 和 mouseleave 是一对，IE、FireFox 9+ 和 Opera 支持这个事件。</li></ul></li><li>mousemove：鼠标指针在元素内部移动时重复触发。</li><li>mouseout：在鼠标指针位于一个元素上，然后用户将其移入另一个元素时触发。</li><li>mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一元素边界之内时触发</li><li>mouseup：鼠标抬起时触发。</li></ul><h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h4><ul><li>mousewheel 事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查浏览器是否支持上面所有的事件</span></span><br><span class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvent"</span>, <span class="string">"3.0"</span>);</span><br></pre></td></tr></table></figure><h4 id="客户区坐标位置"><a href="#客户区坐标位置" class="headerlink" title="客户区坐标位置"></a>客户区坐标位置</h4><ul><li>event.clientX 事件发生时鼠标指针在视口中的位置</li><li>event.clientY 事件发生时鼠标指针在视口中的位置</li></ul><h4 id="屏幕坐标位置"><a href="#屏幕坐标位置" class="headerlink" title="屏幕坐标位置"></a>屏幕坐标位置</h4><ul><li>event.screenX 相对于整个电脑屏幕的坐标位置</li><li>event.screenY 相对于整个电脑屏幕的坐标位置</li></ul><h4 id="键"><a href="#键" class="headerlink" title="键"></a>键</h4><ul><li>shiftKey</li><li>ctrlKey</li><li>altKey</li><li>metaKey</li></ul><h4 id="相关元素"><a href="#相关元素" class="headerlink" title="相关元素"></a>相关元素</h4><p>发生 mouseover 和 mouseout 时，还会涉及更多的元素。 DOM 通过 event 对象的 relatedTarget 属性提供了相关元素信息。在 mouseover 事件触发时， IE 的 fromElement 保存了相关元素，在 mouseout 事件触发时，IE 的 toElement 保存了相关元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtill = &#123;</span><br><span class="line">  getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.toElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromEvent) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.fromEvent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多事件信息"><a href="#更多事件信息" class="headerlink" title="更多事件信息"></a>更多事件信息</h3><p>DOM2 级事件规范在 event 对象提供了 detail 属性，用于给出有关事件的更多信息。包含了一个数值表示单击了多少次。</p><ul><li>altLeft</li><li>ctrlLeft</li><li>shiftLeft</li><li>offsetX</li><li>offsetY</li></ul><h3 id="键盘和文件属性"><a href="#键盘和文件属性" class="headerlink" title="键盘和文件属性"></a>键盘和文件属性</h3><ul><li>keydown：按下键盘上的任意键触发</li><li>keypress：按下键盘上的字符键触发</li><li>keyup：释放键盘上的键时触发</li></ul><h4 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h4><ul><li>event.keyCode</li></ul><h4 id="textInput-事件"><a href="#textInput-事件" class="headerlink" title="textInput 事件"></a>textInput 事件</h4><ul><li>textInput 事件</li><li>event.data 属性的值是用户输入的字符。</li><li>event.inputMethod 属性表示把文本输入到文本框的方式</li></ul><h3 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h3><ul><li>compositionstart</li><li>compositionupdate</li><li>compositionend</li></ul><h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><ul><li>DOMSubtreeModified</li><li>DOMNodeInserted</li><li>DOMNodeRemoved</li><li>DOMNodeInsertedIntoDocuemnt</li><li>DOMNodeRemovedFromDocuemnt</li><li>DOMAttrModified</li><li>DOMCharacterDataModified</li></ul><h3 id="HTML5-事件"><a href="#HTML5-事件" class="headerlink" title="HTML5 事件"></a>HTML5 事件</h3><ul><li>contexmenu 事件</li><li>beforeunload 事件</li><li>DOMContentLoaded 事件</li><li>readystatechange 事件<ul><li>uninitialized 对象尚未初始化</li><li>loading 对象正在加载</li><li>loaded 对象加载数据完成</li><li>interactive 可以操作对象了，但还没有完全加载</li><li>complete 对象已经加载完毕</li></ul></li><li>pageshow 和 pagehide 事件</li><li>hashchange 事件</li></ul><h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><ul><li>orientationonchange 事件</li><li>MozOrientation 事件</li><li>deviceorientation 事件 设备在空间中朝向哪里<ul><li>alpha 属性</li><li>beta 属性</li><li>gamma 属性</li><li>absolute 属性</li><li>compassCalibrated 属性<br>+devicemotion 事件</li></ul></li></ul><h3 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h3><ul><li>touchstart：手势在触摸屏时触发</li><li>touchmove：手势在屏幕上滑动时触发</li><li>touchend：手势离开触摸屏时触发</li><li>touchcansel：当系统停止跟踪触摸时触发</li><li>touches：表示当前跟踪的触摸操作的 Touch 对象的数组</li><li>targetTouches：特定于事件目标的 Touch 对象的数组</li><li>changeTouches：表示自上次触摸以来发生了什么改变 Touch 对象的数组</li></ul><p>每个 touch 对象包含以下属性</p><ul><li>clientX</li><li>clientY</li><li>identitier</li><li>pageX</li><li>pageY</li><li>screenX</li><li>screenY</li><li>target</li></ul><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>对事件处理程序过多的问题的解决方法就是 事件委托 。事件委托就是利用了事件冒泡，只指定一个事件处理程序来管理某一类型的的所有事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ulBox"</span>&gt;</span><br><span class="line">  &lt;li id=<span class="string">"li1"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li id="li2"&gt;2&lt;/</span>li&gt;</span><br><span class="line">  &lt;li id=<span class="string">"li3"</span>&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>委托事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"ulBox"</span>);</span><br><span class="line">EventUtil.addHandler(ul, <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  <span class="keyword">var</span> target = EventUtil.getTarget(event);</span><br><span class="line">  <span class="keyword">switch</span> (target.id) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"li1"</span>:</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"I changed"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"li2"</span>:</span><br><span class="line">      location.herf = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"li3"</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Hi"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="禁止a标签的默认行为"><a href="#禁止a标签的默认行为" class="headerlink" title="禁止a标签的默认行为"></a>禁止a标签的默认行为</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onclick = <span class="string">"return false;"</span></span><br></pre></td></tr></table></figure><h2 id="一个判断客户端是-PC-端还是移动端的程序"><a href="#一个判断客户端是-PC-端还是移动端的程序" class="headerlink" title="一个判断客户端是 PC 端还是移动端的程序"></a>一个判断客户端是 PC 端还是移动端的程序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"txt"</span>).onkeydown=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="built_in">console</span>.log(e.keyCode); &#125;;</span><br><span class="line"><span class="built_in">window</span>.onresize=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.body.clientWidth&gt;<span class="number">960</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"您用的是电脑浏览的该页面"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.body.clientWidth&gt;<span class="number">500</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"您用的是平板浏览的该页面"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"您用的是手机浏览的页面"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// 判断浏览器窗口大小</span></span><br><span class="line"><span class="built_in">document</span>.onclick=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;   </span><br><span class="line">  <span class="built_in">document</span>.title = e.screenX+<span class="string">"==="</span>+e.screenY; <span class="comment">//screenX和screenY是相对于屏幕的左上角</span></span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="图片跟着鼠标飞"><a href="#图片跟着鼠标飞" class="headerlink" title="图片跟着鼠标飞"></a>图片跟着鼠标飞</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onmousemove=<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e=e||<span class="built_in">window</span>.event; <span class="comment">// 兼容代码</span></span><br><span class="line">  <span class="built_in">document</span>.title=e.clientX+<span class="string">"==="</span>+e.clientY; <span class="comment">// clientX和clientY----事件参数获取</span></span><br><span class="line">  imgObj.style.position=<span class="string">"absolute"</span>;</span><br><span class="line">  imgObj.style.left=e.clientX+<span class="string">"px"</span>;</span><br><span class="line">      imgObj.style.top=e.clientY+<span class="string">"px"</span>;</span><br><span class="line">  imgObj.style.left=e.pageX+<span class="string">"px"</span>; <span class="comment">//pageX--包含可视区域的横坐标和隐藏区域</span></span><br><span class="line">      imgObj.style.top=e.pageY+<span class="string">"px"</span>; <span class="comment">//pageY---包含可视区域的纵坐标和隐藏区域</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="模拟多人开发注册事件"><a href="#模拟多人开发注册事件" class="headerlink" title="模拟多人开发注册事件"></a>模拟多人开发注册事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, eventName, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldEvent=element[<span class="string">"on"</span>+eventName];</span><br><span class="line">    <span class="keyword">if</span>(oldEvent==<span class="literal">null</span>)&#123;<span class="comment">//表示该事件没有处理函数</span></span><br><span class="line">        element[<span class="string">"on"</span>+eventName]=fn;<span class="comment">//注册事件了</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//有事件了---先调用原来的事件,再重新注册新的事件</span></span><br><span class="line">        element[<span class="string">"on"</span>+eventName]=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//调用原来的事件-注册新的事件</span></span><br><span class="line">            oldEvent();</span><br><span class="line">            fn();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册多个事件"><a href="#注册多个事件" class="headerlink" title="注册多个事件"></a>注册多个事件</h2><blockquote><p>三种注册事件的方式:</p></blockquote><ul><li>对象.on事件名字=事件处理函数;</li><li>对象.addEventListener(“事件的名字”,事件处理函数,false);</li><li>对象.attachEvent(“on事件的名字”,事件处理函数);</li><li>注册事件方式的区别:<ul><li>btnObj.onclick=fn;这种方式任何浏览器都支持</li><li>btnObj.addEventListener();谷歌和火狐浏览器支持</li><li>btnObj.attachEvent();IE8支持</li></ul></li><li>同一个元素同时注册多个相同的事件，addEventListener和attachEvent区别:<ul><li>前者三个参数,后者两个参数</li><li>前者第一个参数是事件的名字，没有on</li><li>后者第一个参数是事件的名字,有on</li><li>addEventListener方法中第三个参数如果是false则是事件冒泡,如果是true则是事件捕获</li></ul></li></ul><h2 id="事件冒泡阶段判断"><a href="#事件冒泡阶段判断" class="headerlink" title="事件冒泡阶段判断"></a>事件冒泡阶段判断</h2><ul><li>通过事件参数–e.eventPhase 可以获取当前事件经历的是什么阶段</li><li>如果是1则是捕获阶段</li><li>如果是2则是目标阶段:第一次点谁谁就是目标</li><li>目标阶段之后就是冒泡阶段</li><li>以上是结合第三个参数是false的情况而言</li><li>另一种情况:第三个参数是true的时候,只有捕获阶段和目标阶段</li><li>先捕获,然后再目标</li><li>一般网页中都是有事件冒泡的,一般情况我们不用捕获</li></ul><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>两种方式:</p><ul><li>第一种:方法 e.stopPropagation();</li><li>第二种:属性 window.event.cancelBubble=true;</li></ul><h2 id="有关事件处理的函数的封装"><a href="#有关事件处理的函数的封装" class="headerlink" title="有关事件处理的函数的封装"></a>有关事件处理的函数的封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeListener) &#123;</span><br><span class="line">      element.removeListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line">  getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line">  preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getRelatedTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.relatedTarget) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.toElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromEvent) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.fromEvent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getWheelDelta: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.wheelDelta) &#123;</span><br><span class="line">      <span class="keyword">return</span> (client.engine.opera &amp;&amp; client.engine.opera &lt; <span class="number">9.5</span> ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -event.detail * <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getCharCode: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.charCode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> event.keyCode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">    <span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setClipboardText: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.clipboardData) &#123;</span><br><span class="line">      <span class="keyword">return</span> event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动画函数封装（js）"><a href="#动画函数封装（js）" class="headerlink" title="动画函数封装（js）"></a>动画函数封装（js）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id获取对应的元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my$</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* element---任意的元素</span></span><br><span class="line"><span class="comment">* attr---属性</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAttrValue</span>(<span class="params">element,attr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element.currentStyle ? element.currentStyle[attr] : <span class="built_in">window</span>.getComputedStyle(element,<span class="literal">null</span>)[attr]||<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* element----要移动的元素</span></span><br><span class="line"><span class="comment">* target----移动的目标</span></span><br><span class="line"><span class="comment">* 初级版本</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate1</span>(<span class="params">element,target</span>) </span>&#123;</span><br><span class="line">    clearInterval(element.timeId);</span><br><span class="line">    element.timeId=setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前的位置</span></span><br><span class="line">        <span class="keyword">var</span> current=element.offsetLeft;</span><br><span class="line">        <span class="comment">//每次移动多少步</span></span><br><span class="line">        <span class="keyword">var</span> step=(target-current)/<span class="number">10</span>;<span class="comment">//(目标-当前)/10</span></span><br><span class="line">        step=step&gt;<span class="number">0</span>?<span class="built_in">Math</span>.ceil(step):<span class="built_in">Math</span>.floor(step);</span><br><span class="line">        current=current+step;</span><br><span class="line">        element.style.left=current+<span class="string">"px"</span>;</span><br><span class="line">        <span class="keyword">if</span>(current==target)&#123;</span><br><span class="line">            clearInterval(element.timeId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"target:"</span>+target+<span class="string">"current:"</span>+current+<span class="string">"step:"</span>+step);</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 终极版本的动画函数</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">element,json,fn</span>) </span>&#123;</span><br><span class="line">    clearInterval(element.timeId);</span><br><span class="line">    element.timeId=setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> flag=<span class="literal">true</span>;<span class="comment">//假设都达到了目标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> json)&#123;</span><br><span class="line">            <span class="keyword">if</span>(attr==<span class="string">"opacity"</span>)&#123;<span class="comment">//判断属性是不是opacity</span></span><br><span class="line">                <span class="keyword">var</span> current= getAttrValue(element,attr)*<span class="number">100</span>;</span><br><span class="line">                <span class="comment">//每次移动多少步</span></span><br><span class="line">                <span class="keyword">var</span> target=json[attr]*<span class="number">100</span>;<span class="comment">//直接赋值给一个变量,后面的代码都不用改</span></span><br><span class="line">                <span class="keyword">var</span> step=(target-current)/<span class="number">10</span>;<span class="comment">//(目标-当前)/10</span></span><br><span class="line">                step=step&gt;<span class="number">0</span>?<span class="built_in">Math</span>.ceil(step):<span class="built_in">Math</span>.floor(step);</span><br><span class="line">                current=current+step;</span><br><span class="line">                element.style[attr]=current/<span class="number">100</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(attr==<span class="string">"zIndex"</span>)&#123;<span class="comment">//判断属性是不是zIndex</span></span><br><span class="line">                element.style[attr]=json[attr];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//普通的属性</span></span><br><span class="line">                <span class="comment">//获取当前的位置----getAttrValue(element,attr)获取的是字符串类型</span></span><br><span class="line">                <span class="keyword">var</span> current= <span class="built_in">parseInt</span>(getAttrValue(element,attr))||<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//每次移动多少步</span></span><br><span class="line">                <span class="keyword">var</span> target=json[attr];<span class="comment">//直接赋值给一个变量,后面的代码都不用改</span></span><br><span class="line">                <span class="keyword">var</span> step=(target-current)/<span class="number">10</span>;<span class="comment">//(目标-当前)/10</span></span><br><span class="line">                step=step&gt;<span class="number">0</span>?<span class="built_in">Math</span>.ceil(step):<span class="built_in">Math</span>.floor(step);</span><br><span class="line">                current=current+step;</span><br><span class="line">                element.style[attr]=current+<span class="string">"px"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(current!=target)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;<span class="comment">//如果没到目标结果就为false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;<span class="comment">//结果为true</span></span><br><span class="line">            clearInterval(element.timeId);</span><br><span class="line">            <span class="keyword">if</span>(fn)&#123;<span class="comment">//如果用户传入了回调的函数</span></span><br><span class="line">                fn(); <span class="comment">//就直接的调用,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"target:"</span>+target+<span class="string">"current:"</span>+current+<span class="string">"step:"</span>+step);</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结三大系列"><a href="#总结三大系列" class="headerlink" title="总结三大系列"></a>总结三大系列</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clientX  clientY  clientWidth  clientHeight</span><br><span class="line">pageX  pageY  pageWidth pageHeight</span><br><span class="line">offsetLeft offsetTop  offsetWidth offsetHeight</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 与 HTML 之间的交互是通过 &lt;strong&gt;事件&lt;/strong&gt; 实现的。事件三要素: 事件源.事件 = function(){ 事件处理程序 }；等价于 &amp;lt;标签 事件= “事件处理程序”&amp;gt;。&lt;/p&gt;
&lt;p&gt;事件就是文档或浏览器窗口中发生的一些特定交互瞬间。包括事件类型、事件目标、事件处理程序、事件对象。&lt;/p&gt;
&lt;p&gt;事件类型是用过用来说明发生什么类型事件的字符串。&lt;/p&gt;
&lt;p&gt;事件目标是发生的事件或与之相关的对象。如 window、Document、Element 对象。以及由 XMLHTTPRequest 对象。&lt;/p&gt;
&lt;p&gt;事件处理程序或事件监听程序是处理或响应事件的函数。&lt;/p&gt;
&lt;p&gt;事件对象是与特定事件相关且包含有关该事件的详细信息的对象。&lt;/p&gt;
&lt;p&gt;事件传播是浏览器决定哪个对象触发其事件处理程序的过程。当文档元素上发生某个类型的事件时，它们会在文档树上向上冒泡。&lt;/p&gt;
&lt;p&gt;事件传播的另一中形式称为事件捕获，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获。&lt;/p&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="事件" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>DOM-文档对象模型</title>
    <link href="http://yoursite.com/2015/10/08/DOM-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2015/10/08/DOM-文档对象模型/</id>
    <published>2015-10-07T16:00:00.000Z</published>
    <updated>2018-05-31T03:54:08.450Z</updated>
    
    <content type="html"><![CDATA[<p>DOM 是针对 HTML 和 XML 文档的一个 API。 DOM 描绘了一个层次化的节点树。 HTML 文档的树形结构包含表示 HTML 标签或元素和表示文本字符串的节点，它也可能包括表示 HTML 注释节点。</p><h2 id="DOM基本概念"><a href="#DOM基本概念" class="headerlink" title="DOM基本概念"></a>DOM基本概念</h2><h3 id="DOM-描述"><a href="#DOM-描述" class="headerlink" title="DOM 描述"></a>DOM 描述</h3><ul><li>DOM Document Object Model 文档对象模型</li><li>就是把HTML文档模型化，当作对象来处理</li><li>DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。</li></ul><h3 id="内容概念"><a href="#内容概念" class="headerlink" title="内容概念"></a>内容概念</h3><ul><li>文档(Document)：就是指HTML或者XML文件</li><li>节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有<ul><li>元素节点</li><li>属性节点</li><li>文本节点</li><li>注释节点</li></ul></li><li>元素(Element)<ul><li>HTML文档中的标签可以称为元素</li></ul></li></ul><h3 id="结构概念"><a href="#结构概念" class="headerlink" title="结构概念"></a>结构概念</h3><ul><li>父节点 当前节点的父级</li><li>子节点 当前节点的子级</li><li>兄弟节点 和当前节点同属一个父级的节点</li></ul><a id="more"></a><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>DOM1 级定义了一个 Node 接口，该接口由 DOM 中的所有节点类型实现。这个 Node 接口在 JavaScript 中是作为 Node 类型事项的。JavaScript 中的所有节点类型都继承自 Node 类型。每个节点有一个 NodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的 12 个常量来表示：</p><ul><li>Node.ELEMENT_NODE(1); 表示元素节点</li><li>Node.ATTRIBUTE_NODE(2); 表示属性节点</li><li>Node.TEXT_NODE(3); 表示文本节点</li><li>Node.CDATA_SECTION_NODE(4);</li><li>Node.ENTITY_REFERENCE_NODE(5);</li><li>Node.ENTITY_NODE(6);</li><li>Node.PROCESSING_INSTRUCTION_NODE(7);</li><li>Node.COMMENT_NODE(8); 表示文本节点</li><li>Node.DOCUMENT_NODE(9); Document 节点</li><li>Node.DOCUMENT_TYPE_NODE(10);</li><li>Node.DOCUMENT_FRAGEMENT_NODE(11); DocumentFragment 是特殊的节点，作为其它节点的一个容器。</li><li>Node.NOTATION_NODE(12);</li></ul><p><code>someNode.nodeType</code> 兼容所有浏览器，IE 没有公开 Node 类型的构造函数。</p><h3 id="nodeName-和-nodeValue"><a href="#nodeName-和-nodeValue" class="headerlink" title="nodeName 和 nodeValue"></a>nodeName 和 nodeValue</h3><p>这两个属性了解节点的具体信息，对于节点类型为 1 的元素节点，nodeName 中保存的是元素标签名，nodeType 的值始终是 null。</p><h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><h4 id="作为元素树的文档节点"><a href="#作为元素树的文档节点" class="headerlink" title="作为元素树的文档节点"></a>作为元素树的文档节点</h4><ul><li>firstChild 指向 childNodes 列表中的第一个元素</li><li>lastChild 指向 childNodes 列表中的最后一个元素</li><li>childNodes 每个节点都有 childNodes 属性，保存了 NodeList 类数组对象。<ul><li>NodeList 是有生命、有呼吸的对象，DOM 结构的变化能够自动反映在 NodeList 对象中。</li><li>下面代码将 NodeList 对象转成真正的数组。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToArray</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    array = <span class="built_in">Array</span>.prototype.slice.call(nodes, <span class="number">0</span>);  <span class="comment">// 针对非 IE 浏览器</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    array = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = nodes.length; i &lt; len; i++) &#123;</span><br><span class="line">      array.push(nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parentNode 每个节点都有 parentNode 属性，指向文档树的根节点。</li><li>previousSibling 上一个同胞节点</li><li>nextSibling 下一个同胞节点</li></ul><h4 id="作为元素树的文档"><a href="#作为元素树的文档" class="headerlink" title="作为元素树的文档"></a>作为元素树的文档</h4><ul><li>firstElementChild 第一个子元素 有兼容性问题</li><li>lastElementChild 最后一个子元素 有兼容性问题</li><li>children 子元素 虽然不是早期DOM标准中的方法，但是所有浏览器都支持。</li><li>childElemntCount 子元素的数量。返回值和 childre.length 相等。</li><li>previousElementSibling 上一个兄弟元素 有兼容性问题</li><li>nextElementSibling 下一个兄弟元素 有兼容性问题</li></ul><p><code>haschildNodes()</code> 方法在节点包含一个或多个子节点的情况下返回 true。</p><h3 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h3><ul><li>appendChild() 向 childNodes 列表的末尾添加一个节点。<ul><li>添加节点后，childNodes 的新增节点、父节点以及以前的最后一个子节点的关系指针都会相应地得到更新。返回新增的节点。</li><li>如果传入的节点已经是文档的一部分了，那么就将该节点从原来的位置移动到新位置。</li></ul></li><li>insertBefore()<ul><li>接收两个参数：要插入的节点和作为参照的节点。</li><li>插入节点后，被插入的节点会变成参照节点的前一个同胞节点，同时被方法返回。</li><li>如果参照节点是空，则该方法和 appendChild() 执行相同的操作。</li></ul></li><li>replaceChild()<ul><li>接收两个参数：要插入的节点，要替换的节点。</li><li>要替换的节点被该方法返回，从文档树种移除，该节点所占位置被新的节点代替</li></ul></li><li>removeChild()<ul><li>接收一个参数，即要被移除的节点，返回这个节点。</li></ul></li></ul><p>以上几个方法是有父节点的子节点才具有的。下面两个方法所有类型的节点都有的。</p><ul><li>cloneNode()<ul><li>用于创建调用该方法的节点完全相同的节点。</li><li>该方法接收一个布尔值，表示是否深度克隆</li><li>参数为 true 时，克隆调用该方法的节点及其整个子节点树</li><li>参数为 false 时，只复制节点本身。</li><li>复制后返回的节点副本属于文档所有，但并没有为它指定父节点。</li><li>使用上面的 appendChild()、insertBefore()、replaceChild()方法添加的文档中。</li></ul></li><li>normalize()<ul><li>唯一作用是处理文档树中的文本节点。</li><li>调用该方法的节点，在其后代节点中查找空文本节点并删除。如果找到相邻文本节点，则合并</li></ul></li></ul><h2 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h2><p>在浏览器中，document 对象是 HTMLDocument (继承自 Document) 的一个实例，表示整个 HTML 页面。</p><p>特点：</p><ul><li>nodeType 为 9</li><li>nodeName 为 “#document”</li><li>nodeValue 为 “null”</li><li>parentNode 为 “null”</li><li>ownerDocument 为 “null”</li><li>子节点可能是 DocumentType(最多一个)、Element(最多一个)、Comment、ProcessingInstruction。</li></ul><h3 id="文档子节点"><a href="#文档子节点" class="headerlink" title="文档子节点"></a>文档子节点</h3><ul><li>documentElement 属性<ul><li>内置的访问子节点的方式 <code>document.documentElement</code> ， 返回值和 childNodes[0]、firstChlid 的值相同。</li></ul></li><li>body 属性<ul><li>直接指向 body 元素。</li></ul></li></ul><p>documentElement 和 body 属性所有浏览器都支持。</p><ul><li>doctype 属性<ul><li>IE8 以及之前的版本，如果存在文档声明，会错误的解释为 一个助手并当做 Comment 节点。返回 null。</li><li>IE9+ 以及 FF，如果存在文档声明，会将其作为文档的第一个子节点；document.doctype 是一个 DocmentType 节点。会出现在 document.childNodes 中。</li><li>Safari、Chrome 和 Opera，如果存在文档声明，将其解析，不作为文档的子节点。document.doctype 是一个 DocmentType 节点。不会出现在 document.childNodes 中。</li></ul></li></ul><p>浏览器对处理位于 <code>&lt;html&gt;</code> 外部的注释节点，也有差异</p><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>document.title<ul><li>获取 <title></title> 标签中的内容</li></ul></li></ul><h3 id="网页请求相关的属性"><a href="#网页请求相关的属性" class="headerlink" title="网页请求相关的属性"></a>网页请求相关的属性</h3><ul><li>document.URL<ul><li>包含网页完整的 URL</li></ul></li><li>document.domain<ul><li>包含页面的域名</li></ul></li><li>document.referrer<ul><li>保存着链接到当前页面的那个页面的 URL。</li></ul></li></ul><p>所有的这些信息保存在请求的 HTTP 头部。以上三个属性中只有 domain 属性是可以设置的。</p><p>当页面中包含来自其它子域的框架或者内嵌框架时候，能够设置 document.domain 就非常方便。由于跨域安全限制，来自不通子域的页面无法通过 JavaScript 通信。而通过将每个页面的 document.domain 设置为相同的值，这些页面就可以听歌互相访问对方包含的 JavaScript 对象了。</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li><code>getElementById();</code><ul><li>该方法只能被document对象调用；</li><li>该方法接收一个参数，要获取元素的 ID ；</li><li>如果找到返回该 DOM 元素，否则返回 null。</li><li>IE7 以及较低版本会将表单元素 name 值为该方法中的 id 相同的元素返回。</li></ul></li><li><code>getElementsByTagName();</code><ul><li>该方法接收一个参数，标签名。还可以传入 “*”，表示获取文档中的所有元素。</li><li>通过标签名寻找一类元素（找到的是由元素对象组成的伪数组）。返回的是一个 HTMLCollection。</li><li>即可以被 document 调用，又可以被元素对象调用。</li><li>被元素对象调用时表示在该元素对象内部执行查找。</li></ul></li><li><code>getElementByName();</code><ul><li>只有 HTMLDocument 才有的方法。</li><li>返回带有给定 name 特性的所有元素。最常用于取得单选按钮。</li></ul></li></ul><p>可以使用方括号或者 item() 来访问 HTMLCollection 集合中的项。该对象还有一个 nameItem() 方法，可以通过元素的 name 特性取得集合中的项。</p><h3 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h3><ul><li>document.anchors 返回包含页面中所有带 name 特性的 <code>&lt;a&gt;</code>元素</li><li>document.applets 包含文档中所有的 <code>&lt;applet&gt;</code> 元素，这个已经不用了。</li><li>document.froms 包含文档中的所有的 <code>&lt;form&gt;</code> 元素。</li><li>document.images 包含文档中的所有的 <code>&lt;img&gt;</code> 元素。</li><li>document.links 包含文档中的所有带 herf 的 <code>&lt;a&gt;</code> 元素。</li></ul><h3 id="DOM-的一致性检测"><a href="#DOM-的一致性检测" class="headerlink" title="DOM 的一致性检测"></a>DOM 的一致性检测</h3><ul><li>document.implementation 属性<ul><li>该属性有个 hasFeature() 方法，接收两个参数：<ul><li>要检测的 DOM 功能的名称</li><li>要检测的 DOM 功能的版本号</li></ul></li></ul></li></ul><h3 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h3><p>将输出流写入到网页中。可以使用这些方法动态的给网页中添加内容。</p><ul><li>document.write()<ul><li>接收要写到输出流的文本</li></ul></li><li>document.writeln()<ul><li>接收要写到输出流的文本</li></ul></li><li>document.open()<ul><li>打开输出流</li></ul></li><li>document.close()<ul><li>关闭输出流</li></ul></li></ul><p>write() 和 writeln() 方法动态地包含外部资源。使用时不能直接包含字符串<code>&lt;/sript&gt;</code>，而是使用 <code>&lt;\/script&gt;</code> 进行转义。</p><h2 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h2><p>Element 提供了对元素标签名、子节点及其特性的访问。</p><p>特点：</p><ul><li>nodeType 为 1</li><li>nodeName 为 元素的标签名</li><li>nodeValue 为 “null”</li><li>parentNode 可能是 Document 或 element</li><li>子节点可能是 Element、Text、Comment、ProcessingInstruction、CDATASection 或 EntityReference</li></ul><p>要访问元素的标签名可以使用 nodeName 或 tagName 属性。DOM元素.tagName 输出的是大写。 在 HTML 中，标签名始终都是全部以大写标书；而在 XML 或 XHML 中标签名会与源码代码中保持一致。</p><h3 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h3><p>由 HTMLElement 类型表示。每个 HTML 元素的特性：</p><ul><li>id 元素在文档中的唯一标识符</li><li>title 有关元素的附加说明</li><li>lang 元素内容的语言代码，很少用</li><li>dir 语言的方向，值为 “ltr” (从左至右) 或 “rtr” (从右至左)，很少用</li><li>className，与元素的 class 相对应。</li></ul><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><ul><li>getAttribute()<ul><li>传递的参数与实际的属性名相同。</li><li>可以获取自定义属性。</li></ul></li></ul><p>任何元素的所有特性，都可以通过 DOM 元素本身的属性来访问。只有非自定义的属性才会以属性的形式添加到 DOM 对象中。</p><p>有两类特殊的属性，虽然有对应的属性名，但是属性的值与通过 getAttribute() 返回的值并不相同。</p><ul><li>style, 用于通过 CSS 为元素指定样式；</li><li>事件处理程序。通过 getAttribute() 访问会返回相对应的代码字符串。</li></ul><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><ul><li>setAttribute()<ul><li>接收两个参数：要设置的属性名，要设置的值</li><li>存在替换，不存在创建</li></ul></li><li><code>元素对象.属性名 = &quot;属性值&quot;;</code></li><li><code>&lt;标签 属性名=&quot;属性值&quot;&gt;</code></li></ul><h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><ul><li>removeAttribute()<ul><li>IE6 之前版本不支持。</li></ul></li></ul><h3 id="attribute-属性"><a href="#attribute-属性" class="headerlink" title="attribute 属性"></a>attribute 属性</h3><p>该属性有一下几种方法：</p><ul><li>getNamedItem(name)<ul><li>返回 nodeName 等于 name 的节点</li></ul></li><li>removeNamedItem(name)<ul><li>移除 nodeName 等于 name 的节点</li></ul></li><li>setNamedItem(node)<ul><li>向列表中添加节点</li></ul></li><li>item(pos)<ul><li>返回位于 pos 处的节点</li></ul></li></ul><h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><ul><li>document.createElement()<ul><li>接收的参数是要创建元素的标签名</li><li>HTML 中不区分大小写，XML 或 XHTML 中区分大小写</li><li>在 IE 中可以使用为该方法传入完整的元素标签的方式创建。</li></ul></li></ul><h3 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h3><p>元素可以任意多的子节点和后代节点。 childNodes 属性包含了所有的子节点。</p><h2 id="Text-类型"><a href="#Text-类型" class="headerlink" title="Text 类型"></a>Text 类型</h2><p>不包含 HTML 结构的纯文本</p><p>特点：</p><ul><li>nodeType 为 3</li><li>nodeName 为 “#text”</li><li>nodeValue 为 节点所包含的文本</li><li>parentNode 是 Element</li></ul><p>可以通过 nodeValue 属性或 data 属性访问 Text 节点中包含的文本。</p><ul><li>appendData(text): 将 text 添加到节点的末尾</li><li>deleteData(offset, count): 从 offset 指定的位置开始删除 count 个字符</li><li>insertData(offset, text): 从 offset 指定的位置开始插入 text</li><li>replaceData(offset, count, text): 用 text 替换 offset 指定的位置开始到 + offset+count 为止处的文本。</li><li>splitText(offset): 从 offset 指定的位置将当前文本分成两个文本节点</li><li>substringData(offset, count): 提取从 offset 指定的位置开始到 offset + count 为止处的字符串</li></ul><p>还有个 length 属性，保存着节点中字符的数目。</p><h3 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h3><ul><li>document.createTextNode()<ul><li>创建新文本节点</li><li>接受一个参数-要创建的文本</li></ul></li></ul><h3 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h3><ul><li>normalize()<ul><li>在包含两个或多个文本节点的父元素上调用此方法，则会将所有文本节点合并成一个节点。</li></ul></li></ul><h3 id="切割文本节点"><a href="#切割文本节点" class="headerlink" title="切割文本节点"></a>切割文本节点</h3><ul><li>splitText()<ul><li>将一个文本分隔成两个文本节点。</li></ul></li></ul><h2 id="Comment-类型"><a href="#Comment-类型" class="headerlink" title="Comment 类型"></a>Comment 类型</h2><p>特点：</p><ul><li>nodeType 为 8</li><li>nodeName 为 “#document”</li><li>nodeValue 为 注释内容</li><li>parentNode 是 Document 或 Element</li><li>无子节点</li></ul><h2 id="CDATASection-类型"><a href="#CDATASection-类型" class="headerlink" title="CDATASection 类型"></a>CDATASection 类型</h2><p>特点：</p><ul><li>nodeType 为 4</li><li>nodeName 为 “#cdata-section”</li><li>nodeValue 为 CDATA 区域中的内容</li><li>parentNode 是 Document 或 Element</li><li>无子节点</li></ul><h2 id="DocumentType-类型"><a href="#DocumentType-类型" class="headerlink" title="DocumentType 类型"></a>DocumentType 类型</h2><p>特点：</p><ul><li>nodeType 为 10</li><li>nodeName 为 doctype 的名称</li><li>nodeValue 为 null</li><li>parentNode 是 Document</li><li>无子节点</li></ul><h2 id="DocumentFragment-类型"><a href="#DocumentFragment-类型" class="headerlink" title="DocumentFragment 类型"></a>DocumentFragment 类型</h2><p>特点：</p><ul><li>nodeType 为 11</li><li>nodeName 为 “#document-fragment”</li><li>nodeValue 为 null</li><li>parentNode 是 null</li><li>子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference</li></ul><p>使用 document.createDocumentFragment() 方法。可以通过 appendChild() 或 insertBefore() 将文档片段中内容添加到文档中。</p><h2 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h2><p>特点：</p><ul><li>nodeType 为 2</li><li>nodeName 为 属性名</li><li>nodeValue 为 特性的值</li><li>parentNode 是 null</li><li>HTML 中无子节点</li><li>XML 或 HTML 中子节点可以是 Text 或 EntityReference</li></ul><p>Attr 有 3 个属性：name、value 和 specified。</p><h2 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h2><ul><li>caption</li><li>tBodies</li><li>tFoot</li><li>tHead</li><li>rows</li><li>createHead()</li><li>createTFoot()</li><li>createCaption()</li><li>deleteRow(pos)</li><li>insertRow(pos)</li><li>cells</li><li>deleteCell(pos)</li><li>insertCell(pos)</li></ul><h2 id="DOM-扩展"><a href="#DOM-扩展" class="headerlink" title="DOM 扩展"></a>DOM 扩展</h2><p>对 DOM 的两个主要扩展是 Selectors API 和 HTML5。支持的浏览器： IE8+、FireFox 3.5+、Safari 3.1+、Chrome 和 Opera 10+。</p><h3 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h3><p>Selectors APILevel 1 的核心是两个方法：</p><ul><li>querySelector()<ul><li>接收一个 CSS 选择符，返回与该模式匹配的第一个元素，如果没有匹配到，返回 null。</li></ul></li><li>querySelectorAll()<ul><li>接收一个 CSS 选择符，返回一个 NodeList 对象。如果没有找到，NodeList 对象是空的。</li></ul></li></ul><p>Selectors APILevel 2 新增了一个 matchesSelector() 方法，接收一个参数，CSS 选择符，如果调用元素与该选择符匹配，返回 true，否则返回 false。</p><h3 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h3><ul><li>childElementCount: 返回不包括文本节点和注释的子元素个数；</li><li>firstElementChild: 指向一个子元素，firstChild 元素版</li><li>lastElementChild: 指向最后一个子元素，lastChild 元素版</li><li>previousElementChild: 指向前一个兄弟元素。 previousSibling 的元素版</li><li>nextElementChild: 指向下一个兄弟元素。 nextSibling 的元素版</li></ul><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h4><ul><li><code>getElementsByClassName();</code><ul><li>通过类名获取元素。</li><li>可以通过 document以及所有 HTML 元素调用该方法。</li><li>接收一个参数，即包含一或多个类名的字符串。</li><li>返回指定类型的所有 NodeList。</li></ul></li></ul><p>getElementsByClassName() 支持的浏览器有 IE9+、FireFox 3+、Safari 3.1+、Chrome 和 Opera 9.5+。</p><h4 id="classList-属性"><a href="#classList-属性" class="headerlink" title="classList 属性"></a>classList 属性</h4><p>HTML5 新增了一种操作类名的方式，就是为所有的元素添加 classList 属性。</p><ul><li>add(value): 给定的字符串值添加到列表中。如果值已经存在，就不添加了。</li><li>contains(value): 表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。</li><li>remove(value): 从列表中删除给定的字符串。</li><li>toggle(value): 如果列表中已存在给定的值，删除它；如果列表值没有给定的值，添加它。</li></ul><h4 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h4><ul><li>document.activeElement 属性<ul><li>始终会引用 DOM 中当前获得了焦点的元素。</li></ul></li><li>document.hasFocus() 方法<ul><li>用于确定文档是否获得了焦点</li></ul></li></ul><p>支持的浏览器有 IE4+、FireFox 3+、Safari 4+、Chrome 和 Opera 8+。</p><h4 id="HTMLDocument-的变化"><a href="#HTMLDocument-的变化" class="headerlink" title="HTMLDocument 的变化"></a>HTMLDocument 的变化</h4><h5 id="readyState-属性"><a href="#readyState-属性" class="headerlink" title="readyState 属性"></a>readyState 属性</h5><ul><li>loading， 正则加载文档</li><li>complete，已经加载完文档</li></ul><p>支持的浏览器有 IE4+、FireFox 3.6+、Safari、Chrome 和 Opera 9+。</p><h5 id="兼容模式"><a href="#兼容模式" class="headerlink" title="兼容模式"></a>兼容模式</h5><p>在标准模式下，document.compatMode 的值等于 “CSS1Compat”; 在混杂模式下，document.compatMode 的值等于 “BackCompat”。</p><p>支持的浏览器有 FireFox、Safari 3.1+、Chrome 和 Opera。</p><h5 id="head-属性"><a href="#head-属性" class="headerlink" title="head 属性"></a>head 属性</h5><p>document.head，引用文档的 <code>&lt;head&gt;</code> 元素。</p><p>支持的浏览器有 Safari 5、Chrome。</p><h4 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h4><ul><li>charset 属性表示文档中实际使用的字符集。默认是这个属性值是 “UTF-16”，可以通过 <code>&lt;meta&gt;</code> 元素、响应头部或者直接设置 charset 属性修改这个值。</li><li>defaultCharset，表示根据默认浏览器以及操作系统的设置。</li></ul><p>document.charset 支持的浏览器有 IE、Safari、Chrome 和 Opera。document.defaultCharset 支持的浏览器有 IE、Safari 和 Chrome。</p><h4 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h4><p>自定义数据属性是以 <code>data-</code> 开头的。这些属性可以任意添加、随便命名。</p><p>添加了自定义属性之后，可以通过元素的 dataset 属性来访问自定义属性的值。dataset 属性的值是 DOMStringMap 的一个实例，也就是键值对的映射。在这个映射中，每一个 data-name 形式的属性都会有一个对应的属性，只不过属性名没有 data- 前缀。</p><p>支持的浏览器有 FireFox 6+ 和 Chrome。</p><h4 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h4><ul><li>innerHTML 属性<ul><li>读模式下，innerHTML 属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的 HTML 标记；</li><li>写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素原先的所有子节点。</li><li>读模式返回的字符串内容各浏览器之间有差异</li><li>写模式 innerHTML 的值被认为是 HTML，如果是纯文本，则设置纯文本</li><li>innerHTML 中的 <code>&lt;script&gt;</code> 标签不会执行其中的脚本</li><li>并不是所有的元素都支持 innerHTML 属性。<ul><li><code>&lt;col&gt;、&lt;colgrounp&gt;、&lt;frameset&gt;、&lt;head&gt;、&lt;html&gt;、&lt;style&gt;、&lt;table&gt;、&lt;tbody&gt;、&lt;thead&gt;、&lt;tfoot&gt;、&lt;tr&gt;</code></li><li>IE8 以及之前的版本 <code>&lt;title&gt;</code> 没有 innerHTML 属性</li></ul></li></ul></li><li>outerHTML 属性<ul><li>读模式下，outerHTML 属性返回与调用元素的所有子节点的 HTML 标签；</li><li>写模式下，outerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素。</li><li>支持的浏览器有 IE4+、Safari 4+、Chrome 和 Opera 8+。</li></ul></li><li>innerAdjacentHTML() 方法<ul><li>接收两个参数：插入位置和要插入的 HTML 文本，第一个参数必须是：<ul><li>“beforebegin” 在当前元素之前插入一个紧邻的兄弟元素</li><li>“afterbegin” 在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素</li><li>“beforeend” 在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素</li><li>“afterend” 在当前元素之后插入一个紧邻的兄弟元素</li></ul></li></ul></li></ul><h4 id="内存与性能"><a href="#内存与性能" class="headerlink" title="内存与性能"></a>内存与性能</h4><p>在使用innerHTML、outerHTML、innerAdjacentHTML() 等时最好先把被替换元素上绑定的事件处理程序删除。</p><p>使用 innerHTML 方法时，首先拼串，然后在往 DOM 树中添加，提高性能。</p><h4 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView() 方法"></a>scrollIntoView() 方法</h4><p>任何 HTML 元素都可以调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在时口中。</p><p>支持的浏览器有 IE、Safari、FireFox 和 Opera。</p><h3 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h3><h4 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h4><p>文档模式决定了页面可以使用什么功能。有混杂模式和标准模式。</p><p>通过 <code>document.documentMode</code> 属性可以指定给定页面使用的是什么样的文档模式。</p><h4 id="children-属性"><a href="#children-属性" class="headerlink" title="children 属性"></a>children 属性</h4><p>返回只包含元素中同样还是元素的子节点，与 childNodes 没区别。</p><h5 id="contains-方法"><a href="#contains-方法" class="headerlink" title="contains() 方法"></a>contains() 方法</h5><p>返回 true 或 false，如果传入的参数元素是调用元素的后代，则返回 true，否则返回 false。</p><h4 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h4><ul><li>innerText 属性<ul><li>可以操作元素中包含的所有文本内容</li><li>会按照由浅到深的顺序，将子文档树中的所有文本都拼接起来</li><li>会对文本中存在的 HTML 语法字符进行编码</li></ul></li></ul><p>支持 innerText 属性有 IE9+、Safari 3+、Chrome 和 Opera 8+。</p><ul><li>textContext 属性<ul><li>是 DOMLevel 3 规定的一个属性。</li></ul></li></ul><p>支持 textContext 属性有 IE9+、Safari 3+、Chrome、FireFox 和 Opera 10+。</p><ul><li>outerText<ul><li>它的读模式和 innerText 没区别</li><li>写模式：outerText 不只是替换调用它的子节点，而是会替换包括替换整个元素。</li></ul></li></ul><p>支持的浏览器有 IE4+、Safari3+、Chrome 和 Opera8+。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.innerText === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.innerText;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element.textContent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element, content</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.innerText === <span class="string">"string"</span>) &#123;</span><br><span class="line">        element.innerText = content;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element.textContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><ul><li>scrollIntoViewIfNeeded(alignCenter): 只有当前元素在视口中不可见的情况下，才能滚动浏览器窗口或容器让其可见。</li><li>scrollByLines(lineCount): 将元素的内容滚动指定的行高；</li><li>scrollByPages(pageCount): 将元素的内容滚动指定页面的高度；</li></ul><p>支持的浏览器 Chrome 和 Safari。scrollIntoView() 是唯一个所有浏览器都支持的方法，所以比较常用。</p><h2 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h2><p>DOM1 级主要定义的是 HTML 和 XML 文档的底层结构。DOM2 和 DOM3 则在这个基础上引进了更多的交互能力。DOM2 和 DOM3 分为很多模块。如下：</p><ul><li>DOM2 级核心(DOM Level 2 Core)：为节点添加了更多的方法和属性</li><li>DOM2 级视图(DOM Level 2 Views)：为文档定义了基于样式基本信息的不同视图。</li><li>DOM2 级事件(DOM Level 2 Events): 说明了如何使用事件与 DOM 文档操作</li><li>DOM2 级样式(DOM Level 2 Style)：定义了如何通过编程方式操作 CSS 样式</li><li>DOM2 级遍历和范围(DOM Level 2 Trversal and Range): 引入了遍历 DOM 文档和选择其他特定部分的新接口。</li><li>DOM2 级 HTML(DOM Level 2 HTML)：在 1 级 HTML 基础上添加了更多的属性、方法和新接口</li></ul><h3 id="DOM-变化"><a href="#DOM-变化" class="headerlink" title="DOM 变化"></a>DOM 变化</h3><h4 id="针对-XML-命名空间的变化"><a href="#针对-XML-命名空间的变化" class="headerlink" title="针对 XML 命名空间的变化"></a>针对 XML 命名空间的变化</h4><p>HTML 不支持 XML 命名空间，XHTML 支持 XML 的命名空间。</p><p>命名空间使用 xmlns 特性来定义。</p><ul><li>Node 类型变化</li><li>Document 类型变化</li><li>Element 类型变化</li><li>NamedNodeMap 类型的变化</li><li>NamedNodeMap 类型的变化</li><li>Document 类型的变化</li><li>框架的变化</li></ul><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h4 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h4><p>任何支持 style 特性的 HTML 元素在 JavaScript 中都有一个对应的 style 属性。在 style 特性指定的任何 CSS 属性都将表现为 style 对象的相应属性。对于使用短线分隔的 CSS 属性，将其转换成驼峰大小写的形式。</p><p>float 是 javascript 的保留字，不能用作属性名，其相应的属性名是 cssFloat，FireFox、Safari、Opera、Chrome 都支持；但是 IE 支持的是 styleFloat.</p><p>直接可以访问的样式：<code>widh; height; padding; margin; display;</code></p><h4 id="设置和获取样式"><a href="#设置和获取样式" class="headerlink" title="设置和获取样式"></a>设置和获取样式</h4><ul><li>通过对象的style属性只能设置和获取行内样式</li><li>获取样式的时候 如果行内没有该样式 输出空字符串</li><li>设置样式的时候 赋的值是一个字符串 如果这个属性有单位 一定要节点加单位</li></ul><h4 id="什么情况通过class控制样式-什么情况通过style控制样式"><a href="#什么情况通过class控制样式-什么情况通过style控制样式" class="headerlink" title="什么情况通过class控制样式 什么情况通过style控制样式"></a>什么情况通过class控制样式 什么情况通过style控制样式</h4><p>不严格的说：</p><ul><li>如果样式很多 通过 直接控制类名 的方式加样式</li><li>如果样式比较少 通过直接设置比较方便</li></ul><p>严格来说：</p><ul><li>从标准的角度讲 即使是样式比较少的时候 设置样式也要用类名</li><li>但是有一类情况 是无论如何也必须直接通过JS加的 那就是涉及到计算的时候</li></ul><h5 id="DOM-样式属性和方法"><a href="#DOM-样式属性和方法" class="headerlink" title="DOM 样式属性和方法"></a>DOM 样式属性和方法</h5><ul><li>cssText</li><li>length 应用给元素的 CSS 属性</li><li>parentRule</li><li>getPropertyCSSValue(propertyName)</li><li>getPropertyPriority(propertyName)</li><li>getPropertyValue(propertyName)</li><li>item(index) 返回给定位置的 CSS 属性名称。</li><li>removeProperty(propertyName)</li><li>setProperty(propertyName, value, priority)</li></ul><h5 id="计算的样式"><a href="#计算的样式" class="headerlink" title="计算的样式"></a>计算的样式</h5><ul><li>getComputedStyle()<ul><li>接收两个参数：要获取的计算样式的元素和一个伪元素字符串。第二个参数是可选的</li><li>在 IE 中不支持，而是有个 currentStyle 属性</li></ul></li><li>使用 document.defaulView.getComputedStyle(DOM元素, 伪元素/null)</li><li>返回 CSSStyleDeclaration 对象，包含当前元素的所有计算的样式。</li></ul><h5 id="操作样式表"><a href="#操作样式表" class="headerlink" title="操作样式表"></a>操作样式表</h5><ul><li>disabled</li><li>href</li><li>media</li><li>ownerNode</li><li>parentStyleSheet</li><li>title</li><li>type</li><li>cssRules</li><li>ownerRule</li><li>deleteRule(index)</li><li>inserRule(rule, index)</li></ul><p>应用于文档的所有样式表时通过 document.styleSheets 集合来表示的。IE 支持的是 styleSheet 属性 而其他浏览器都支持 sheet 属性。</p><h5 id="CSS-规则，CSSStyleRule-类型继承了-CSSRule，包含以下属性："><a href="#CSS-规则，CSSStyleRule-类型继承了-CSSRule，包含以下属性：" class="headerlink" title="CSS 规则，CSSStyleRule 类型继承了 CSSRule，包含以下属性："></a>CSS 规则，CSSStyleRule 类型继承了 CSSRule，包含以下属性：</h5><ul><li>CSSText</li><li>parentRule</li><li>parentStyleSheet</li><li>selectorText</li><li>style</li><li>type</li></ul><h5 id="创建规则"><a href="#创建规则" class="headerlink" title="创建规则"></a>创建规则</h5><ul><li>sheet.insertRule()<ul><li>接收两个参数：规则文本和在哪里插入规则的索引。</li><li>除了 IE 以外的其它四个浏览器支持</li></ul></li><li>sheet.addRule()<ul><li>接收两个必选参数一个可选参数：选择符文本和CSS样式信息，在哪里插入规则的索引。</li><li>IE 浏览器支持</li></ul></li></ul><h5 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h5><ul><li>sheet.deleteRule()<ul><li>接收一个参数：要删除规则的位置</li><li>除了 IE 以外的其它四个浏览器支持</li></ul></li><li>sheet.removeRule()<ul><li>接收一个参数：要删除规则的位置</li><li>IE 浏览器支持</li></ul></li></ul><h5 id="元素的大小"><a href="#元素的大小" class="headerlink" title="元素的大小"></a>元素的大小</h5><p>偏移量：包括元素在屏幕上占用的所有的可见的空间。由其高度、宽度来决定，包括内边距、滚动条和边框大小。</p><ul><li>偏移量<ul><li>offsetHeight</li><li>offsetWidth</li><li>offsetLeft</li><li>offsetTop</li></ul></li><li>客户区的大小：不包括边框，包括内边距<ul><li>clientWidth</li><li>clientHeight</li></ul></li><li>滚动大小：包含滚动内容的大小<ul><li>scrollHeight</li><li>scrollWidth</li><li>scrollLeft</li><li>scrollTop</li></ul></li><li>确定元素的大小<ul><li>getBoundingClientRect() 方法返回一个矩形对象，有四个属性：<ul><li>left、top、right、bottom</li><li>给出了元素在叶明中相对于视口的位置。</li></ul></li></ul></li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h3 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h3><p>可以使用 document.createNodeIterator() 方法来创建 NodeIterator 的新实例，接收四个参数。</p><ul><li>root: 想要搜索的起始树中的节点</li><li>whatToShow: 要访问哪些节点的数字代码</li><li>filter: 是一个 NodeFilter 对象，表示应该接收还是拒绝某种特定的节点的函数</li><li>entityReferenceExpansion: 布尔值，是否要扩展引用。</li></ul><p>whatToShow 的参数在这里不再列出，需要的时候直接查找 JavaScript 高级程序设计；</p><h3 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h3><p>是 NodeIterator 的更高级版本。可以使用 document.createTreeWalker() 方法来创建 TreeWalker 的新实例，接收四个参数。</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>有关范围的一些方法、属性此处不再列出。详细更多参见 《JavaScript 高级程序设计》</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>动态创建结构</p><ul><li>方式一：直接在文档中书写<ul><li>document.write(“内容”)</li></ul></li><li>方式二：改变元素对象内部的HTML<ul><li>innerHTML=”内容”</li></ul></li><li>方式三：创建或克隆节点并追加<ul><li>createElement();</li><li>cloneNode();</li><li>通过这两种方法创建出来的元素只是保存在内存中，必须放到页面上才行!</li></ul></li><li>动态创建结构（效率问题）<ul><li>把字符串变为文档对象</li><li>把当前对象挂接到DOM树上</li><li>渲染引擎根据新的DOM树重新渲染</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM 是针对 HTML 和 XML 文档的一个 API。 DOM 描绘了一个层次化的节点树。 HTML 文档的树形结构包含表示 HTML 标签或元素和表示文本字符串的节点，它也可能包括表示 HTML 注释节点。&lt;/p&gt;
&lt;h2 id=&quot;DOM基本概念&quot;&gt;&lt;a href=&quot;#DOM基本概念&quot; class=&quot;headerlink&quot; title=&quot;DOM基本概念&quot;&gt;&lt;/a&gt;DOM基本概念&lt;/h2&gt;&lt;h3 id=&quot;DOM-描述&quot;&gt;&lt;a href=&quot;#DOM-描述&quot; class=&quot;headerlink&quot; title=&quot;DOM 描述&quot;&gt;&lt;/a&gt;DOM 描述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DOM Document Object Model 文档对象模型&lt;/li&gt;
&lt;li&gt;就是把HTML文档模型化，当作对象来处理&lt;/li&gt;
&lt;li&gt;DOM提供的一系列属性和方法可以视作一个工具箱，极大地方便了我们对文档的处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;内容概念&quot;&gt;&lt;a href=&quot;#内容概念&quot; class=&quot;headerlink&quot; title=&quot;内容概念&quot;&gt;&lt;/a&gt;内容概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;文档(Document)：就是指HTML或者XML文件&lt;/li&gt;
&lt;li&gt;节点(Node)：HTML文档中的所有内容都可以称之为节点，常见的节点有&lt;ul&gt;
&lt;li&gt;元素节点&lt;/li&gt;
&lt;li&gt;属性节点&lt;/li&gt;
&lt;li&gt;文本节点&lt;/li&gt;
&lt;li&gt;注释节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元素(Element)&lt;ul&gt;
&lt;li&gt;HTML文档中的标签可以称为元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;结构概念&quot;&gt;&lt;a href=&quot;#结构概念&quot; class=&quot;headerlink&quot; title=&quot;结构概念&quot;&gt;&lt;/a&gt;结构概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;父节点 当前节点的父级&lt;/li&gt;
&lt;li&gt;子节点 当前节点的子级&lt;/li&gt;
&lt;li&gt;兄弟节点 和当前节点同属一个父级的节点&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="DOM系列" scheme="http://yoursite.com/categories/DOM%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>BOM-浏览器对象模型</title>
    <link href="http://yoursite.com/2015/09/28/BOM-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2015/09/28/BOM-浏览器对象模型/</id>
    <published>2015-09-27T16:00:00.000Z</published>
    <updated>2018-05-31T03:07:44.909Z</updated>
    
    <content type="html"><![CDATA[<p>DOM:中的顶级对象是document—-太监(大总管);BOM:中的顶级对象是window——皇上;整个浏览器就是window,页面中的document也属于window</p><ul><li>变量,函数,对象都属于window</li><li>但是:写代码的时候,window可以直接省略</li></ul><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>BOM，即浏览器对象模型，核心是：window 对象</p><a id="more"></a><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量不能通过 delete 操作符删除。</p><h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，每个框架都有自己的 window 对象，并且保存在 frames 集合中。每一个 window 对象都有一个 name 属性，其中包含框架的名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Frameset Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">"160, *"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame0.html"</span> <span class="attr">name</span> = <span class="string">"topFrame"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%, 50%"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame1.html"</span> <span class="attr">name</span> = <span class="string">"leftFrame"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"frame2.html"</span> <span class="attr">name</span> = <span class="string">"rightFrame"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>window.frames[0]</li><li>window.frames[“topFrame”]</li><li>top.frames[0]</li><li>top.frames[“topFrame”]</li><li>frames[0]</li><li>frames[“topFrame”]</li></ul><h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><p>IE、Safari、Opera、Chrome 支持</p><ul><li>screenLeft</li><li>screenTop</li></ul><p>FireFox 支持</p><ul><li>screenX</li><li>screenY</li></ul><p>窗口移动方法</p><ul><li>moveTo()</li><li>moveBy()</li></ul><h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>IE9+、Safari、Opera、FireFox、Chrome 支持</p><ul><li>innerWidth</li><li>innerHeight</li><li>outerWidth</li><li>outerHeight</li></ul><p>IE9+、Safari、FireFox 中 outer… 返回浏览器本身的尺寸(window 和 框架都是)。Opera 中则是页面视图容器大小。Chrome 中 两两都返回相同的值，即视口大小而非浏览器窗口大小。</p><p>在 IE9、Safari、Opera、FireFox、Chrome 中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 保存了页面视口信息。在 IE 的标准模式下生效，而混杂模式使用的是： document.body 中的 clientHeight 和 clientWidth。而 Chrome 通过 document.body 和 document.documentElement 都可以获取到页面视图。</p><p>可以通过检查 document.compatMode 来检测浏览器是否处于标准模式。</p><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>window.open() 方法，四个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。和 a 标签的 herf 属性一个功能。不怎么用。</p><h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><blockquote><p>超时调用</p></blockquote><ul><li>setTimeout() 方法<ul><li>两个参数，</li><li>一是要执行的回调函数或一个包含 JavaScript 代码的字符串</li><li>而是以毫秒值表示的时间。即在执行前需要等待的时间。</li><li>传递字符串消耗性能。</li><li>返回一个 ID</li><li>在非严格模式下，this 指向 window，严格模式下是 undefined。</li></ul></li><li>clearTimeout() 清除超时调用</li></ul><blockquote><p>间歇调用</p></blockquote><ul><li>setInterval() 方法<ul><li>参数同 setTimeout() 方法相同</li><li>返回也是一个 ID</li><li>间歇调用一直执行到页面卸载</li></ul></li><li>clearInterval()<ul><li>清除间歇调用</li></ul></li></ul><h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><ul><li>alert()</li><li>confirm()</li><li>prompt()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.confirm(<span class="string">"你确定要退出吗?"</span>)) &#123;</span><br><span class="line">    <span class="comment">//执行到这里,证明用户点击了确定按钮</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"点击了确定"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//证明了用户点击了取消的按钮</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"点击了取消"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.prompt(<span class="string">"请输入用户名"</span>);</span><br></pre></td></tr></table></figure><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>属性有：</p><ul><li>hash 返回 URL 中的哈希值</li><li>hostname 返回服务器名称和端口号</li><li>herf 返回当前页面加载的完整的 URL。 location 对象的 toString() 方法也返回这个值。</li><li>pathname 返回 URL 中的目录（或）文件名</li><li>port 返回 URL 中指定的端口号</li><li>protocol 返回页面使用的协议</li><li>search 返回 URL 的查询字符串</li></ul><p>方法有：</p><ul><li>location.assign(“<a href="http://www.baidu.com“)" target="_blank" rel="noopener">http://www.baidu.com“)</a>;<ul><li>改变浏览器的位置</li></ul></li><li>location.replace(“<a href="http://www.baidu.com“)" target="_blank" rel="noopener">http://www.baidu.com“)</a>;<ul><li>地址不会记录到历时中—-后退点不了</li></ul></li><li>location.reload();<ul><li>刷新—一般情况在页面中用一个按钮点击刷新</li></ul></li></ul><h2 id="BOM的一些方法"><a href="#BOM的一些方法" class="headerlink" title="BOM的一些方法"></a>BOM的一些方法</h2><ul><li>win = window.open(“09test.html”,”_blank”,”width=200,height=200,top=100,left=100,resizable=no”);</li><li>win.close();//此时close方法 无论open中第一个参数是不是地址都可以关闭窗口</li><li>win.moveTo(300,300);//把新打开的窗口移动到距离左侧和上面300px</li><li>win.moveBy(20,20);//每次移动20px</li><li>win.resizeTo(400,400);//窗口的大小发生了改变</li><li>win.resizeBy(40,40);</li></ul><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>属性或方法：</p><ul><li>appCodeName 浏览器名称</li><li>appMinorVersion 此版本信息</li><li>appName 完整浏览器名称</li><li>appVersion 浏览器版本</li><li>buildID</li><li>cookieEnabled</li><li>cpuClass</li><li>javaEnabled()</li><li>language</li><li>mimeType</li><li>onLine</li><li>opsProfile</li><li>oscpu</li><li>platform</li><li>plugins</li><li>preference()</li><li>product</li><li>productSub</li><li>register-ContentHandler()</li><li>register-ProtocalHandler()</li><li>securifyPolicy</li><li>systemLanguage</li><li>taintEnabled()</li><li>userAgent</li><li>userLanguage</li><li>userProfile</li><li>vendor</li><li>vendorSub</li></ul><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><p>用处不大，此处不再详细说明。</p><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><ul><li>window.history.forward();</li><li>window.history.back();//后退</li><li>window.history.go();</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DOM:中的顶级对象是document—-太监(大总管);BOM:中的顶级对象是window——皇上;整个浏览器就是window,页面中的document也属于window&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量,函数,对象都属于window&lt;/li&gt;
&lt;li&gt;但是:写代码的时候,window可以直接省略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;window-对象&quot;&gt;&lt;a href=&quot;#window-对象&quot; class=&quot;headerlink&quot; title=&quot;window 对象&quot;&gt;&lt;/a&gt;window 对象&lt;/h2&gt;&lt;p&gt;BOM，即浏览器对象模型，核心是：window 对象&lt;/p&gt;
    
    </summary>
    
      <category term="BOM系列" scheme="http://yoursite.com/categories/BOM%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="BOM" scheme="http://yoursite.com/tags/BOM/"/>
    
  </entry>
  
  <entry>
    <title>js的正则表达式</title>
    <link href="http://yoursite.com/2015/09/16/js%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/09/16/js的正则表达式/</id>
    <published>2015-09-15T16:00:00.000Z</published>
    <updated>2018-06-01T06:18:41.487Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一个描述字符模式的对象。 JavaScript 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。</p><h2 id="正则表达式定义"><a href="#正则表达式定义" class="headerlink" title="正则表达式定义"></a>正则表达式定义</h2><p>正则表达式的直接量定义为包含在一对斜杠 (/) 之间的字符</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>;</span><br></pre></td></tr></table></figure><h2 id="正则表达式中的基本元字符"><a href="#正则表达式中的基本元字符" class="headerlink" title="正则表达式中的基本元字符"></a>正则表达式中的基本元字符</h2><ul><li><code>.</code> 通配符（. 除了\n以外的任意一个内容）</li><li><code>[]</code> 表示的是范围:表示的是范围中的任意一个</li><li><code>[0-9]</code> 表示的是:0到9之间(包含)任意一个数字</li><li><code>[a-z]</code> 表示所有的小写字母中的一个</li><li><code>[A-Z]</code> 表示的是所有的大写字母中的任意一个</li><li><code>[a-zA-Z]</code> 表示的是所有的字母中的任意一个</li><li><code>[9]</code> 表示的就是9</li><li><code>[0-9a-zA-Z]</code> 表示的是任意的一个数字或者任意的一个字母</li><li><code>()</code>表示的是分组(为了更明确这个正则表达式的意思),提升优先级</li><li><code>|</code> 表示的是或者的意思</li><li><code>[0-9]|[a-z]</code> 0-9之间的任意一个数字或者是小写字母中的任意一个字母</li><li><code>*</code>表示的是该符号前面的表达式出现了0次到多次</li><li><code>+</code> 表示的是该符号前面的表达式出现了1次到多次</li><li><code>?</code> 表示的是该符号前面的表达式出现了0次到一次</li><li><code>{}</code> 表示的是前面的表达式出现了多少次,具体是多少次:大括号中的写法</li><li><code>{n,m}</code> 匹配前一项至少 n 次，但不超过 m 次</li><li><code>{n,}</code>匹配前一项 n 次或者更多次</li><li><code>{n}</code> 匹配前一项 0 次或多次，等价于 {0,}</li></ul><a id="more"></a><h2 id="数字、字母、特殊符号"><a href="#数字、字母、特殊符号" class="headerlink" title="数字、字母、特殊符号"></a>数字、字母、特殊符号</h2><ul><li>\d 表示的是任意的一个数字和 <code>[0-9]</code> 一样</li><li>\D 表示的是非数字，等价于 <code>[^0-9]</code></li><li>\s 空白符号</li><li>\S 非空白符号</li><li>\w 非特殊符号，等价于 <code>[a-zA-Z0-9]</code></li><li>\W 特殊符号，等价于 <code>[^a-zA-Z0-9]</code></li></ul><h2 id="之前的元字符、都是不严格的匹配字符串"><a href="#之前的元字符、都是不严格的匹配字符串" class="headerlink" title="之前的元字符、都是不严格的匹配字符串"></a>之前的元字符、都是不严格的匹配字符串</h2><ul><li><code>^</code><ul><li>(1)、以什么内容开头，必须以什么开始;</li><li>(2)、取反</li><li>用法:<ul><li><code>^[0-9]</code> 必须以数字开头</li><li><code>^[a-z0-9]</code> 必须以数字或者以小写字母开始</li><li><code>^[0-9a-zA-Z]</code>必须以数字或者是字母开头</li><li><code>^\d</code> 必须以数字开头</li><li><code>[^0-9]</code>取反 字母或者特殊符号</li><li><code>[^0-9a-zA-Z]</code> 特殊符号</li><li><code>$</code> 必须以什么内容结尾</li><li><code>[0-9]$</code> “hsgd7y273d9”</li><li><code>[a-zA-Z]$</code></li><li><code>^[0-9a-z][a-z]$</code></li></ul></li></ul></li></ul><h2 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h2><ul><li><code>^</code>匹配字符串的开头，在多行检索中，匹配一行的开头。</li><li><code>$</code> 匹配字符串的结尾，在多行检索中，匹配一行的结尾。</li><li><code>\b</code> 匹配一个单词的边界，就是位于 \w 和 \W 之间的位置，或位于字符 \w 和字符串的开头或者结尾之间的位置。</li><li><code>\B</code> 匹配非单词边界的位置</li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul><li><code>i</code> 执行不分区大小写的匹配；</li><li><code>g</code>执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止；</li><li><code>m</code>多行匹配模式， <code>^</code> 匹配一行的开头和字符串的开头， <code>$</code>匹配行的结束和字符串的结束。</li></ul><h2 id="在js中正则表达式的写法-正则表达式"><a href="#在js中正则表达式的写法-正则表达式" class="headerlink" title="在js中正则表达式的写法: /正则表达式/"></a>在js中正则表达式的写法: /正则表达式/</h2><blockquote><p>创建正则表达式对象的方式:</p></blockquote><p>(1)、 var reg=new RegExp(/正则表达式/<br>(2)、 var reg=/正则表达式/; reg.test(“hello998”);<br>(3)、 /正则表达式/.方法名(参数);</p><h3 id="RegExp-属性"><a href="#RegExp-属性" class="headerlink" title="RegExp 属性"></a>RegExp 属性</h3><ul><li>source</li><li>global</li><li>ignoreCase</li><li>multiline</li><li>lastIndex</li></ul><h2 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h2><p>正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符串。</p><ul><li>字符<code>|</code> 用来分隔供选择的字符。<ul><li>选择项的尝试匹配次序是从左至右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。</li></ul></li><li>圆括号 <code>()</code><ul><li>圆括号的作用：一个作用是把单独的项组合成子表达式，以便可以处理像一个独立的单元那样用”|”、”*”、”+”、或者”?”等来对单元内的项进行处理。</li><li>另一个作用是在完整的模式中定义模式。当一个正则表达式成功地和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分。</li><li>允许在同一正则表达式的后部引用前面的子表达式。<ul><li>这是通过在字符 “\” 后加一位或多位数字来实现。这个数字指定了带圆括号的子表达式在正则表达式中的位置。</li></ul></li></ul></li></ul><h2 id="用于模式匹配的String方法的使用"><a href="#用于模式匹配的String方法的使用" class="headerlink" title="用于模式匹配的String方法的使用"></a>用于模式匹配的String方法的使用</h2><p><code>str=str.replace(/帅/g,&quot;呆&quot;);</code>g表示的是全局; i 表示的是小写的<br><code>str=str.replace(/^\s+|\s+$/g,&quot;&quot;);</code><br><code>while((index=reg.exec(str))!=null){console.log(index.index); }</code> // 如果结果为null没有匹配的<br><code>var result=str.match(/帅/g);</code> // match根据正则表达式匹配字符串中的内容,如果没有g,匹配的是第一个,如果有g匹配的是全局的</p><ul><li>search()<ul><li>参数是一个正则表达式；</li><li>返回第一个与之匹配的子串的起始位置；</li><li>找不到返回 -1。</li><li>如果参数不是正则表达式，则先通过 RegExp 构造函数将它转换成正则表达式；</li><li>search() 方法不支持全局检索，会忽略正则表达式参数中的修饰符 g。</li></ul></li><li>replace() 方法执行检索与替换操作：<ul><li>第一个参数是一个正则表达式；</li><li>第二个参数是要进行替换的字符串；</li><li>如果正则表达式中设置了修饰符 g，那么源字符串中所有与模式匹配的第一个字符串都将替换成第二个蚕食指定的字符串；</li><li>如果不带修饰符 g, 则只替换所匹配的第一个字符串。</li><li>如果第一个参数是字符串而不是正则表达式，则 replace() 方法将直接搜索这个字符串。</li><li>正则表达式如果使用了圆括号括起来的子表达式是带有从左到右的索引编号的，而且正则表达式会记忆与每个子表达式匹配的文本。如果在替换字符串中出现了 $ 加数字，将用于指定的子表达式相匹配的文本来替换这两个字符串。</li><li>replace() 方法的第二个参数还可以是函数，该函数能够动态的计算替换字符串。</li></ul></li><li>match() 是最常用的 String 正则表达式。<ul><li>唯一的参数是一个正则表达式，返回的是一个有匹配结果组成的数组。</li><li>如果正则表达式设置了修饰符 g, match() 方法返回的数组包含字符串中的所有匹配结果。</li><li>如果正则表达式没有设置修饰符，match() 方法就不会进行全局检索，它只检索第一个匹配。</li><li>即使不设置全局，还是返回一个数组。</li><li>该数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果 match() 返回一个数组 a，那么 a[0] 存放的是完整的匹配，a[1] 存放的则是与第一个用圆括号起来的表达式相匹配的子串，依此类推。</li></ul></li><li>split()<ul><li>split() 方法用以调用它的字符串拆分为一个子串组成的数组，使用的分隔符是 split() 的参数。</li></ul></li></ul><h2 id="RegExp-的方法"><a href="#RegExp-的方法" class="headerlink" title="RegExp 的方法"></a>RegExp 的方法</h2><ul><li>exec() 方法返回一个数组<ul><li>exec() 方法对一个指定的字符串执行一个正则表达式，就是在一个字符串中执行匹配检索；</li><li>给字符串的 match() 传入一个非全局的正则表达式，和给这个正则表达式的 exec() 方法传入的字符串是一模一样的，返回一个数组，数组有两个属性：index 和 input。</li><li>第一个元素包含的是与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。</li><li>属性 index 包含了发生匹配的字符位置，属性 input引用的是正在检索的字符串。</li><li>当调用 exec() 的正则表达式对象具有修饰符 g 时，它将当前正则表达式对象的 lastIndex 属性设置为紧挨着匹配子串的字符位置。当统一正则表达式第二次调用 exec() 时，它将从 lastIndex 属性所指示的字符处开始检索。如果没有匹配结果，会将 lastIndex 重置为 0；</li></ul></li><li>test() 方法<ul><li>参数是一个字符串</li><li>用 test() 对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回 true；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式是一个描述字符模式的对象。 JavaScript 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。&lt;/p&gt;
&lt;h2 id=&quot;正则表达式定义&quot;&gt;&lt;a href=&quot;#正则表达式定义&quot; class=&quot;headerlink&quot; title=&quot;正则表达式定义&quot;&gt;&lt;/a&gt;正则表达式定义&lt;/h2&gt;&lt;p&gt;正则表达式的直接量定义为包含在一对斜杠 (/) 之间的字符&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; pattern = &lt;span class=&quot;regexp&quot;&gt;/s$/&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;正则表达式中的基本元字符&quot;&gt;&lt;a href=&quot;#正则表达式中的基本元字符&quot; class=&quot;headerlink&quot; title=&quot;正则表达式中的基本元字符&quot;&gt;&lt;/a&gt;正则表达式中的基本元字符&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 通配符（. 除了\n以外的任意一个内容）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 表示的是范围:表示的是范围中的任意一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; 表示的是:0到9之间(包含)任意一个数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt; 表示所有的小写字母中的一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z]&lt;/code&gt; 表示的是所有的大写字母中的任意一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-zA-Z]&lt;/code&gt; 表示的是所有的字母中的任意一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[9]&lt;/code&gt; 表示的就是9&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9a-zA-Z]&lt;/code&gt; 表示的是任意的一个数字或者任意的一个字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;表示的是分组(为了更明确这个正则表达式的意思),提升优先级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; 表示的是或者的意思&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]|[a-z]&lt;/code&gt; 0-9之间的任意一个数字或者是小写字母中的任意一个字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;表示的是该符号前面的表达式出现了0次到多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 表示的是该符号前面的表达式出现了1次到多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 表示的是该符号前面的表达式出现了0次到一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; 表示的是前面的表达式出现了多少次,具体是多少次:大括号中的写法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; 匹配前一项至少 n 次，但不超过 m 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt;匹配前一项 n 次或者更多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; 匹配前一项 0 次或多次，等价于 {0,}&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="正则系列" scheme="http://yoursite.com/categories/%E6%AD%A3%E5%88%99%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>实现继承的几种方式</title>
    <link href="http://yoursite.com/2015/08/28/%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/08/28/实现继承的几种方式/</id>
    <published>2015-08-27T16:00:00.000Z</published>
    <updated>2018-05-31T02:42:57.793Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 中只支持实现继承，而且主要依靠的是原型链来实现。</p><h2 id="扩展原型对象实现继承"><a href="#扩展原型对象实现继承" class="headerlink" title="扩展原型对象实现继承"></a>扩展原型对象实现继承</h2><ul><li>描述：直接在构造函数的prototype属性上添加方法</li><li>解决的问题：解决了直接将方法设置在构造函数上时，实例化每个对象这些方法都会开辟新空间，造成内存严重浪费的问题</li><li>缺点：如果将所有的方法都直接设置到原型对象上，代码冗余</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一、 扩展原型对象实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.personFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"personFn is run..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"z3"</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"============== 一、 扩展原型对象实现继承 =================="</span>);</span><br><span class="line">p1.personFn();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="替换原型对象实现继承"><a href="#替换原型对象实现继承" class="headerlink" title="替换原型对象实现继承"></a>替换原型对象实现继承</h2><ul><li>描述：将构造函数的原型对象用新对象替换，再往新的对象中添加新方法</li><li>解决的问题：扩展原型对象使得代码冗余</li><li>缺点：所有的方法和属性都被实例共享</li><li>注意：还原构造器</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二、 替换原型对象实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">color, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Animal,</span><br><span class="line">    animalFn: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"animalFn is run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">"white"</span>, <span class="string">"cat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"======================== 二、 替换原型对象实现继承 ========================="</span>);</span><br><span class="line">animal.animalFn();</span><br></pre></td></tr></table></figure><h2 id="另一种原型继承（动态原型模式）-特点：让代码封装到一起"><a href="#另一种原型继承（动态原型模式）-特点：让代码封装到一起" class="headerlink" title="另一种原型继承（动态原型模式） 特点：让代码封装到一起"></a>另一种原型继承（动态原型模式） 特点：让代码封装到一起</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二、 另一种原型继承（动态原型模式） 特点：让代码封装到一起 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Paper</span>(<span class="params">color, size</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="comment">// 动态原型方法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.write !== <span class="string">"function"</span>)&#123;</span><br><span class="line">        Paper.prototype.write = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"color: "</span> + <span class="keyword">this</span>.color + <span class="string">", size: "</span> + <span class="keyword">this</span>.size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> paper = <span class="keyword">new</span> Paper(<span class="string">"orange"</span>, <span class="string">"16k"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"================= 二、另一种原型继承（动态原型模式）===================="</span>);</span><br><span class="line">paper.write();</span><br></pre></td></tr></table></figure><h2 id="混入继承：-已知两个对象，一个对象继承另一个对象的功能，for-in"><a href="#混入继承：-已知两个对象，一个对象继承另一个对象的功能，for-in" class="headerlink" title="混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in"></a>混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in</h2><ul><li>描述： jQuery的extend()方法原理是混入继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 三、 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        target[key] = source[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"Amiy"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    pray: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"name: "</span> + <span class="keyword">this</span>.name + <span class="string">", age: "</span> + <span class="keyword">this</span>.age + <span class="string">", sex: "</span> + <span class="keyword">this</span>.sex + <span class="string">"; obj2.pray is run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    sex: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line">mixin(obj2, obj1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"=================== 三、 混入继承： 已知两个对象，一个对象继承另一个对象的功能，for..in ==================="</span>);</span><br><span class="line">obj2.pray();</span><br></pre></td></tr></table></figure><h2 id="原型-混入继承：混入继承的应用"><a href="#原型-混入继承：混入继承的应用" class="headerlink" title="原型+混入继承：混入继承的应用"></a>原型+混入继承：混入继承的应用</h2><ul><li>描述：在一个对象的原型对象上扩展另一个对象的属性和方法</li><li>jQuery.fn.extend() 利用的原理是原型+混入继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 四、 原型+混入继承：混入继承的应用 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    o2Attr1: <span class="string">"o2Attr1"</span>,</span><br><span class="line">    o2Attr2: <span class="string">"o2Attr2"</span>,</span><br><span class="line">    o2Method1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"o2Method1 is run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mixin(Cat.prototype, o2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"======== 四、 原型+混入继承：混入继承的应用 ========="</span>);</span><br><span class="line">cat.o2Method1();</span><br></pre></td></tr></table></figure><h2 id="经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj"><a href="#经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj" class="headerlink" title="经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj"></a>经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj</h2><ul><li>注意： ES5 Object.create()方法的实现原理就是经典继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 五、 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCreate</span>(<span class="params">knownObj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    F.prototype = knownObj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> knownObj = &#123;</span><br><span class="line">    knownObjAttr1: <span class="string">"knownObjAttr1"</span>,</span><br><span class="line">    knownObjMethod1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"knownObjMethod1 is run..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = myCreate(knownObj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"=============== 五、 经典继承：已知一个对象knownObj，需要创建一个新对象，这个新对象继承自已知的对象knownObj =================="</span>);</span><br><span class="line">o.knownObjMethod1();</span><br><span class="line"><span class="comment">/* 在旧浏览器下实现继承 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        F.prototype = obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="借用构造函数实现继承"><a href="#借用构造函数实现继承" class="headerlink" title="借用构造函数实现继承"></a>借用构造函数实现继承</h2><ul><li>特点： 不会继承原型对象上的方法，因为this的指向变了，原型对象上的方法只能通过构造函数的实例来访问</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 六： 借用构造函数实现继承 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Computer</span>(<span class="params">color, type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"run method is run... "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Computer.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Computer.prototype.start is run..."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面的借用构造函数实现继承就是对这段代码的优化</span></span><br><span class="line"><span class="comment"> * function LenovoNoteBook(color, type, interfaceCount) &#123;</span></span><br><span class="line"><span class="comment"> *     this.color = color;</span></span><br><span class="line"><span class="comment"> *     this.type = type;</span></span><br><span class="line"><span class="comment"> *     this.interfaceCount = interfaceCount;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LenovoNoteBook</span>(<span class="params">color, type, interfaceCount</span>) </span>&#123;</span><br><span class="line">    Computer.call(<span class="keyword">this</span>, color, type);</span><br><span class="line">    <span class="keyword">this</span>.interfaceCount = interfaceCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lenovo = <span class="keyword">new</span> LenovoNoteBook(<span class="string">"write"</span>, <span class="string">"Y470"</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"========= 六： 借用构造函数实现继承 ========"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"color: "</span> + lenovo.color + <span class="string">", type: "</span> + lenovo.type + <span class="string">", interfaceCount: "</span> + lenovo.interfaceCount);</span><br><span class="line">lenovo.run();</span><br><span class="line"><span class="comment">// lenovo.start();</span></span><br></pre></td></tr></table></figure><h2 id="混合继承（经典继承-借用构造函数）"><a href="#混合继承（经典继承-借用构造函数）" class="headerlink" title="混合继承（经典继承+借用构造函数）"></a>混合继承（经典继承+借用构造函数）</h2><ul><li>特点：解决借用构造函数继承不能够继承原型对象上的方法的问题</li><li>缺点：继承了两次构造函数（模板）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 七、 混合继承（经典继承+借用构造函数）*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BaseCar</span>(<span class="params">type, modelNumber, color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.modelNumber = modelNumber;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象上的方法</span></span><br><span class="line">BaseCar.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: BaseCar,</span><br><span class="line">    canSell: function (price) &#123;</span><br><span class="line">        <span class="keyword">var</span> leastPrice = <span class="number">2500000</span>;</span><br><span class="line">        <span class="keyword">if</span> (leastPrice &lt;= price) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"恭喜恭喜，您可以卖车"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"您还差:"</span> + (leastPrice - price) + <span class="string">"元就可以买车了"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Car 构造函数，调用call()实现继承BaseCar中的方法</span></span><br><span class="line"><span class="comment"> * @param type</span></span><br><span class="line"><span class="comment"> * @param modelNumber</span></span><br><span class="line"><span class="comment"> * @param color</span></span><br><span class="line"><span class="comment"> * @constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">type, modelNumber, color</span>) </span>&#123;</span><br><span class="line">    BaseCar.call(<span class="keyword">this</span>, type, modelNumber);</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.bmwStart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Bmv car is starting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典继承</span></span><br><span class="line">Car.prototype = <span class="keyword">new</span> BaseCar();</span><br><span class="line"><span class="keyword">var</span> bmwCar = <span class="keyword">new</span> Car(<span class="string">"Bmw"</span>, <span class="string">"B34212"</span>, <span class="string">"write"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"=================== 七、 混合继承（经典继承+借用构造函数） 白贺翔视频 ====================="</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bmwCar.canSell(<span class="number">2400000</span>));</span><br></pre></td></tr></table></figure><h2 id="解决混合继承的缺点"><a href="#解决混合继承的缺点" class="headerlink" title="解决混合继承的缺点"></a>解决混合继承的缺点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 八、 解决混合继承的缺点 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"父的构造函数上的静态sayHello方法 运行"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: People,</span><br><span class="line">    sayHello: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"父的原型对象中的sayHello方法：name: "</span> + <span class="keyword">this</span>.name + <span class="string">", age: "</span> + <span class="keyword">this</span>.age + <span class="string">", sex: "</span> + <span class="keyword">this</span>.sex + <span class="string">", HelloWorld !!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Boy</span>(<span class="params">name, age, sex, studyNumber</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 子类中保存了父类的原型对象</span></span><br><span class="line">    <span class="comment">// 借用构造函数实现继承</span></span><br><span class="line">    Boy.superClass.constructor.call(<span class="keyword">this</span>, name, age, sex);</span><br><span class="line">    <span class="keyword">this</span>.studyNumber = studyNumber;</span><br><span class="line">&#125;</span><br><span class="line">myExtend(Boy, People);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myExtend</span>(<span class="params">subConstructor, supConstructor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 用一个空函数进行中转</span></span><br><span class="line">    <span class="keyword">var</span> F = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">    <span class="comment">// 2. 保存父的原型对象</span></span><br><span class="line">    F.prototype = supConstructor.prototype;</span><br><span class="line">    <span class="comment">// 3. 实现经典继承</span></span><br><span class="line">    subConstructor.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="comment">// 4. 还原子构造函数原型对象的构造器</span></span><br><span class="line">    subConstructor.prototype.constructor = subConstructor;</span><br><span class="line">    <span class="comment">// 5. 保存父的原型对象，一方面方便解耦，另一方面可以轻松获得原型对象（添加静态方法）</span></span><br><span class="line">    subConstructor.superClass = supConstructor.prototype;</span><br><span class="line">    <span class="comment">// 6. 判断父类型的原型对象构造器，加保险</span></span><br><span class="line">    <span class="keyword">if</span> (supConstructor.prototype.constructor !== supConstructor) &#123;</span><br><span class="line">        supConstructor.prototype.constructor = supConstructor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7. 利用保存的父类原型对象实现父类子类有重载的方法</span></span><br><span class="line">Boy.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Boy,</span><br><span class="line">    sayHello: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"子的原型对象中的sayHello方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意： 子类的原型对象上添加方法必须在实现继承之后</span></span><br><span class="line"><span class="keyword">var</span> boy = <span class="keyword">new</span> Boy(<span class="string">"Ping"</span>, <span class="number">22</span>, <span class="literal">true</span>, <span class="number">345234</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"================ 八、 解决混合继承的缺点，封装函数 ExtJs 底层 白贺翔 ==================="</span>);</span><br><span class="line">boy.sayHello();  <span class="comment">// 父的构造函数上的静态sayHello方法 运行</span></span><br><span class="line">Boy.prototype.sayHello();  <span class="comment">// 子的原型对象中的sayHello方法</span></span><br><span class="line">Boy.superClass.sayHello.call(boy); <span class="comment">// 父的原型对象中的sayHello方法：name: Ping, age: 22, sex: true, HelloWorld !!!</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript 中只支持实现继承，而且主要依靠的是原型链来实现。&lt;/p&gt;
&lt;h2 id=&quot;扩展原型对象实现继承&quot;&gt;&lt;a href=&quot;#扩展原型对象实现继承&quot; class=&quot;headerlink&quot; title=&quot;扩展原型对象实现继承&quot;&gt;&lt;/a&gt;扩展原型对象实现继承&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;描述：直接在构造函数的prototype属性上添加方法&lt;/li&gt;
&lt;li&gt;解决的问题：解决了直接将方法设置在构造函数上时，实例化每个对象这些方法都会开辟新空间，造成内存严重浪费的问题&lt;/li&gt;
&lt;li&gt;缺点：如果将所有的方法都直接设置到原型对象上，代码冗余&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 一、 扩展原型对象实现继承 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prototype.personFn = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;personFn is run...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;z3&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;============== 一、 扩展原型对象实现继承 ==================&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p1.personFn();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="原型链系列" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="原型链，继承" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2015/08/08/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2015/08/08/原型链/</id>
    <published>2015-08-07T16:00:00.000Z</published>
    <updated>2018-05-31T02:24:09.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>原型对象：构造函数的prototype属性：随着实例化的次数增加，不同的对象他们拥有的say方法指向不同的内存，能相同，造成了内存的浪费,为了解决内存，将这个方法放在某个对象（原型对象）中.</p><p>结论1：给构造函数的prototype属性（对象）添加一个方法，这个方法就可以被构造函数的实例所共享<br>推论1：构造函数的prototype属性(对象)上面的属性、方法都可以被构造函数的实例所共享<br>推论2：Student.prototype.constructor===s1.constructor<br>结论2：构造函数的实例有一个<strong>proto</strong>指向的是构造函数的prototype属性(原型对象) s1.<strong>proto</strong>===Student.prototype</p><p>(1). 原型对象是构造函数的prototype属性<br>(2). 构造函数的实例的<strong>proto</strong>属性指向原型对象<br>(3). 原型对象有一个constructor属性指向构造函数本身</p><p><img src="/images/原型01.png" alt="原型图01"></p><a id="more"></a><h2 id="对象的属性的读取与设置"><a href="#对象的属性的读取与设置" class="headerlink" title="对象的属性的读取与设置"></a>对象的属性的读取与设置</h2><blockquote><p>查找一个对象上的是否存在某个属性的过程</p></blockquote><p>(1). 查找当前对象(s1)的内存中是否定义了该属性，找到就停止查找<br>(2). 去当前对象的proto属性（原型对象）中去查找是否定义了该属性，找到就停止查找<br>(3). 如果2中没找到，就去原型对象的原型对象中去查找是否定义了该属性<br>(4). <code>s1.__proto__.__proto__</code><br>……<br>(N). 找到某个对象（是没有原型对象的：没有proto属性），如果这个对象中还没有，确定了无法获取该属性</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JavaScript 的对象组成，一个对象就有它的原型对象(<code>__proto__</code>)，原型对象也有它的原型对象，一直到原型链的顶端，这样构成了一个具有链条形状的结构，称之为原型链</p><ul><li><code>__proto__</code>该属性可以被修改，但是无法被删除</li></ul><p><strong>对象字面量的原型链</strong></p><p><img src="/images/原型02.png" alt="原型图02"></p><p><strong>构造函数创建对象的原型链</strong></p><p><img src="/images/原型03.png" alt="原型图03"></p><p><strong>数组对象的原型链</strong></p><p><img src="/images/原型04.png" alt="原型图04"></p><p><strong>一般来说，无论是对象字面量，还是构造函数创建的对象、内置对象，基本包装了类型的对象，2次原型查找（.proto）就可以找到</strong></p><h2 id="函数的原型链"><a href="#函数的原型链" class="headerlink" title="函数的原型链"></a>函数的原型链</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">f();<span class="comment">//f当成了普通函数来调用</span></span><br><span class="line"><span class="keyword">new</span> f();<span class="comment">//f当成了构造函数来调用</span></span><br></pre></td></tr></table></figure><p>一些结论：</p><ul><li>几乎所有函数都有prototype属性（Function.prototype这个函数上没有）</li><li>所有对象中都有proto属性（Object.prototype该属性的值null）</li></ul><p><code>—&gt; 几乎所有函数都有prototype/__proto__属性</code></p><ul><li>函数都是Function的实例（函数是通过Function创建出来的对象）<ul><li>——&gt; 自定义函数、Function、Array、RegExp、String、Boolean、Number、Object</li></ul></li><li>几乎所有函数都是继承自：Function.prototype（除了Function.prototype）<ul><li>——&gt; <code>函数.__proto__ === Function.prototype</code></li><li>——&gt; <code>Object.__proto__ === Function.prototype</code></li><li>——&gt; <code>Function.__proto__ === Function.prototype</code></li><li><code>Function.prototype.__proto__ === Object.prototype</code></li><li><code>String.prototype.__proto__ === Object.prototype</code></li><li><code>Array.prototype.__proto__ === Object.prototype</code></li><li><code>Boolean.prototype.__proto__ === Object.prototype</code></li><li><code>Number.prototype.__proto__ === Object.prototype</code></li><li><code>RegExp.prototype.__proto__ === Object.prototype</code></li></ul></li></ul><p><strong>练习</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="number">1</span>、<span class="built_in">console</span>.log(fn.constructor===<span class="built_in">Function</span>);<span class="comment">//true //查找fn的内存——&gt;查找fn.__proto__(Function.prototype)——&gt;Function</span></span><br><span class="line"><span class="number">2</span>、<span class="built_in">console</span>.log(fn.__proto__===_______);<span class="comment">//true //Function.prototype</span></span><br><span class="line"><span class="number">3</span>、<span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__===______);<span class="comment">//true //Function.prototype</span></span><br><span class="line"><span class="number">4</span>、<span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype===______);<span class="comment">//true //Function.__proto__——&gt;fn.__proto__——&gt;Object.__proto__</span></span><br><span class="line"><span class="number">5</span>、<span class="built_in">console</span>.log(<span class="built_in">Object</span>.constructor); <span class="comment">//Function</span></span><br><span class="line"><span class="number">6</span>、<span class="built_in">console</span>.log(fn.prototype.constructor); <span class="comment">//fn</span></span><br><span class="line"><span class="number">7</span>、<span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__.constructor); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure><p><strong>原型链完整图</strong></p><p><img src="/images/原型05.png" alt="原型图05"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型对象&quot;&gt;&lt;a href=&quot;#原型对象&quot; class=&quot;headerlink&quot; title=&quot;原型对象&quot;&gt;&lt;/a&gt;原型对象&lt;/h2&gt;&lt;p&gt;原型对象：构造函数的prototype属性：随着实例化的次数增加，不同的对象他们拥有的say方法指向不同的内存，能相同，造成了内存的浪费,为了解决内存，将这个方法放在某个对象（原型对象）中.&lt;/p&gt;
&lt;p&gt;结论1：给构造函数的prototype属性（对象）添加一个方法，这个方法就可以被构造函数的实例所共享&lt;br&gt;推论1：构造函数的prototype属性(对象)上面的属性、方法都可以被构造函数的实例所共享&lt;br&gt;推论2：Student.prototype.constructor===s1.constructor&lt;br&gt;结论2：构造函数的实例有一个&lt;strong&gt;proto&lt;/strong&gt;指向的是构造函数的prototype属性(原型对象) s1.&lt;strong&gt;proto&lt;/strong&gt;===Student.prototype&lt;/p&gt;
&lt;p&gt;(1). 原型对象是构造函数的prototype属性&lt;br&gt;(2). 构造函数的实例的&lt;strong&gt;proto&lt;/strong&gt;属性指向原型对象&lt;br&gt;(3). 原型对象有一个constructor属性指向构造函数本身&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/原型01.png&quot; alt=&quot;原型图01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="原型链系列" scheme="http://yoursite.com/categories/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="面向对象，原型链" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>js String对象</title>
    <link href="http://yoursite.com/2015/07/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2015/07/18/面向对象的程序设计/</id>
    <published>2015-07-17T16:00:00.000Z</published>
    <updated>2018-06-01T06:19:52.422Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象的语言的标志就是它们有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。JavaScript 中的类的实现是基于其原型继承机制。如果两个实例都从同一个原型对象上继承了属性，就认为是同一个类的实例。</p><p>JavaScript 的对象是属性名以及与之对应的值的基本集合。集合是一种数据结构，泳衣表示非重复值的无序集合。</p><a id="more"></a><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>JavaScript 是一门基于对象的多泛式语言。可以使用面向过程进行开发：</p><ul><li>获取元素，绑定事件、设置样式、完成动画。。。。。。</li></ul><p>可以使用面向对象的方式进行开发：</p><ul><li>面向（关注于）过程：基于函数，封装函数</li><li>面向对象：关注点变成了对象</li><li>对象的概念：数据集，功能集： 无序属性的集合，包含基本值，对象或者函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CEO：安排一个任务给CTO(7天)，CTO又把任务给PM(5天)，PM又把任务给我了(3天)，我去开发这个页面</span></span><br><span class="line"><span class="keyword">var</span> ceo = &#123;</span><br><span class="line">    assignTaskToCTO: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"安排一个任务给CTO"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cto = &#123;</span><br><span class="line">    assignTaskToPM: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"安排一个任务给PM"</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> pm = &#123;</span><br><span class="line">    assignTaskToMe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"安排一个任务给我"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    developWeb:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">"我去开发这个页面"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//开发一个页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleveWeb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ceo.assignTaskToCTO();</span><br><span class="line">    cto.assignTaskToPM();</span><br><span class="line">    pm.assignTaskToMe();</span><br><span class="line">    me.developWeb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个例子： 利用构造函数来定义 “范围类”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 构造函数初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">from, to</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 存储起始位置和结束位置</span></span><br><span class="line">  <span class="keyword">this</span>.from = <span class="keyword">from</span>;</span><br><span class="line">  <span class="keyword">this</span>.to = to;</span><br><span class="line">&#125;</span><br><span class="line">Range.prototype = &#123;</span><br><span class="line">  <span class="comment">// constructor: Range,</span></span><br><span class="line">  <span class="comment">// 如果 x 在范围内，返回 true，否则返回 false</span></span><br><span class="line">  <span class="comment">// 这个方法可以比较数字范围，也可以比较字符串和日期范围</span></span><br><span class="line">  includes: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.from &lt;= x &amp;&amp; x &lt;= <span class="keyword">this</span>.to&#125;,</span><br><span class="line">  <span class="comment">// 对于范围内的每一个整数调用函数 f</span></span><br><span class="line">  foreach: <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="built_in">Math</span>.ceil(<span class="keyword">this</span>.from); x &lt;= <span class="keyword">this</span>.to; x++) f(x);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 返回表示这个范围的字符串</span></span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + <span class="keyword">this</span>.from + <span class="string">"..."</span> + <span class="keyword">this</span>.to + <span class="string">")"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Range(<span class="number">3</span>, <span class="number">5</span>); </span><br><span class="line"><span class="built_in">console</span>.log(r.includes(<span class="number">4</span>)); <span class="comment">// true</span></span><br><span class="line">r.foreach(<span class="built_in">console</span>.log); <span class="comment">// 3, 4, 5</span></span><br><span class="line"><span class="built_in">console</span>.log(r);  <span class="comment">// Range&#123;from:3, to:5&#125;</span></span><br></pre></td></tr></table></figure><h2 id="构造函数和类的标识"><a href="#构造函数和类的标识" class="headerlink" title="构造函数和类的标识"></a>构造函数和类的标识</h2><p>当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。初始化对象的状态的构造函数不能作为类的标识，两个构造函数的 prototype 属性可能指向同一个原型对象。那么这连个构造函数的实例是属于同一类型的。</p><p>可以使用<code>r instanceof Range</code>来判断一个实例是否继承自 Range.prototype。</p><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><p>每一个 JavaScript 函数都自动拥有一个 prototype 属性，这个属性指向一个对象即称作原型对象，这个对象包含唯一一个不可枚举的属性 constructor。 constructor 的值是一个函数对象。</p><p>构造函数的原型中存在预先定义好的 constructor 属性，这意味着通常继承的 constructor 均指代它们的构造函数。</p><p>在上面定义的 Range 构造函数的原型由于被另一个对象替换了，所以重写了预定义的 Range.prototype 对象。 Range 的实例的 constructor 没有继承自 Range.prototype 的 constructor 属性。其值变成了 Object。</p><h2 id="创建对象的几种方式"><a href="#创建对象的几种方式" class="headerlink" title="创建对象的几种方式"></a>创建对象的几种方式</h2><p> 使用 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点： 使用一个接口创建很多对象会产生大量的重复代码。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含所有必要信息的 Person 对象</span></span><br><span class="line"><span class="comment">// 可以无数次的调用这个函数，而且每次都会返回一个包含三个属性的方法的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">"Hiraku"</span>, <span class="number">23</span>, <span class="string">"JavaScript Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">"Wang"</span>, <span class="number">22</span>, <span class="string">"Java Engineer"</span>);</span><br><span class="line">p1.sayName();</span><br><span class="line">p2.sayName();</span><br></pre></td></tr></table></figure><p>问题： 并没有解决对象识别的问题（即怎样知道一个对象的类型）。</p><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"Hiraku"</span>, <span class="number">23</span>, <span class="string">"JavaScript Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"Wang"</span>, <span class="number">22</span>, <span class="string">"Java Engineer"</span>);</span><br><span class="line">p1.sayName();</span><br><span class="line">p2.sayName();</span><br></pre></td></tr></table></figure><p>和工厂模式的区别：</p><ul><li>没有显式的创建对象；</li><li>直接将属性和方法赋值给了 this 对象</li><li>没有 return 语句</li><li>使用 new 关键字创建对象的实例</li><li>将构造函数的作用域赋值给新对象（因此 this 就指向了这个对象）</li><li>返回新对象</li><li>p1 和 p2 有继承自 Person.prototype 的属性 constructor，该属性指向 Person</li></ul><p>使用构造函数模式的缺点：每个方法都要在每个实例上创建一遍。如 p1 和 p2 都有一个名为 sayName() 方法，但是两个方法不是同一个 Function 的实例。创建两个完成相同任务的 Function 实例没有必要，这样会浪费内存。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Hiraku"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">22</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"JavaScript Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.sayName();</span><br></pre></td></tr></table></figure><p>好处：可以让所有对象实例共享它所包含的属性和方法。</p><p>当给对象的实例添加一个属性时，这个属性会屏蔽原型对象中保存的同名属性。</p><h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">"Hiraku"</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  job: <span class="string">"JavaScript Engineer"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时 constructor 属性不再指向 Person 了，constructor 变成了新对象的 constructor，是 Object 构造函数。</p><p>这时，需要还原构造器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: "Hiraku",</span><br><span class="line">  age: 23,</span><br><span class="line">  job: "JavaScript Engineer",</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注： 以上方式重置 constructor 属性会导致它的 [[enumerable]] 特性被设置为 true。 默认情况下，原生的 constructor 属性是不可枚举的，因此，可以使用 ECMAScript5 中的 Object.defineProperty() 方法来设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="原型的动态特性"><a href="#原型的动态特性" class="headerlink" title="原型的动态特性"></a>原型的动态特性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &quot;Hiraku&quot;,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">friend.sayName();  // 报错</span><br></pre></td></tr></table></figure><p>原因是重写了原型对象，把原型对象修改为另一个对象就等于切断了构造函数与最初原型之间的联系。 实例中的指针仅仅指向原型，而不指向构造函数。</p><h4 id="原生的对象原型"><a href="#原生的对象原型" class="headerlink" title="原生的对象原型"></a>原生的对象原型</h4><p>原型模式不仅仅体现在创建自定义类型放没放，就连所有原生的引用类型，都采用这种模式创建的。所有原生原生引用类型都在其构造函数的原型上定义了方法。</p><p>通过原生原型对象，不仅可以取得默认方法的引用，而且还可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。</p><p>但是，不建议在编程时修改原生对象的原型。</p><h4 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h4><p>省略了构造函数初始化，所有实例默认情况下都将取得相同的属性值。还有，原型模式的最大问题是由其共享的本性所导致。</p><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Herschal"</span>, <span class="string">"Camile"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"Hiraku"</span>, <span class="number">23</span>, <span class="string">"JavaScript Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"Wang"</span>, <span class="number">22</span>, <span class="string">"Java Engineer"</span>);</span><br><span class="line">p1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.friends);  <span class="comment">// "Herschal, Camile, Van"</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.friends);  <span class="comment">// "Herschal, Camile"</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.friends === p2.friends);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName);  <span class="comment">// true</span></span><br><span class="line">p1.sayName();</span><br><span class="line">p2.sayName();</span><br></pre></td></tr></table></figure><p>这种方式是使用最广泛的。</p><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Herschal"</span>, <span class="string">"Camile"</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"Hiraku"</span>, <span class="number">23</span>, <span class="string">"JavaScript Engineer"</span>);</span><br><span class="line">p1.sayName();</span><br></pre></td></tr></table></figure><p>这里在对原型做的修改，能立即在所有实例中得到反映。</p><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>基本思路是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回创建的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"Hiraku"</span>, <span class="number">23</span>, <span class="string">"JavaScript Engineer"</span>);</span><br><span class="line">p1.sayName();</span><br></pre></td></tr></table></figure><p>关于寄生构造模式，首先，返回对象与构造函数或者构造函数的原型属性之间没有关系。也就是说，构造函数返回到对象与在构造函数外部创建的对象没有什么不同。不能依赖 instanceof 操作符来确定对象的类型。</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>首先介绍稳妥对象，稳妥对象是指没有公共属性，而且其它方法也不引用 this 的对象。稳妥模式适合在一些安全的环境中，或者在防止数据被其它应用程序改动时使用。稳妥模式遵循寄生模式，但有两点不同。</p><ul><li>新创建对象的实例方法不引用 this；</li><li>不使用 new 操作符来调用构造函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">"Hiraku"</span>, <span class="number">23</span>, <span class="string">"JavaScript Engineer"</span>);</span><br><span class="line">p1.sayName();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象的语言的标志就是它们有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。JavaScript 中的类的实现是基于其原型继承机制。如果两个实例都从同一个原型对象上继承了属性，就认为是同一个类的实例。&lt;/p&gt;
&lt;p&gt;JavaScript 的对象是属性名以及与之对应的值的基本集合。集合是一种数据结构，泳衣表示非重复值的无序集合。&lt;/p&gt;
    
    </summary>
    
      <category term="面向对象系列" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>js String对象</title>
    <link href="http://yoursite.com/2015/07/06/js%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2015/07/06/js的函数/</id>
    <published>2015-07-05T16:00:00.000Z</published>
    <updated>2018-05-31T01:57:03.308Z</updated>
    
    <content type="html"><![CDATA[<p>js 高程中这样定义函数：函数是这样一段 JavaScript 代码，只定义一次，但可以被执行任意多次。JavaScript 的函数是参数化的：函数的定义会包括一个称为形参和标识符列表，这些参数在函数体中就像局部变量一样工作。函数的调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，成为该函数调用表达式的值。出来实参之外，每次调用还会拥有另一个值-本次调用的上下文-这就是 <code>this</code> 关键字的值。</p><p>如果函数挂载在一个对象上，作为对象的一个方法调用，就称之为 <code>对象的方法</code>。当通过这个对象来调用函数时，该对象就是此次调用的上下文，也就是该函数的 this 的值。</p><p>用于初始化一个新建的对象的函数成为<code>构造函数</code>。</p><p>在 JavaScript 里，函数即对象。可以把函数赋值给变量，或者作为参数传递给其他函数。</p><p>JavaScript 的函数可以嵌套在其他函数中定义，这样就可以访问它们被定义时所处的作用域中的任何变量。这意味着 JavaScript 函数构成了一个闭包。</p><a id="more"></a><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h3 id="函数定义方式一：-函数声明"><a href="#函数定义方式一：-函数声明" class="headerlink" title="函数定义方式一： 函数声明"></a>函数定义方式一： 函数声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">arg0, arg1, ...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的组成：</p><ul><li>function 关键字</li><li>函数名标识符：是函数声明语句的必要组成</li><li>一对圆括号：其中包含有 0 个或多个逗号分隔的标识符组成的列表，表示函数的参数</li><li>一对花括号</li></ul><h3 id="函数的定义方式二：-函数表达式"><a href="#函数的定义方式二：-函数表达式" class="headerlink" title="函数的定义方式二： 函数表达式"></a>函数的定义方式二： 函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, ...</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg0, arg1, ...</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以函数表达式定义的函数，函数名称是可选的。一条语句实际上声明了一个变量，并把一个函数对象赋值给它。函数表达式定义函数通常不加函数名，图特别适合仅调用一次的函数。</p><h3 id="函数的嵌套"><a href="#函数的嵌套" class="headerlink" title="函数的嵌套"></a>函数的嵌套</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hypotenuse</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(square(a) + square(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用、this指向、返回值"><a href="#函数调用、this指向、返回值" class="headerlink" title="函数调用、this指向、返回值"></a>函数调用、this指向、返回值</h2><p>一个函数最终产生什么样的结构，跟如何调用这个函数息息相关：函数的四种调用模式</p><h3 id="函数的4种调用模式"><a href="#函数的4种调用模式" class="headerlink" title="函数的4种调用模式"></a>函数的4种调用模式</h3><ol><li>第一种模式：函数调用模式，也就是写一个函数，然后调用一下</li><li>第二种模式：方法调用模式，也就是将函数成为对象的一个方法，然后通过对象来调用</li><li>第三种模式：构造函数调用模式，也就是将函数当成构造函数来调用</li><li>第四种调用模式：上下文调用模式，根据调用方式的不同可以产生不同的结果</li></ol><p>第四种函数调用的实现方式</p><ul><li>实现方式：call/apply (apply 和 call 的唯一区别是第二个参数是数组，将实参值一一传到数组中。fn.call (函数内部的 this 的值,实参1，实参2…))</li></ul><h3 id="不同调用模式中的this的值"><a href="#不同调用模式中的this的值" class="headerlink" title="不同调用模式中的this的值"></a>不同调用模式中的this的值</h3><ol><li>函数调用模式中 this 指向：window</li><li>方法调用模式中 this 指向：调用的对象</li><li>构造函数调用模式中 this 指向：构造函数的实例</li><li>上下文调用模式中 this 指向：</li></ol><ul><li>(1) 如果 call 方法的第一个参数是一个对象，则 fn 函数内部的 this 的值指向该对象</li><li>(2) 如果 call 方法的第一个参数是一个字符串、数字、布尔值，则 fn 函数内部的 this 的值会转换为该类型所对应的基本包装类型的对象</li><li>(3) 如果 call 方法的第一个参数是 null ，则 fn 函数内部的 this 的值是 window ——&gt; 就相当于是一次函数调用模式</li></ul><h3 id="调用模式中的返回值"><a href="#调用模式中的返回值" class="headerlink" title="调用模式中的返回值"></a>调用模式中的返回值</h3><ol><li>函数调用模式中返回值：由 return 语句决定</li><li>方法调用模式中返回值：由 return 语句决定</li><li>构造函数调用模式中的返回值：</li></ol><ul><li>(1). 如果构造函数没有手动设置返回值，那么会返回构造函数的实例</li><li>(2). 如果手动给构造函数添加了返回值，有以下2种情况：<ul><li>(a). 返回值是值类型：最终的返回值还是构造函数的实例</li><li>(b). 返回值是引用类型(对象)：最终的返回值就是该对象</li></ul></li></ul><ol><li>上下文调用模式中的返回值：由 return 语句决定</li></ol><h2 id="函数的实参和形参"><a href="#函数的实参和形参" class="headerlink" title="函数的实参和形参"></a>函数的实参和形参</h2><h3 id="函数的可选形参"><a href="#函数的可选形参" class="headerlink" title="函数的可选形参"></a>函数的可选形参</h3><p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPropertyName</span>(<span class="params">o, <span class="regexp">/*可选的*/</span> a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">undefined</span>) a = [];  <span class="comment">// 如果未定义，赋值一个新数组</span></span><br><span class="line">  <span class="comment">// 上面这句代码可以替换成 a = a || []; // 这才是习惯写法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> property <span class="keyword">in</span> a) a.push(property);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = getPropertyName(o);</span><br><span class="line">getPropertyNames(o, p); <span class="comment">// 将 ｐ 的属性追加到数组 a 中</span></span><br></pre></td></tr></table></figure><p>注意： 需要定义可选的实参来实现函数时，需要将可选的实参放在实参列表的最后。</p><h3 id="可变长的实参列表、实参对象"><a href="#可变长的实参列表、实参对象" class="headerlink" title="可变长的实参列表、实参对象"></a>可变长的实参列表、实参对象</h3><p>当调用函数时传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。函数的参数对象解决了这个问题。</p><p>在函数体内部， 标识符 arguments 指向实参对象的引用，实参对象包含一个 length 属性，是一个伪数组。、</p><p>实参的重要用途是可以操作任意数量的实参。</p><p>在非严格模式下，当一个函数包含若干个形参，实参对象的数组元素是函数形参所对应实参的别名，实参对象中以数字索引，并且形参名称可以认为是相同变量的不同命名。</p><p>严格模式下，arguments 对象变成了一个保留字，不能给其赋值，也不能使用 arguments 作为形参名或者局部变量名，也不能给 arguments 赋值。</p><h3 id="callee-和-caller-属性"><a href="#callee-和-caller-属性" class="headerlink" title="callee 和 caller 属性"></a>callee 和 caller 属性</h3><p>callee 指向当前正在执行的函数。</p><p>caller 是非标准的，但大多数函数实现了这个属性。指的是调用当前正在执行的函数的函数。</p><h3 id="将对象的属性作为实参"><a href="#将对象的属性作为实参" class="headerlink" title="将对象的属性作为实参"></a>将对象的属性作为实参</h3><p>JavaScript 中，可以通过 <code>键/值</code> 对的形式来传入参数，这样当一个函数中的参数有很多的时候，不需要记住传入的顺序。</p><p>这种风格调用的函数，传入的实参都写进一个单独的对象中，在调用的时候传入一个对象，对象中的 <code>键/值</code>对是真正需要的实参数据。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原始数组中的 length 元素复制到目标数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arraycopy</span>(<span class="params"><span class="regexp">/* array */</span> from, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">/* index */</span> form_start, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">/* array */</span> to, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">/* index */</span> to_start, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">/* integer */</span> length</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 代码段</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这种方式效率较低，但不必记住参数顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easycopy</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    arraycopy(args.from,</span><br><span class="line">        args.from_start || <span class="number">0</span>,</span><br><span class="line">        args.to,</span><br><span class="line">        args.to_start || <span class="number">0</span>,</span><br><span class="line">        args.length );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 easycopy 方法</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], b = [];</span><br><span class="line">easycopy(&#123;<span class="attr">from</span>: a, <span class="attr">to</span>: b, <span class="attr">length</span>: <span class="number">4</span>&#125;);</span><br></pre></td></tr></table></figure><p>可以使用以上这种代码来适当使用文档说明自己的函数的参数</p><h3 id="实参类型"><a href="#实参类型" class="headerlink" title="实参类型"></a>实参类型</h3><p>JavaScript 方法的形参并未声明类型，在形参传入函数之前没有做任何类型检测。在定义函数的时候，需要添加类型判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">"object"</span> </span><br><span class="line">    &amp;&amp; <span class="built_in">isFinite</span>(o.length)</span><br><span class="line">    &amp;&amp; o.length &gt;=<span class="number">0</span> </span><br><span class="line">    &amp;&amp; o.length === <span class="built_in">Math</span>.floor(o.length)</span><br><span class="line">    &amp;&amp; o.length &lt; <span class="number">4294967296</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; argument.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> element = <span class="built_in">arguments</span>[i], n;</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="literal">null</span>) <span class="keyword">continue</span>;          <span class="comment">// 忽略 null 和 undefined 实参</span></span><br><span class="line">        <span class="keyword">if</span> (isArray(element))                   <span class="comment">// 如果实参是数组</span></span><br><span class="line">            n = sum.apply(<span class="keyword">this</span>, element);       <span class="comment">// 递归地计算累加...</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">'function'</span>) <span class="comment">// 是函数</span></span><br><span class="line">            n = <span class="built_in">Number</span>(element());              <span class="comment">// 调用并做类型转换</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            n = <span class="built_in">Number</span>(element);                <span class="comment">// 否则直接做类型转换         </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(n))                           <span class="comment">// 如果无法转换为数字，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"sum(): can't convert "</span> + element + <span class="string">" to number"</span>);</span><br><span class="line">        total += n; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>JavaScript 中的函数不仅仅是一种语法，也是值，可以将函数赋值给变量，也可以存储在对象的属性或数组的元素中，还可以作为参数传入另外一个函数等。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x*x;&#125;, <span class="number">20</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>](a[<span class="number">2</span>]));  <span class="comment">// =&gt; 400</span></span><br></pre></td></tr></table></figure><h3 id="自定义函数的属性"><a href="#自定义函数的属性" class="headerlink" title="自定义函数的属性"></a>自定义函数的属性</h3><p>JavaScript 中的函数并不是原始值，而是一个种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个”静态” 变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniquInteger.counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniquInteger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uniquInteger.counter++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算阶乘的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFinite</span>(n) &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n == <span class="built_in">Math</span>.round(n)) &#123; <span class="comment">// 有限的正整数</span></span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) </span><br><span class="line">            factorial[n] = n * factorial(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> factorial[n]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NaN</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial[<span class="number">1</span>]); <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure><h2 id="作为命名空间的函数"><a href="#作为命名空间的函数" class="headerlink" title="作为命名空间的函数"></a>作为命名空间的函数</h2><p>命名空间内定义的变量不会污染全局变量，这就解决环境中变量冲突问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块代码段</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个用来将第二个以及后续参数复制至第一个参数</span></span><br><span class="line"><span class="comment">// 如果 o 的属性拥有了一个不可枚举的同名属性，则 for/in 循环</span></span><br><span class="line"><span class="comment">// 不会枚举对象 o 的可枚举属性</span></span><br><span class="line"><span class="keyword">var</span> extend = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在修复之前，先检测 bug 是否存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> &#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 代码执行到这里，for/in 循环会正确工作并返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) o[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代码执行到这里，说明 for/in 不会枚举测试对象的 toString 属性</span></span><br><span class="line">    <span class="comment">// 如果返回的另一个版本的 extend() 函数，这个函数是显式测试 Object.prototype中的不可枚举属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patched_extend</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) o[prop] = source[prop];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; protoprops.length; i++) &#123;</span><br><span class="line">                prop = protoprops[j];</span><br><span class="line">                <span class="keyword">if</span> (source.hasOwnProperty(prop)) o[prop] = source[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 列出了需要检测的特殊属性</span></span><br><span class="line">    <span class="keyword">var</span> protoprops = [<span class="string">"toString"</span>, <span class="string">"valueOf"</span>, <span class="string">"constructor"</span>, <span class="string">"hasOwnProperty"</span>,</span><br><span class="line">        <span class="string">"isPrototypeOf"</span>, <span class="string">"propertyIsEnumerable"</span>, <span class="string">"toLocaleString"</span></span><br><span class="line">    ];</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2 id="js-词法分析"><a href="#js-词法分析" class="headerlink" title="js 词法分析"></a>js 词法分析</h2><h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><ol><li>读取代码，主关注声明的部分：var</li><li>判断var后面的名字是否已经被标记，如果没有被标记过，就标记</li><li>读取完毕后，代码从上往下，从左往右依次执行</li></ol><h3 id="词法作用域（作用域：变量可以使用到不能使用的范围）"><a href="#词法作用域（作用域：变量可以使用到不能使用的范围）" class="headerlink" title="词法作用域（作用域：变量可以使用到不能使用的范围）"></a>词法作用域（作用域：变量可以使用到不能使用的范围）</h3><blockquote><p>词法作用域就是描述变量的访问范围：</p></blockquote><ol><li>在代码中只有函数可以限定作用范围，允许函数访问外部的变量</li><li>在函数内优先访问内部声明的变量，如果没有才会访问外部的</li><li>所有变量的访问规则，按照预解析规则来访问</li></ol><p>作用域链：</p><p>每一个函数具有独立作用域，由于函数内可以套函数，所以在函数内部访问变量的时候，需要一级一级的往上查找该变量，这样就好像构成了一个链式结构，把它称之为作用域链。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>开启严格模式：”use strict”;</p><ol><li>严格模式中禁止给一个未声明的变量赋值：</li><li>严格模式中eval具有了独立作用域——&gt;在eval中声明的变量和函数都是局部变量</li><li>严格模式中禁止使用arguments.callee进行递归调用</li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JavaScript 函数的执行依赖于变量作用域，这个作用域在函数定义时决定的，而不是函数调用的时候决定的。为了实现这种词法作用域, JavaScript 函数对象的内部状态不仅仅包含函数的代码逻辑，还必须引用当前的作用域， JavaScript 函数对象的内部状态不仅包含函数代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称闭包。</p><p>函数定义时的定义作用域链到函数执行时依然有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用闭包实现的私有属性存取器方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrivateProperty</span> (<span class="params">o, name, predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    o[<span class="string">"get"</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line">    o[<span class="string">"set"</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate &amp;&amp; !predicate(v))</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"set"</span> + name + <span class="string">": invalid value "</span> + v);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            value = v;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">addPrivateProperty(o, <span class="string">"Name"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> x == <span class="string">"string"</span>&#125;);</span><br><span class="line">o.setName(<span class="string">"Hiraku"</span>);  <span class="comment">// 设置属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getName); <span class="comment">// 获取属性值</span></span><br><span class="line">o.setName(<span class="number">0</span>);  <span class="comment">// 试图设置一个错误的值</span></span><br></pre></td></tr></table></figure><p>闭包的一个应用: 模块化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面向对象——&gt;模块化</span></span><br><span class="line"><span class="keyword">var</span> SongManager2=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SongManager</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    SongManager.prototype=&#123; <span class="comment">//原型对象</span></span><br><span class="line">        init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            f1();</span><br><span class="line">            f2();</span><br><span class="line">            f3();<span class="comment">//这3个功能：如果业务逻辑非常复杂，需要把这些方法拆分掉，</span></span><br><span class="line">            <span class="comment">//     并且这些方法不能让用户随便调用，用一些函数封装一下</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//原型对象中的方法对于子对象是完全公开的，对象可以随意调用</span></span><br><span class="line">        init1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">        init2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> SongManager;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="闭包实现思路：外层函数，内层函数"><a href="#闭包实现思路：外层函数，内层函数" class="headerlink" title="闭包实现思路：外层函数，内层函数"></a>闭包实现思路：外层函数，内层函数</h3><ul><li>通常设置外层函数的返回值就是内层函数</li><li>也可以让外层函数的返回值是一个对象（方法)</li><li>如果需要保存一个数据(外层函数的同一个变量)，让内层函数调用多次，该变量的值都是共享的</li><li>如果需要保存多个数据(外层函数的同一个变量)，让外层函数调用多次</li></ul><h2 id="函数的属性、方法和构造函数"><a href="#函数的属性、方法和构造函数" class="headerlink" title="函数的属性、方法和构造函数"></a>函数的属性、方法和构造函数</h2><p>JavaScript 中的函数是值， 使用 typeof 方法得到的结果是 “function”，但是函数是 JavaScript 中的特殊的对象，也可以拥有属性和方法。甚至可以用 Function()构造函数来创建新的函数对象。</p><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p>在函数体里， arguments.length 表示传入函数的实参的个数。而函数本事的 length 属性是只读的，它代表函数形参数量，即函数定义时时给出的实参个数，通常也是函数在调用时期望传入的个数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断所传入的实参个数是否正确</span></span><br><span class="line"><span class="comment">// 该函数使用 arguments.callee 不能在严格模式下调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> actual = args.length;</span><br><span class="line">    <span class="keyword">var</span> expected = args.callee.length;</span><br><span class="line">    <span class="keyword">if</span> (actural !== expected) </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Expected "</span> + expected + <span class="string">"args; got "</span> + actual);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    check(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prototype-属性"><a href="#prototype-属性" class="headerlink" title="prototype 属性"></a>prototype 属性</h3><p>每一个函数都包含一个 prototype 属性，该属性指向一个对象的引用，这个对象称为原型对象。下一篇文章将深入分析。</p><h3 id="call-方法和-apply-方法"><a href="#call-方法和-apply-方法" class="headerlink" title="call() 方法和 apply() 方法"></a>call() 方法和 apply() 方法</h3><p>call() 和 apply() 的第一个实参是要调用函数的母体对象，它是调用上下文，在函数体内通过 this 来获得对它的引用。</p><p>在严格模式中，call() 和 apply() 的第一个实参都会变成 this 的值，哪怕传入的是 null 或 undefined。在严格模式下，传入 null 或 undefined 的时候都会被全局对象代替。</p><h3 id="call-apply区别"><a href="#call-apply区别" class="headerlink" title="call/apply区别"></a>call/apply区别</h3><ol><li><p>相同点：</p><ul><li>(1) 都是Function.prototype对象中定义的方法</li><li>(2) 第一个参数都是表示函数内部的this的值</li></ul></li><li><p>不同点：</p></li></ol><ul><li>如果需要给函数传递参数的时候:<ul><li>利用call方法，将函数的参数从第二个参数开始依次排开</li><li>apply方法的第二个参数是一个数组对象，数组的第一个参数表示函数的第一个实参，依次以此类推</li></ul></li></ul><h3 id="apply的一个漂亮的应用"><a href="#apply的一个漂亮的应用" class="headerlink" title="apply的一个漂亮的应用"></a>apply的一个漂亮的应用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> points = [</span><br><span class="line">        &#123; <span class="attr">x</span>: <span class="number">110</span>, <span class="attr">y</span>: <span class="number">50</span>&#125;, &#123; <span class="attr">x</span>: <span class="number">130</span>, <span class="attr">y</span>: <span class="number">60</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">20</span>, <span class="attr">y</span>: <span class="number">70</span> &#125;, &#123; <span class="attr">x</span>: <span class="number">60</span>, <span class="attr">y</span>: <span class="number">50</span> &#125;</span><br><span class="line">    ];</span><br><span class="line"><span class="keyword">var</span> maxX = <span class="built_in">Math</span>.max.apply( <span class="literal">null</span>, points.map(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v.x; &#125;));</span><br></pre></td></tr></table></figure><p>以上代码中借用Math对的max方法，利用arr.map()方法中返回的是数组这一特性得到了数组中对象的某个属性的最大值。</p><h3 id="将当前函数的-arguments-数组直接传入-apply-来调用另一个函数"><a href="#将当前函数的-arguments-数组直接传入-apply-来调用另一个函数" class="headerlink" title="将当前函数的 arguments 数组直接传入 apply() 来调用另一个函数"></a>将当前函数的 arguments 数组直接传入 apply() 来调用另一个函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象 o 中的方法替换为另一个方法</span></span><br><span class="line"><span class="comment">// 可以在调用原始方法之前和之后记录日志消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> original = o[m]; <span class="comment">// 在闭包中保存原有方法</span></span><br><span class="line">    o[m] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 定义新方法</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">"Entering:"</span>, m); <span class="comment">// 输出日志消息</span></span><br><span class="line">      <span class="keyword">var</span> result = original.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原始函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">"Exiting:"</span>, m); <span class="comment">// 输出日志消息</span></span><br><span class="line">      <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>trace 方法接收两个参数，一个对象和一个方法名，它将制定的方法替换为一个新的方法。</p><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h3><p>bind() 方法在 Function 的原型对象上</p><p>bind 方法是 ECMAScript 5 的新方法，用途是将函数绑定到某个对象。当函数 f() 上调用 bind 方法并传入一个对象 o 作为参数，这个方法返回一个新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x + y; &#125;; </span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(o);</span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">2</span>));  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>bind() 简单绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个函数，通过调用它来调用 o 中的方法 f(), 传递它所有的实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">f, o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f.bind) <span class="keyword">return</span> f.bind(o);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.apply(o, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 5 的 bind() 方法不仅仅是将函数绑定到一个对象，它还可以附带一些其它应用：除了第一个参数外，传入 bind() 的实参也会绑定到 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">// 创建一个类似 sum 的函数，但 this 的值绑定到 null</span></span><br><span class="line"><span class="comment">// 并且第一个参数绑定到 1，这个新的函数期望只传入一个实参</span></span><br><span class="line"><span class="keyword">var</span> succ = sum.bind(<span class="literal">null</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(succ(<span class="number">2</span>));  <span class="comment">// 3: x 绑定到 1， 并传入 2 作为实参 y</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y,z</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x + y + z &#125;;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g(<span class="number">3</span>));  <span class="comment">// 6: this.x 绑定到 1，y 绑定到 2， z 绑定到 3</span></span><br></pre></td></tr></table></figure><h3 id="bind-的兼容方法"><a href="#bind-的兼容方法" class="headerlink" title="bind() 的兼容方法"></a>bind() 的兼容方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">o <span class="regexp">/*, args*/</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将 this 和 arguments 的值保存到变量中</span></span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>, boundArgs = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> args = [], i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">            <span class="keyword">return</span> self.apply(o, args);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 5 的 bind() 方法返回的函数不包含 prototype 属性，并且将这些绑定的函数用作构造函数时所创建的对象从原始的未绑定的构造函数中继承 prototype 。</p><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><p>函数也有 toString() 方法，大多数函数的 toString() 方法返回包含函数体本身的字符串。</p><h3 id="静态属性和实例属性"><a href="#静态属性和实例属性" class="headerlink" title="静态属性和实例属性"></a>静态属性和实例属性</h3><ol><li>给函数添加一个属性（静态属性——&gt;函数对象自身的属性）</li><li>给某个构造函数的实例添加的属性：实例属性</li></ol><h3 id="所有的函数对象都共有的一些静态属性"><a href="#所有的函数对象都共有的一些静态属性" class="headerlink" title="所有的函数对象都共有的一些静态属性"></a>所有的函数对象都共有的一些静态属性</h3><ol><li>name：获取函数的名称</li><li>length：表示函数形参的个数</li><li>caller：表示当前函数调用是在哪个函数内</li></ol><h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function() 构造函数"></a>Function() 构造函数</h3><p>Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体，它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其它所有字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只需要给构造函数简单的传入一个字符串，即函数体。</p><p>注： Function() 构造函数并不需要通过传入实参以指定函数名。就像函数的直接量一样，Function() 构造函数创建一个匿名函数。</p><ul><li>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数</li><li>每次调用 Function() 构造函数都会解析函数体，并创建函数对象</li><li>Function() 构造函数创建的函数并不使用词法作用域，函数体代码的编译总是会在顶层函数执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"return scope"</span>);  <span class="comment">// 这里无法使用局部作用域的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 Function() 构造函数定义的函数使用的不是局部作用域</span></span><br><span class="line"><span class="built_in">console</span>.log(constructFunction()());   <span class="comment">// "golobal"</span></span><br></pre></td></tr></table></figure><p>可以认为 Function() 构造函数是在全局作用域中执行的 eval(); eval() 可以在自己的私有作用域内定义新变量和函数。 Function() 很少用到。</p><h3 id="可调用的对象"><a href="#可调用的对象" class="headerlink" title="可调用的对象"></a>可调用的对象</h3><p>类似于 所有的”伪数组”，对于函数也存在类似的情况。”可调用对象” 是一个对象，可以在函数调用表达式中调用这个对象。所有的函数都是可调用的，但并非所有的可调用对象都是函数。</p><p>可调用对象在两个 JavaScript 实现中不能算作函数。首先，IE Web 浏览器实现了客户端方法，比如 Window.alert(), Document.getElementById(), 使用了可调用的宿主对象，而不是内置函数对象。</p><p>另一个可调用对象是 RegExp 对象，可以直接调用 RegExp 对象，这比调用它的 exec() 方法更快一些。这是 JavaScript 中的一个非标准特性，使用typeof 运算的结果并不统一。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="使用函数处理数组"><a href="#使用函数处理数组" class="headerlink" title="使用函数处理数组"></a>使用函数处理数组</h3><p>ECMAScript 3 中没有数组的 map() 和 reduce() 函数，封装兼容的 map() 和 reduce()。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于数组的每个元素调用函数，返回一个数组</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map </span><br><span class="line">  ? <span class="function"><span class="keyword">function</span>(<span class="params">a, callback</span>) </span>&#123; <span class="keyword">return</span> a.map(callback); &#125; </span><br><span class="line">  : <span class="function"><span class="keyword">function</span>(<span class="params">a, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> a) results[i] = callback.call(<span class="literal">null</span>, a[i], i, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 如果函数 callback 和可选的初始值将数组 a 减至一个值</span></span><br><span class="line"><span class="keyword">var</span> reduce = <span class="built_in">Array</span>.prototype.reduce</span><br><span class="line">  ? <span class="function"><span class="keyword">function</span>(<span class="params">a, callback, initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> a.reduce(callback, initial);   <span class="comment">// 如果传入了一个初始值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.reduce(callback); <span class="comment">// 否则没有初始值</span></span><br><span class="line">  &#125;</span><br><span class="line">  : funciton(a, callback, initial) &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>, len = a.length, accumulator;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) accumulator = initial;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 找到数组中已定义的索引</span></span><br><span class="line">      <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">      <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i <span class="keyword">in</span> a) &#123;</span><br><span class="line">          accumulator = a[i++];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == len) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对数组剩余的元素依次调用 callback</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> a)</span><br><span class="line">        accumulator = callback.call(<span class="literal">undefined</span>, accumulator, a[i], i, a);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="递归：函数自己调用自己"><a href="#递归：函数自己调用自己" class="headerlink" title="递归：函数自己调用自己"></a>递归：函数自己调用自己</h2><h3 id="计算斐波那契数列第n项的值：1-1-2-3-5-8-13…"><a href="#计算斐波那契数列第n项的值：1-1-2-3-5-8-13…" class="headerlink" title="计算斐波那契数列第n项的值：1,1,2,3,5,8,13…"></a>计算斐波那契数列第n项的值：1,1,2,3,5,8,13…</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="built_in">console</span>.log(fibonacci(i+<span class="number">1</span>)); &#125;</span><br></pre></td></tr></table></figure><h3 id="递归计算阶乘"><a href="#递归计算阶乘" class="headerlink" title="递归计算阶乘"></a>递归计算阶乘</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//为了防止报错</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归的结束条件：0的阶乘为1</span></span><br><span class="line">    <span class="keyword">return</span> factorial(n<span class="number">-1</span>)*n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="built_in">console</span>.log(<span class="string">"数字："</span>+i); <span class="built_in">console</span>.log(factorial(i));&#125;</span><br></pre></td></tr></table></figure><h3 id="m的n次方"><a href="#m的n次方" class="headerlink" title="m的n次方"></a>m的n次方</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (m === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> / (pow(n, -(m + <span class="number">1</span>)) * n);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; <span class="number">0</span>) <span class="keyword">return</span> pow(n, m - <span class="number">1</span>) * n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">-2</span>; i &lt;= <span class="number">0</span>; i++) &#123; <span class="built_in">console</span>.log(pow(<span class="number">2</span>, i)); &#125;</span><br></pre></td></tr></table></figure><h3 id="递归查找父元素"><a href="#递归查找父元素" class="headerlink" title="递归查找父元素"></a>递归查找父元素</h3><p>需求：要判断一个div是否在另一个div的下面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">child,parent</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//实现思路：由子元素一级一级的查找父元素</span></span><br><span class="line">    <span class="comment">//递归的结束条件：查到了文档的根节点、找到了父元素</span></span><br><span class="line">    <span class="keyword">if</span>(child.parentNode===parent) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//说明已经找到了符合条件的父元素</span></span><br><span class="line">    <span class="keyword">if</span>(child.parentNode===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//说明已经查找到了文档的根节点</span></span><br><span class="line">    <span class="keyword">return</span> find(child.parentNode,parent);</span><br><span class="line">    <span class="comment">//第1次执行find——&gt;child.parentNode===parent</span></span><br><span class="line">    <span class="comment">//第2次执行find——&gt;child.parentNode.parentNode===parent</span></span><br><span class="line">    <span class="comment">//第3次执行find——&gt;child.parentNode.parentNode.parentNode===parent</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(find(d3,d10));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(find(d3,d1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 高程中这样定义函数：函数是这样一段 JavaScript 代码，只定义一次，但可以被执行任意多次。JavaScript 的函数是参数化的：函数的定义会包括一个称为形参和标识符列表，这些参数在函数体中就像局部变量一样工作。函数的调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，成为该函数调用表达式的值。出来实参之外，每次调用还会拥有另一个值-本次调用的上下文-这就是 &lt;code&gt;this&lt;/code&gt; 关键字的值。&lt;/p&gt;
&lt;p&gt;如果函数挂载在一个对象上，作为对象的一个方法调用，就称之为 &lt;code&gt;对象的方法&lt;/code&gt;。当通过这个对象来调用函数时，该对象就是此次调用的上下文，也就是该函数的 this 的值。&lt;/p&gt;
&lt;p&gt;用于初始化一个新建的对象的函数成为&lt;code&gt;构造函数&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 JavaScript 里，函数即对象。可以把函数赋值给变量，或者作为参数传递给其他函数。&lt;/p&gt;
&lt;p&gt;JavaScript 的函数可以嵌套在其他函数中定义，这样就可以访问它们被定义时所处的作用域中的任何变量。这意味着 JavaScript 函数构成了一个闭包。&lt;/p&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js String对象</title>
    <link href="http://yoursite.com/2015/06/28/js%20String%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2015/06/28/js String对象/</id>
    <published>2015-06-27T16:00:00.000Z</published>
    <updated>2018-05-31T01:32:43.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 类型是字符串的对象包装类型。创建方式有两种：</p><ul><li>var strObject = new String(“abc”);</li><li>var strValue = “abc”;<br>其中，继承的 valueOf()，toLocaleString()，toString() 方法，都返回对象所表示的基本字符串值。</li></ul><p>String 类型的实例都有一个 length 属性，表示包含多少个字符，可以用来获取字符串的长度。</p><a id="more"></a><h2 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法:"></a>字符方法:</h2><h3 id="charAt-和-charCodeAt"><a href="#charAt-和-charCodeAt" class="headerlink" title="charAt() 和 charCodeAt()"></a>charAt() 和 charCodeAt()</h3><ul><li>charAt(下标);获取该下标位置的字符串</li><li>charCodeAt(下标);获取对应下标字符串的ASCII的码值<ul><li>charAt() 和 charCodeAt() 方法接收一个参数，即基于 0 的字符位置</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">1</span>));  <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure><ul><li>concat(字符串);<ul><li>拼接字符串，用于将一个或多个字符串拼接起来，得到新串</li><li>concat 可以接收任意多个参数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.concat(<span class="string">"de"</span>, <span class="string">"fgh"</span>)); <span class="comment">// "abcdefgh"</span></span><br></pre></td></tr></table></figure><h3 id="slice-、substring-和-substr"><a href="#slice-、substring-和-substr" class="headerlink" title="slice()、substring() 和 substr()"></a>slice()、substring() 和 substr()</h3><ul><li>slice(开始下标,结束下标);截取一段字符串的</li><li>substring(开始的下标,结束的下标);截取指定部分的字符串</li><li>substr(开始的下标，截取的个数);截取指定长度的字符串<ul><li>slice(), substring(), substr() 这三个方法都会返回被操作字符串的一个子串</li><li>都接受一个或两个参数</li><li>第二个参数表示子字符串到哪里结束</li><li>slice() 和 substring() 第二个参数是子字符串最后一个字符后面的位置</li><li>substr() 的第二个参数是指返回的字符个数</li><li>如果没有给这三个方法指定第二个参数，则将字符串的长度作为结束位置。</li><li>这几个方法都返回新字符串，不影响原字符串.</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello World&quot;;</span><br><span class="line">console.log(str.slice(3));  // &quot;Hello World&quot;</span><br><span class="line">console.log(str.substring(3)); // &quot;Hello World&quot;</span><br><span class="line">console.log(str.substr(3)); // &quot;Hello World&quot;</span><br><span class="line">console.log(str.slice(3, 7)); // &quot;lo W&quot;</span><br><span class="line">console.log(str.subtring(3, 7)); // &quot;lo W&quot;</span><br><span class="line">console.log(str.subtr(3, 7)); // &quot;lo Worl&quot;</span><br></pre></td></tr></table></figure><ul><li>传入负值时，slice() 方法会将传入的负值与字符串的长度相加</li><li>substr() 方法将负的第一个参数加载字符串的长度，而将负的第二个参数转为 0</li><li>substring() 方法会把所有负值参数都转换为 0 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-3</span>));  <span class="comment">// "rld"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-3</span>)); <span class="comment">// "Hello World"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-3</span>)); <span class="comment">// "rld"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// "lo W" 会将传入的负值与字符串的长度相加，第二个值转成了7</span></span><br><span class="line"><span class="built_in">console</span>.log(str.subtring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// "Hel", 会将较小的数作为起始位置，将较大的说作为结束位置</span></span><br><span class="line"><span class="built_in">console</span>.log(str.subtr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><h3 id="toLocaleUpperCase-、toUpperCase-、toLocaleLowerCase-、toLowerCase"><a href="#toLocaleUpperCase-、toUpperCase-、toLocaleLowerCase-、toLowerCase" class="headerlink" title="toLocaleUpperCase()、toUpperCase()、toLocaleLowerCase()、toLowerCase()"></a>toLocaleUpperCase()、toUpperCase()、toLocaleLowerCase()、toLowerCase()</h3><ul><li>toLocaleUpperCase 字符串转大写, 针对特定地区</li><li>toUpperCase 字符串转大写</li><li>toLocaleLowerCase 字符串转小写, 针对特定地区</li><li>toLowerCase 字符串转小写</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleUpperCase());  <span class="comment">// "HELLO WORLD"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase());  <span class="comment">// "HELLO WORLD"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleLowerCase());  <span class="comment">// "hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLowerCase());  <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure><h3 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h3><ul><li>indexOf 查找指定的字符串，找到则返回下标，找不到返回-1</li><li>lastIndexOf 从后面向前面找指定的字符串，找不到也是返回的是-1<ul><li>indexOf() 和 lastIndexOf() 方法都是从一个字符串中搜索给定的子字符串，</li><li>返回子字符串的位置</li><li>找不到则返回 -1</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"o"</span>));  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"o"</span>));  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ul><li>indexOf() 和 lastIndexOf() 方法都可以接收第二个参数，表示从字符串中的哪个位置开始搜索</li><li>indexOf() 会从指定位置向后搜索，忽略指定位置之前的</li><li>lastIndexOf() 会从指定位置向前搜索，忽略指定位置之后的</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"o"</span>, <span class="number">6</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"o"</span>, <span class="number">6</span>));  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>查找某个元素在字符串中出现的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Spell at all costs， to rush you in the future。"</span>,</span><br><span class="line">    position = [],</span><br><span class="line">    pos = str.indexOf(<span class="string">"t"</span>);</span><br><span class="line"><span class="keyword">while</span>( pos &gt; <span class="number">-1</span> )&#123;</span><br><span class="line">  position.push(pos);</span><br><span class="line">  pos = str.indexOf(<span class="string">"t"</span>, pos + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(position); <span class="comment">// [7, 16, 20, 35, 41]</span></span><br></pre></td></tr></table></figure><ul><li>trim 切掉字符串前面和后面的空格<ul><li>创建一个字符串的副本，删除前置以及后缀空格，然后返回结果</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"    Hello World   "</span>;</span><br><span class="line"><span class="keyword">var</span> strTrim = str.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str);  <span class="comment">// "    Hello World   "</span></span><br><span class="line"><span class="built_in">console</span>.log(strTrim);  <span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure><h3 id="字符串匹配模式方法"><a href="#字符串匹配模式方法" class="headerlink" title="字符串匹配模式方法"></a>字符串匹配模式方法</h3><p>match() 直接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="comment">// 与 pattern.exec() 方法相同</span></span><br><span class="line"><span class="keyword">var</span> matches = str.match(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);  <span class="comment">// "cat"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches);  <span class="comment">// ["cat", index: 0, input: "cat, bat, sat, fat"]</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>以上的实例中 match 方法返回了一个数组； 如果是调用 RegExp 对象的 exec() 方法并,传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串；</p><ul><li>search() 方法<ul><li>唯一参数与 match() 方法的相同：</li><li>由字符串或 RegExp 对象指定的一个正则表达式。</li><li>该方法返回字符串中第一个匹配项的索引；</li><li>如果没有找到返回 -1</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> pos = str.search(<span class="regexp">/at/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>replace() 方法<ul><li>两个参数：<ul><li>第一个可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转成正则表示）</li><li>第二个参数可以是一个字符串或者一个函数</li></ul></li><li>如果第一个参数是字符串，只会替换第一个字符串</li><li>要替换所有，指定正则表达式，指定 g 标志</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"cat, bat, sat, fat"</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = str.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>);</span><br><span class="line"><span class="keyword">var</span> res2 = str.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1);  <span class="comment">// "cond, bat, sat, fat"</span></span><br><span class="line"><span class="built_in">console</span>.log(res2);  <span class="comment">// "cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure><ul><li>replace() 方法的第二个参数可以是函数。<ul><li>在只有一个匹配项（即与模式匹配的字符串）的情况下，会向函数传递三个参数</li><li>模式匹配项、模式匹配项在字符串中的位置和原始字符串。</li><li>在正则表达式定义了多个捕获组的情况下，</li><li>传递给函数的参数一次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……</li><li>最后两个参数依然分别是模式匹配项在字符串中的位置和原始字符串。</li><li>函数返回一个字符串，表示应该被替换的匹配项。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, pos, orginText</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(match)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&amp;quot;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(htmlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;"</span>));</span><br><span class="line"><span class="comment">// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello World!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure><ul><li>split 切割指定的字符串的，返回的是一个数组<ul><li>基于指定的分隔符将一个字符串分隔成多个子字符串，并将结果放在数组中</li><li>分隔符可以是一个 RegExp 对象。</li><li>可接受第二个可选的参数，指定数组中大小。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"red,green,yellow,blue"</span>;</span><br><span class="line"><span class="keyword">var</span> colors1 = color.split(<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors1);  <span class="comment">// ["red", "green", "yellow", "blue"]</span></span><br><span class="line"><span class="keyword">var</span> colors2 = color.split(<span class="string">","</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// ["red", "green"]</span></span><br><span class="line"><span class="keyword">var</span> colors3 = color.split(<span class="regexp">/[^\,]+/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors3);  <span class="comment">//["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure><h3 id="localCompare"><a href="#localCompare" class="headerlink" title="localCompare()"></a>localCompare()</h3><p>此方法比较两个字符串，并返回：</p><ul><li>若字符串再字母表中排在字符串参数之前，返回一个负数，大多数情况下为 -1</li><li>若字符串邓毅字符串参数，返回 0</li><li>若字符串再字母表中排在字符串参数之后，返回一个正数，大多数情况下为 1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"yellow"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.localCompare(<span class="string">"brick"</span>));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.localCompare(<span class="string">"yellow"</span>));  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(str.localCompare(<span class="string">"zoo"</span>));  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h3 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode()"></a>fromCharCode()</h3><p>这个方法是 String 构造函数的静态方法，接收一个多字符编码，转化为一个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>)); <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure><h3 id="HTML-方法"><a href="#HTML-方法" class="headerlink" title="HTML 方法"></a>HTML 方法</h3><ul><li>anchor() <code>&lt;a name=&quot;name&quot;&gt;string&lt;/a&gt;</code></li><li>big() <code>&lt;big&gt;string&lt;/big&gt;</code></li><li>bold() <code>&lt;b&gt;string&lt;/b&gt;</code></li><li>fixd() <code>&lt;tt&gt;string&lt;/tt&gt;</code></li><li>fontcolor(color) <code>&lt;font color=&quot;color&quot;&gt;string&lt;/font&gt;</code></li><li>fontsize(size) <code>&lt;font size=&quot;size&quot;&gt;string&lt;/font&gt;</code></li><li>italics() <code>&lt;i&gt;string&lt;/i&gt;</code></li><li>link(url) <code>&lt;a href=&quot;url&quot;&gt;string&lt;/a&gt;</code></li><li>small() <code>&lt;small&gt;string&lt;/small&gt;</code></li><li>strike() <code>&lt;strike&gt;string&lt;/strike&gt;</code></li><li>sub() <code>&lt;sub&gt;string&lt;/sub&gt;</code></li><li>sup() <code>&lt;sup&gt;string&lt;/sup&gt;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;String类型&quot;&gt;&lt;a href=&quot;#String类型&quot; class=&quot;headerlink&quot; title=&quot;String类型&quot;&gt;&lt;/a&gt;String类型&lt;/h2&gt;&lt;p&gt;String 类型是字符串的对象包装类型。创建方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;var strObject = new String(“abc”);&lt;/li&gt;
&lt;li&gt;var strValue = “abc”;&lt;br&gt;其中，继承的 valueOf()，toLocaleString()，toString() 方法，都返回对象所表示的基本字符串值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;String 类型的实例都有一个 length 属性，表示包含多少个字符，可以用来获取字符串的长度。&lt;/p&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的数组</title>
    <link href="http://yoursite.com/2015/06/22/js%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2015/06/22/js的数组/</id>
    <published>2015-06-21T16:00:00.000Z</published>
    <updated>2018-05-30T07:27:46.349Z</updated>
    
    <content type="html"><![CDATA[<p>数组是表示集合的值，每一个值是一个元素，每一个元素在数组中有一个位置，以数字表示，叫索引。数组继承自 Array.prototype.</p><h2 id="js的内置对象：数组Array"><a href="#js的内置对象：数组Array" class="headerlink" title="js的内置对象：数组Array"></a>js的内置对象：数组Array</h2><h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><ul><li>直接量方式创建数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = []; <span class="comment">// 没有元素的空数组</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]; <span class="comment">// 有5个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> misc = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">"a"</span>, ]; <span class="comment">// 有不同数据类型元素的数组</span></span><br><span class="line"><span class="keyword">var</span> misc2 = [[<span class="number">1</span>], &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;,[<span class="number">2</span>, &#123;<span class="attr">x</span>:<span class="number">2</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;]];</span><br></pre></td></tr></table></figure><p>数组直接量中可以是任意的表达式。</p><ul><li>使用构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">// 数组的构造函数 创建的是一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"4"</span>);<span class="comment">// 只有传入一个数值的时候 才表示数组元素的个数</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="string">"abc"</span>); <span class="comment">// 显示的指定两个或多个数组元素或者数组的一个非数值元素</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数组元素的读和写"><a href="#数组元素的读和写" class="headerlink" title="数组元素的读和写"></a>数组元素的读和写</h2><h3 id="数组的合法表达式"><a href="#数组的合法表达式" class="headerlink" title="数组的合法表达式"></a>数组的合法表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"world"</span>]; </span><br><span class="line"><span class="keyword">var</span> value = a[<span class="number">0</span>]; <span class="comment">// 读取第 0 个元素</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span>; <span class="comment">// 设置值</span></span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">  a[length++] = i;  <span class="comment">// 将 0 - 4 的数值装到数组中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = <span class="number">2</span>;</span><br><span class="line">a[j] = <span class="number">3</span>;  <span class="comment">// 写第二个元素</span></span><br><span class="line">a[j+<span class="number">1</span>] = <span class="string">"abc"</span>; <span class="comment">// 写第三个元素</span></span><br><span class="line">a[a[j]] = a[<span class="number">0</span>];  <span class="comment">// 读第 0 个元素和第 2 个元素，写第 3 个元素</span></span><br></pre></td></tr></table></figure><h3 id="数组索引和对象属性"><a href="#数组索引和对象属性" class="headerlink" title="数组索引和对象属性"></a>数组索引和对象属性</h3><p>数组是对象的特殊形式。 常规的对象如：<code>o = {}; o[1] = &quot;one&quot;; // 可以用一个整数来访问。</code>数组的索引只能是 0 ~ 2的32次幂 - 2 之间的整数，所有的索引是属性名。负数和浮点数也可以来索引数组。这种情况下转成字符串当成常规对象的属性，而非负整数字符串被使用了： <code>arr[&quot;99&quot;]</code>, 当做数组的索引，而非对象的属性。数组的索引是属性的特殊类型，因此数组的索引找不到值时不会报错，而是 undefined。</p><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>每一个数组都有一个 length 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(arr.lengh); <span class="comment">//获取数组元素的个数</span></span><br><span class="line"><span class="comment">// length属性是动态改变的 通过arr.length可以动态追加</span></span><br></pre></td></tr></table></figure><p>可以将数组的长度设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.length = [<span class="number">1</span>]; <span class="comment">// arr 现在为 [1];</span></span><br><span class="line">arr.length = []; <span class="comment">// 删除 arr 中的元素</span></span><br><span class="line">arr.length = <span class="number">5</span>; <span class="comment">// 长度为 4，但没有元素，相当于 new Array(5);</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5，可以使用 Object.defineProperty() 来设置数组的 length 为只读的。</p><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>稀疏数组是包含从 0 开始的不连续索引的数组。可以使用 Array() 构造函数或简单指定数组索引大于当前数组的长度来定义稀疏数组。还可以使用 delete 操作符来创建稀疏数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> arr[<span class="number">99</span>] = <span class="number">1</span>; <span class="comment">// 赋值添加一个元素1，length 变为 100</span></span><br><span class="line"><span class="keyword">var</span> a2 = [];</span><br><span class="line"><span class="keyword">var</span> a3 = [,]; <span class="comment">// 此时数组没有元素，长度是 1；也是稀疏数组</span></span><br></pre></td></tr></table></figure><p>注：当给直接量中省略值时不会创建稀疏数组。因为省略的值是 undefined 类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a5 = [,,,]; <span class="comment">// 不是稀疏数组</span></span><br><span class="line"><span class="keyword">var</span> a4 = [<span class="literal">undefined</span>]; <span class="comment">// 此时数组包含一个数值 undefined 类型。</span></span><br></pre></td></tr></table></figure><h2 id="数组冒泡排序"><a href="#数组冒泡排序" class="headerlink" title="数组冒泡排序"></a>数组冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr17 = [<span class="number">56</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">78</span>,<span class="number">67</span>,<span class="number">34</span>,<span class="number">96</span>,<span class="number">39</span>,<span class="number">44</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">85</span>];</span><br><span class="line"><span class="keyword">var</span> outer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> inner = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr17.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; arr17.length - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr17[j] &gt; arr17[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">var</span> tempValue = arr17[j+<span class="number">1</span>];</span><br><span class="line">            arr17[j+<span class="number">1</span>] = arr17[j];</span><br><span class="line">            arr17[j] = tempValue;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inner++;</span><br><span class="line">    &#125;</span><br><span class="line">    outer++;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><ul><li>push();<ul><li>尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样；</li><li>返回新数组长度</li><li>操作原数组，末尾追加</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a.push(<span class="string">"ab"</span>);</span><br><span class="line">a.push(<span class="string">"bc"</span>,<span class="string">"cd"</span>);  <span class="comment">// a = ["ab","bc","cd"];</span></span><br><span class="line">a.push(<span class="string">"123"</span>,[<span class="string">"e"</span>,<span class="string">"f"</span>]);  <span class="comment">// a = ["ab","bc","cd","123",["e","f"]];</span></span><br></pre></td></tr></table></figure><ul><li>pop();<ul><li>删除数组中最后一个元素，</li><li>返回值是被删除的这个元素</li><li>操作原数组</li></ul></li><li>shift();<ul><li>删除数组中的第一个元素，</li><li>返回值是被删除的元素</li></ul></li><li>unshift();<ul><li>向数组中第一个元素之前插入一个或多个新的元素</li><li>返回值是新数组的长度</li></ul></li><li>concat(); Array.concat() 方法创建并返回新数组<ul><li>新的数组和旧的数组拼接，产生一个新的数组</li><li>不修改原数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">arr.concat([<span class="number">3</span>,<span class="number">4</span>]);  <span class="comment">// 返回 [1,2,3,4]</span></span><br><span class="line">arr.concat(<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>]]); <span class="comment">// 返回 [1,2,3,4,[5,6]]</span></span><br></pre></td></tr></table></figure><ul><li>slice(); Array.slice()方法返回指定数组的一个片段或子数组<ul><li>两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素；</li><li>指定一个参数，返回包含开始位置到数组结尾的所有元素</li><li>参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个</li><li>从原来的数组中截取出来指定的一部分元素，产生新的数组</li><li>不操作原数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.slice (<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// [0,1,2];</span></span><br><span class="line">a.slice(<span class="number">3</span>); <span class="comment">// [3,4,5]</span></span><br><span class="line">a.slice(<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">// [1,2,3,4];</span></span><br><span class="line">a.slice(<span class="number">-3</span>,<span class="number">-2</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><ul><li>splice(); Array.splice()是数组中插入或删除元素的方法。<ul><li>会修改调用数组，</li><li>第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数；</li><li>如果省略了第二个参数，从开始索引位置后的元素都被删除；</li><li>可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入；</li><li>该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。</li></ul></li><li>join(); 将数组中的所有元素都转化成字符串并连接到一起<ul><li>返回最终生成的字符串</li><li>是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组；</li></ul></li><li>reverse();<ul><li>反转数组</li><li>操作原数组</li><li>返回操作后的逆向数组</li></ul></li><li>sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组<ul><li>操作原数组；</li><li>返回排序后的数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (fn(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                  arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                  arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                  flag = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>toString()<ul><li>和不使用任何参数调用 join() 方法返回的字符串是一样的。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>].toString();  <span class="comment">// "1,2"</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="string">"c"</span>,<span class="number">5</span>]].toString(); <span class="comment">// "1,2,3,c,5"</span></span><br></pre></td></tr></table></figure><ul><li>toLocalString() 方法是 toString() 方法的本地化版本，使用本地化分隔符将这些字符串连接起来生成最终字符串。</li></ul><h2 id="ECMAScript-5-中的数组方法"><a href="#ECMAScript-5-中的数组方法" class="headerlink" title="ECMAScript 5 中的数组方法"></a>ECMAScript 5 中的数组方法</h2><p>ECMAScript 5 定义了 9 个新的数组方法来遍历、映射、过滤、检测、简化和搜索数组；大多数 ECMAScript 5 数组方法的第一个参数是一个函数，第二个参数是可选的，如果有第二个参数，则调用的函数被看做是第二个参数的方法。即在调用函数时传递的第二个参数作为它的 this 关键字的值来使用。ECMAScript 5 中的数组方法都不会修改原始数组。</p><ul><li>indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素<ul><li>查找某个元素，</li><li>第一个参数是要查找的元素,</li><li>第二个参数是开始查找的下标,</li><li>找到则返回找到的第一个元素的索引，找不到则返回-1</li></ul></li><li>lastIndexOf();<ul><li>这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1；</li><li>第二个元素可以是负数，代表相对数组末尾的偏移量；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findall</span>(<span class="params">a, x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [],</span><br><span class="line">      len = a.length,</span><br><span class="line">      index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">    index = a.indexOf(x, index);</span><br><span class="line">    <span class="keyword">if</span> (pos === <span class="number">-1</span>) <span class="keyword">break</span>;  <span class="comment">// 未找到，完成搜索</span></span><br><span class="line">    results.push(index); <span class="comment">// 否则在数组中存储索引</span></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  returen results;  <span class="comment">// 返回包含索引的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件；<ul><li>every() 方法针对所有的元素判断调用函数返回全为 true，则返回true；</li><li>every() 方法有一个不满足条件的则返回 false</li><li>some() 方法所有的元素判断调用函数有一个满足条件的则返回 true</li><li>some() 方法全为 false, 则返回 false</li></ul></li><li>map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个包含该函数的数组。<ul><li>返回新数组</li><li>不修改原数组</li><li>稀疏数组调用返回的还是稀疏数组<ul><li>一个例子：arr.map(Math.sqrt);<ul><li>map这个方法可以传入一个回调函数,</li><li>直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的</li><li>调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数</li><li>map方法内部帮我们遍历并且传入数组的每个元素</li></ul></li></ul></li></ul></li><li>filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值；<ul><li>压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter();</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><ul><li>instanceof</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但是在web浏览器多窗口或窗体存在时，每个全局对象有自己的一组构造函数。一个窗体中的对象不可能是另外一个窗体中构造函数和实例。因此，instanceof 操作符不能视为一个可靠的数组检测方法。</p><ul><li>isArray(); ECMAScript 5 中给出的检测数组类型的方法；<ul><li>这个方法是判断变量是不是数组</li></ul></li></ul><p>因此，封装检测数组的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = <span class="built_in">Function</span>.isArray || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">"object"</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(o) === <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数；<ul><li>三个参数，数值元素、数组索引、数组本身</li><li>无法再所有元素传递完调用函数之前终止遍历</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 计算数组元素和值</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">data.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  sum += v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum);  <span class="comment">// sum =&gt; 15</span></span><br><span class="line">data.forEach(funciton (v,i,a) &#123;</span><br><span class="line">  a[i] = v + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// [2,3,4,5,6];</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止 forEach 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span> (<span class="params">a, f, t</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123; a.forEach (f, t)&#125;</span><br><span class="line">  <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e === foreach.break) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foreach.break = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"StopIteration"</span>);</span><br></pre></td></tr></table></figure><ul><li>reduce()和 reduceRight()<ul><li>reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">var</span> max = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt;y)?x:y;</span><br><span class="line">&#125;);  <span class="comment">// 求最大值</span></span><br></pre></td></tr></table></figure><ul><li>reduce() 两个参数：<ul><li>第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。</li><li>第二个参数是可选参数</li></ul></li><li>reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组；</li></ul><p>reduce() 和 reduceRight() 都能接收一个可选的参数，它指定了化简函数调用时的 this 关键值。</p><p>计算两个对象的并集，返回一个新对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [union description] 如果有重名属性，使用 p 中的属性</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; p [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description] 返回一个新对象这个对象同时拥有 o 的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span> (<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extend (extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objs = [&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> merged = objs.reduce(union);  <span class="comment">// &#123;x:1, y:2, z:3&#125;</span></span><br></pre></td></tr></table></figure><p>拥有同名属性时，reduce() 和 reduceRight() 方法返回值不同；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objs = [&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">y</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">z</span>:<span class="number">3</span>, <span class="attr">a</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> lUnion = objs.reduce(union);  <span class="comment">// &#123;x:1, y:2, z:3, a:1&#125;</span></span><br><span class="line"><span class="keyword">var</span> lUnion = objs.reduceRight(union);  <span class="comment">// &#123;x:1, y:2, z:3, a:3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="ECMAScript-6-中数组新方法"><a href="#ECMAScript-6-中数组新方法" class="headerlink" title="ECMAScript 6 中数组新方法"></a>ECMAScript 6 中数组新方法</h2><ul><li>Array.prototype.find 方法用于找出第一个符合条件的数组成员。<ul><li>参数是一个回调函数，找到第一个返回 true 的数组项，然后返回该数组项；</li><li>找不到返回undefined；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">123</span>,<span class="number">23</span>];</span><br><span class="line">arr.find(functiton(num)&#123;</span><br><span class="line">  <span class="keyword">return</span> num === <span class="number">123</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>两个静态方法<ul><li>Array.from<ul><li>将一个伪数组转成正真的数组</li></ul></li><li>Array.of<ul><li>将方法中参数都添加到一个数组中</li></ul></li></ul></li><li>操作、填充和过滤数组的方法<ul><li>Array.prototype.copyWidthin</li><li>Array.prototype.fill</li><li>Array.prototype.find<ul><li>接收一个回调函数，每一项执行调用它</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'bb'</span>, <span class="attr">age</span>:<span class="number">24</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'cc'</span>, <span class="attr">age</span>:<span class="number">32</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'dd'</span>, <span class="attr">age</span>:<span class="number">12</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'aa'</span>, <span class="attr">age</span>:<span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'ed'</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'aa'</span>, <span class="attr">age</span>:<span class="number">29</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(users.find(<span class="function"><span class="params">u</span> =&gt;</span> u.name === <span class="string">'aa'</span>)); <span class="comment">// &#123;name: 'aa', age:16&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Array.prototype.findIndex<ul><li>有关数组迭代的方法</li></ul></li><li>Array.prototype.keys</li><li>Array.prototype.values</li><li>Array.prototype.entries</li><li>Array.prototype[Symbol.iterator]</li></ul><h2 id="类数组对象-伪数组"><a href="#类数组对象-伪数组" class="headerlink" title="类数组对象(伪数组)"></a>类数组对象(伪数组)</h2><p>JavaScript 的类数组对象：把拥有数组 length 属性和对应非负整数属性的对象看着一种类型的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  a[i] = i * i;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line">a.length = i;</span><br><span class="line"><span class="comment">// 那么可以当成真正的数组遍历</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; a.length; j++)&#123;</span><br><span class="line">  total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否是伪数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">"object"</span> </span><br><span class="line">  &amp;&amp; <span class="built_in">isFinite</span>(o.length)</span><br><span class="line">  &amp;&amp; o.length &gt;=<span class="number">0</span> </span><br><span class="line">  &amp;&amp; o.length === <span class="built_in">Math</span>.floor(o.length)</span><br><span class="line">  &amp;&amp; o.length &lt; <span class="number">4294967296</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h2><p>ECMAScript 5 中的字符串除了用 charAt() 访问单个元素之外，还可以使用方括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"string"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">1</span>));  <span class="comment">// =&gt; "t";</span></span><br><span class="line"><span class="built_in">console</span>.log(s[<span class="number">1</span>]);  <span class="comment">// =&gt; "t";</span></span><br></pre></td></tr></table></figure><p>数组方法总结：</p><ul><li>push();<ul><li>尾部追加一个或多个元素，push 一个元素与给数组 a[a.length] 赋值一样；</li><li>返回新数组长度</li><li>操作原数组，末尾追加</li></ul></li><li>pop();<ul><li>删除数组中最后一个元素，</li><li>返回值是被删除的这个元素</li><li>操作原数组</li></ul></li><li>shift();<ul><li>删除数组中的第一个元素，</li><li>返回值是被删除的元素</li></ul></li><li>unshift();<ul><li>向数组中第一个元素之前插入一个或多个新的元素</li><li>返回值是新数组的长度</li></ul></li><li>concat(); Array.concat() 方法创建并返回新数组<ul><li>新的数组和旧的数组拼接，产生一个新的数组</li><li>不修改原数组</li></ul></li><li>slice(); Array.slice()方法返回指定数组的一个片段或子数组<ul><li>两个参数： 开始索引，结束索引，返回包含开始索引，不包含结束索引位置之间的所有数组元素；</li><li>指定一个参数，返回包含开始位置到数组结尾的所有元素</li><li>参数是负数，相对于最后一个位置的。如参数 -1 指定了最后一个元素，-2 是倒数第二个</li><li>从原来的数组中截取出来指定的一部分元素，产生新的数组</li><li>不操作原数组</li></ul></li><li>splice(); Array.splice()是数组中插入或删除元素的方法。<ul><li>会修改调用数组，</li><li>第一个参数是开始的下标,第二个参数是指定了删除原数组元素的个数；</li><li>如果省略了第二个参数，从开始索引位置后的元素都被删除；</li><li>可以有第三个参数，第四个参数…跟在第二个参数后的任意多个参数是需要插入原数组中的元素，从第一个参数指定的索引位置插入；</li><li>该方法返回的是删除元素组成的数组,如果没有替换则返回空数组。</li></ul></li><li>join(); 将数组中的所有元素都转化成字符串并连接到一起<ul><li>返回最终生成的字符串</li><li>是 String.split() 方法的逆向操作。String.split() 是将字符串分隔成分隔，返回数组；</li></ul></li><li>reverse();<ul><li>反转数组</li><li>操作原数组</li><li>返回操作后的逆向数组</li></ul></li><li>sort(); Array.sort() 方法将数组中的元素排序并返回排序后的数组<ul><li>操作原数组；</li><li>返回排序后的数组</li></ul></li><li>toString()<ul><li>和不使用任何参数调用 join() 方法返回的字符串是一样的。</li></ul></li><li>toLocalString() 方法是 toString() 方法的本地化版本，使用本地化分隔符将这些字符串连接起来生成最终字符串。</li><li>indexOf()和lastIndexOf(); 搜索整个数组中具有给定值的元素<ul><li>查找某个元素，</li><li>第一个参数是要查找的元素,</li><li>第二个参数是开始查找的下标,</li><li>找到则返回找到的第一个元素的索引，找不到则返回-1</li></ul></li><li>lastIndexOf();<ul><li>这个方法也是查找元素,从后面向前面找,找到则返回对应的下标,找不到则返回-1；</li><li>第二个元素可以是负数，代表相对数组末尾的偏移量；</li></ul></li><li>every() 和 some(); 数组的逻辑判定，传入一个函数,判断每个数组中的元素是否满足条件；<ul><li>every() 方法针对所有的元素判断调用函数返回全为 true，则返回true；</li><li>every() 方法有一个不满足条件的则返回 false</li><li>some() 方法所有的元素判断调用函数有一个满足条件的则返回 true</li><li>some() 方法全为 false, 则返回 false</li></ul></li><li>map() 方法，将调用的数组的每个元素传递给指定的函数，并返回一个包含该函数的数组。<ul><li>返回新数组</li><li>不修改原数组</li><li>稀疏数组调用返回的还是稀疏数组<ul><li>一个例子：arr.map(Math.sqrt);<ul><li>map这个方法可以传入一个回调函数,</li><li>直接传入了一个Math.sqrt方法,sqrt方法是为某个数字开平方的</li><li>调用map方法传入Math.sqrt的时候,去掉了括号,也没有传入参数</li><li>map方法内部帮我们遍历并且传入数组的每个元素</li></ul></li></ul></li></ul></li><li>filter() 方法，返回的是调用的数组的一个子集，传递的回调函数用来逻辑判断，该函数的返回值是布尔值；<ul><li>压缩空缺或并删除 undefined 和 null 元素，也可以使用 filter();</li></ul></li><li>instanceof</li><li>isArray(); ECMAScript 5 中给出的检测数组类型的方法；<ul><li>这个方法是判断变量是不是数组</li></ul></li><li>forEach 方法，从头至尾遍历数组，为每个元素调用指定的函数；<ul><li>三个参数，数值元素、数组索引、数组本身</li><li>无法再所有元素传递完调用函数之前终止遍历</li></ul></li><li>reduce()和 reduceRight()<ul><li>reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。</li><li>reduce() 两个参数：<ul><li>第一个是执行简化操作的函数。化简函数的任务就是用某种方法把两个值组合和化简为一个值，并返回简化后的值。</li><li>第二个参数是可选参数</li></ul></li><li>reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低处理数组；</li></ul></li></ul><p>本文参考自：《JavaScript 权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组是表示集合的值，每一个值是一个元素，每一个元素在数组中有一个位置，以数字表示，叫索引。数组继承自 Array.prototype.&lt;/p&gt;
&lt;h2 id=&quot;js的内置对象：数组Array&quot;&gt;&lt;a href=&quot;#js的内置对象：数组Array&quot; class=&quot;headerlink&quot; title=&quot;js的内置对象：数组Array&quot;&gt;&lt;/a&gt;js的内置对象：数组Array&lt;/h2&gt;&lt;h2 id=&quot;数组声明&quot;&gt;&lt;a href=&quot;#数组声明&quot; class=&quot;headerlink&quot; title=&quot;数组声明&quot;&gt;&lt;/a&gt;数组声明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;直接量方式创建数组&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; empty = []; &lt;span class=&quot;comment&quot;&gt;// 没有元素的空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;// 有5个元素的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; misc = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, ]; &lt;span class=&quot;comment&quot;&gt;// 有不同数据类型元素的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; misc2 = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], &amp;#123;&lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;,[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &amp;#123;&lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组直接量中可以是任意的表达式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;span class=&quot;comment&quot;&gt;// 数组的构造函数 创建的是一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 只有传入一个数值的时候 才表示数组元素的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 显示的指定两个或多个数组元素或者数组的一个非数值元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的对象</title>
    <link href="http://yoursite.com/2015/06/18/js%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2015/06/18/js的对象/</id>
    <published>2015-06-17T16:00:00.000Z</published>
    <updated>2018-05-30T06:51:19.712Z</updated>
    
    <content type="html"><![CDATA[<p>除了字符串、数字、true、false、null 和 undefined 之外，JavaScript 中的值都是对象。引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。</p><p>从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示；</p><p>从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理。</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>JavaScript 对象的创建有三种方式：直接量，new 关键字 和 Object.creat() 方来创建。</p><a id="more"></a><h3 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h3><p>对象的直接量就是由若干兼职对组成的映射表，键和值之间用 “:” 分隔，键值对之间用 “,” 分隔，整个映射表用一对花括号包裹，比如通过字面量声明（更加简便）<code>var obj= {};</code></p><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><p>键值对就是一种对应关系，通过键能够方便地找到值</p><p>键:值 <code>key:value</code>  <code>k:v</code></p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> pointObj = &#123;<span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pointObj2 = &#123;<span class="attr">x</span>: pointObj.x, <span class="attr">y</span>: pointObj.y&#125;;</span><br><span class="line"><span class="keyword">var</span> books = &#123;</span><br><span class="line">  <span class="string">"main title"</span>: <span class="string">"JavaScript"</span>,   <span class="comment">// 属性名中有空格时，必须用字符串</span></span><br><span class="line">  <span class="string">'sub-title'</span>: <span class="string">"The Definitive Guide"</span>,   <span class="comment">// 属性名中有连字符，必须用字符串</span></span><br><span class="line">  <span class="string">"for"</span>: <span class="string">"all audiences"</span>,   <span class="comment">// "for" 是保留字，必须用引号</span></span><br><span class="line">  author: &#123;     <span class="comment">// 这里的属性名没有引号</span></span><br><span class="line">    firstname: <span class="string">"Hiraku"</span>,</span><br><span class="line">    surname: <span class="string">"Hongqin"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象的字面量是一个表达式，这个表达式的每次运算都创建并初始化一个新对象。每次计算对象直接量的时候，也会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用对象直接量，它将创建很多新对象，并且每次创建的对象的属性值可有可能不同。</p><h2 id="通过-new-关键字创建对象"><a href="#通过-new-关键字创建对象" class="headerlink" title="通过 new 关键字创建对象"></a>通过 new 关键字创建对象</h2><p>new 运算符创建并初始化一个新对象。n关键字 new 后面跟随一个函数调用。</p><p>通过构造函数声明（更加通用）var obj= new Object(); // 创建一个空对象，和 {} 一样</p><p>对象具有属性和方法</p><ul><li>属性 用来描述对象的特征 一般是名词 对应变量</li><li>方法 用来描述对象的行为 一般是动词 对应函数</li></ul><h2 id="原型初识"><a href="#原型初识" class="headerlink" title="原型初识"></a>原型初识</h2><p>除了 null 以外的每一个 JavaScript 对象都和 <code>原型</code> 相关联。所有通过对象直接量创建的对象对具有同一个原型对象，可通过 Object.prototype 获得对原型对象的引用。通过 new 关键字和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，和使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自 Object.prototype。</p><p>没有原型的对象有 Object.prototype，它不继承任何属性。其他对象都是普通对象，都有原型。所有的内置构造函数比如：Array(), Date() 都具有一个继承自 Object.prototype 的原型。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>ECMAScript 5 定义了一个名为 Object.create() 方法，是一个静态函数，可以用来创建对象。有两个参数：第一个参数是对象，第二个参数可选，用于对属性进行详细描述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// o1 继承了属性 x 和 y</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;);  </span><br><span class="line"><span class="comment">// o2 不继承任何属性和方法，没有原型，不能和 + 运算符一起工作</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// o3 创建一个普通的空对象</span></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>可以通过任意原型对象创建新对象，即可以使任意对象继承。</p><p>例子： 返回一个继承自原型对象 p 的属性的新对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();            <span class="comment">// p 是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);  <span class="comment">// 如果存在 Object.create，直接使用它来创建</span></span><br><span class="line">  <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;  <span class="comment">// 否则进一步检测</span></span><br><span class="line">  <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 创建一个空构造函数</span></span><br><span class="line">  f.prototype = p; <span class="comment">// 将其原型属性设置为 p</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">// 使用 f() 创建 p 的继承对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性和方法的查询和设置"><a href="#属性和方法的查询和设置" class="headerlink" title="属性和方法的查询和设置"></a>属性和方法的查询和设置</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>属性的定义<ul><li>对象.属性名 = 值；</li><li>对象[“属性名”] = 值;</li></ul></li><li>属性的调用<ul><li>对象.属性名;</li><li>对象[“属性名”];</li></ul></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>方法的定义<ul><li>对象.方法名 = function() { //函数体 };</li><li>对象[“方法名”] = function() { //函数体 };</li></ul></li><li>方法的调用<ul><li>对象.方法名();</li><li>对象[“方法名”];</li></ul></li></ul><h3 id="作为关联数组的对象"><a href="#作为关联数组的对象" class="headerlink" title="作为关联数组的对象"></a>作为关联数组的对象</h3><p>对象属性和方法的第二种设置和访问用了 “[]”，只是利用的不是索引访问，而是字符串。这种数据就是关联数组，也叫散列、映射或者字典。</p><p>当我们通过 [] 来访问对象的属性时，在程序运行是可以设置和修改或者创建它们。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>对象具有自有属性（own property），也有一些属性是从原型对象上继承来的。</p><p>还是这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();            <span class="comment">// p 是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);  <span class="comment">// 如果存在 Object.create，直接使用它来创建</span></span><br><span class="line">  <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;  <span class="comment">// 否则进一步检测</span></span><br><span class="line">  <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 创建一个空构造函数</span></span><br><span class="line">  f.prototype = p; <span class="comment">// 将其原型属性设置为 p</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">// 使用 f() 创建 p 的继承对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> p = inherit(o);  <span class="comment">// p 继承自对象 o 和 Object.prototype</span></span><br><span class="line">p.y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> q = inherit(p);  <span class="comment">// q 继承自对象 p、 o 和 Object.prototype</span></span><br><span class="line">q.z = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> s = q.toString();</span><br><span class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// "[object object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(q.x + q.y + q.z); <span class="comment">// 6 属性 x 和 y 分别继承自 o 和 p</span></span><br></pre></td></tr></table></figure><h3 id="属性访问错误"><a href="#属性访问错误" class="headerlink" title="属性访问错误"></a>属性访问错误</h3><ul><li>JavaScript 中，属性访问时，并不总是会话或者设置。</li><li>在查询不存在的属性时不会报错，而返回 undefined。</li><li>内置构造函数的原型是只读的。</li></ul><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>delete 运算符可以删除对象的属性。delete 只是断开属性和宿主对象的联系，而不会操作属性中的属性。</p><p>delete 只能删除自有属性，不能删除继承属性。</p><p>delete 不能删除可配置属性。</p><p>在非严格模式下，删除全局独享的可配置属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟要删除的属性名即可。</p><p>在严格模式下，delete x; 报错， delete this.x; 正常运行</p><h2 id="属性检测"><a href="#属性检测" class="headerlink" title="属性检测"></a>属性检测</h2><p>通过 in 运算符、hasOwnProperty()、propertyIsEnumerable() 方法；</p><ul><li>in 运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o;  <span class="comment">// true "x" 是 o 的属性</span></span><br></pre></td></tr></table></figure><ul><li>hasOwnProperty() 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o.hasOwnProperty(x);  <span class="comment">// true "x" 是 o 的自有属性</span></span><br><span class="line">o.hasOwnProperty(<span class="keyword">constructor</span>);  // false <span class="keyword">constructor</span> 是原型中的属性</span><br></pre></td></tr></table></figure><ul><li>propertyIsEnumerable() 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();            <span class="comment">// p 是一个对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="keyword">return</span> <span class="built_in">Object</span>.create(p);  <span class="comment">// 如果存在 Object.create，直接使用它来创建</span></span><br><span class="line">  <span class="keyword">var</span> t = <span class="keyword">typeof</span> p;  <span class="comment">// 否则进一步检测</span></span><br><span class="line">  <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 创建一个空构造函数</span></span><br><span class="line">  f.prototype = p; <span class="comment">// 将其原型属性设置为 p</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">// 使用 f() 创建 p 的继承对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = interit(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line">o.y = <span class="number">1</span>;  </span><br><span class="line">o.propertyIsEnumerable(<span class="string">"x"</span>); <span class="comment">// false "x" 属性是继承的，不能被枚举</span></span><br><span class="line">o.propertyIsEnumerable(<span class="string">"y"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了 in 以外， 另一种简单的判断一个属性是否是 “undefined” 使用 “!==”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;   <span class="comment">// true</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;   <span class="comment">// false;</span></span><br><span class="line">o.toString !== <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但 in 可以区分不存在的属性和存在但值为 undefined 类型的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">o.x !== <span class="literal">undefined</span>;   <span class="comment">// false  属性存在，但是值为 undefined</span></span><br><span class="line">o.y !== <span class="literal">undefined</span>;   <span class="comment">// false  属性不存在</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o; <span class="comment">// true 属性存在</span></span><br><span class="line"><span class="string">"y"</span> <span class="keyword">in</span> o; <span class="comment">// false 属性不存在</span></span><br><span class="line"><span class="keyword">delete</span> o.x;  <span class="comment">// 删除了属性 x</span></span><br><span class="line"><span class="string">"x"</span> <span class="keyword">in</span> o; <span class="comment">// false 属性不再存在</span></span><br></pre></td></tr></table></figure><h2 id="对象的枚举属性"><a href="#对象的枚举属性" class="headerlink" title="对象的枚举属性"></a>对象的枚举属性</h2><p>除了检测对象的属性，我们经常需要遍历对象的属性，通常使用 for-in 遍历;</p><p>ECMAScript 5 提供了 Object.keys() 方法，返回值是一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p><p>ECMASciript 5 提供的另一种枚举属性的方法是 Object.getOwnPropertyNames(), 和 Object.keys() 类似，只是它返回对象的所有自有属性的名称，而不仅仅是可以枚举的属性。</p><h3 id="用来枚举对象属性的工具函数"><a href="#用来枚举对象属性的工具函数" class="headerlink" title="用来枚举对象属性的工具函数"></a>用来枚举对象属性的工具函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [extend description] 把 P 中的可枚举属性复制到 o 中，</span></span><br><span class="line"><span class="comment"> * 如果有同名属性，则覆盖 o 中的属性 </span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; p [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">    o[prop] = p [prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [merge description] 把 P 中的可枚举属性复制到 o 中，</span></span><br><span class="line"><span class="comment"> * 如果有同名属性, o 中的属性不受影响 </span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; p [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.hasOwnProperty[prop]) <span class="keyword">continue</span>;</span><br><span class="line">    o[prop] = p [prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [restrict description] 如果 o 中的属性没有同名属性，则从 o 中删除这个属性</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; p [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description] 返回 o </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restrict</span> (<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(prop <span class="keyword">in</span> p)) <span class="keyword">delete</span> o[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [substract description] 如果 o 中存在同名属性，则删除这个属性</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; p [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">substract</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> p) &#123;</span><br><span class="line">    <span class="keyword">delete</span> o[prop];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [union description] 如果有重名属性，使用 p 中的属性</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; p [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description] 返回一个新对象这个对象同时拥有 o 的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span> (<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extend (extend(&#123;&#125;, o), p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [keys description] 返回的数组中包含的是 o 中可枚举的自有属性的名字</span></span><br><span class="line"><span class="comment"> * @param  &#123;[type]&#125; o [description]</span></span><br><span class="line"><span class="comment"> * @return &#123;[type]&#125;   [description] 返回一个数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keys</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> o !== <span class="string">"object"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</span><br><span class="line">    <span class="keyword">if</span> (o.hasOwnProperty(prop)) result.push(prop);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性-getter-和-setter"><a href="#属性-getter-和-setter" class="headerlink" title="属性 getter 和 setter"></a>属性 getter 和 setter</h2><p>当程序执行查询存储属性的值的时候，JavaScript 调用 getter 方法(无参数)，当设置属性值的时候，调用的是 setter 方法。</p><h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h2><p>属性包含一个属性名和4个特性：</p><ul><li>value 属性值</li><li>writable 可写性</li><li>enumerable 可枚举性</li><li>configurable 可配置性<br>存取器属性不具有值 value 和 可写性</li></ul><p>ECMAScript 5 中定义了属性描述符 Object.getOwnPropertyDesctiptor() 获取某个对象特定的属性，这个方法只能得到自有属性的特性。</p><p>让新建的属性具有某种特性，需要调用 Object.definePeoperty() 方法；传入要修改的对象，要创建或修改的属性的名称以及属性描述符对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;  <span class="comment">// 创建一个空对象</span></span><br><span class="line"><span class="comment">// 插入一个不可枚举的数据属性 x, 并赋值为 1；</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">o.x;   <span class="comment">// --&gt; 1</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// --&gt; []</span></span><br><span class="line"><span class="comment">// 对属性 x 做修改变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 试图更改这个属性值</span></span><br><span class="line">o.x = <span class="number">2</span>; <span class="comment">// 更改操作失败，在严格模式中抛出异常</span></span><br><span class="line">o.x;  <span class="comment">// =&gt; 1;</span></span><br><span class="line"><span class="comment">// 属性依然是可配置的，因此可以通过这种方式对它进行修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;);</span><br><span class="line">o.x; <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// 现在讲 x 从数据属性修改为存储器属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.x; <span class="comment">// =&gt; 0</span></span><br></pre></td></tr></table></figure><p>需要同时修改多个属性，使用 Object.defineProperties(),它返回修改后的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制属性的特性</span></span><br><span class="line"><span class="comment"> * 给 Object.prototype 上添加一个不可枚举的extend() 方法</span></span><br><span class="line"><span class="comment"> * 这个方法继承自它的调用对象，将作为参数传入的对象的属性以一幅字</span></span><br><span class="line"><span class="comment"> * 除了值之外也赋值属性所有的特性，除非在目标对象中存在同名的属性。</span></span><br><span class="line"><span class="comment"> * 参数对象的所有自有属性（包括不可枚举的属性）也会一一复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object.prototype, <span class="string">"extend"</span>, &#123; <span class="comment">// 定义 Object.prototype.extend</span></span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,  <span class="comment">// 将其定义为不可枚举的</span></span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 得到所有的自有属性，包括不可枚举属性</span></span><br><span class="line">    <span class="keyword">var</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line">    <span class="comment">// 遍历它们</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; names.length; i++)&#123;</span><br><span class="line">      <span class="comment">// 如果属性已经存在，则跳过</span></span><br><span class="line">      <span class="keyword">if</span> (names[i] <span class="keyword">in</span> <span class="keyword">this</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 获取 o 中的属性描述符</span></span><br><span class="line">      <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, names[i])</span><br><span class="line">      <span class="comment">// 用它给 this 创建一个属性</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, names[i], desc)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="对象的三个属性"><a href="#对象的三个属性" class="headerlink" title="对象的三个属性"></a>对象的三个属性</h2><p>每一个对象都有与之相关联的原型 (prototype)、类 (class) 和可扩展性 (extensible attribute)。</p><h3 id="原型属性"><a href="#原型属性" class="headerlink" title="原型属性"></a>原型属性</h3><p>通过直接量创建的对象使用 Object.prototype 作为它们的原型，而使用 new 创建的对象使用 构造函数的 prototype 属性作为它们的原型。而通过 Object.create() 创建的对象使用第一个参数作为它们的原型，也可以是 null .</p><p>ECMAScript 5 中将对象作为参数传入 Object.getPrototypeOf() 方法中可以查询它的原型。</p><p>要检测一个对象是否是另一个对象的原型（或处于原型链中），用 isPrototypeOf() 方法。</p><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>对象的类属性是一个字符串，用以表示对象的类型信息。只有一种间接的方法可以访问，即toString() 方法。默认的 toString() 方法继承自 Object.prototype，返回 <code>[object class]</code> 格式的字符串。</p><p>如何获得对象的类？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * classof() 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o === <span class="literal">null</span> ) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">  <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"undefined"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数可以传入任意的参数。</p><h3 id="对象的可扩展性"><a href="#对象的可扩展性" class="headerlink" title="对象的可扩展性"></a>对象的可扩展性</h3><p>ECMAScript 5 的 Object.preventExtensions() 方法将对象转为不可扩展的，Object.seal() 还可以设置对象的属性不可配置。</p><h2 id="序列化对象（JSON-对象表示法）"><a href="#序列化对象（JSON-对象表示法）" class="headerlink" title="序列化对象（JSON 对象表示法）"></a>序列化对象（JSON 对象表示法）</h2><p>是指将对象的状态转为字符串，也可以将字符串还原为对象。</p><p>ECMAScript 5 提供了内置函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原JavaScript对象。这两个方法使用 JSON 数据格式。</p><p>JSON, 即 <code>JavaScript Object Notation</code>（ JavaScript 对象表示法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。 即 JSON</p><p>注意：函数、RegExp、Error 对象和 undefined 值不能序列化和还原</p><ul><li>JSON 转字符串 序列化 JSON.stringfy();</li><li>字符串转 JSON 反序列化 JSON.parse();</li></ul><h3 id="遍历的-JSON-两种方式"><a href="#遍历的-JSON-两种方式" class="headerlink" title="遍历的 JSON 两种方式"></a>遍历的 JSON 两种方式</h3><p>通过for可以对集合进行有序的遍历for(var k in json) { 语句 }; k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思,名字不同而已</p><h2 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h2><ul><li>toString() 方法</li><li>toLocalString() 方法</li><li>toJSON() 方法</li><li>valueOf() 方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了字符串、数字、true、false、null 和 undefined 之外，JavaScript 中的值都是对象。引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。&lt;/p&gt;
&lt;p&gt;从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示；&lt;/p&gt;
&lt;p&gt;从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理。&lt;/p&gt;
&lt;h2 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h2&gt;&lt;p&gt;JavaScript 对象的创建有三种方式：直接量，new 关键字 和 Object.creat() 方来创建。&lt;/p&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js语句</title>
    <link href="http://yoursite.com/2015/06/15/js%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2015/06/15/js语句/</id>
    <published>2015-06-14T16:00:00.000Z</published>
    <updated>2018-05-30T06:37:26.527Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 语法定义的语句通常使用一个或多个关键字来完成给定的任务。</p><h2 id="条件判断结构-if-if…else-if…else-嵌套"><a href="#条件判断结构-if-if…else-if…else-嵌套" class="headerlink" title="条件判断结构 if/ if…else/ if…else 嵌套"></a>条件判断结构 if/ if…else/ if…else 嵌套</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  <span class="comment">// 如果条件表达式为true，执行该处代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 如果条件表达式为false,执行该处代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>条件判断的嵌套</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式）&#123;</span><br><span class="line">  <span class="comment">//如果条件表达式结果为true,执行该语句，下边语句不执行。</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  <span class="comment">// 如果条件表达式结果为true,执行该语句，下边语句不执行。</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">  <span class="comment">// 如果条件表达式结果为true,执行该语句，下边语句不执行。</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果以上语句都为false,执行该语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h2><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mon=prompt(<span class="string">"请输入月份"</span>);</span><br><span class="line"><span class="keyword">switch</span>(mon)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"3"</span>: <span class="keyword">case</span> <span class="string">"4"</span>:  <span class="keyword">case</span> <span class="string">"5"</span>:</span><br><span class="line">  alert(<span class="string">"春季"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"6"</span>: <span class="keyword">case</span> <span class="string">"7"</span>:  <span class="keyword">case</span> <span class="string">"8"</span>:</span><br><span class="line">  alert(<span class="string">"夏季"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"9"</span>: <span class="keyword">case</span> <span class="string">"10"</span>:  <span class="keyword">case</span> <span class="string">"11"</span>:</span><br><span class="line">  alert(<span class="string">"秋季"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"12"</span>: <span class="keyword">case</span> <span class="string">"1"</span>:  <span class="keyword">case</span> <span class="string">"2"</span>:</span><br><span class="line">  alert(<span class="string">"冬季"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  alert(<span class="string">"请输入正确月份"</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:switch后边的变量和case后边值的数据类型必须保持一致。</p><h2 id="While循环语句"><a href="#While循环语句" class="headerlink" title="While循环语句"></a>While循环语句</h2><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1;</span><br><span class="line">While(条件表达式)&#123;</span><br><span class="line">  <span class="comment">// 循环语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果while后边的条件表达式为true,循环语句一直执行，直到while后边的条件表达式为false, 循环终止（跳出循环）,使用while语句的时候，需在外边定义一个变量。</p><h2 id="Do-while-语句"><a href="#Do-while-语句" class="headerlink" title="Do while 语句"></a>Do while 语句</h2><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">// 循环语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式)</span><br></pre></td></tr></table></figure><p>先执行do里循环代码，再和while后边的条件表达式进行判断，如果结果为true,继续执行do里的循环，结果为false，循环终止。比while多执行一次循环。</p><p>while语句 先判断后执行do while 语句 先执行后判断</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">  <span class="comment">//循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>单独使用 break 语句的作用是立即退出最内层的循环或 switch 语句。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;</span><br><span class="line">  <span class="comment">// 循环语句</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Break是跳出当前循环体；</p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>跳出循环一次。后边的代码不继续执行。</p><h3 id="break-和-continue-的区别"><a href="#break-和-continue-的区别" class="headerlink" title="break 和 continue 的区别"></a>break 和 continue 的区别</h3><ul><li>break跳出当前循环，执行循环后的语句</li><li>continue跳出当前循环，继续执行循环</li></ul><h2 id="for-in-属性枚举语句"><a href="#for-in-属性枚举语句" class="headerlink" title="for-in 属性枚举语句"></a>for-in 属性枚举语句</h2><p><code>for-in</code> 语句用来枚举对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span> object)&#123;</span><br><span class="line">  <span class="comment">// 代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>variable 是一个变量名，也可以是一个可以产生左值表达式或者一个通过 var 语句声明的变量，每次循环都会计算 variable 这个表达式，也就是说每次循环它的值可能不同。for/in 循环并不会遍历对象的所有属性，只有”可枚举”的属性才会遍历到。内置对象的方法就是不可枚举的</p><h2 id="label-（标签）语句"><a href="#label-（标签）语句" class="headerlink" title="label （标签）语句"></a>label （标签）语句</h2><p>label 语句可以在代码中添加标签，以便将来使用。通过给语句定义标签，就可以在程序的任何地方通过标签名引用这条语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><p>with 语句的作用是将作用域设置到一个特定的对象中。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring();</span><br><span class="line"><span class="keyword">var</span> hostName = location.hostname();</span><br><span class="line"><span class="keyword">var</span> utl = location.href();</span><br><span class="line"><span class="comment">// 以上代码可以写成下面的方式, 严格模式下不允许使用 with</span></span><br><span class="line"><span class="keyword">with</span>(location)&#123;</span><br><span class="line">  <span class="keyword">var</span> qs = search.substring();</span><br><span class="line">  <span class="keyword">var</span> hostName = hostname();</span><br><span class="line">  <span class="keyword">var</span> utl = href();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h2><p>函数是一种表达式，所有的表达式都有值。函数中国的 return 语句既是指定函数调用后的返回值。因此，return 语句只能在函数体内部出现，而且 return 语句经常作为函数的最后一条语句出现，但并不是说一定要放在函数体的最后，即使在执行 return 语句的时候还有很多后续代码没有执行，这是函数也还会返回调用程序。</p><h2 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h2><p>异常是指程序在程序在运行时发生的异常情况或错误时产生的一个信号。在 JavaScript 中，当产生运行时错误或者程序使用 throw 语句时就会显式的抛出异常。</p><h2 id="try-catch-finally-语句"><a href="#try-catch-finally-语句" class="headerlink" title="try/catch/finally 语句"></a>try/catch/finally 语句</h2><p>try/catch/finally 是 JavaScript 的异常处理机制。其中 try 从句中定义了需要处理的异常所在代码块，catch 从句跟在 try 后，当 try 块内发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中国放置清理代码，不管是 try 块中是否产生异常，finally 块内的逻辑总是会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 需要捕获异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// try 代码块抛出异常才会执行此代码块中的逻辑</span></span><br><span class="line">  <span class="comment">// 还可以通过 throw 语句来再次抛出异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 不管异常有没有发生，这个代码块中的逻辑都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它语句"><a href="#其它语句" class="headerlink" title="其它语句"></a>其它语句</h2><h3 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h3><h3 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h3><p>开启 ECMAScript 5 引入的一条命令，开启严格模式。说明后续的所有 JavaScript 代码都在严格模式下执行。</p><ul><li>严格模式下禁止使用 with 语句</li><li>在严格模式下，所有的变量都要先声明；</li><li>严格模式中，调用的函数中的一个 this 值是 undefined ；<ul><li>可以利用这种方式判断 JavaScript 实现是否支持严格模式</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasStrictMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span> === <span class="literal">undefined</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><ul><li>在严格模式中，当通过 call() 或 apply() 来调用函数时，其中 this 值就是通过 call() 或 apply() 传入的第一个参数；<br>+（在非严格模式中，null 和 undefined 值被全局对象和转换为对象的费对象值所替代）</li><li>在严格模式，给只读属性和给不可扩展的对象创建新成员都抛出一个类型错误异常。<br>+（在非严格模式中，这些操作只是简单地操作失败，不会报错）</li><li>在严格模式下，传入 eval() 的代码不能在调用程序锁在的上下文中声明变量或定义函数<ul><li>在非严格模式中是可以这样做的。</li></ul></li><li>严格模式下，函数里的 arguments 对象拥有传入函数值的静态副本。</li><li>严格模式下，delete 运算符后跟随非法的标识符会抛出异常</li><li>严格模式下，试图删除一个不可配置的属性将抛出一个类型错误异常</li><li>严格模式下，在一个对象直接量中定义两个或多个同名属性将会产生一个语法错误</li><li>严格模式下是不允许使用八进制整数直接量</li><li>严格模式下标识符 eval() 和 arguments 当做关键字，它们的值是不能更改的。不能给这些标识符赋值。</li><li>严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常。<ul><li>严格模式的函数同样具有 caller 和 arguments 属性，当访问这两个属性时将会抛出类型错误异常。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMAScript 语法定义的语句通常使用一个或多个关键字来完成给定的任务。&lt;/p&gt;
&lt;h2 id=&quot;条件判断结构-if-if…else-if…else-嵌套&quot;&gt;&lt;a href=&quot;#条件判断结构-if-if…else-if…else-嵌套&quot; class=&quot;headerlink&quot; title=&quot;条件判断结构 if/ if…else/ if…else 嵌套&quot;&gt;&lt;/a&gt;条件判断结构 if/ if…else/ if…else 嵌套&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(条件表达式)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 如果条件表达式为true，执行该处代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 如果条件表达式为false,执行该处代码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js Date、Math、包装对象、RegExp</title>
    <link href="http://yoursite.com/2015/06/08/js%20Date%E3%80%81Math%E3%80%81%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1%E3%80%81RegExp/"/>
    <id>http://yoursite.com/2015/06/08/js Date、Math、包装对象、RegExp/</id>
    <published>2015-06-07T16:00:00.000Z</published>
    <updated>2018-05-30T06:24:00.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javaScript的几个内置对象"><a href="#javaScript的几个内置对象" class="headerlink" title="javaScript的几个内置对象"></a>javaScript的几个内置对象</h2><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>ECMAScript 5 提供了两个方法：Date.parase() 和 Date.UTC() 返回日期的毫秒数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();   <span class="comment">//创建对象</span></span><br><span class="line">alert(<span class="built_in">Date</span>()); <span class="comment">//返回一个完整的日期时间</span></span><br><span class="line">alert(now.getDate()); <span class="comment">//返回从1开始计数的天数</span></span><br><span class="line">alert(now.getDay()); <span class="comment">//返回当前周几</span></span><br><span class="line">alert(now.getFullYear()); <span class="comment">//返回当前年份</span></span><br><span class="line">alert(now.getMonth()+<span class="number">1</span>);  <span class="comment">//返回当前月份</span></span><br><span class="line">alert(now.getHours());  <span class="comment">//当地时间的小时</span></span><br><span class="line"><span class="keyword">var</span> then = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">10</span>);  <span class="comment">// 2011年10月10日</span></span><br></pre></td></tr></table></figure><h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ul><li>toDateString();</li><li>toTimeString();</li><li>toLocaleDateString();</li><li>toLocalTimeString();</li><li>toUTCString()</li></ul><a id="more"></a><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//这些数字中的最大值</span></span><br><span class="line"><span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);<span class="comment">//返回多个数中的最小值</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">45.84334</span>);<span class="comment">//向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">5.4443</span>);<span class="comment">//向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">67.55</span>);<span class="comment">//四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.random();<span class="comment">//随机数 0-1 </span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">10</span>+<span class="number">1</span>); <span class="comment">//随机数 1-10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">100</span>+<span class="number">1</span>); <span class="comment">//随机数 1-100</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-100</span>);<span class="comment">//返回绝对值       </span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>,<span class="number">3</span>); <span class="comment">//4 的 3 次幂  </span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">16</span>); <span class="comment">//开平方</span></span><br><span class="line"><span class="built_in">Math</span>.sin(<span class="number">4</span>);<span class="comment">//返回正弦值</span></span><br><span class="line"><span class="built_in">Math</span>.PI; <span class="comment">// π 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">3</span>); <span class="comment">// 3 的平方根</span></span><br><span class="line"><span class="built_in">Math</span>.exp(<span class="number">3</span>); <span class="comment">// e 的 3 次幂</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">10</span>); <span class="comment">// 10 的自然对数</span></span><br><span class="line"><span class="built_in">Math</span>.E; <span class="comment">// 自然对数的底数</span></span><br></pre></td></tr></table></figure><h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>当 JavaScript 解释器启动时，它将创建一个新的全局对象，并给它一组定义的初始属性。</p><ul><li>全局属性，如 undefined、Infinity 和 NaN;</li><li>全局函数，如：isNaN()、parseInt() 和 eval();</li><li>构造函数，如：Date()、RegExp()、String()、Object() 和 Array()</li><li>全局对象，如：Math 和 JSON;</li></ul><h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><ul><li>String()</li><li>Number()</li><li>Boolean()<br>字符串字面量、数字字面量、布尔字面量均可以使用”.”符号引用属性值，当属性值是一个函数时，称其为方法。只有对象有属性，JavaScript 在创建字符串、数字、布尔值时会自动的通过调用 new String(); new Number(); new Boolean() 的方式调用。</li></ul><h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p><code>var expression = /pattern/flags;</code></p><p>pattern 是正则表达式，可以包含字符类，限定符，分组，向前查找以及反向查找。flag是标志，有 3 种：</p><ul><li>g: 全局(global)模式</li><li>i: 表示不区分大小写</li><li>m: 表示多行(multiline)模式</li></ul><p>RegExp 构造函数的模式参数是字符串，在某些情况下需要双重转义；</p><h3 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h3><ul><li>global 布尔值，是否设置了 g 标志</li><li>ignoreCase 布尔值，是否设置了 i 标志</li><li>lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从 0 算起</li><li>multiline 布尔值，是否设置了 m 标志</li><li>source 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回；</li></ul><h3 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h3><ul><li>exec() ；<ul><li>接收一个参数，要引用匹配模式的字符串，返回包含第一个匹配项信息的数组；</li><li>没有匹配项的情况下返回 null</li><li>返回的数组虽然是 Array 的实例，但包含两个属性：index 和 input<ul><li>index 表示匹配项子在字符串中的位置</li><li>input 表示应用正则表达式的字符串</li></ul></li><li>exec() 方法在设置了全局标志的情况下，每次调用该方法都会在字符串中继续查找新匹配项。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">var</span> mataches = pattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]); <span class="comment">// "mom and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]); <span class="comment">// " and dad and baby"</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]); <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure><p>总之：正则分组之后匹配到的结果如果匹配成功则会得到数组，数组中第 0 项是与整个模式匹配的字符串，从第一项开始就是数正则表达式中的左括号就可以了，左括号是第几个，则解析出来的数据就是数组中下标为该数字的元素`</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;javaScript的几个内置对象&quot;&gt;&lt;a href=&quot;#javaScript的几个内置对象&quot; class=&quot;headerlink&quot; title=&quot;javaScript的几个内置对象&quot;&gt;&lt;/a&gt;javaScript的几个内置对象&lt;/h2&gt;&lt;h2 id=&quot;Date对象&quot;&gt;&lt;a href=&quot;#Date对象&quot; class=&quot;headerlink&quot; title=&quot;Date对象&quot;&gt;&lt;/a&gt;Date对象&lt;/h2&gt;&lt;p&gt;ECMAScript 5 提供了两个方法：Date.parase() 和 Date.UTC() 返回日期的毫秒数&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; now = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;();   &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;()); &lt;span class=&quot;comment&quot;&gt;//返回一个完整的日期时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(now.getDate()); &lt;span class=&quot;comment&quot;&gt;//返回从1开始计数的天数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(now.getDay()); &lt;span class=&quot;comment&quot;&gt;//返回当前周几&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(now.getFullYear()); &lt;span class=&quot;comment&quot;&gt;//返回当前年份&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(now.getMonth()+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//返回当前月份&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(now.getHours());  &lt;span class=&quot;comment&quot;&gt;//当地时间的小时&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; then = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2011&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// 2011年10月10日&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;日期格式化方法&quot;&gt;&lt;a href=&quot;#日期格式化方法&quot; class=&quot;headerlink&quot; title=&quot;日期格式化方法&quot;&gt;&lt;/a&gt;日期格式化方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;toDateString();&lt;/li&gt;
&lt;li&gt;toTimeString();&lt;/li&gt;
&lt;li&gt;toLocaleDateString();&lt;/li&gt;
&lt;li&gt;toLocalTimeString();&lt;/li&gt;
&lt;li&gt;toUTCString()&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS系列" scheme="http://yoursite.com/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
